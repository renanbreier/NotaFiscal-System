import {
  toolbar_default
} from "./chunk-CUMO577X.js";
import {
  tree_view_default,
  tree_view_search_default
} from "./chunk-DYGKOJFJ.js";
import {
  ui_overlay_default
} from "./chunk-RNPOV4XI.js";
import {
  m_sortable_default
} from "./chunk-FFMEWCSQ.js";
import {
  date_default as date_default2,
  form_default,
  m_select_box_default,
  m_validator_default,
  number_box_default,
  ui_popup_default,
  ui_widget_default
} from "./chunk-ZRDPRZOD.js";
import {
  DBLCLICK_EVENT_NAME
} from "./chunk-YAW44OPQ.js";
import {
  check_box_default
} from "./chunk-O4CT4SVL.js";
import {
  DomComponentWrapper,
  editor_default
} from "./chunk-WL3AHEXM.js";
import {
  scroll_view_default
} from "./chunk-XYVVW653.js";
import {
  context_menu_default,
  context_menu_default2,
  menu_base_default
} from "./chunk-PDY33GM5.js";
import {
  list_edit_search_default
} from "./chunk-DHHSGAOU.js";
import {
  data_source_default,
  m_popup_default
} from "./chunk-GQ5A5LDB.js";
import {
  load_panel_default
} from "./chunk-2P3276RG.js";
import {
  DataSource,
  Selection,
  aggregators,
  applyBatch,
  createObjectWithChanges,
  errors,
  findChanges,
  keysEqual,
  m_abstract_store_default,
  m_array_store_default,
  m_custom_store_default,
  m_data_controller_default,
  m_hold_default,
  m_query_default,
  m_store_helper_default,
  normalizeDataSourceOptions,
  normalizeSortingInfo
} from "./chunk-EGHIGSYM.js";
import {
  DxiButtonModule,
  DxiChangeModule,
  DxiColumnModule,
  DxiCustomOperationModule,
  DxiFieldModule,
  DxiGroupItemModule,
  DxiItemModule,
  DxiSortByGroupSummaryInfoModule,
  DxiTabModule,
  DxiTotalItemModule,
  DxiValidationRuleModule,
  DxoAnimationModule,
  DxoAtModule,
  DxoBoundaryOffsetModule,
  DxoButtonOptionsModule,
  DxoColCountByScreenModule,
  DxoCollisionModule,
  DxoColumnChooserModule,
  DxoColumnFixingModule,
  DxoCursorOffsetModule,
  DxoEditingModule,
  DxoExportModule,
  DxoFilterBuilderModule,
  DxoFilterBuilderPopupModule,
  DxoFilterOperationDescriptionsModule,
  DxoFilterPanelModule,
  DxoFilterRowModule,
  DxoFormItemModule,
  DxoFormModule,
  DxoFormatModule,
  DxoFromModule,
  DxoGroupOperationDescriptionsModule,
  DxoGroupPanelModule,
  DxoGroupingModule,
  DxoHeaderFilterModule,
  DxoHideModule,
  DxoIconsModule,
  DxoKeyboardNavigationModule,
  DxoLabelModule,
  DxoLoadPanelModule,
  DxoLookupModule,
  DxoMasterDetailModule,
  DxoMyModule,
  DxoOffsetModule,
  DxoOperationDescriptionsModule,
  DxoPagerModule,
  DxoPagingModule,
  DxoPopupModule,
  DxoPositionModule,
  DxoRemoteOperationsModule,
  DxoRowDraggingModule,
  DxoScrollingModule,
  DxoSearchModule,
  DxoSearchPanelModule,
  DxoSelectionModule,
  DxoShowModule,
  DxoSortingModule,
  DxoStateStoringModule,
  DxoSummaryModule,
  DxoTabPanelOptionsModule,
  DxoTextsModule,
  DxoToModule,
  DxoToolbarModule,
  DxoValueFormatModule
} from "./chunk-PRGABLET.js";
import {
  getElementLocationInternal,
  scrollable_default
} from "./chunk-KCGINBM5.js";
import {
  load_indicator_default2 as load_indicator_default
} from "./chunk-CAF7VME4.js";
import {
  BaseInfernoComponent,
  BaseWidgetDefaultProps,
  ComponentWrapper,
  ConfigContext,
  InfernoComponent,
  InfernoEffect,
  InfernoWrapperComponent,
  Widget,
  button_default,
  combineClasses,
  createComponentVNode,
  createContext,
  createFragment,
  createReRenderEffect,
  createRef,
  createVNode,
  getImageContainer,
  getImageSourceType,
  normalizeProps,
  number_default,
  subscribeToClickEvent,
  validation_engine_default
} from "./chunk-UQXIHJH2.js";
import {
  message_default
} from "./chunk-XULD25K2.js";
import {
  current,
  isFluent,
  isMaterial,
  isMaterialBased
} from "./chunk-BBLJGJFI.js";
import {
  PROPERTY_TOKEN_buttons,
  PROPERTY_TOKEN_changes,
  PROPERTY_TOKEN_columns,
  PROPERTY_TOKEN_customOperations,
  PROPERTY_TOKEN_fields,
  PROPERTY_TOKEN_groupItems,
  PROPERTY_TOKEN_items,
  PROPERTY_TOKEN_sortByGroupSummaryInfo,
  PROPERTY_TOKEN_toolbarItems,
  PROPERTY_TOKEN_totalItems,
  PROPERTY_TOKEN_validationRules
} from "./chunk-QTDRYW7W.js";
import {
  DRAG_END_EVENT,
  DRAG_EVENT,
  DRAG_START_EVENT,
  swatch_container_default
} from "./chunk-MJRE2EKH.js";
import {
  CLICK_EVENT_NAME,
  EVENT_NAME,
  HOVEREND,
  _objectWithoutPropertiesLoose,
  action_default,
  addNamespace,
  browser_default,
  component_registrator_default,
  createEvent,
  eventData,
  focused,
  fx_default,
  getBoundingRect,
  getDefaultAlignment,
  getPublicElement,
  isCommandKeyPressed,
  isElementInDom,
  isTouchEvent,
  keyboard,
  m_dom_default,
  m_pointer_default,
  move,
  normalizeIndexes,
  normalizeKeyName,
  position_default,
  removeEvent
} from "./chunk-54SHI7Z2.js";
import {
  date_default,
  date_serialization_default,
  devices_default,
  getSessionStorage,
  m_support_default,
  resize_callbacks_default,
  ui_errors_default,
  value
} from "./chunk-A3D3LIWG.js";
import {
  CollectionNestedOption,
  DxComponent,
  DxIntegrationModule,
  DxTemplateHost,
  DxTemplateModule,
  IterableDifferHelper,
  NestedOption,
  NestedOptionHost,
  WatcherHelper,
  extractTemplate
} from "./chunk-N6JIRJK4.js";
import {
  captionize,
  data,
  getHeight,
  getInnerHeight,
  getInnerWidth,
  getOuterHeight,
  getOuterWidth,
  getWidth,
  m_inflector_default,
  renderer_default,
  setHeight,
  setHeight2,
  setOuterHeight,
  setOuterWidth,
  setWidth,
  setWidth2
} from "./chunk-3GE2VGI4.js";
import {
  Component,
  ContentChildren,
  DOCUMENT,
  ElementRef,
  Host,
  Inject,
  Input,
  NgModule,
  NgZone,
  Output,
  PLATFORM_ID,
  Renderer2,
  SkipSelf,
  TransferState,
  setClassMetadata,
  ɵɵInheritDefinitionFeature,
  ɵɵNgOnChangesFeature,
  ɵɵProvidersFeature,
  ɵɵcontentQuery,
  ɵɵdefineComponent,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdirectiveInject,
  ɵɵloadQuery,
  ɵɵprojection,
  ɵɵprojectionDef,
  ɵɵqueryRefresh
} from "./chunk-GBBTBBS3.js";
import {
  m_events_engine_default
} from "./chunk-4JX72F7N.js";
import {
  Deferred,
  _extends,
  callbacks_default,
  compileGetter,
  compileSetter,
  config_default2 as config_default,
  deepExtendArraySafe,
  deferRender,
  deferUpdate,
  dependency_injector_default,
  dom_adapter_default,
  each,
  encodeHtml,
  ensureDefined,
  equalByValue,
  extend,
  format,
  fromPromise,
  getKeyHash,
  getPathParts,
  getWindow,
  grep,
  guid_default2 as guid_default,
  hasWindow,
  isBoolean,
  isDate,
  isDeferred,
  isDefined,
  isEmpty,
  isEmptyObject,
  isFunction,
  isNumeric,
  isObject,
  isPlainObject,
  isRenderer,
  isString,
  logger,
  m_common_default,
  map,
  noop,
  orderEach,
  toComparable,
  type,
  variable_wrapper_default,
  when
} from "./chunk-4U6OD5AW.js";

// node_modules/devextreme/esm/__internal/grids/grid_core/keyboard_navigation/const.js
var ATTRIBUTES = {
  ariaColIndex: "aria-colindex",
  dragCell: "dx-drag-cell"
};
var ROWS_VIEW_CLASS = "rowsview";
var TABLE_CLASS = "table";
var EDIT_FORM_CLASS = "edit-form";
var DATA_ROW_CLASS = "dx-data-row";
var GROUP_ROW_CLASS = "dx-group-row";
var HEADER_ROW_CLASS = "dx-header-row";
var EDIT_FORM_ITEM_CLASS = "edit-form-item";
var MASTER_DETAIL_ROW_CLASS = "dx-master-detail-row";
var FREESPACE_ROW_CLASS = "dx-freespace-row";
var VIRTUAL_ROW_CLASS = "dx-virtual-row";
var MASTER_DETAIL_CELL_CLASS = "dx-master-detail-cell";
var DROPDOWN_EDITOR_OVERLAY_CLASS = "dx-dropdowneditor-overlay";
var COMMAND_EXPAND_CLASS = "dx-command-expand";
var ADAPTIVE_COLUMN_NAME_CLASS = "dx-command-adaptive";
var ADAPTIVE_ITEM_TEXT_CLASS = "dx-adaptive-item-text";
var COMMAND_SELECT_CLASS = "dx-command-select";
var COMMAND_EDIT_CLASS = "dx-command-edit";
var COMMAND_CELL_SELECTOR = "[class^=dx-command]";
var CELL_FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled";
var DATEBOX_WIDGET_NAME = "dxDateBox";
var FOCUS_STATE_CLASS = "dx-state-focused";
var WIDGET_CLASS = "dx-widget";
var REVERT_BUTTON_CLASS = "dx-revert-button";
var FOCUSED_CLASS = "dx-focused";
var FAST_EDITING_DELETE_KEY = "delete";
var INTERACTIVE_ELEMENTS_SELECTOR = '\n  input:not([type="hidden"]):not([disabled]),\n  textarea:not([disabled]),\n  a:not([disabled]),\n  select:not([disabled]),\n  button:not([disabled]),\n  [tabindex]:not([disabled]),\n  .dx-checkbox:not([disabled],.dx-state-readonly)\n';
var NON_FOCUSABLE_ELEMENTS_SELECTOR = `${INTERACTIVE_ELEMENTS_SELECTOR}, .dx-dropdowneditor-icon`;
var FOCUS_TYPE_ROW = "row";
var FOCUS_TYPE_CELL = "cell";
var COLUMN_HEADERS_VIEW = "columnHeadersView";
var ROWS_VIEW = "rowsView";
var FUNCTIONAL_KEYS = ["shift", "control", "alt"];
var DRAG_COLUMN_NAME = "drag";
var Direction;
!(function(Direction2) {
  Direction2.Next = "next";
  Direction2.Previous = "previous";
})(Direction || (Direction = {}));
var ViewName;
!(function(ViewName2) {
  ViewName2.Group = "group";
  ViewName2.Headers = "headers";
})(ViewName || (ViewName = {}));
var KEY_CODES = {
  G: 71
};

// node_modules/devextreme/esm/__internal/grids/grid_core/context_menu/const.js
var CONTEXT_MENU_MOVE_PREVIOUS_ICON_NAME = "arrowleft";
var CONTEXT_MENU_MOVE_NEXT_ICON_NAME = "arrowright";

// node_modules/devextreme/esm/__internal/grids/grid_core/context_menu/m_column_context_menu_mixin.js
var ColumnContextMenuMixin = (Base) => class extends Base {
  constructor() {
    super(...arguments);
    this.isNeedToFocusColumn = false;
  }
  getMoveColumnContextMenuItems(options) {
    var _this$isColumnReorder, _this$getKeyboardNavi;
    const {
      column,
      rowIndex
    } = options;
    const allowColumnReordering = null === (_this$isColumnReorder = this.isColumnReorderingEnabled) || void 0 === _this$isColumnReorder ? void 0 : _this$isColumnReorder.call(this, null === options || void 0 === options ? void 0 : options.column);
    const keyboardNavigationController = null === (_this$getKeyboardNavi = this.getKeyboardNavigationController) || void 0 === _this$getKeyboardNavi ? void 0 : _this$getKeyboardNavi.call(this);
    if (!allowColumnReordering || !keyboardNavigationController) {
      return [];
    }
    const rtlEnabled = this.option("rtlEnabled");
    const onItemClick = (e) => {
      var _e$itemData;
      this.isNeedToFocusColumn = true;
      keyboardNavigationController.moveColumn(column, null === (_e$itemData = e.itemData) || void 0 === _e$itemData ? void 0 : _e$itemData.value, rowIndex);
    };
    return [{
      text: rtlEnabled ? message_default.format("dxDataGrid-moveColumnToTheRight") : message_default.format("dxDataGrid-moveColumnToTheLeft"),
      value: Direction.Previous,
      beginGroup: true,
      disabled: !keyboardNavigationController.canReorderColumn(column, Direction.Previous, rowIndex),
      icon: rtlEnabled ? CONTEXT_MENU_MOVE_NEXT_ICON_NAME : CONTEXT_MENU_MOVE_PREVIOUS_ICON_NAME,
      onItemClick
    }, {
      text: rtlEnabled ? message_default.format("dxDataGrid-moveColumnToTheLeft") : message_default.format("dxDataGrid-moveColumnToTheRight"),
      value: Direction.Next,
      disabled: !keyboardNavigationController.canReorderColumn(column, Direction.Next, rowIndex),
      icon: rtlEnabled ? CONTEXT_MENU_MOVE_PREVIOUS_ICON_NAME : CONTEXT_MENU_MOVE_NEXT_ICON_NAME,
      onItemClick
    }];
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/columns_resizing_reordering/const.js
var CLASSES = {
  draggableColumn: "draggable-column"
};

// node_modules/devextreme/esm/ui/shared/accessibility.js
var FOCUS_STATE_CLASS2 = "dx-state-focused";
var FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled";
var GRID_ROW_SELECTOR = ".dx-datagrid-rowsview .dx-row";
var GRID_CELL_SELECTOR = `${GRID_ROW_SELECTOR} > td`;
var TREELIST_ROW_SELECTOR = ".dx-treelist-rowsview .dx-row";
var TREELIST_CELL_SELECTOR = `${TREELIST_ROW_SELECTOR} > td`;
var viewItemSelectorMap = {
  groupPanel: [".dx-datagrid-group-panel .dx-group-panel-item[tabindex]"],
  columnHeaders: [".dx-datagrid-headers .dx-header-row > td.dx-datagrid-action", ".dx-treelist-headers .dx-header-row > td.dx-treelist-action"],
  filterRow: [".dx-datagrid-headers .dx-datagrid-filter-row .dx-editor-cell .dx-texteditor-input", ".dx-treelist-headers .dx-treelist-filter-row .dx-editor-cell .dx-texteditor-input"],
  rowsView: [".dx-row-focused", `${GRID_ROW_SELECTOR}[tabindex]`, `${GRID_CELL_SELECTOR}[tabindex]`, `${GRID_CELL_SELECTOR}`, `${TREELIST_ROW_SELECTOR}[tabindex]`, `${TREELIST_CELL_SELECTOR}[tabindex]`, `${TREELIST_CELL_SELECTOR}`],
  footer: [".dx-datagrid-total-footer .dx-datagrid-summary-item", ".dx-treelist-total-footer .dx-treelist-summary-item"],
  filterPanel: [".dx-datagrid-filter-panel .dx-icon-filter", ".dx-treelist-filter-panel .dx-icon-filter"],
  pager: [".dx-datagrid-pager [tabindex]", ".dx-treelist-pager [tabindex]"]
};
var isMouseDown = false;
var isHiddenFocusing = false;
var focusedElementInfo = null;
var needToSkipFocusin = false;
function processKeyDown(viewName2, instance, event, action, $mainElement, executeKeyDown) {
  const isHandled = fireKeyDownEvent(instance, event.originalEvent, executeKeyDown);
  if (isHandled) {
    return;
  }
  const keyName = normalizeKeyName(event);
  if ("enter" === keyName || "space" === keyName) {
    saveFocusedElementInfo(event.target, instance);
    action && action({
      event
    });
  } else if ("tab" === keyName) {
    $mainElement.addClass(FOCUS_STATE_CLASS2);
  } else {
    selectView(viewName2, instance, event);
  }
}
function saveFocusedElementInfo(target, instance) {
  const $target = renderer_default(target);
  const ariaLabel = $target.attr("aria-label");
  const $activeElements = getActiveAccessibleElements(ariaLabel, instance.element());
  const targetIndex = $activeElements.index($target);
  focusedElementInfo = extend({}, {
    ariaLabel,
    index: targetIndex
  }, {
    viewInstance: instance
  });
}
function getActiveAccessibleElements(ariaLabel, viewElement) {
  const $viewElement = renderer_default(viewElement);
  let $activeElements;
  if (ariaLabel) {
    const escapedAriaLabel = null === ariaLabel || void 0 === ariaLabel ? void 0 : ariaLabel.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
    $activeElements = $viewElement.find(`[aria-label="${escapedAriaLabel}"][tabindex]`);
  } else {
    $activeElements = $viewElement.find("[tabindex]");
  }
  return $activeElements;
}
function findFocusedViewElement(instanceRootDomNode, viewSelectors, element) {
  const root = instanceRootDomNode ?? (null === element || void 0 === element ? void 0 : element.getRootNode()) ?? dom_adapter_default.getDocument();
  if (!root) {
    return;
  }
  const $root = renderer_default(root);
  for (const index in viewSelectors) {
    const selector = viewSelectors[index];
    const $focusViewElement = $root.find(selector).first();
    if ($focusViewElement.length) {
      return $focusViewElement;
    }
  }
}
function fireKeyDownEvent(instance, event, executeAction) {
  const args = {
    event,
    handled: false
  };
  if (executeAction) {
    executeAction(args);
  } else {
    instance._createActionByOption("onKeyDown")(args);
  }
  return args.handled;
}
function onDocumentVisibilityChange() {
  const focusedElement = dom_adapter_default.getActiveElement();
  needToSkipFocusin = focusedElement && !focusedElement.closest(`.${FOCUS_STATE_CLASS2}`);
}
function subscribeVisibilityChange() {
  m_events_engine_default.on(dom_adapter_default.getDocument(), "visibilitychange", onDocumentVisibilityChange);
}
function unsubscribeVisibilityChange() {
  m_events_engine_default.off(dom_adapter_default.getDocument(), "visibilitychange", onDocumentVisibilityChange);
}
function hiddenFocus(element, preventScroll) {
  isHiddenFocusing = true;
  element.focus({
    preventScroll
  });
  isHiddenFocusing = false;
}
function registerKeyboardAction(viewName2, instance, $element, selector, action, executeKeyDown) {
  if (instance.option("useLegacyKeyboardNavigation")) {
    return noop;
  }
  const getMainElement = () => renderer_default(instance.element());
  const keyDownHandler = (e) => processKeyDown(viewName2, instance, e, action, getMainElement(), executeKeyDown);
  const mouseDownHandler = () => {
    isMouseDown = true;
    getMainElement().removeClass(FOCUS_STATE_CLASS2);
  };
  const focusinHandler = () => {
    if (needToSkipFocusin) {
      needToSkipFocusin = false;
      return;
    }
    const needShowOverlay = !isMouseDown && !isHiddenFocusing;
    if (needShowOverlay) {
      getMainElement().addClass(FOCUS_STATE_CLASS2);
    }
    isMouseDown = false;
  };
  const mouseUpHandler = () => {
    isMouseDown = false;
  };
  m_events_engine_default.on($element, "keydown", selector, keyDownHandler);
  m_events_engine_default.on($element, "mousedown", selector, mouseDownHandler);
  m_events_engine_default.on($element, "focusin", selector, focusinHandler);
  m_events_engine_default.on($element, "mouseup contextmenu", selector, mouseUpHandler);
  return () => {
    m_events_engine_default.off($element, "keydown", selector, keyDownHandler);
    m_events_engine_default.off($element, "mousedown", selector, mouseDownHandler);
    m_events_engine_default.off($element, "focusin", selector, focusinHandler);
    m_events_engine_default.off($element, "mouseup contextmenu", selector, mouseUpHandler);
  };
}
function restoreFocus(instance) {
  if (!instance.option("useLegacyKeyboardNavigation") && focusedElementInfo) {
    const viewInstance = focusedElementInfo.viewInstance;
    if (viewInstance) {
      const $activeElements = getActiveAccessibleElements(focusedElementInfo.ariaLabel, viewInstance.element());
      const $targetElement = $activeElements.eq(focusedElementInfo.index);
      focusedElementInfo = null;
      m_events_engine_default.trigger($targetElement, "focus");
    }
  }
}
function selectView(viewName2, instance, event) {
  const keyName = normalizeKeyName(event);
  if (event.ctrlKey && ("upArrow" === keyName || "downArrow" === keyName)) {
    var _instance$component, _instance$component$e;
    const viewNames = Object.keys(viewItemSelectorMap);
    let viewItemIndex = viewNames.indexOf(viewName2);
    const instanceRootDomNode = null === instance || void 0 === instance || null === (_instance$component = instance.component) || void 0 === _instance$component || null === (_instance$component$e = _instance$component.element) || void 0 === _instance$component$e ? void 0 : _instance$component$e.call(_instance$component);
    while (viewItemIndex >= 0 && viewItemIndex < viewNames.length) {
      viewItemIndex = "upArrow" === keyName ? --viewItemIndex : ++viewItemIndex;
      const viewName3 = viewNames[viewItemIndex];
      const viewSelectors = viewItemSelectorMap[viewName3];
      const $focusViewElement = findFocusedViewElement(instanceRootDomNode, viewSelectors, event.target);
      if ($focusViewElement && $focusViewElement.length) {
        $focusViewElement.attr("tabindex", instance.option("tabindex") || 0);
        m_events_engine_default.trigger($focusViewElement, "focus");
        $focusViewElement.removeClass(FOCUS_DISABLED_CLASS);
        break;
      }
    }
  }
}
function setTabIndex(instance, $element) {
  if (!instance.option("useLegacyKeyboardnavigation")) {
    $element.attr("tabindex", instance.option("tabindex") || 0);
  }
}

// node_modules/devextreme/esm/__internal/grids/grid_core/m_accessibility.js
var registerKeyboardAction2 = function(viewName2, instance, $element, selector, action) {
  let executeKeyDown = (args) => {
  };
  const keyboardController = instance.getController("keyboardNavigation");
  if (instance.option("useLegacyKeyboardNavigation") || keyboardController && !keyboardController.isKeyboardEnabled()) {
    return;
  }
  if ("filterPanel" === viewName2) {
    executeKeyDown = (args) => {
      instance.executeAction("onKeyDown", args);
    };
    instance.createAction("onKeyDown");
  }
  registerKeyboardAction(viewName2, instance, $element, selector, action, executeKeyDown);
};

// node_modules/devextreme/esm/__internal/grids/grid_core/column_state_mixin/m_column_state_mixin.js
var ColumnStateMixin = (Base) => class extends Base {
  _applyColumnState(options) {
    var _that$component;
    const rtlEnabled = this.option("rtlEnabled");
    const columnAlignment = this._getColumnAlignment(options.column.alignment, rtlEnabled);
    const parameters = extend(true, {
      columnAlignment
    }, options);
    const isGroupPanelItem = parameters.rootElement.hasClass("dx-group-panel-item");
    const $indicatorsContainer = this._createIndicatorContainer(parameters, isGroupPanelItem);
    const $span = renderer_default("<span>").addClass(this._getIndicatorClassName(options.name));
    const columnsController = null === (_that$component = this.component) || void 0 === _that$component ? void 0 : _that$component.getController("columns");
    const indicatorAlignment = (null === columnsController || void 0 === columnsController ? void 0 : columnsController.getHeaderContentAlignment(columnAlignment)) || columnAlignment;
    parameters.container = $indicatorsContainer;
    parameters.indicator = $span;
    this._renderIndicator(parameters);
    $indicatorsContainer[(isGroupPanelItem || !options.showColumnLines) && "left" === indicatorAlignment ? "appendTo" : "prependTo"](options.rootElement);
    return $span;
  }
  _getIndicatorClassName(name) {
  }
  _getColumnAlignment(alignment, rtlEnabled) {
    rtlEnabled = rtlEnabled || this.option("rtlEnabled");
    return alignment && "center" !== alignment ? alignment : getDefaultAlignment(rtlEnabled);
  }
  _createIndicatorContainer(options, ignoreIndicatorAlignment) {
    let $indicatorsContainer = this._getIndicatorContainer(options.rootElement);
    const indicatorAlignment = "left" === options.columnAlignment ? "right" : "left";
    if (!$indicatorsContainer.length) {
      $indicatorsContainer = renderer_default("<div>").addClass("dx-column-indicators");
    }
    this.setAria("role", "presentation", $indicatorsContainer);
    return $indicatorsContainer.css("float", options.showColumnLines && !ignoreIndicatorAlignment ? indicatorAlignment : null);
  }
  _getIndicatorContainer($cell) {
    return $cell && $cell.find(".dx-column-indicators");
  }
  _getIndicatorElements($cell) {
    const $indicatorContainer = this._getIndicatorContainer($cell);
    return $indicatorContainer && $indicatorContainer.children();
  }
  _renderIndicator(options) {
    const $container = options.container;
    const $indicator = options.indicator;
    $container && $indicator && $container.append($indicator);
  }
  _updateIndicators(indicatorName) {
    const that = this;
    const columns7 = that.getColumns();
    const $cells = that.getColumnElements();
    let $cell;
    if (!$cells || columns7.length !== $cells.length) {
      return;
    }
    for (let i = 0; i < columns7.length; i++) {
      $cell = $cells.eq(i);
      that._updateIndicator($cell, columns7[i], indicatorName);
      const rowOptions = $cell.parent().data("options");
      if (rowOptions && rowOptions.cells) {
        rowOptions.cells[$cell.index()].column = columns7[i];
      }
    }
  }
  _updateIndicator($cell, column, indicatorName) {
    if (!column.command) {
      return this._applyColumnState({
        name: indicatorName,
        rootElement: $cell,
        column,
        showColumnLines: this.option("showColumnLines")
      });
    }
    return;
  }
};
var m_column_state_mixin_default = ColumnStateMixin;

// node_modules/devextreme/esm/__internal/grids/grid_core/views/utils/update_views_borders.js
var _excluded = ["rowsView"];
var CLASSES2 = {
  borderedTop: "dx-bordered-top-view",
  borderedBottom: "dx-bordered-bottom-view"
};
var getFirstVisibleViewElement = (_ref) => {
  let {
    columnHeadersView: columnHeadersView10,
    rowsView: rowsView18
  } = _ref;
  if (null !== columnHeadersView10 && void 0 !== columnHeadersView10 && columnHeadersView10.isVisible()) {
    return columnHeadersView10.element();
  }
  return rowsView18.element();
};
var getLastVisibleViewElement = (_ref2) => {
  let {
    filterPanelView,
    footerView: footerView3,
    rowsView: rowsView18
  } = _ref2;
  if (null !== filterPanelView && void 0 !== filterPanelView && filterPanelView.isVisible()) {
    return filterPanelView.element();
  }
  if (null !== footerView3 && void 0 !== footerView3 && footerView3.isVisible()) {
    return footerView3.element();
  }
  return rowsView18.element();
};
var getViewElementWithClass = (viewsWithBorder, className) => {
  const borderedView = Object.values(viewsWithBorder).find(((view) => {
    var _view$element;
    return null === view || void 0 === view || null === (_view$element = view.element()) || void 0 === _view$element ? void 0 : _view$element.hasClass(className);
  }));
  return (null === borderedView || void 0 === borderedView ? void 0 : borderedView.element()) ?? null;
};
var shouldUpdateBorders = (viewName2, viewsWithBorder) => {
  var _rowsView$element;
  if (!Object.keys(viewsWithBorder).includes(viewName2)) {
    return false;
  }
  const {
    rowsView: rowsView18
  } = viewsWithBorder, otherViews = _objectWithoutPropertiesLoose(viewsWithBorder, _excluded);
  if (!isDefined(null === rowsView18 || void 0 === rowsView18 || null === (_rowsView$element = rowsView18.element) || void 0 === _rowsView$element ? void 0 : _rowsView$element.call(rowsView18))) {
    return false;
  }
  return Object.values(otherViews).filter(((view) => {
    var _view$isVisible;
    return null === view || void 0 === view || null === (_view$isVisible = view.isVisible) || void 0 === _view$isVisible ? void 0 : _view$isVisible.call(view);
  })).every(((view) => isDefined(null === view || void 0 === view ? void 0 : view.element())));
};
var updateViewsBorders = (viewName2, viewsWithBorder) => {
  if (!shouldUpdateBorders(viewName2, viewsWithBorder)) {
    return;
  }
  const $oldFirst = getViewElementWithClass(viewsWithBorder, CLASSES2.borderedTop);
  const $oldLast = getViewElementWithClass(viewsWithBorder, CLASSES2.borderedBottom);
  const $newFirst = getFirstVisibleViewElement(viewsWithBorder);
  const $newLast = getLastVisibleViewElement(viewsWithBorder);
  if ($oldFirst && !$oldFirst.is($newFirst)) {
    $oldFirst.removeClass(CLASSES2.borderedTop);
  }
  if ($oldLast && !$oldLast.is($newLast)) {
    $oldLast.removeClass(CLASSES2.borderedBottom);
  }
  if (!$newFirst.hasClass(CLASSES2.borderedTop)) {
    $newFirst.addClass(CLASSES2.borderedTop);
  }
  if (!$newLast.hasClass(CLASSES2.borderedBottom)) {
    $newLast.addClass(CLASSES2.borderedBottom);
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/m_modules.js
var ModuleItem = class {
  constructor(component) {
    const that = this;
    that._updateLockCount = 0;
    that.component = component;
    that._actions = {};
    that._actionConfigs = {};
    each(this.callbackNames() || [], (function(index, name) {
      const flags = that.callbackFlags(name) || {};
      flags.unique = true;
      flags.syncStrategy = true;
      that[this] = callbacks_default(flags);
    }));
  }
  _endUpdateCore() {
  }
  init() {
  }
  callbackNames() {
    return;
  }
  callbackFlags(name) {
  }
  publicMethods() {
    return [];
  }
  beginUpdate() {
    this._updateLockCount++;
  }
  endUpdate() {
    if (this._updateLockCount > 0) {
      this._updateLockCount--;
      if (!this._updateLockCount) {
        this._endUpdateCore();
      }
    }
  }
  option(name) {
    const {
      component
    } = this;
    const optionCache = component._optionCache;
    if (1 === arguments.length && optionCache) {
      if (!(name in optionCache)) {
        optionCache[name] = component.option(name);
      }
      return optionCache[name];
    }
    return component.option.apply(component, arguments);
  }
  _silentOption(name, value2) {
    const {
      component
    } = this;
    const optionCache = component._optionCache;
    if (optionCache) {
      optionCache[name] = value2;
    }
    return component._setOptionWithoutOptionChange(name, value2);
  }
  localize(name) {
    const optionCache = this.component._optionCache;
    if (optionCache) {
      if (!(name in optionCache)) {
        optionCache[name] = message_default.format(name);
      }
      return optionCache[name];
    }
    return message_default.format(name);
  }
  on(event, callback) {
    return this.component.on.apply(this.component, arguments);
  }
  off() {
    return this.component.off.apply(this.component, arguments);
  }
  optionChanged(args) {
    if (args.name in this._actions) {
      this.createAction(args.name, this._actionConfigs[args.name]);
      args.handled = true;
    }
  }
  getAction(actionName) {
    return this._actions[actionName];
  }
  setAria(name, value2, $target) {
    const target = $target.get(0);
    const prefix = "role" !== name && "id" !== name ? "aria-" : "";
    if (target.setAttribute) {
      target.setAttribute(prefix + name, value2);
    } else {
      $target.attr(prefix + name, value2);
    }
  }
  _createComponent($container, component, options) {
    return this.component._createComponent($container, component, options);
  }
  getController(name) {
    return this.component._controllers[name];
  }
  createAction(actionName, config) {
    if (isFunction(actionName)) {
      const action = this.component._createAction(actionName.bind(this), config);
      return function(e) {
        action({
          event: e
        });
      };
    }
    this._actions[actionName] = this.component._createActionByOption(actionName, config);
    this._actionConfigs[actionName] = config;
    return;
  }
  executeAction(actionName, options) {
    const action = this._actions[actionName];
    return action && action(options);
  }
  dispose() {
    const that = this;
    each(that.callbackNames() || [], (function() {
      that[this].empty();
    }));
  }
  addWidgetPrefix(className) {
    const componentName = this.component.NAME;
    return `dx-${componentName.slice(2).toLowerCase()}${className ? `-${className}` : ""}`;
  }
  getWidgetContainerClass() {
    const containerName = "dxDataGrid" === this.component.NAME ? null : "container";
    return this.addWidgetPrefix(containerName);
  }
  elementIsInsideGrid($element) {
    const $gridElement = $element.closest(`.${this.getWidgetContainerClass()}`).parent();
    return $gridElement.is(this.component.$element());
  }
};
var Controller = class extends ModuleItem {
};
var ViewController = class extends Controller {
  getView(name) {
    return this.component._views[name];
  }
  getViews() {
    return this.component._views;
  }
};
var View = class extends ModuleItem {
  constructor(component) {
    super(component);
    this.renderCompleted = callbacks_default();
    this.resizeCompleted = callbacks_default();
  }
  _isReady() {
    return this.component.isReady();
  }
  _endUpdateCore() {
    super._endUpdateCore();
    if (!this._isReady() && this._requireReady) {
      this._requireRender = false;
      this.component._requireResize = false;
    }
    if (this._requireRender) {
      this._requireRender = false;
      this.render(this._$parent);
    }
  }
  _invalidate(requireResize, requireReady) {
    this._requireRender = true;
    this.component._requireResize = hasWindow() && (this.component._requireResize || requireResize);
    this._requireReady = this._requireReady || requireReady;
  }
  _renderCore(options) {
  }
  _resizeCore() {
  }
  _parentElement() {
    return this._$parent;
  }
  element() {
    return this._$element;
  }
  getElementHeight() {
    const $element = this.element();
    if (!$element) {
      return 0;
    }
    const marginTop = parseFloat($element.css("marginTop")) || 0;
    const marginBottom = parseFloat($element.css("marginBottom")) || 0;
    const {
      offsetHeight
    } = $element.get(0);
    return offsetHeight + marginTop + marginBottom;
  }
  isVisible() {
    return true;
  }
  getTemplate(name) {
    return this.component._getTemplate(name);
  }
  getView(name) {
    return this.component._views[name];
  }
  _getBorderedViews() {
    return {
      columnHeadersView: this.component._views.columnHeadersView,
      rowsView: this.component._views.rowsView,
      filterPanelView: this.component._views.filterPanelView,
      footerView: this.component._views.footerView
    };
  }
  render($parent, options) {
    let $element = this._$element;
    const isVisible2 = this.isVisible();
    if (!$element && !$parent) {
      return;
    }
    this._requireReady = false;
    if (!$element) {
      $element = this._$element = renderer_default("<div>").appendTo($parent);
      this._$parent = $parent;
    }
    $element.toggleClass("dx-hidden", !isVisible2);
    if (this.component._views) {
      updateViewsBorders(this.name, this._getBorderedViews());
    }
    if (isVisible2) {
      this.component._optionCache = {};
      const deferred = this._renderCore(options);
      this.component._optionCache = void 0;
      if (deferred) {
        deferred.done((() => {
          this.renderCompleted.fire(options);
        }));
      } else {
        this.renderCompleted.fire(options);
      }
    }
  }
  resize() {
    this.isResizing = true;
    this._resizeCore();
    this.resizeCompleted.fire();
    this.isResizing = false;
  }
  focus(preventScroll) {
    this.element().get(0).focus({
      preventScroll
    });
  }
};
function getExtendedTypes(types) {
  let moduleExtenders = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
  const extendTypes = {};
  Object.entries(moduleExtenders).forEach(((_ref) => {
    let [name, extender] = _ref;
    const currentType = types[name];
    if (currentType) {
      if (isFunction(extender)) {
        extendTypes[name] = extender(currentType);
      } else {
        const classType = currentType;
        extendTypes[name] = classType.inherit(extender);
      }
    }
  }));
  return extendTypes;
}
function registerPublicMethods(componentInstance, name, moduleItem) {
  const publicMethods = moduleItem.publicMethods();
  if (publicMethods) {
    each(publicMethods, ((_, methodName) => {
      if (moduleItem[methodName]) {
        if (!componentInstance[methodName]) {
          componentInstance[methodName] = function() {
            return moduleItem[methodName](...arguments);
          };
        } else {
          throw ui_errors_default.Error("E1005", methodName);
        }
      } else {
        throw ui_errors_default.Error("E1006", name, methodName);
      }
    }));
  }
}
function processModules(componentInstance, componentClass) {
  const {
    modules
  } = componentClass;
  const {
    modulesOrder
  } = componentClass;
  function createModuleItems(moduleTypes) {
    const moduleItems = {};
    each(moduleTypes, ((name, moduleType) => {
      const moduleItem = new moduleType(componentInstance);
      moduleItem.name = name;
      registerPublicMethods(componentInstance, name, moduleItem);
      moduleItems[name] = moduleItem;
    }));
    return moduleItems;
  }
  if (modulesOrder) {
    modules.sort(((module1, module2) => {
      let orderIndex1 = modulesOrder.indexOf(module1.name);
      let orderIndex2 = modulesOrder.indexOf(module2.name);
      if (orderIndex1 < 0) {
        orderIndex1 = 1e6;
      }
      if (orderIndex2 < 0) {
        orderIndex2 = 1e6;
      }
      return orderIndex1 - orderIndex2;
    }));
  }
  const rootControllerTypes = {};
  const rootViewTypes = {};
  modules.forEach(((_ref2) => {
    let {
      name: moduleName,
      controllers = {},
      views = {}
    } = _ref2;
    Object.entries(controllers).forEach(((_ref3) => {
      let [name, type2] = _ref3;
      if (rootControllerTypes[name]) {
        throw ui_errors_default.Error("E1001", moduleName, name);
      } else if (!((null === type2 || void 0 === type2 ? void 0 : type2.prototype) instanceof Controller)) {
        throw ui_errors_default.Error("E1002", moduleName, name);
      }
      rootControllerTypes[name] = type2;
    }));
    Object.entries(views).forEach(((_ref4) => {
      let [name, type2] = _ref4;
      if (rootViewTypes[name]) {
        throw ui_errors_default.Error("E1003", moduleName, name);
      } else if (!((null === type2 || void 0 === type2 ? void 0 : type2.prototype) instanceof View)) {
        throw ui_errors_default.Error("E1004", moduleName, name);
      }
      rootViewTypes[name] = type2;
    }));
  }));
  const moduleExtenders = modules.filter(((_ref5) => {
    let {
      extenders
    } = _ref5;
    return !!extenders;
  }));
  const controllerTypes = moduleExtenders.reduce(((types, _ref6) => {
    let {
      extenders
    } = _ref6;
    return _extends({}, types, getExtendedTypes(types, null === extenders || void 0 === extenders ? void 0 : extenders.controllers));
  }), rootControllerTypes);
  const viewTypes = moduleExtenders.reduce(((types, _ref7) => {
    let {
      extenders
    } = _ref7;
    return _extends({}, types, getExtendedTypes(types, null === extenders || void 0 === extenders ? void 0 : extenders.views));
  }), rootViewTypes);
  componentInstance._controllers = createModuleItems(controllerTypes);
  componentInstance._views = createModuleItems(viewTypes);
}
var callModuleItemsMethod = function(that, methodName, args) {
  args = args || [];
  if (that._controllers) {
    each(that._controllers, (function() {
      this[methodName] && this[methodName].apply(this, args);
    }));
  }
  if (that._views) {
    each(that._views, (function() {
      this[methodName] && this[methodName].apply(this, args);
    }));
  }
};
var m_modules_default = {
  modules: [],
  View,
  ViewController,
  Controller,
  registerModule(name, module) {
    const {
      modules
    } = this;
    for (let i = 0; i < modules.length; i++) {
      if (modules[i].name === name) {
        return;
      }
    }
    module.name = name;
    modules.push(module);
  },
  registerModulesOrder(moduleNames) {
    this.modulesOrder = moduleNames;
  },
  unregisterModule(name) {
    this.modules = grep(this.modules, ((module) => module.name !== name));
  },
  processModules,
  callModuleItemsMethod
};

// node_modules/devextreme/esm/format_helper.js
var format_helper_default = dependency_injector_default({
  format: function(value2, format2) {
    const formatIsValid = isString(format2) && "" !== format2 || isPlainObject(format2) || isFunction(format2);
    const valueIsValid = isNumeric(value2) || isDate(value2);
    if (!formatIsValid || !valueIsValid) {
      return isDefined(value2) ? value2.toString() : "";
    }
    if (isFunction(format2)) {
      return format2(value2);
    }
    if (isString(format2)) {
      format2 = {
        type: format2
      };
    }
    if (isNumeric(value2)) {
      return number_default.format(value2, format2);
    }
    if (isDate(value2)) {
      return date_default2.format(value2, format2);
    }
  },
  getTimeFormat: function(showSecond) {
    return showSecond ? "longtime" : "shorttime";
  },
  _normalizeFormat: function(format2) {
    if (!Array.isArray(format2)) {
      return format2;
    }
    if (1 === format2.length) {
      return format2[0];
    }
    return function(date) {
      return format2.map((function(formatPart) {
        return date_default2.format(date, formatPart);
      })).join(" ");
    };
  },
  getDateFormatByDifferences: function(dateDifferences, intervalFormat) {
    const resultFormat = [];
    const needSpecialSecondFormatter = intervalFormat && dateDifferences.millisecond && !(dateDifferences.year || dateDifferences.month || dateDifferences.day);
    if (needSpecialSecondFormatter) {
      const secondFormatter = function(date) {
        return date.getSeconds() + date.getMilliseconds() / 1e3 + "s";
      };
      resultFormat.push(secondFormatter);
    } else if (dateDifferences.millisecond) {
      resultFormat.push("millisecond");
    }
    if (dateDifferences.hour || dateDifferences.minute || !needSpecialSecondFormatter && dateDifferences.second) {
      resultFormat.unshift(this.getTimeFormat(dateDifferences.second));
    }
    if (dateDifferences.year && dateDifferences.month && dateDifferences.day) {
      if (intervalFormat && "month" === intervalFormat) {
        return "monthandyear";
      } else {
        resultFormat.unshift("shortdate");
        return this._normalizeFormat(resultFormat);
      }
    }
    if (dateDifferences.year && dateDifferences.month) {
      return "monthandyear";
    }
    if (dateDifferences.year && dateDifferences.quarter) {
      return "quarterandyear";
    }
    if (dateDifferences.year) {
      return "year";
    }
    if (dateDifferences.quarter) {
      return "quarter";
    }
    if (dateDifferences.month && dateDifferences.day) {
      if (intervalFormat) {
        const monthDayFormatter = function(date) {
          return date_default2.getMonthNames("abbreviated")[date.getMonth()] + " " + date_default2.format(date, "day");
        };
        resultFormat.unshift(monthDayFormatter);
      } else {
        resultFormat.unshift("monthandday");
      }
      return this._normalizeFormat(resultFormat);
    }
    if (dateDifferences.month) {
      return "month";
    }
    if (dateDifferences.day) {
      if (intervalFormat) {
        resultFormat.unshift("day");
      } else {
        const dayFormatter = function(date) {
          return date_default2.format(date, "dayofweek") + ", " + date_default2.format(date, "day");
        };
        resultFormat.unshift(dayFormatter);
      }
      return this._normalizeFormat(resultFormat);
    }
    return this._normalizeFormat(resultFormat);
  },
  getDateFormatByTicks: function(ticks) {
    let maxDiff;
    let currentDiff;
    let i;
    if (ticks.length > 1) {
      maxDiff = date_default.getDatesDifferences(ticks[0], ticks[1]);
      for (i = 1; i < ticks.length - 1; i++) {
        currentDiff = date_default.getDatesDifferences(ticks[i], ticks[i + 1]);
        if (maxDiff.count < currentDiff.count) {
          maxDiff = currentDiff;
        }
      }
    } else {
      maxDiff = {
        year: true,
        month: true,
        day: true,
        hour: ticks[0].getHours() > 0,
        minute: ticks[0].getMinutes() > 0,
        second: ticks[0].getSeconds() > 0,
        millisecond: ticks[0].getMilliseconds() > 0
      };
    }
    const resultFormat = this.getDateFormatByDifferences(maxDiff);
    return resultFormat;
  },
  getDateFormatByTickInterval: function(startValue, endValue, tickInterval) {
    let dateUnitInterval;
    const correctDateDifferences = function(dateDifferences2, tickInterval2, value2) {
      switch (tickInterval2) {
        case "year":
        case "quarter":
          dateDifferences2.month = value2;
        case "month":
          dateDifferences2.day = value2;
        case "week":
        case "day":
          dateDifferences2.hour = value2;
        case "hour":
          dateDifferences2.minute = value2;
        case "minute":
          dateDifferences2.second = value2;
        case "second":
          dateDifferences2.millisecond = value2;
      }
    };
    tickInterval = isString(tickInterval) ? tickInterval.toLowerCase() : tickInterval;
    const dateDifferences = date_default.getDatesDifferences(startValue, endValue);
    if (startValue !== endValue) {
      !(function(differences, minDate, maxDate) {
        if (!maxDate.getMilliseconds() && maxDate.getSeconds()) {
          if (maxDate.getSeconds() - minDate.getSeconds() === 1) {
            differences.millisecond = true;
            differences.second = false;
          }
        } else if (!maxDate.getSeconds() && maxDate.getMinutes()) {
          if (maxDate.getMinutes() - minDate.getMinutes() === 1) {
            differences.second = true;
            differences.minute = false;
          }
        } else if (!maxDate.getMinutes() && maxDate.getHours()) {
          if (maxDate.getHours() - minDate.getHours() === 1) {
            differences.minute = true;
            differences.hour = false;
          }
        } else if (!maxDate.getHours() && maxDate.getDate() > 1) {
          if (maxDate.getDate() - minDate.getDate() === 1) {
            differences.hour = true;
            differences.day = false;
          }
        } else if (1 === maxDate.getDate() && maxDate.getMonth()) {
          if (maxDate.getMonth() - minDate.getMonth() === 1) {
            differences.day = true;
            differences.month = false;
          }
        } else if (!maxDate.getMonth() && maxDate.getFullYear()) {
          if (maxDate.getFullYear() - minDate.getFullYear() === 1) {
            differences.month = true;
            differences.year = false;
          }
        }
      })(dateDifferences, startValue > endValue ? endValue : startValue, startValue > endValue ? startValue : endValue);
    }
    dateUnitInterval = date_default.getDateUnitInterval(dateDifferences);
    correctDateDifferences(dateDifferences, dateUnitInterval, true);
    dateUnitInterval = date_default.getDateUnitInterval(tickInterval || "second");
    correctDateDifferences(dateDifferences, dateUnitInterval, false);
    dateDifferences[{
      week: "day"
    }[dateUnitInterval] || dateUnitInterval] = true;
    const resultFormat = this.getDateFormatByDifferences(dateDifferences);
    return resultFormat;
  }
});

// node_modules/devextreme/esm/ui/load_panel.js
var load_panel_default2 = load_panel_default;

// node_modules/devextreme/esm/ui/shared/filtering.js
var DEFAULT_DATE_INTERVAL = ["year", "month", "day"];
var DEFAULT_DATETIME_INTERVAL = ["year", "month", "day", "hour", "minute"];
var isDateType = function(dataType) {
  return "date" === dataType || "datetime" === dataType;
};
var getGroupInterval = function(column) {
  let index;
  let result = [];
  const dateIntervals = ["year", "month", "day", "hour", "minute", "second"];
  const groupInterval = column.headerFilter && column.headerFilter.groupInterval;
  const interval = "quarter" === groupInterval ? "month" : groupInterval;
  if (isDateType(column.dataType) && null !== groupInterval) {
    result = "datetime" === column.dataType ? DEFAULT_DATETIME_INTERVAL : DEFAULT_DATE_INTERVAL;
    index = dateIntervals.indexOf(interval);
    if (index >= 0) {
      result = dateIntervals.slice(0, index);
      result.push(groupInterval);
      return result;
    }
    return result;
  } else if (isDefined(groupInterval)) {
    return Array.isArray(groupInterval) ? groupInterval : [groupInterval];
  }
};
var getNormalizedCalculateDisplayValue = function(column) {
  var _column$calculateDisp;
  return null !== (_column$calculateDisp = column.calculateDisplayValue) && void 0 !== _column$calculateDisp && _column$calculateDisp.context ? column.calculateDisplayValue : null;
};
var filtering_default = /* @__PURE__ */ (function() {
  const getFilterSelector = function(column, target) {
    let selector = column.dataField || column.selector;
    if ("search" === target) {
      selector = column.displayField || getNormalizedCalculateDisplayValue(column) || selector;
    }
    return selector;
  };
  const getFilterExpressionByRange = function(filterValue, target) {
    const column = this;
    let endFilterValue;
    let startFilterExpression;
    let endFilterExpression;
    const selector = getFilterSelector(column, target);
    if (Array.isArray(filterValue) && isDefined(filterValue[0]) && isDefined(filterValue[1])) {
      startFilterExpression = [selector, ">=", filterValue[0]];
      endFilterExpression = [selector, "<=", filterValue[1]];
      if (isDateType(column.dataType) && (date = filterValue[1], date.getHours() + date.getMinutes() + date.getSeconds() + date.getMilliseconds() < 1)) {
        endFilterValue = new Date(filterValue[1].getTime());
        if ("date" === column.dataType) {
          endFilterValue.setDate(filterValue[1].getDate() + 1);
        }
        endFilterExpression = [selector, "<", endFilterValue];
      }
      return [startFilterExpression, "and", endFilterExpression];
    }
    var date;
  };
  const getFilterExpressionForDate = function(filterValue, selectedFilterOperation, target) {
    const column = this;
    let dateStart;
    let dateEnd;
    let dateInterval;
    const values = (function(dateValue) {
      if (isDate(dateValue)) {
        return [dateValue.getFullYear(), dateValue.getMonth(), dateValue.getDate(), dateValue.getHours(), dateValue.getMinutes(), dateValue.getSeconds()];
      }
      return map(("" + dateValue).split("/"), (function(value2, index) {
        return 1 === index ? Number(value2) - 1 : Number(value2);
      }));
    })(filterValue);
    const selector = getFilterSelector(column, target);
    if ("headerFilter" === target) {
      dateInterval = getGroupInterval(column)[values.length - 1];
    } else if ("datetime" === column.dataType) {
      dateInterval = "minute";
    }
    switch (dateInterval) {
      case "year":
        dateStart = new Date(values[0], 0, 1);
        dateEnd = new Date(values[0] + 1, 0, 1);
        break;
      case "month":
        dateStart = new Date(values[0], values[1], 1);
        dateEnd = new Date(values[0], values[1] + 1, 1);
        break;
      case "quarter":
        dateStart = new Date(values[0], 3 * values[1], 1);
        dateEnd = new Date(values[0], 3 * values[1] + 3, 1);
        break;
      case "hour":
        dateStart = new Date(values[0], values[1], values[2], values[3]);
        dateEnd = new Date(values[0], values[1], values[2], values[3] + 1);
        break;
      case "minute":
        dateStart = new Date(values[0], values[1], values[2], values[3], values[4]);
        dateEnd = new Date(values[0], values[1], values[2], values[3], values[4] + 1);
        break;
      case "second":
        dateStart = new Date(values[0], values[1], values[2], values[3], values[4], values[5]);
        dateEnd = new Date(values[0], values[1], values[2], values[3], values[4], values[5] + 1);
        break;
      default:
        dateStart = new Date(values[0], values[1], values[2]);
        dateEnd = new Date(values[0], values[1], values[2] + 1);
    }
    switch (selectedFilterOperation) {
      case "<":
        return [selector, "<", dateStart];
      case "<=":
        return [selector, "<", dateEnd];
      case ">":
        return [selector, ">=", dateEnd];
      case ">=":
        return [selector, ">=", dateStart];
      case "<>":
        return [
          [selector, "<", dateStart],
          "or",
          [selector, ">=", dateEnd]
        ];
      default:
        return [
          [selector, ">=", dateStart],
          "and",
          [selector, "<", dateEnd]
        ];
    }
  };
  const getFilterExpressionForNumber = function(filterValue, selectedFilterOperation, target) {
    const selector = getFilterSelector(this, target);
    const groupInterval = getGroupInterval(this);
    if ("headerFilter" === target && groupInterval && isDefined(filterValue)) {
      const values = ("" + filterValue).split("/");
      const value2 = Number(values[values.length - 1]);
      const interval = groupInterval[values.length - 1];
      const startFilterValue = [selector, ">=", value2];
      const endFilterValue = [selector, "<", value2 + interval];
      const condition = [startFilterValue, "and", endFilterValue];
      return condition;
    }
    return [selector, selectedFilterOperation || "=", filterValue];
  };
  return {
    defaultCalculateFilterExpression: function(filterValue, selectedFilterOperation, target) {
      const column = this;
      const selector = getFilterSelector(column, target);
      const isSearchByDisplayValue = column.calculateDisplayValue && "search" === target;
      const dataType = isSearchByDisplayValue && column.lookup && column.lookup.dataType || column.dataType;
      let filter = null;
      if (("headerFilter" === target || "filterBuilder" === target) && null === filterValue) {
        filter = [selector, selectedFilterOperation || "=", null];
        if ("string" === dataType) {
          filter = [filter, "=" === selectedFilterOperation ? "or" : "and", [selector, selectedFilterOperation || "=", ""]];
        }
      } else if ("string" === dataType && (!column.lookup || isSearchByDisplayValue)) {
        filter = [selector, selectedFilterOperation || "contains", filterValue];
      } else if ("between" === selectedFilterOperation) {
        return getFilterExpressionByRange.apply(column, [filterValue, target]);
      } else if (isDateType(dataType) && isDefined(filterValue)) {
        return getFilterExpressionForDate.apply(column, arguments);
      } else if ("number" === dataType) {
        return getFilterExpressionForNumber.apply(column, arguments);
      } else {
        filter = [selector, selectedFilterOperation || "=", filterValue];
      }
      return filter;
    },
    getGroupInterval
  };
})();

// node_modules/devextreme/esm/__internal/grids/grid_core/utils/selector_comparison.js
var getNormalizedCallback = (callback) => "originalCallback" in callback ? callback.originalCallback : callback;
var getNormalizedColumnIdx = (callback) => "columnIndex" in callback ? callback.columnIndex ?? null : void 0;
var compareCallbacks = (callback, callbackToCompare) => {
  const normalizedCallback = getNormalizedCallback(callback);
  const normalizedCallbackToCompare = getNormalizedCallback(callbackToCompare);
  const normalizedColumnIdx = getNormalizedColumnIdx(callback);
  const normalizedColumnIdxToCompare = getNormalizedColumnIdx(callbackToCompare);
  const originalCallbacksEqual = normalizedCallback === normalizedCallbackToCompare;
  const shouldCompareColumnIdx = void 0 !== normalizedColumnIdx;
  const columnIdxEqual = normalizedColumnIdx === normalizedColumnIdxToCompare;
  return originalCallbacksEqual && (!shouldCompareColumnIdx || columnIdxEqual);
};
var isEqualSelectors = (selector, selectorToCompare) => {
  if ("string" === typeof selector && "string" === typeof selectorToCompare) {
    return selector === selectorToCompare;
  }
  if ("function" === typeof selector && "function" === typeof selectorToCompare) {
    return compareCallbacks(selector, selectorToCompare);
  }
  return false;
};
var isSelectorEqualWithCallback = (selector, callback) => {
  if ("function" === typeof selector && "function" === typeof callback) {
    return compareCallbacks(selector, callback);
  }
  return false;
};

// node_modules/devextreme/esm/__internal/grids/grid_core/m_utils.js
var LEGACY_SCROLLING_MODE = "scrolling.legacyMode";
var ROW_RENDERING_MODE_OPTION = "scrolling.rowRenderingMode";
var DATE_INTERVAL_SELECTORS = {
  year: (value2) => value2 && value2.getFullYear(),
  month: (value2) => value2 && value2.getMonth() + 1,
  day: (value2) => value2 && value2.getDate(),
  quarter: (value2) => value2 && Math.floor(value2.getMonth() / 3) + 1,
  hour: (value2) => value2 && value2.getHours(),
  minute: (value2) => value2 && value2.getMinutes(),
  second: (value2) => value2 && value2.getSeconds()
};
var getIntervalSelector = function() {
  const data17 = arguments[1];
  const value2 = this.calculateCellValue(data17);
  if (!isDefined(value2)) {
    return null;
  }
  if (isDateType2(this.dataType)) {
    const nameIntervalSelector = arguments[0];
    return DATE_INTERVAL_SELECTORS[nameIntervalSelector](value2);
  }
  if ("number" === this.dataType) {
    const groupInterval = arguments[0];
    return Math.floor(Number(value2) / groupInterval) * groupInterval;
  }
};
function isDateType2(dataType) {
  return "date" === dataType || "datetime" === dataType;
}
var setEmptyText = function($container) {
  $container.get(0).textContent = " ";
};
var normalizeSortingInfo2 = function(sort) {
  sort = sort || [];
  const result = normalizeSortingInfo(sort);
  for (let i = 0; i < sort.length; i++) {
    if (sort && sort[i] && void 0 !== sort[i].isExpanded) {
      result[i].isExpanded = sort[i].isExpanded;
    }
    if (sort && sort[i] && void 0 !== sort[i].groupInterval) {
      result[i].groupInterval = sort[i].groupInterval;
    }
  }
  return result;
};
var formatValue = function(value2, options) {
  const valueText = format_helper_default.format(value2, options.format) || value2 && value2.toString() || "";
  const formatObject = {
    value: value2,
    valueText: options.getDisplayFormat ? options.getDisplayFormat(valueText) : valueText,
    target: options.target || "row",
    groupInterval: options.groupInterval
  };
  return options.customizeText ? options.customizeText.call(options, formatObject) : formatObject.valueText;
};
var getSummaryText = function(summaryItem, summaryTexts) {
  const displayFormat = summaryItem.displayFormat || summaryItem.columnCaption && summaryTexts[`${summaryItem.summaryType}OtherColumn`] || summaryTexts[summaryItem.summaryType];
  return formatValue(summaryItem.value, {
    format: summaryItem.valueFormat,
    getDisplayFormat: (valueText) => displayFormat ? format(displayFormat, valueText, summaryItem.columnCaption) : valueText,
    customizeText: summaryItem.customizeText
  });
};
var getWidgetInstance = function($element) {
  const editorData = $element.data && $element.data();
  const dxComponents = editorData && editorData.dxComponents;
  const widgetName = dxComponents && dxComponents[0];
  return widgetName && editorData[widgetName];
};
var equalFilterParameters = function(filter1, filter2, langParams) {
  if (Array.isArray(filter1) && Array.isArray(filter2)) {
    if (filter1.length !== filter2.length) {
      return false;
    }
    for (let i = 0; i < filter1.length; i++) {
      if (!equalFilterParameters(filter1[i], filter2[i], langParams)) {
        return false;
      }
    }
    return true;
  }
  if (isFunction(filter1) && filter1.columnIndex >= 0 && isFunction(filter2) && filter2.columnIndex >= 0) {
    return filter1.columnIndex === filter2.columnIndex && toComparable(filter1.filterValue, void 0, langParams) === toComparable(filter2.filterValue, void 0, langParams) && toComparable(filter1.selectedFilterOperation, void 0, langParams) === toComparable(filter2.selectedFilterOperation, void 0, langParams);
  }
  return toComparable(filter1, void 0, langParams) == toComparable(filter2, void 0, langParams);
};
var createPoint = (options) => ({
  index: options.index,
  columnIndex: options.columnIndex,
  x: options.x,
  y: options.y
});
var addPointIfNeed = (points, pointProps, pointCreated) => {
  let notCreatePoint = false;
  if (pointCreated) {
    notCreatePoint = pointCreated(pointProps);
  }
  if (!notCreatePoint) {
    const point = createPoint(pointProps);
    points.push(point);
  }
};
function normalizeGroupingLoadOptions(group) {
  if (!Array.isArray(group)) {
    group = [group];
  }
  return group.map(((item, i) => {
    if (isString(item)) {
      return {
        selector: item,
        isExpanded: i < group.length - 1
      };
    }
    return item;
  }));
}
var m_utils_default = {
  renderNoDataText($element) {
    const that = this;
    $element = $element || this.element();
    if (!$element) {
      return;
    }
    const noDataClass = that.addWidgetPrefix("nodata");
    let noDataElement = $element.find(`.${noDataClass}`).last();
    const isVisible2 = this._dataController.isEmpty();
    const isLoading = this._dataController.isLoading();
    if (!noDataElement.length) {
      noDataElement = renderer_default("<span>").addClass(noDataClass);
    }
    if (!noDataElement.parent().is($element)) {
      noDataElement.appendTo($element);
    }
    if (isVisible2 && !isLoading) {
      noDataElement.removeClass("dx-hidden").text(that._getNoDataText());
    } else {
      noDataElement.addClass("dx-hidden");
    }
  },
  renderLoadPanel($element, $container, isLocalStore) {
    const that = this;
    let loadPanelOptions;
    that._loadPanel && that._loadPanel.$element().remove();
    loadPanelOptions = that.option("loadPanel");
    if (loadPanelOptions && ("auto" === loadPanelOptions.enabled ? !isLocalStore : loadPanelOptions.enabled)) {
      loadPanelOptions = extend({
        shading: false,
        message: loadPanelOptions.text,
        container: $container
      }, loadPanelOptions);
      that._loadPanel = that._createComponent(renderer_default("<div>").appendTo($container), load_panel_default2, loadPanelOptions);
    } else {
      that._loadPanel = null;
    }
  },
  calculateLoadPanelPosition($element) {
    const $window = renderer_default(getWindow());
    if (getHeight($element) > getHeight($window)) {
      return {
        of: $window,
        boundary: $element,
        collision: "fit"
      };
    }
    return {
      of: $element
    };
  },
  getIndexByKey(key, items, keyName) {
    let index = -1;
    if (void 0 !== key && Array.isArray(items)) {
      keyName = arguments.length <= 2 ? "key" : keyName;
      for (let i = 0; i < items.length; i++) {
        const item = isDefined(keyName) ? items[i][keyName] : items[i];
        if (equalByValue(key, item)) {
          index = i;
          break;
        }
      }
    }
    return index;
  },
  combineFilters(filters, operation) {
    let resultFilter = [];
    operation = operation || "and";
    for (let i = 0; i < filters.length; i++) {
      var _filters$i;
      if (!filters[i]) {
        continue;
      }
      if (1 === (null === (_filters$i = filters[i]) || void 0 === _filters$i ? void 0 : _filters$i.length) && "!" === filters[i][0]) {
        if ("and" === operation) {
          return ["!"];
        }
        if ("or" === operation) {
          continue;
        }
      }
      if (resultFilter.length) {
        resultFilter.push(operation);
      }
      resultFilter.push(filters[i]);
    }
    if (1 === resultFilter.length) {
      resultFilter = resultFilter[0];
    }
    if (resultFilter.length) {
      return resultFilter;
    }
    return;
  },
  checkChanges(changes, changeNames) {
    let changesWithChangeNamesCount = 0;
    for (let i = 0; i < changeNames.length; i++) {
      if (changes[changeNames[i]]) {
        changesWithChangeNamesCount++;
      }
    }
    return changes.length && changes.length === changesWithChangeNamesCount;
  },
  equalFilterParameters,
  proxyMethod(instance, methodName, defaultResult) {
    if (!instance[methodName]) {
      instance[methodName] = function() {
        const dataSource = this._dataSource;
        return dataSource ? dataSource[methodName].apply(dataSource, arguments) : defaultResult;
      };
    }
  },
  formatValue,
  getFormatOptionsByColumn: (column, target) => ({
    format: column.format,
    getDisplayFormat: column.getDisplayFormat,
    customizeText: column.customizeText,
    target,
    trueText: column.trueText,
    falseText: column.falseText
  }),
  getDisplayValue(column, value2, data17, rowType) {
    if (column.displayValueMap && void 0 !== column.displayValueMap[value2]) {
      return column.displayValueMap[value2];
    }
    if (column.calculateDisplayValue && data17 && "group" !== rowType) {
      return column.calculateDisplayValue(data17);
    }
    if (column.lookup && !("group" === rowType && (column.calculateGroupValue || column.calculateDisplayValue))) {
      return column.lookup.calculateCellValue(value2);
    }
    return value2;
  },
  getGroupRowSummaryText(summaryItems, summaryTexts) {
    let result = "(";
    for (let i = 0; i < summaryItems.length; i++) {
      const summaryItem = summaryItems[i];
      result += (i > 0 ? ", " : "") + getSummaryText(summaryItem, summaryTexts);
    }
    return result + ")";
  },
  getSummaryText,
  normalizeSortingInfo: normalizeSortingInfo2,
  getFormatByDataType(dataType) {
    switch (dataType) {
      case "date":
        return "shortDate";
      case "datetime":
        return "shortDateShortTime";
      default:
        return;
    }
  },
  getHeaderFilterGroupParameters(column, remoteGrouping) {
    let result = [];
    const dataField = column.dataField || column.name;
    const groupInterval = filtering_default.getGroupInterval(column);
    if (groupInterval) {
      each(groupInterval, ((index, interval) => {
        result.push(remoteGrouping ? {
          selector: dataField,
          groupInterval: interval,
          isExpanded: index < groupInterval.length - 1
        } : getIntervalSelector.bind(column, interval));
      }));
      return result;
    }
    if (remoteGrouping) {
      result = [{
        selector: dataField,
        isExpanded: false
      }];
    } else {
      result = function(data17) {
        let result2 = column.calculateCellValue(data17);
        if (void 0 === result2 || "" === result2) {
          result2 = null;
        }
        return result2;
      };
      if (column.sortingMethod) {
        result = [{
          selector: result,
          compare: column.sortingMethod.bind(column)
        }];
      }
    }
    return result;
  },
  equalSortParameters(sortParameters1, sortParameters2, ignoreIsExpanded) {
    sortParameters1 = normalizeSortingInfo2(sortParameters1);
    sortParameters2 = normalizeSortingInfo2(sortParameters2);
    if (Array.isArray(sortParameters1) && Array.isArray(sortParameters2)) {
      if (sortParameters1.length !== sortParameters2.length) {
        return false;
      }
      for (let i = 0; i < sortParameters1.length; i++) {
        if (!isEqualSelectors(sortParameters1[i].selector, sortParameters2[i].selector) || sortParameters1[i].desc !== sortParameters2[i].desc || sortParameters1[i].groupInterval !== sortParameters2[i].groupInterval || !ignoreIsExpanded && Boolean(sortParameters1[i].isExpanded) !== Boolean(sortParameters2[i].isExpanded)) {
          return false;
        }
      }
      return true;
    }
    return (!sortParameters1 || !sortParameters1.length) === (!sortParameters2 || !sortParameters2.length);
  },
  getPointsByColumns(items, pointCreated) {
    let isVertical = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;
    let startColumnIndex = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
    let needToCheckPrevPoint = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;
    const result = [];
    const cellsLength = items.length;
    let $item;
    let offset = {
      left: 0,
      top: 0
    };
    let itemRect = {
      width: 0,
      height: 0
    };
    let columnIndex = startColumnIndex;
    let rtlEnabled;
    for (let i = 0; i <= cellsLength; i++) {
      var _$item;
      if (i < cellsLength) {
        $item = items.eq(i);
        offset = $item.offset();
        itemRect = getBoundingRect($item.get(0));
        rtlEnabled = "rtl" === $item.css("direction");
      }
      const offsetRight = offset.left + itemRect.width;
      const offsetBottom = offset.top + itemRect.height;
      const pointProps = {
        index: columnIndex,
        columnIndex,
        item: null === (_$item = $item) || void 0 === _$item ? void 0 : _$item.get(0),
        x: !isVertical && rtlEnabled !== (i === cellsLength) ? offsetRight : offset.left,
        y: isVertical && i === cellsLength ? offsetBottom : offset.top
      };
      if (!isVertical && i > 0) {
        const prevItemOffset = items.eq(i - 1).offset();
        const {
          width: prevItemWidth
        } = getBoundingRect(items[i - 1]);
        const prevItemOffsetX = rtlEnabled ? prevItemOffset.left : prevItemOffset.left + prevItemWidth;
        if (prevItemOffset.top < pointProps.y) {
          pointProps.y = prevItemOffset.top;
        }
        if (needToCheckPrevPoint && Math.round(prevItemOffsetX) !== Math.round(pointProps.x)) {
          const prevPointProps = _extends({}, pointProps, {
            item: items[i - 1],
            x: prevItemOffsetX
          });
          if (rtlEnabled) {
            pointProps.isRightBoundary = true;
            prevPointProps.isLeftBoundary = true;
          } else {
            pointProps.isLeftBoundary = true;
            prevPointProps.isRightBoundary = true;
          }
          addPointIfNeed(result, prevPointProps, pointCreated);
        }
      }
      addPointIfNeed(result, pointProps, pointCreated);
      columnIndex++;
    }
    return result;
  },
  getExpandCellTemplate: () => ({
    allowRenderToDetachedContainer: true,
    render(container, options) {
      const $container = renderer_default(container);
      if (isDefined(options.value) && !(options.data && options.data.isContinuation) && !options.row.isNewRow) {
        const rowsView18 = options.component.getView("rowsView");
        $container.addClass("dx-datagrid-expand").addClass("dx-selection-disabled");
        renderer_default("<div>").addClass(options.value ? "dx-datagrid-group-opened" : "dx-datagrid-group-closed").appendTo($container);
        rowsView18.setAria("label", options.value ? rowsView18.localize("dxDataGrid-ariaCollapse") : rowsView18.localize("dxDataGrid-ariaExpand"), $container);
      } else {
        setEmptyText($container);
      }
    }
  }),
  setEmptyText,
  isDateType: isDateType2,
  getSelectionRange(focusedElement) {
    try {
      if (focusedElement) {
        return {
          selectionStart: focusedElement.selectionStart,
          selectionEnd: focusedElement.selectionEnd
        };
      }
    } catch (e) {
    }
    return {};
  },
  setSelectionRange(focusedElement, selectionRange) {
    try {
      if (focusedElement && focusedElement.setSelectionRange) {
        focusedElement.setSelectionRange(selectionRange.selectionStart, selectionRange.selectionEnd);
      }
    } catch (e) {
    }
  },
  focusAndSelectElement(component, $element) {
    const isFocused = $element.is(":focus");
    m_events_engine_default.trigger($element, "focus");
    const isSelectTextOnEditingStart = component.option("editing.selectTextOnEditStart");
    const element = $element.get(0);
    if (!isFocused && isSelectTextOnEditingStart && $element.is(".dx-texteditor-input") && !$element.is("[readonly]")) {
      const editor = getWidgetInstance($element.closest(".dx-texteditor"));
      when(editor && editor._loadItemDeferred).done((() => {
        element.select();
      }));
    }
  },
  getWidgetInstance,
  getLastResizableColumnIndex(columns7, resultWidths) {
    const hasResizableColumns = columns7.some(((column) => column && !column.command && !column.fixed && false !== column.allowResizing));
    let lastColumnIndex;
    for (lastColumnIndex = columns7.length - 1; columns7[lastColumnIndex]; lastColumnIndex--) {
      const column = columns7[lastColumnIndex];
      const width = resultWidths && resultWidths[lastColumnIndex];
      const allowResizing2 = !hasResizableColumns || false !== column.allowResizing;
      if (!column.command && !column.fixed && "adaptiveHidden" !== width && allowResizing2) {
        break;
      }
    }
    return lastColumnIndex;
  },
  isElementInCurrentGrid(controller, $element) {
    if ($element && $element.length) {
      const $grid = $element.closest(`.${controller.getWidgetContainerClass()}`).parent();
      return $grid.is(controller.component.$element());
    }
    return false;
  },
  isVirtualRowRendering(that) {
    const rowRenderingMode = that.option(ROW_RENDERING_MODE_OPTION);
    const isVirtualMode3 = "virtual" === that.option("scrolling.mode");
    const isAppendMode3 = "infinite" === that.option("scrolling.mode");
    if (false === that.option(LEGACY_SCROLLING_MODE) && (isVirtualMode3 || isAppendMode3)) {
      return true;
    }
    return "virtual" === rowRenderingMode;
  },
  getPixelRatio: (window2) => window2.devicePixelRatio || 1,
  getContentHeightLimit(browser) {
    if (browser.mozilla) {
      return 8e6;
    }
    return 15e6 / this.getPixelRatio(getWindow());
  },
  normalizeLookupDataSource(lookup) {
    let lookupDataSourceOptions;
    if (lookup.items) {
      lookupDataSourceOptions = lookup.items;
    } else {
      lookupDataSourceOptions = lookup.dataSource;
      if (isFunction(lookupDataSourceOptions) && !variable_wrapper_default.isWrapped(lookupDataSourceOptions)) {
        lookupDataSourceOptions = lookupDataSourceOptions({});
      }
    }
    return normalizeDataSourceOptions(lookupDataSourceOptions);
  },
  getWrappedLookupDataSource(column, dataSource, filter) {
    if (!dataSource) {
      return [];
    }
    const lookupDataSourceOptions = this.normalizeLookupDataSource(column.lookup);
    if (column.calculateCellValue !== column.defaultCalculateCellValue) {
      return lookupDataSourceOptions;
    }
    const hasGroupPaging = dataSource.remoteOperations().groupPaging;
    const hasLookupOptimization = column.displayField && isString(column.displayField);
    let cachedUniqueRelevantItems;
    let previousTake;
    let previousSkip;
    const sliceItems = (items, loadOptions) => {
      const start = loadOptions.skip ?? 0;
      const end = loadOptions.take ? start + loadOptions.take : items.length;
      return items.slice(start, end);
    };
    const lookupDataSource = _extends({}, lookupDataSourceOptions, {
      __dataGridSourceFilter: filter,
      load: (loadOptions) => {
        const d = new Deferred();
        ((loadOptions2) => {
          const group = normalizeGroupingLoadOptions(hasLookupOptimization ? [column.dataField, column.displayField] : column.dataField);
          const d2 = new Deferred();
          const canUseCache = cachedUniqueRelevantItems && (!hasGroupPaging || loadOptions2.skip === previousSkip && loadOptions2.take === previousTake);
          if (canUseCache) {
            d2.resolve(sliceItems(cachedUniqueRelevantItems, loadOptions2));
          } else {
            previousSkip = loadOptions2.skip;
            previousTake = loadOptions2.take;
            dataSource.load({
              filter,
              group,
              take: hasGroupPaging ? loadOptions2.take : void 0,
              skip: hasGroupPaging ? loadOptions2.skip : void 0
            }).done(((items) => {
              cachedUniqueRelevantItems = items;
              d2.resolve(hasGroupPaging ? items : sliceItems(items, loadOptions2));
            })).fail(d2.fail);
          }
          return d2;
        })(loadOptions).done(((items) => {
          if (0 === items.length) {
            d.resolve([]);
            return;
          }
          const filter2 = this.combineFilters(items.flatMap(((data17) => data17.key)).map(((key) => [column.lookup.valueExpr, key])), "or");
          const newDataSource = new data_source_default(_extends({}, lookupDataSourceOptions, loadOptions, {
            filter: this.combineFilters([filter2, loadOptions.filter], "and"),
            paginate: false
          }));
          newDataSource.load().done(d.resolve).fail(d.fail);
        })).fail(d.fail);
        return d;
      },
      key: column.lookup.valueExpr,
      byKey(key) {
        const d = Deferred();
        this.load({
          filter: [column.lookup.valueExpr, "=", key]
        }).done(((arr) => {
          d.resolve(arr[0]);
        }));
        return d.promise();
      }
    });
    return lookupDataSource;
  },
  logHeaderFilterDeprecatedWarningIfNeed(component) {
    const logWarning = component._logDeprecatedOptionWarning.bind(component);
    if (isDefined(component.option("headerFilter.allowSearch"))) {
      logWarning("headerFilter.allowSearch", {
        since: "23.1",
        alias: "headerFilter.search.enabled"
      });
    }
    if (isDefined(component.option("headerFilter.searchTimeout"))) {
      logWarning("headerFilter.searchTimeout", {
        since: "23.1",
        alias: "headerFilter.search.timeout"
      });
    }
    const specificName = "dxPivotGrid" === component.NAME ? "dataSource.fields" : "columns";
    const columns7 = component.option(specificName);
    if (!Array.isArray(columns7)) {
      return;
    }
    const logSpecificDeprecatedWarningIfNeed = (columns8) => {
      columns8.forEach(((column) => {
        var _column$columns;
        const headerFilter = column.headerFilter || {};
        if (isDefined(headerFilter.allowSearch)) {
          logWarning(`${specificName}[].headerFilter.allowSearch`, {
            since: "23.1",
            alias: `${specificName}[].headerFilter.search.enabled`
          });
        }
        if (isDefined(headerFilter.searchMode)) {
          logWarning(`${specificName}[].headerFilter.searchMode`, {
            since: "23.1",
            alias: `${specificName}[].headerFilter.search.mode`
          });
        }
        if (null !== (_column$columns = column.columns) && void 0 !== _column$columns && _column$columns.length) {
          logSpecificDeprecatedWarningIfNeed(column.columns);
        }
      }));
    };
    logSpecificDeprecatedWarningIfNeed(columns7);
  },
  getComponentBorderWidth(that, $rowsViewElement) {
    const borderWidth = that.option("showBorders") ? Math.ceil(getOuterWidth($rowsViewElement) - getInnerWidth($rowsViewElement)) : 0;
    return borderWidth;
  },
  isCustomCommandColumn(columns7, commandColumn) {
    const customCommandColumns = columns7.filter(((column) => column.type === commandColumn.type));
    return !!customCommandColumns.length;
  },
  isEqualSelectors,
  isSelectorEqualWithCallback
};

// node_modules/devextreme/esm/__internal/grids/grid_core/views/m_columns_view.js
var DETAIL_ROW_CLASS = "dx-master-detail-row";
var CELL_HINT_VISIBLE = "dxCellHintVisible";
var appendElementTemplate = {
  render(options) {
    options.container.append(options.content);
  }
};
var subscribeToRowEvents = function(that, $table) {
  let touchTarget;
  let touchCurrentTarget;
  let timeoutId;
  function clearTouchTargets(timeout) {
    return setTimeout((() => {
      touchTarget = touchCurrentTarget = null;
    }), timeout);
  }
  m_events_engine_default.on($table, "touchstart touchend", ".dx-row", ((e) => {
    var _e$event;
    if (null !== e && void 0 !== e && null !== (_e$event = e.event) && void 0 !== _e$event && _e$event.target && !m_utils_default.isElementInCurrentGrid(that, renderer_default(e.event.target))) {
      return;
    }
    clearTimeout(timeoutId);
    if ("touchstart" === e.type) {
      touchTarget = e.target;
      touchCurrentTarget = e.currentTarget;
      timeoutId = clearTouchTargets(1e3);
    } else {
      timeoutId = clearTouchTargets();
    }
  }));
  m_events_engine_default.on($table, [CLICK_EVENT_NAME, DBLCLICK_EVENT_NAME, m_pointer_default.down].join(" "), ".dx-row", that.createAction(((e) => {
    var _e$event2;
    const {
      event
    } = e;
    if (null !== e && void 0 !== e && null !== (_e$event2 = e.event) && void 0 !== _e$event2 && _e$event2.target && !m_utils_default.isElementInCurrentGrid(that, renderer_default(event.target))) {
      return;
    }
    if (touchTarget) {
      event.target = touchTarget;
      event.currentTarget = touchCurrentTarget;
    }
    if (!renderer_default(event.target).closest("a").length) {
      e.rowIndex = that.getRowIndex(event.currentTarget);
      if (e.rowIndex >= 0) {
        e.rowElement = getPublicElement(renderer_default(event.currentTarget));
        e.columns = that.getColumns();
        if (event.type === m_pointer_default.down) {
          that._rowPointerDown(e);
        } else if (event.type === CLICK_EVENT_NAME) {
          that._rowClick(e);
        } else {
          that._rowDblClick(e);
        }
      }
    }
  })));
};
var getWidthStyle = function(width) {
  if ("auto" === width) {
    return "";
  }
  return isNumeric(width) ? `${width}px` : width;
};
var setCellWidth = function(cell, column, width) {
  cell.style.width = cell.style.maxWidth = "auto" === column.width ? "" : width;
};
var copyAttributes = function(element, newElement) {
  if (!element || !newElement) {
    return;
  }
  const oldAttributes = element.attributes;
  const newAttributes = newElement.attributes;
  let i;
  for (i = 0; i < oldAttributes.length; i++) {
    const name = oldAttributes[i].nodeName;
    if (!newElement.hasAttribute(name)) {
      element.removeAttribute(name);
    }
  }
  for (i = 0; i < newAttributes.length; i++) {
    element.setAttribute(newAttributes[i].nodeName, newAttributes[i].nodeValue);
  }
};
var removeHandler = function(templateDeferred) {
  templateDeferred.resolve();
};
var normalizeWidth = (width) => {
  if ("number" === typeof width) {
    return `${width.toFixed(3)}px`;
  }
  if ("adaptiveHidden" === width) {
    return "0.0001px";
  }
  return width;
};
var ColumnsView = class extends ColumnStateMixin(m_modules_default.View) {
  init() {
    this._scrollLeft = -1;
    this._columnsController = this.getController("columns");
    this._dataController = this.getController("data");
    this._adaptiveColumnsController = this.getController("adaptiveColumns");
    this._columnChooserController = this.getController("columnChooser");
    this._editorFactoryController = this.getController("editorFactory");
    this._selectionController = this.getController("selection");
    this._columnChooserView = this.getView("columnChooserView");
    this._delayedTemplates = [];
    this._templateDeferreds = /* @__PURE__ */ new Set();
    this._templatesCache = {};
    this._templateTimeouts = /* @__PURE__ */ new Set();
    this.createAction("onCellClick");
    this.createAction("onRowClick");
    this.createAction("onCellDblClick");
    this.createAction("onRowDblClick");
    this.createAction("onCellHoverChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
    this.createAction("onCellPrepared", {
      excludeValidators: ["disabled", "readOnly"],
      category: "rendering"
    });
    this.createAction("onRowPrepared", {
      excludeValidators: ["disabled", "readOnly"],
      category: "rendering",
      afterExecute: (e) => {
        this._afterRowPrepared(e);
      }
    });
    this._columnsController.columnsChanged.add(this._columnOptionChanged.bind(this));
    this._dataController && this._dataController.changed.add(this._handleDataChanged.bind(this));
  }
  dispose() {
    if (hasWindow()) {
      var _this$_templateTimeou, _this$_templateTimeou2;
      const window2 = getWindow();
      null === (_this$_templateTimeou = this._templateTimeouts) || void 0 === _this$_templateTimeou || _this$_templateTimeou.forEach(((templateTimeout) => window2.clearTimeout(templateTimeout)));
      null === (_this$_templateTimeou2 = this._templateTimeouts) || void 0 === _this$_templateTimeou2 || _this$_templateTimeou2.clear();
    }
  }
  optionChanged(args) {
    super.optionChanged(args);
    switch (args.name) {
      case "cellHintEnabled":
      case "onCellPrepared":
      case "onRowPrepared":
      case "onCellHoverChanged":
        this._invalidate(true, true);
        args.handled = true;
        break;
      case "keyboardNavigation":
        if ("keyboardNavigation.enabled" === args.fullName) {
          this._invalidate(true, true);
        }
        args.handled = true;
    }
  }
  _createScrollableOptions() {
    const scrollingOptions = this.option("scrolling");
    let useNativeScrolling = this.option("scrolling.useNative");
    const options = extend({}, scrollingOptions, {
      direction: "both",
      bounceEnabled: false,
      useKeyboard: false
    });
    if (void 0 === useNativeScrolling) {
      useNativeScrolling = true;
    }
    if ("auto" === useNativeScrolling) {
      delete options.useNative;
      delete options.useSimulatedScrollbar;
    } else {
      options.useNative = !!useNativeScrolling;
      options.useSimulatedScrollbar = !useNativeScrolling;
    }
    return options;
  }
  _updateCell($cell, parameters) {
    if (parameters.rowType) {
      this._cellPrepared($cell, parameters);
    }
  }
  _needToSetCellWidths() {
    return this.option("columnAutoWidth");
  }
  _createCell(options) {
    const {
      column
    } = options;
    const alignment = column.alignment || getDefaultAlignment(this.option("rtlEnabled"));
    const needToSetCellWidths = this._needToSetCellWidths();
    const cell = dom_adapter_default.createElement("td");
    cell.style.textAlign = alignment;
    const $cell = renderer_default(cell);
    if (column.cssClass) {
      $cell.addClass(column.cssClass);
    }
    if (Array.isArray(column.elementAttr)) {
      column.elementAttr.forEach(((_ref) => {
        let {
          name,
          value: value2
        } = _ref;
        $cell.attr(name, value2);
      }));
    }
    if ("expand" === column.command) {
      $cell.addClass(column.cssClass);
      $cell.addClass(this.addWidgetPrefix("group-space"));
    }
    if (column.colspan > 1) {
      $cell.attr("colSpan", column.colspan);
    } else if (!column.isBand && "auto" !== column.visibleWidth && needToSetCellWidths) {
      if (column.width || column.minWidth) {
        cell.style.minWidth = getWidthStyle(column.minWidth || column.width);
      }
      if (column.width) {
        setCellWidth(cell, column, getWidthStyle(column.width));
      }
    }
    return $cell;
  }
  _createRow(rowObject, tagName) {
    tagName = tagName || "tr";
    const $element = renderer_default(`<${tagName}>`).addClass("dx-row");
    if ("tr" === tagName) {
      this.setAria("role", "row", $element);
    }
    return $element;
  }
  _isAltRow(row) {
    return row && row.dataIndex % 2 === 1;
  }
  _createTable(columns7, isAppend) {
    const $table = renderer_default("<table>").addClass(this.addWidgetPrefix("table")).addClass(this.addWidgetPrefix("table-fixed"));
    if (columns7 && !isAppend) {
      $table.attr("id", `dx-${new guid_default()}`).append(this._createColGroup(columns7));
      if (browser_default.safari) {
        $table.append(renderer_default("<thead>").append("<tr>"));
      }
      this.setAria("role", "presentation", $table);
    } else {
      this.setAria("hidden", true, $table);
    }
    this.setAria("role", "presentation", renderer_default("<tbody>").appendTo($table));
    if (isAppend) {
      return $table;
    }
    if (browser_default.mozilla) {
      m_events_engine_default.on($table, "mousedown", "td", ((e) => {
        if (e.ctrlKey) {
          e.preventDefault();
        }
      }));
    }
    if (this.option("cellHintEnabled")) {
      m_events_engine_default.on($table, "mousemove", ".dx-row > td", this.createAction(((args) => {
        const e = args.event;
        const $element = renderer_default(e.target);
        const $cell = renderer_default(e.currentTarget);
        const $row = $cell.parent();
        const visibleColumns = this._columnsController.getVisibleColumns();
        const rowOptions = $row.data("options");
        const columnIndex = $cell.index();
        const cellOptions = rowOptions && rowOptions.cells && rowOptions.cells[columnIndex];
        const column = cellOptions ? cellOptions.column : visibleColumns[columnIndex];
        const isHeaderRow = $row.hasClass("dx-header-row");
        const isDataRow2 = $row.hasClass("dx-data-row");
        const isMasterDetailRow = $row.hasClass(DETAIL_ROW_CLASS);
        const isGroupRow3 = $row.hasClass("dx-group-row");
        const isFilterRow = $row.hasClass(this.addWidgetPrefix("filter-row"));
        const isDataRowWithTemplate = isDataRow2 && (!column || column.cellTemplate);
        const isEditorShown = isDataRow2 && cellOptions && (rowOptions.isEditing || cellOptions.isEditing || (null === column || void 0 === column ? void 0 : column.showEditorAlways));
        const isHeaderRowWithTemplate = isHeaderRow && (!column || column.headerCellTemplate);
        const isGroupCellWithTemplate = isGroupRow3 && (!column || column.groupIndex && column.groupCellTemplate);
        const shouldShowHint = !isMasterDetailRow && !isFilterRow && !isEditorShown && !isDataRowWithTemplate && !isHeaderRowWithTemplate && !isGroupCellWithTemplate;
        if (shouldShowHint) {
          if ($element.data(CELL_HINT_VISIBLE)) {
            $element.removeAttr("title");
            $element.data(CELL_HINT_VISIBLE, false);
          }
          const difference = $element[0].scrollWidth - $element[0].clientWidth;
          if (difference > 0 && !isDefined($element.attr("title"))) {
            $element.attr("title", $element.text());
            $element.data(CELL_HINT_VISIBLE, true);
          }
        }
      })));
    }
    const getOptions = (event) => {
      const $cell = renderer_default(event.currentTarget);
      const $fieldItemContent = renderer_default(event.target).closest(".dx-field-item-content");
      const $row = $cell.parent();
      const rowOptions = $row.data("options");
      const options = rowOptions && rowOptions.cells && rowOptions.cells[$cell.index()];
      if (!$cell.closest("table").is(event.delegateTarget)) {
        return;
      }
      const resultOptions = extend({}, options, {
        cellElement: getPublicElement($cell),
        event,
        eventType: event.type
      });
      resultOptions.rowIndex = this.getRowIndex($row);
      if ($fieldItemContent.length) {
        const formItemOptions = $fieldItemContent.data("dx-form-item");
        if (formItemOptions.column) {
          resultOptions.column = formItemOptions.column;
          resultOptions.columnIndex = this._columnsController.getVisibleIndex(resultOptions.column.index);
        }
      }
      return resultOptions;
    };
    m_events_engine_default.on($table, "mouseover", ".dx-row > td", ((e) => {
      const options = getOptions(e);
      options && this.executeAction("onCellHoverChanged", options);
    }));
    m_events_engine_default.on($table, "mouseout", ".dx-row > td", ((e) => {
      const options = getOptions(e);
      options && this.executeAction("onCellHoverChanged", options);
    }));
    m_events_engine_default.on($table, CLICK_EVENT_NAME, ".dx-row > td", ((e) => {
      const options = getOptions(e);
      options && this.executeAction("onCellClick", options);
    }));
    m_events_engine_default.on($table, DBLCLICK_EVENT_NAME, ".dx-row > td", ((e) => {
      const options = getOptions(e);
      options && this.executeAction("onCellDblClick", options);
    }));
    subscribeToRowEvents(this, $table);
    return $table;
  }
  _rowPointerDown(e) {
  }
  _rowClick() {
  }
  _rowDblClick() {
  }
  _createColGroup(columns7) {
    const colgroupElement = renderer_default("<colgroup>");
    for (let i = 0; i < columns7.length; i++) {
      const colspan = columns7[i].colspan || 1;
      for (let j = 0; j < colspan; j++) {
        colgroupElement.append(this._createCol(columns7[i]));
      }
    }
    return colgroupElement;
  }
  _createCol(column) {
    let width = column.visibleWidth || column.width;
    if ("adaptiveHidden" === width) {
      width = "0.0001px";
    }
    const col = renderer_default("<col>");
    setWidth2(col, width);
    return col;
  }
  renderDelayedTemplates(change) {
    const delayedTemplates = this._delayedTemplates;
    const syncTemplates = delayedTemplates.filter(((template) => !template.async));
    const asyncTemplates = delayedTemplates.filter(((template) => template.async));
    this._delayedTemplates = [];
    this._renderDelayedTemplatesCore(syncTemplates, false, change);
    this._renderDelayedTemplatesCoreAsync(asyncTemplates);
  }
  _renderDelayedTemplatesCoreAsync(templates) {
    if (templates.length) {
      const templateTimeout = getWindow().setTimeout((() => {
        this._templateTimeouts.delete(templateTimeout);
        this._renderDelayedTemplatesCore(templates, true);
      }));
      this._templateTimeouts.add(templateTimeout);
    }
  }
  _renderDelayedTemplatesCore(templates, isAsync, change) {
    const date = /* @__PURE__ */ new Date();
    while (templates.length) {
      const templateParameters = templates.shift();
      const {
        options
      } = templateParameters;
      const doc = dom_adapter_default.getRootNode(renderer_default(options.container).get(0));
      const needWaitAsyncTemplates = this.needWaitAsyncTemplates();
      if (!isAsync || renderer_default(options.container).closest(doc).length || needWaitAsyncTemplates) {
        if (change) {
          options.change = change;
        }
        templateParameters.template.render(options);
      }
      if (isAsync && /* @__PURE__ */ new Date() - date > 30) {
        this._renderDelayedTemplatesCoreAsync(templates);
        break;
      }
    }
    if (!templates.length && this._delayedTemplates.length) {
      this.renderDelayedTemplates();
    }
  }
  _processTemplate(template, options) {
    const that = this;
    let renderingTemplate;
    if (template && template.render && !isRenderer(template)) {
      renderingTemplate = {
        allowRenderToDetachedContainer: template.allowRenderToDetachedContainer,
        render(options2) {
          template.render(options2.container, options2.model, options2.change);
          options2.deferred && options2.deferred.resolve();
        }
      };
    } else if (isFunction(template)) {
      renderingTemplate = {
        render(options2) {
          const renderedTemplate = template(getPublicElement(options2.container), options2.model, options2.change);
          if (renderedTemplate && (renderedTemplate.nodeType || isRenderer(renderedTemplate))) {
            options2.container.append(renderedTemplate);
          }
          options2.deferred && options2.deferred.resolve();
        }
      };
    } else {
      const templateID = isString(template) ? template : renderer_default(template).attr("id");
      if (!templateID) {
        renderingTemplate = that.getTemplate(template);
      } else {
        if (!that._templatesCache[templateID]) {
          that._templatesCache[templateID] = that.getTemplate(template);
        }
        renderingTemplate = that._templatesCache[templateID];
      }
    }
    return renderingTemplate;
  }
  renderTemplate(container, template, options, allowRenderToDetachedContainer, change) {
    const renderingTemplate = this._processTemplate(template, options);
    const {
      column
    } = options;
    const isDataRow2 = "data" === options.rowType;
    const templateDeferred = new Deferred();
    const templateOptions = {
      container,
      model: options,
      deferred: templateDeferred,
      onRendered: () => {
        if (this.isDisposed()) {
          templateDeferred.reject();
        } else {
          templateDeferred.resolve();
        }
      }
    };
    if (renderingTemplate) {
      options.component = this.component;
      const columnAsync = column && (column.renderAsync && isDataRow2 || this.option("renderAsync") && (false !== column.renderAsync && (column.command || column.showEditorAlways) && isDataRow2 || "filter" === options.rowType));
      const async = options.renderAsync ?? columnAsync;
      if ((renderingTemplate.allowRenderToDetachedContainer || allowRenderToDetachedContainer) && !async) {
        renderingTemplate.render(templateOptions);
      } else {
        this._delayedTemplates.push({
          template: renderingTemplate,
          options: templateOptions,
          async
        });
      }
      this._templateDeferreds.add(templateDeferred);
      m_events_engine_default.on(container, removeEvent, removeHandler.bind(null, templateDeferred));
    } else {
      templateDeferred.reject();
    }
    return templateDeferred.promise().always((() => {
      this._templateDeferreds.delete(templateDeferred);
    }));
  }
  _getBodies(tableElement) {
    return renderer_default(tableElement).children("tbody").not(".dx-header").not(".dx-footer");
  }
  _needWrapRow($tableElement) {
    var _this$_getBodies;
    const hasRowTemplate = !!this.option().rowTemplate;
    return hasRowTemplate && !!(null !== (_this$_getBodies = this._getBodies($tableElement)) && void 0 !== _this$_getBodies && _this$_getBodies.filter(".dx-row").length);
  }
  _wrapRowIfNeed($table, $row, isRefreshing) {
    const $tableElement = isRefreshing ? $table || this._tableElement : this._tableElement || $table;
    const needWrapRow = this._needWrapRow($tableElement);
    if (needWrapRow) {
      const $tbody = renderer_default("<tbody>").addClass($row.attr("class"));
      this.setAria("role", "presentation", $tbody);
      return $tbody.append($row);
    }
    return $row;
  }
  _appendRow($table, $row, appendTemplate) {
    appendTemplate = appendTemplate || appendElementTemplate;
    appendTemplate.render({
      content: $row,
      container: $table
    });
  }
  _resizeCore() {
    const scrollLeft = this._scrollLeft;
    if (scrollLeft >= 0) {
      this._scrollLeft = 0;
      this.scrollTo({
        left: scrollLeft
      });
    }
  }
  _renderCore(e) {
    const $root = this.element().parent();
    if (!$root || $root.parent().length) {
      this.renderDelayedTemplates(e);
    }
    return new Deferred().resolve();
  }
  _renderTable(options) {
    options = options || {};
    options.columns = this._columnsController.getVisibleColumns();
    const changeType = options.change && options.change.changeType;
    const $table = this._createTable(options.columns, "append" === changeType || "prepend" === changeType || "update" === changeType);
    this._renderRows($table, options);
    return $table;
  }
  _renderRows($table, options) {
    const that = this;
    const rows = that._getRows(options.change);
    const columnIndices = options.change && options.change.columnIndices || [];
    const changeTypes = options.change && options.change.changeTypes || [];
    for (let i = 0; i < rows.length; i++) {
      that._renderRow($table, extend({
        row: rows[i],
        columnIndices: columnIndices[i],
        changeType: changeTypes[i]
      }, options));
    }
  }
  _renderRow($table, options) {
    if (!options.columnIndices) {
      options.row.cells = [];
    }
    const $row = this._createRow(options.row);
    const $wrappedRow = this._wrapRowIfNeed($table, $row);
    if ("remove" !== options.changeType) {
      this._renderCells($row, options);
    }
    this._appendRow($table, $wrappedRow);
    const rowOptions = extend({
      columns: options.columns
    }, options.row);
    this._addWatchMethod(rowOptions, options.row);
    this._rowPrepared($wrappedRow, rowOptions, options.row);
  }
  _needRenderCell(columnIndex, columnIndices) {
    return !columnIndices || columnIndices.indexOf(columnIndex) >= 0;
  }
  _renderCells($row, options) {
    const that = this;
    let columnIndex = 0;
    const {
      row
    } = options;
    const {
      columns: columns7
    } = options;
    for (let i = 0; i < columns7.length; i++) {
      if (this._needRenderCell(i, options.columnIndices)) {
        that._renderCell($row, extend({
          column: columns7[i],
          columnIndex,
          value: row.values && row.values[columnIndex],
          oldValue: row.oldValues && row.oldValues[columnIndex]
        }, options));
      }
      if (columns7[i].colspan > 1) {
        columnIndex += columns7[i].colspan;
      } else {
        columnIndex++;
      }
    }
  }
  _updateCells($rowElement, $newRowElement, columnIndices, options) {
    var _options$node;
    const that = this;
    const $cells = $rowElement.children();
    const $newCells = $newRowElement.children();
    const highlightChanges = this.option("highlightChanges");
    const cellUpdatedClass = this.addWidgetPrefix("cell-updated-animation");
    if (null !== options && void 0 !== options && null !== (_options$node = options.node) && void 0 !== _options$node && _options$node.hasChildren) {
      $cells.each((function() {
        that.setAria("expanded", options.isExpanded, renderer_default(this));
      }));
    }
    columnIndices.forEach(((columnIndex, index) => {
      const $cell = $cells.eq(columnIndex);
      const $newCell = $newCells.eq(index);
      $cell.replaceWith($newCell);
      if (highlightChanges && !$newCell.hasClass("dx-command-expand")) {
        $newCell.addClass(cellUpdatedClass);
      }
    }));
    copyAttributes($rowElement.get(0), $newRowElement.get(0));
  }
  _setCellAriaAttributes($cell, cellOptions, options) {
    var _row$node;
    const {
      row
    } = options;
    const isFreeSpaceRow = "freeSpace" === cellOptions.rowType;
    const isGroupRow3 = "group" === cellOptions.rowType;
    const rowHasChildren = null === row || void 0 === row || null === (_row$node = row.node) || void 0 === _row$node ? void 0 : _row$node.hasChildren;
    if (isFreeSpaceRow) {
      return;
    }
    this.setAria("role", "gridcell", $cell);
    if (rowHasChildren) {
      this.setAria("expanded", row.isExpanded, $cell);
    }
    const columnIndexOffset = this._columnsController.getColumnIndexOffset();
    const ariaColIndex = isGroupRow3 ? cellOptions.columnIndex + 1 : cellOptions.columnIndex + columnIndexOffset + 1;
    this.setAria("colindex", ariaColIndex, $cell);
  }
  _renderCell($row, options) {
    const cellOptions = this._getCellOptions(options);
    if (options.columnIndices) {
      if (options.row.cells) {
        const cellIndex = options.row.cells.findIndex(((cell) => cell.columnIndex === cellOptions.columnIndex));
        options.row.cells[cellIndex] = cellOptions;
      }
    } else {
      options.row.cells.push(cellOptions);
    }
    const $cell = this._createCell(cellOptions);
    this._setCellAriaAttributes($cell, cellOptions, options);
    this._renderCellContent($cell, cellOptions, options);
    $row.get(0).appendChild($cell.get(0));
    return $cell;
  }
  _renderCellContent($cell, options, renderOptions) {
    const template = this._getCellTemplate(options);
    when(!template || this.renderTemplate($cell, template, options, void 0, renderOptions.change)).done((() => {
      this._updateCell($cell, options);
    }));
  }
  _getCellTemplate(options) {
  }
  _getRows(change) {
    return [];
  }
  _getCellOptions(options) {
    const cellOptions = {
      column: options.column,
      columnIndex: options.columnIndex,
      rowType: options.row.rowType,
      rowIndex: options.row.rowIndex,
      isAltRow: this._isAltRow(options.row)
    };
    this._addWatchMethod(cellOptions);
    return cellOptions;
  }
  _addWatchMethod(options, source) {
    if (!this.option("repaintChangesOnly")) {
      return;
    }
    const watchers = [];
    source = source || options;
    source.watch = source.watch || function(getter, updateValueFunc, updateRowFunc) {
      let oldValue = getter(source.data);
      const watcher = function(row) {
        if (row && updateRowFunc) {
          updateRowFunc(row);
        }
        const newValue = getter(source.data);
        if (JSON.stringify(oldValue) !== JSON.stringify(newValue)) {
          if (row) {
            updateValueFunc(newValue);
          }
          oldValue = newValue;
        }
      };
      watchers.push(watcher);
      return function() {
        const index = watchers.indexOf(watcher);
        if (index >= 0) {
          watchers.splice(index, 1);
        }
      };
    };
    source.update = source.update || function(row, keepRow) {
      if (row) {
        this.data = options.data = row.data;
        this.rowIndex = options.rowIndex = row.rowIndex;
        this.dataIndex = options.dataIndex = row.dataIndex;
        this.isExpanded = options.isExpanded = row.isExpanded;
        if (options.row && !keepRow) {
          options.row = row;
        }
      }
      watchers.forEach(((watcher) => {
        watcher(row);
      }));
    };
    if (source !== options) {
      options.watch = source.watch.bind(source);
    }
    return options;
  }
  _cellPrepared(cell, options) {
    options.cellElement = getPublicElement(renderer_default(cell));
    this.executeAction("onCellPrepared", options);
  }
  _rowPrepared($row, options, row) {
    data($row.get(0), "options", options);
    options.rowElement = getPublicElement($row);
    this.executeAction("onRowPrepared", options);
  }
  _columnOptionChanged(e) {
    const {
      optionNames
    } = e;
    if (m_utils_default.checkChanges(optionNames, ["width", "visibleWidth"])) {
      const visibleColumns = this._columnsController.getVisibleColumns();
      const widths = visibleColumns.map(((column) => column.visibleWidth || column.width));
      this.setColumnWidths({
        widths,
        optionNames
      });
      return;
    }
    if (!this._requireReady) {
      this.render();
    }
  }
  getCellIndex($cell, rowIndex) {
    const cellIndex = $cell.length ? $cell[0].cellIndex : -1;
    return cellIndex;
  }
  getTableElements() {
    return this._tableElement || renderer_default();
  }
  getTableElement(isFixedTableRendering) {
    return this._tableElement;
  }
  setTableElement(tableElement, isFixedTableRendering) {
    this._tableElement = tableElement;
  }
  _afterRowPrepared(e) {
  }
  _handleDataChanged(e) {
  }
  callbackNames() {
    return ["scrollChanged"];
  }
  _updateScrollLeftPosition() {
    const scrollLeft = this._scrollLeft;
    if (scrollLeft >= 0) {
      this._scrollLeft = 0;
      this.scrollTo({
        left: scrollLeft
      });
    }
  }
  scrollTo(pos) {
    const $element = this.element();
    const $scrollContainer = $element && $element.children(`.${this.addWidgetPrefix("scroll-container")}`).not(`.${this.addWidgetPrefix("content-fixed")}`);
    if (isDefined(pos) && isDefined(pos.left) && this._scrollLeft !== pos.left) {
      this._scrollLeft = pos.left;
      $scrollContainer && $scrollContainer.scrollLeft(pos.left);
    }
  }
  getContent(isFixedTableRendering) {
    var _this$_tableElement;
    return null === (_this$_tableElement = this._tableElement) || void 0 === _this$_tableElement ? void 0 : _this$_tableElement.parent();
  }
  _removeContent(isFixedTableRendering) {
    const $scrollContainer = this.getContent(isFixedTableRendering);
    if (null !== $scrollContainer && void 0 !== $scrollContainer && $scrollContainer.length) {
      $scrollContainer.remove();
    }
  }
  handleScroll(e) {
    const scrollLeft = renderer_default(e.target).scrollLeft();
    if (scrollLeft !== this._scrollLeft) {
      this.scrollChanged.fire({
        left: scrollLeft
      }, this.name);
    }
  }
  _wrapTableInScrollContainer($table, isFixedTableRendering) {
    const $scrollContainer = renderer_default("<div>");
    const useNative = this.option("scrolling.useNative");
    if (false === useNative || "auto" === useNative && !m_support_default.nativeScrolling) {
      $scrollContainer.addClass(this.addWidgetPrefix("scrollable-simulated"));
    }
    m_events_engine_default.on($scrollContainer, "scroll", this.handleScroll.bind(this));
    $scrollContainer.addClass(this.addWidgetPrefix("content")).addClass(this.addWidgetPrefix("scroll-container")).append($table).appendTo(this.element());
    this.setAria("role", "presentation", $scrollContainer);
    return $scrollContainer;
  }
  needWaitAsyncTemplates() {
    return this.option("templatesRenderAsynchronously") && false === this.option("renderAsync");
  }
  waitAsyncTemplates() {
    let forceWaiting = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : false;
    const result = new Deferred();
    const needWaitAsyncTemplates = forceWaiting || this.needWaitAsyncTemplates();
    if (!needWaitAsyncTemplates || !isDefined(this._templateDeferreds)) {
      return result.resolve();
    }
    const waitTemplatesRecursion = () => when.apply(this, Array.from(this._templateDeferreds)).done((() => {
      if (this.isDisposed()) {
        result.reject();
      } else if (this._templateDeferreds.size > 0) {
        waitTemplatesRecursion();
      } else {
        result.resolve();
      }
    })).fail(result.reject);
    waitTemplatesRecursion();
    return result.promise();
  }
  _updateContent($newTableElement, change, isFixedTableRendering) {
    return this.waitAsyncTemplates().done((() => {
      this._removeContent(isFixedTableRendering);
      this.setTableElement($newTableElement, isFixedTableRendering);
      this._wrapTableInScrollContainer($newTableElement, isFixedTableRendering);
    }));
  }
  _findContentElement(isFixedTableRendering) {
  }
  _getWidths($cellElements) {
    if (!$cellElements) {
      return [];
    }
    const result = [];
    const cellElements = $cellElements.toArray();
    cellElements.forEach(((cell) => {
      let width = cell.offsetWidth;
      if (cell.getBoundingClientRect) {
        const rect = getBoundingRect(cell);
        if (rect.width > cell.offsetWidth - 1) {
          width = rect.width;
        }
      }
      result.push(width);
    }));
    return result;
  }
  getColumnWidths($tableElement, rowIndex) {
    (this.option("forceApplyBindings") || noop)();
    $tableElement = $tableElement ?? this.getTableElement();
    if ($tableElement) {
      const $rows = $tableElement.children("tbody:not(.dx-header)").children();
      for (let i = 0; i < $rows.length; i++) {
        const $row = $rows.eq(i);
        const isGroupRow3 = $row.hasClass("dx-group-row");
        const isDetailRow3 = $row.hasClass(DETAIL_ROW_CLASS);
        const isErrorRow = $row.hasClass("dx-error-row");
        const isRowVisible = "none" !== $row.get(0).style.display && !$row.hasClass("dx-state-invisible");
        const isRelevantRow = !isGroupRow3 && !isDetailRow3 && !isErrorRow;
        if (isRowVisible && isRelevantRow) {
          const $cells = $row.children("td");
          const result = this._getWidths($cells);
          return result;
        }
      }
    }
    return [];
  }
  getVisibleColumnIndex(columnIndex, rowIndex) {
    return columnIndex;
  }
  setCellPropertiesCore(styleProps, $row, visibleCellIndex) {
    const $cell = $row.hasClass("dx-group-row") ? $row.find(`td[aria-colindex='${visibleCellIndex + 1}']:not(.dx-group-cell)`) : $row.find("td").eq(visibleCellIndex);
    for (let i = 0; i < $cell.length; i += 1) {
      const cell = $cell.get(i);
      Object.assign(cell.style, styleProps);
    }
  }
  setCellProperties(styleProps, columnIndex, rowIndex) {
    const $tableElement = this.getTableElement();
    if (!(null !== $tableElement && void 0 !== $tableElement && $tableElement.length)) {
      return;
    }
    const $rows = $tableElement.children().children(".dx-row").not(`.${DETAIL_ROW_CLASS}`);
    if (isDefined(rowIndex)) {
      this.setCellPropertiesCore(styleProps, $rows.eq(rowIndex), columnIndex);
    } else {
      for (let rowIndex2 = 0; rowIndex2 < $rows.length; rowIndex2++) {
        const visibleIndex = this.getVisibleColumnIndex(columnIndex, rowIndex2);
        if (visibleIndex >= 0) {
          this.setCellPropertiesCore(styleProps, $rows.eq(rowIndex2), visibleIndex);
        }
      }
    }
  }
  setColumnWidths(_ref2) {
    let {
      widths,
      optionNames
    } = _ref2;
    const $tableElement = this.getTableElement();
    if (!(null !== $tableElement && void 0 !== $tableElement && $tableElement.length) || !widths) {
      return;
    }
    const columns7 = this.getColumns();
    const needToSetCellWidths = this._needToSetCellWidths();
    const $cols = $tableElement.children("colgroup").children("col");
    $cols.toArray().forEach(((col) => col.removeAttribute("style")));
    columns7.forEach(((column, columnIndex) => {
      if (needToSetCellWidths && column.width && !column.command) {
        const styleProps = {};
        const width = getWidthStyle(column.visibleWidth || column.width);
        const minWidth = getWidthStyle(column.minWidth || width);
        styleProps.width = "auto" === column.width ? "" : width;
        styleProps.maxWidth = styleProps.width;
        styleProps.minWidth = minWidth;
        this.setCellProperties(styleProps, columnIndex);
      }
      const colWidth = normalizeWidth(widths[columnIndex]);
      if (isDefined(colWidth)) {
        setWidth2($cols.eq(columnIndex), colWidth);
      }
    }));
  }
  getCellElements(rowIndex) {
    return this._getCellElementsCore(rowIndex);
  }
  _getCellElementsCore(rowIndex) {
    if (rowIndex < 0) {
      return;
    }
    const $row = this._getRowElements().eq(rowIndex);
    return $row.children();
  }
  _getCellElement(rowIndex, columnIdentifier) {
    const $cells = this.getCellElements(rowIndex);
    const columnVisibleIndex = this._getVisibleColumnIndex($cells, rowIndex, columnIdentifier);
    if (!(null !== $cells && void 0 !== $cells && $cells.length) || columnVisibleIndex < 0) {
      return;
    }
    const $cell = $cells.eq(columnVisibleIndex);
    return $cell.length > 0 ? $cell : void 0;
  }
  _getRowElement(rowIndex) {
    const that = this;
    let $rowElement = renderer_default();
    const $tableElements = that.getTableElements();
    each($tableElements, ((_, tableElement) => {
      $rowElement = $rowElement.add(that._getRowElements(renderer_default(tableElement)).eq(rowIndex));
    }));
    if ($rowElement.length) {
      return $rowElement;
    }
    return;
  }
  getCellElement(rowIndex, columnIdentifier) {
    const $cell = this._getCellElement(rowIndex, columnIdentifier);
    if ($cell) {
      return getPublicElement($cell);
    }
    return;
  }
  getRowElement(rowIndex) {
    const $rows = this._getRowElement(rowIndex);
    let elements = [];
    if ($rows && !getPublicElement($rows).get) {
      for (let i = 0; i < $rows.length; i++) {
        elements.push($rows[i]);
      }
    } else {
      elements = $rows;
    }
    return elements;
  }
  _getVisibleColumnIndex($cells, rowIndex, columnIdentifier) {
    if (isString(columnIdentifier)) {
      const columnIndex = this._columnsController.columnOption(columnIdentifier, "index");
      return this._columnsController.getVisibleIndex(columnIndex);
    }
    return columnIdentifier;
  }
  getColumnElements() {
  }
  getColumns(rowIndex, $tableElement) {
    return this._columnsController.getVisibleColumns(rowIndex);
  }
  getCell(cellPosition, rows, cells) {
    const $rows = rows || this._getRowElements();
    let $cells;
    if ($rows.length > 0 && cellPosition.rowIndex >= 0) {
      var _$cells;
      if ("virtual" !== this.option("scrolling.mode") && "virtual" !== this.option("scrolling.rowRenderingMode")) {
        cellPosition.rowIndex = cellPosition.rowIndex < $rows.length ? cellPosition.rowIndex : $rows.length - 1;
      }
      $cells = cells || this.getCellElements(cellPosition.rowIndex);
      if ((null === (_$cells = $cells) || void 0 === _$cells ? void 0 : _$cells.length) > 0) {
        return $cells.eq($cells.length > cellPosition.columnIndex ? cellPosition.columnIndex : $cells.length - 1);
      }
    }
  }
  getRowsCount() {
    const tableElement = this.getTableElement();
    if (tableElement && 1 === tableElement.length) {
      return tableElement[0].rows.length;
    }
    return 0;
  }
  _getRowElementsCore(tableElement) {
    tableElement = tableElement || this.getTableElement();
    if (tableElement) {
      const hasRowTemplate = this.option().rowTemplate || this.option("dataRowTemplate");
      const tBodies = hasRowTemplate && tableElement.find("> tbody.dx-row");
      return tBodies && tBodies.length ? tBodies : tableElement.find("> tbody > .dx-row, > .dx-row");
    }
    return renderer_default();
  }
  _getRowElements(tableElement) {
    return this._getRowElementsCore(tableElement);
  }
  getRowIndex($row) {
    return this._getRowElements().index($row);
  }
  getBoundingRect() {
  }
  getName() {
  }
  setScrollerSpacing(width) {
    const $element = this.element();
    const rtlEnabled = this.option("rtlEnabled");
    $element && $element.css({
      paddingLeft: rtlEnabled ? width : "",
      paddingRight: !rtlEnabled ? width : ""
    });
  }
  isScrollbarVisible(isHorizontal) {
    const $element = this.element();
    const $tableElement = this._tableElement;
    if ($element && $tableElement) {
      return isHorizontal ? getOuterWidth($tableElement) - getWidth($element) > 0 : getOuterHeight($tableElement) - getHeight($element) > 0;
    }
    return false;
  }
  isDisposed() {
    var _this$component;
    return null === (_this$component = this.component) || void 0 === _this$component ? void 0 : _this$component._disposed;
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/column_headers/m_column_headers.js
var LINK = "dx-link";
var createCellContent = function(that, $cell, options) {
  const $cellContent = renderer_default("<div>").addClass(that.addWidgetPrefix("text-content"));
  that.setAria("role", "presentation", $cellContent);
  addCssClassesToCellContent(that, $cell, options.column, $cellContent);
  const showColumnLines = that.option("showColumnLines");
  const contentAlignment = that.getController("columns").getHeaderContentAlignment(options.column.alignment);
  return $cellContent[showColumnLines || "right" === contentAlignment ? "appendTo" : "prependTo"]($cell);
};
function addCssClassesToCellContent(that, $cell, column, $cellContent) {
  const $indicatorElements = that._getIndicatorElements($cell, true);
  const $visibleIndicatorElements = that._getIndicatorElements($cell);
  const indicatorCount = null === $indicatorElements || void 0 === $indicatorElements ? void 0 : $indicatorElements.length;
  const columnAlignment = that._getColumnAlignment(column.alignment);
  const sortIndicatorClassName = `.${that._getIndicatorClassName("sort")}`;
  const sortIndexIndicatorClassName = `.${that._getIndicatorClassName("sortIndex")}`;
  const $sortIndicator = $visibleIndicatorElements.filter(sortIndicatorClassName);
  const $sortIndexIndicator = $visibleIndicatorElements.children().filter(sortIndexIndicatorClassName);
  $cellContent = $cellContent || $cell.children(`.${that.addWidgetPrefix("text-content")}`);
  $cellContent.toggleClass("dx-text-content-alignment-" + columnAlignment, indicatorCount > 0).toggleClass("dx-text-content-alignment-" + ("left" === columnAlignment ? "right" : "left"), indicatorCount > 0 && "center" === column.alignment).toggleClass("dx-sort-indicator", !!$sortIndicator.length).toggleClass("dx-sort-index-indicator", !!$sortIndexIndicator.length).toggleClass("dx-header-filter-indicator", !!$visibleIndicatorElements.filter(`.${that._getIndicatorClassName("headerFilter")}`).length);
}
var ColumnHeadersView = class extends ColumnContextMenuMixin(ColumnsView) {
  init() {
    super.init();
    this._headerPanelView = this.getView("headerPanel");
    this._headerFilterController = this.getController("headerFilter");
    this._dataController = this.getController("data");
    this._headersKeyboardNavigation = this.getController("headersKeyboardNavigation");
  }
  _createTable() {
    const $table = super._createTable.apply(this, arguments);
    m_events_engine_default.on($table, "mousedown selectstart", this.createAction(((e) => {
      const {
        event
      } = e;
      if (event.shiftKey) {
        event.preventDefault();
      }
    })));
    return $table;
  }
  _isLegacyKeyboardNavigation() {
    return this.option("useLegacyKeyboardNavigation");
  }
  _getDefaultTemplate(column) {
    const that = this;
    return function($container, options) {
      const {
        caption
      } = column;
      const needCellContent = !column.command || caption && "expand" !== column.command;
      if ("empty" === column.command) {
        that._renderEmptyMessage($container, options);
      } else if (needCellContent) {
        const $content = createCellContent(that, $container, options);
        $content.text(caption);
      } else if (column.command) {
        $container.html("&nbsp;");
      }
    };
  }
  _renderEmptyMessage($container, options) {
    const textEmpty = this._getEmptyHeaderText();
    if (!textEmpty) {
      $container.html("&nbsp;");
      return;
    }
    const $cellContent = createCellContent(this, $container, options);
    const needSplit = textEmpty.includes("{0}");
    if (needSplit) {
      const [leftPart, rightPart] = textEmpty.split("{0}");
      const columnChooserTitle = message_default.format("dxDataGrid-emptyHeaderColumnChooserText");
      const columnChooserView = this._columnChooserView;
      const $link = renderer_default("<a>").text(columnChooserTitle).addClass(LINK);
      m_events_engine_default.on($link, "click", this.createAction((() => columnChooserView.showColumnChooser())));
      $cellContent.append(dom_adapter_default.createTextNode(leftPart)).append($link).append(dom_adapter_default.createTextNode(rightPart));
    } else {
      $cellContent.text(textEmpty);
    }
  }
  _getEmptyHeaderText() {
    const hasHiddenColumns = !!this._columnChooserView.hasHiddenColumns();
    const hasGroupedColumns = !!this._headerPanelView.hasGroupedColumns();
    switch (true) {
      case (hasHiddenColumns && hasGroupedColumns):
        return message_default.format("dxDataGrid-emptyHeaderWithColumnChooserAndGroupPanelText");
      case hasGroupedColumns:
        return message_default.format("dxDataGrid-emptyHeaderWithGroupPanelText");
      case hasHiddenColumns:
        return message_default.format("dxDataGrid-emptyHeaderWithColumnChooserText");
      default:
        return "";
    }
  }
  _getHeaderTemplate(column) {
    return column.headerCellTemplate || {
      allowRenderToDetachedContainer: true,
      render: this._getDefaultTemplate(column)
    };
  }
  _processTemplate(template, options) {
    const that = this;
    let resultTemplate;
    const {
      column
    } = options;
    const renderingTemplate = super._processTemplate(template);
    if ("header" === options.rowType && renderingTemplate && column.headerCellTemplate && !column.command) {
      resultTemplate = {
        render(options2) {
          const $content = createCellContent(that, options2.container, options2.model);
          renderingTemplate.render(extend({}, options2, {
            container: $content
          }));
        }
      };
    } else {
      resultTemplate = renderingTemplate;
    }
    return resultTemplate;
  }
  _handleDataChanged(e) {
    if ("refresh" !== e.changeType) {
      return;
    }
    if (this._isGroupingChanged || this._requireReady) {
      this._isGroupingChanged = false;
      this.render();
    }
  }
  _renderCell($row, options) {
    const $cell = super._renderCell($row, options);
    if ("header" === options.row.rowType) {
      $cell.addClass("dx-cell-focus-disabled");
      if (!this._isLegacyKeyboardNavigation()) {
        const {
          column
        } = options;
        const isCustomCommandColumn = this._columnsController.isCustomCommandColumn(column);
        if (column && (!column.type || isCustomCommandColumn)) {
          $cell.attr("tabindex", this.option("tabindex") || 0);
        }
      }
    }
    return $cell;
  }
  _setCellAriaAttributes($cell, cellOptions, options) {
    super._setCellAriaAttributes($cell, cellOptions, options);
    if ("header" === cellOptions.rowType) {
      if (!cellOptions.column.type) {
        this.setAria("role", "columnheader", $cell);
      }
      if (cellOptions.column && !cellOptions.column.command && !cellOptions.column.isBand) {
        $cell.attr("id", cellOptions.column.headerId);
        this.setAria("label", `${message_default.format("dxDataGrid-ariaColumn")} ${cellOptions.column.caption}`, $cell);
      }
    }
  }
  _createRow(row) {
    const $row = super._createRow.apply(this, arguments);
    $row.toggleClass("dx-column-lines", this.option("showColumnLines"));
    if ("header" === row.rowType) {
      $row.addClass("dx-header-row");
      if (!this._isLegacyKeyboardNavigation()) {
        registerKeyboardAction2("columnHeaders", this, $row, "td", this._handleActionKeyDown.bind(this));
      }
    }
    return $row;
  }
  _processHeaderAction(event, $row) {
  }
  _handleActionKeyDown(args) {
    const {
      event
    } = args;
    const $target = renderer_default(event.target);
    this._lastActionElement = event.target;
    if ($target.is(".dx-header-filter")) {
      const headerFilterController = this._headerFilterController;
      const $column = $target.closest("td");
      const columnIndex = this.getColumnIndexByElement($column);
      if (columnIndex >= 0) {
        headerFilterController.showHeaderFilterMenu(columnIndex, false);
      }
    } else {
      const $row = $target.closest(".dx-row");
      this._processHeaderAction(event, $row);
    }
    event.preventDefault();
  }
  _renderCore() {
    const $container = this.element();
    const change = {};
    if (this._tableElement && !this._dataController.isLoaded() && !this._hasRowElements) {
      return new Deferred().resolve();
    }
    $container.addClass(this.addWidgetPrefix("headers")).toggleClass(this.addWidgetPrefix("nowrap"), !this.option("wordWrapEnabled"));
    this.setAria("role", "presentation", $container);
    const deferred = this._updateContent(this._renderTable({
      change
    }), change);
    $container.toggleClass("dx-header-multi-row", this.getRowCount() > 1);
    super._renderCore.apply(this, arguments);
    return deferred;
  }
  _renderRows() {
    const that = this;
    if (that._dataController.isLoaded() || that._hasRowElements) {
      super._renderRows.apply(that, arguments);
      that._hasRowElements = true;
    }
  }
  _renderRow($table, options) {
    const rowIndex = 1 === this.getRowCount() ? null : options.row.rowIndex;
    options.columns = this.getColumns(rowIndex);
    super._renderRow($table, options);
  }
  _createCell(options) {
    const {
      column
    } = options;
    const $cellElement = super._createCell.apply(this, arguments);
    column.rowspan > 1 && "header" === options.rowType && $cellElement.attr("rowSpan", column.rowspan);
    return $cellElement;
  }
  _getRows() {
    const result = [];
    const rowCount = this.getRowCount();
    if (this.option("showColumnHeaders")) {
      for (let i = 0; i < rowCount; i++) {
        result.push({
          rowType: "header",
          rowIndex: i
        });
      }
    }
    return result;
  }
  _getCellTemplate(options) {
    if ("header" === options.rowType) {
      return this._getHeaderTemplate(options.column);
    }
  }
  _columnOptionChanged(e) {
    const {
      changeTypes
    } = e;
    const {
      optionNames
    } = e;
    if (changeTypes.grouping || changeTypes.groupExpanding) {
      if (changeTypes.grouping) {
        this._isGroupingChanged = true;
      }
      return;
    }
    super._columnOptionChanged(e);
    if (optionNames.width || optionNames.visible) {
      this.resizeCompleted.fire();
    }
  }
  _isElementVisible(elementOptions) {
    return null === elementOptions || void 0 === elementOptions ? void 0 : elementOptions.visible;
  }
  _alignCaptionByCenter($cell) {
    var _$indicatorsContainer;
    let $indicatorsContainer = this._getIndicatorContainer($cell, true);
    if (null !== (_$indicatorsContainer = $indicatorsContainer) && void 0 !== _$indicatorsContainer && _$indicatorsContainer.length) {
      $indicatorsContainer.filter(".dx-visibility-hidden").remove();
      $indicatorsContainer = this._getIndicatorContainer($cell);
      $indicatorsContainer.clone().addClass("dx-visibility-hidden").css("float", "").insertBefore($cell.children(`.${this.addWidgetPrefix("text-content")}`));
    }
  }
  _updateCell($cell, options) {
    if ("header" === options.rowType && "center" === options.column.alignment) {
      this._alignCaptionByCenter($cell);
    }
    super._updateCell.apply(this, arguments);
  }
  _updateIndicator($cell, column, indicatorName) {
    const $indicatorElement = super._updateIndicator.apply(this, arguments);
    if ("center" === column.alignment) {
      this._alignCaptionByCenter($cell);
    }
    addCssClassesToCellContent(this, $cell, column);
    return $indicatorElement;
  }
  _getIndicatorContainer($cell, returnAll) {
    const $indicatorsContainer = super._getIndicatorContainer($cell);
    return returnAll ? $indicatorsContainer : $indicatorsContainer.filter(":not(.dx-visibility-hidden)");
  }
  _isSortableElement($target) {
    return true;
  }
  getHeadersRowHeight() {
    const $tableElement = this.getTableElement();
    const $headerRows = null === $tableElement || void 0 === $tableElement ? void 0 : $tableElement.find(".dx-header-row");
    return (null === $headerRows || void 0 === $headerRows ? void 0 : $headerRows.toArray().reduce(((sum, headerRow) => sum + getHeight(headerRow)), 0)) || 0;
  }
  getHeaderElement(index) {
    const $columnElements = this.getColumnElements();
    return (null === $columnElements || void 0 === $columnElements ? void 0 : $columnElements.eq(index)) ?? renderer_default("");
  }
  getColumnElements(index, bandColumnIndex) {
    const that = this;
    let $cellElement;
    const columnsController = that._columnsController;
    const rowCount = that.getRowCount();
    if (that.option("showColumnHeaders")) {
      if (rowCount > 1 && (!isDefined(index) || isDefined(bandColumnIndex))) {
        const result = [];
        const visibleColumns = isDefined(bandColumnIndex) ? columnsController.getChildrenByBandColumn(bandColumnIndex, true) : columnsController.getVisibleColumns();
        each(visibleColumns, ((_, column) => {
          const rowIndex = isDefined(index) ? index : columnsController.getRowIndex(column.index);
          $cellElement = that._getCellElement(rowIndex, columnsController.getVisibleIndex(column.index, rowIndex));
          $cellElement && result.push($cellElement.get(0));
        }));
        return renderer_default(result);
      }
      if (!index || index < rowCount) {
        return that.getCellElements(index || 0);
      }
    }
    return;
  }
  getColumnIndexByElement($cell) {
    const cellIndex = this.getCellIndex($cell);
    const $row = $cell.closest(".dx-row");
    const {
      rowIndex
    } = $row[0];
    const column = this.getColumns(rowIndex)[cellIndex];
    return column ? column.index : -1;
  }
  getVisibleColumnIndex(columnIndex, rowIndex) {
    const column = this.getColumns()[columnIndex];
    return column ? this._columnsController.getVisibleIndex(column.index, rowIndex) : -1;
  }
  getColumnWidths($tableElement, rowIndex) {
    const $columnElements = this.getColumnElements(rowIndex);
    if (null !== $columnElements && void 0 !== $columnElements && $columnElements.length) {
      return this._getWidths($columnElements);
    }
    return super.getColumnWidths.apply(this, arguments);
  }
  isColumnReorderingEnabled(column) {
    return column.allowReordering && (this.option("allowColumnReordering") ?? this._columnsController.isColumnOptionUsed("allowReordering"));
  }
  allowDragging(column) {
    const rowIndex = column && this._columnsController.getRowIndex(column.index);
    const columns7 = this.getColumns(rowIndex);
    return this.isColumnReorderingEnabled(column) && columns7.length > 1;
  }
  getBoundingRect() {
    const that = this;
    const $columnElements = that.getColumnElements();
    if (null !== $columnElements && void 0 !== $columnElements && $columnElements.length) {
      const offset = that.getTableElement().offset();
      return {
        top: offset.top
      };
    }
    return null;
  }
  getName() {
    return "headers";
  }
  getColumnCount() {
    const $columnElements = this.getColumnElements();
    return $columnElements ? $columnElements.length : 0;
  }
  isVisible() {
    return this.option("showColumnHeaders");
  }
  optionChanged(args) {
    const that = this;
    switch (args.name) {
      case "showColumnHeaders":
      case "wordWrapEnabled":
      case "showColumnLines":
        that._invalidate(true, true);
        args.handled = true;
        break;
      default:
        super.optionChanged(args);
    }
  }
  getHeight() {
    return this.getElementHeight();
  }
  getContextMenuItems(options) {
    let items;
    const {
      column
    } = options;
    if (options.row && ("header" === options.row.rowType || "detailAdaptive" === options.row.rowType)) {
      const sortingOptions = this.option("sorting");
      if (sortingOptions && "none" !== sortingOptions.mode && null !== column && void 0 !== column && column.allowSorting) {
        const onItemClick = (params) => {
          setTimeout((() => {
            this._columnsController.changeSortOrder(column.index, params.itemData.value);
          }));
        };
        items = [{
          text: sortingOptions.ascendingText,
          value: "asc",
          disabled: "asc" === column.sortOrder,
          icon: "context-menu-sort-asc",
          onItemClick
        }, {
          text: sortingOptions.descendingText,
          value: "desc",
          disabled: "desc" === column.sortOrder,
          icon: "context-menu-sort-desc",
          onItemClick
        }, {
          name: "clearSorting",
          text: sortingOptions.clearText,
          value: "none",
          disabled: !column.sortOrder,
          icon: "context-menu-sort-none",
          onItemClick
        }];
      }
      if ("header" === options.row.rowType) {
        const moveColumnItems = this.getMoveColumnContextMenuItems(options);
        if (null !== moveColumnItems && void 0 !== moveColumnItems && moveColumnItems.length) {
          items = items ?? [];
          items.push(...moveColumnItems);
        }
      }
    }
    return items;
  }
  getRowCount() {
    var _this$_columnsControl;
    return null === (_this$_columnsControl = this._columnsController) || void 0 === _this$_columnsControl ? void 0 : _this$_columnsControl.getRowCount();
  }
  toggleDraggableColumnClass(columnIndex, value2, rowIndex) {
    let i;
    let columnElements;
    const rowCount = this.getRowCount();
    const columns7 = this._columnsController.getColumns();
    const column = null === columns7 || void 0 === columns7 ? void 0 : columns7[columnIndex];
    const columnID = (null === column || void 0 === column ? void 0 : column.isBand) && column.index;
    const setColumnClass = (column2, index) => {
      if (column2.ownerBand === columnID) {
        columnElements.eq(index).toggleClass(this.addWidgetPrefix(CLASSES.draggableColumn), value2);
        if (column2.isBand) {
          this.toggleDraggableColumnClass(column2.index, value2, i + 1);
        }
      }
    };
    if (isDefined(columnID)) {
      rowIndex = rowIndex || 0;
      for (i = rowIndex; i < rowCount; i++) {
        columnElements = this.getCellElements(i);
        if (columnElements) {
          const rowColumns = this.getColumns(i);
          rowColumns.forEach(setColumnClass);
        }
      }
    }
  }
  isFilterRowCell($cell) {
    return false;
  }
  getKeyboardNavigationController() {
    return this._headersKeyboardNavigation;
  }
};
var columnHeadersModule = {
  defaultOptions: () => ({
    showColumnHeaders: true,
    cellHintEnabled: true
  }),
  views: {
    columnHeadersView: ColumnHeadersView
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/m_core.js
var m_core_default = _extends({}, m_modules_default, m_utils_default, {
  modules: []
});

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/column_headers.js
var ColumnHeadersView2 = columnHeadersModule.views.columnHeadersView;
m_core_default.registerModule("columnHeaders", columnHeadersModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/sticky_columns/const.js
var STICKY_BORDER_WIDTH = 2;
var StickyPosition;
!(function(StickyPosition2) {
  StickyPosition2.Left = "left";
  StickyPosition2.Right = "right";
  StickyPosition2.Sticky = "sticky";
})(StickyPosition || (StickyPosition = {}));
var CLASSES3 = {
  stickyColumn: "sticky-column",
  stickyColumnLeft: "sticky-column-left",
  stickyColumnRight: "sticky-column-right",
  stickyColumnBorderRight: "sticky-column-border-right",
  stickyColumnBorderLeft: "sticky-column-border-left",
  stickyColumns: "sticky-columns",
  firstHeader: "first-header",
  columnNoBorder: "column-no-border",
  groupRowContainer: "group-row-container",
  focusedFixedElement: "dx-focused-fixed-element",
  focused: "dx-focused",
  hidden: "dx-hidden"
};

// node_modules/devextreme/esm/__internal/grids/grid_core/columns_controller/const.js
var USER_STATE_FIELD_NAMES_15_1 = ["filterValues", "filterType", "fixed", "fixedPosition"];
var USER_STATE_FIELD_NAMES = ["visibleIndex", "dataField", "name", "dataType", "width", "visible", "sortOrder", "lastSortOrder", "sortIndex", "groupIndex", "filterValue", "bufferedFilterValue", "selectedFilterOperation", "bufferedSelectedFilterOperation", "added"].concat(USER_STATE_FIELD_NAMES_15_1);
var IGNORE_COLUMN_OPTION_NAMES = {
  visibleWidth: true,
  bestFitWidth: true,
  bufferedFilterValue: true
};
var COMMAND_EXPAND_CLASS2 = "dx-command-expand";
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
var GROUP_COMMAND_COLUMN_NAME = "groupExpand";
var DETAIL_COMMAND_COLUMN_NAME = "detailExpand";
var COLUMN_OPTION_REGEXP = /columns\[(\d+)\]\.?/gi;
var DEFAULT_COLUMN_OPTIONS = {
  visible: true,
  showInColumnChooser: true
};
var DATATYPE_OPERATIONS = {
  number: ["=", "<>", "<", ">", "<=", ">=", "between"],
  string: ["contains", "notcontains", "startswith", "endswith", "=", "<>"],
  date: ["=", "<>", "<", ">", "<=", ">=", "between"],
  datetime: ["=", "<>", "<", ">", "<=", ">=", "between"]
};
var COLUMN_INDEX_OPTIONS = {
  visibleIndex: true,
  groupIndex: true,
  grouped: true,
  sortIndex: true,
  sortOrder: true
};
var GROUP_LOCATION = "group";
var COLUMN_CHOOSER_LOCATION = "columnChooser";
var UNSUPPORTED_PROPERTIES_FOR_CHILD_COLUMNS = ["fixed", "fixedPosition", "type", "buttons"];

// node_modules/devextreme/esm/__internal/grids/grid_core/adaptivity/const.js
var HIDDEN_COLUMNS_WIDTH = "adaptiveHidden";

// node_modules/devextreme/esm/__internal/grids/grid_core/sticky_columns/utils.js
var getColumnFixedPosition = (that, column) => {
  const {
    fixedPosition
  } = column;
  const rtlEnabled = that.option("rtlEnabled");
  const isExceptionCommandColumn = column.command && "expand" === column.command;
  const isDefaultCommandColumn = column.command && !m_utils_default.isCustomCommandColumn(that._columns, column);
  if (isDefaultCommandColumn && rtlEnabled && !isExceptionCommandColumn) {
    return fixedPosition === StickyPosition.Right ? StickyPosition.Left : StickyPosition.Right;
  }
  return fixedPosition ?? StickyPosition.Left;
};
var needToDisableStickyColumn = function(that, column) {
  return that.isVirtualMode() && !!column.fixed && column.fixedPosition === StickyPosition.Sticky;
};
var processFixedColumns = function(that, columns7) {
  return columns7.map(((column) => {
    if (needToDisableStickyColumn(that, column)) {
      return _extends({}, column, {
        fixed: false,
        fixedPosition: ""
      });
    }
    return column;
  }));
};
var isVisibleColumn = function(that, column) {
  return column.visibleWidth !== HIDDEN_COLUMNS_WIDTH && (!column.isBand || !!that.getVisibleDataColumnsByBandColumn(column.index).length);
};
var areNextOnlyFixedOrHiddenColumns = function(that, columns7) {
  return !columns7.some(((column) => !column.fixed && isVisibleColumn(that, column)));
};
var getStickyOffsetCore = function(that, columns7, widths, columnIndex, fixedPosition, offsets) {
  const column = columns7[columnIndex];
  const isChildColumn = isDefined(column.ownerBand);
  const targetColumnIsRight = fixedPosition === StickyPosition.Right;
  const targetColumnIsSticky = column.fixedPosition === StickyPosition.Sticky;
  const nextOrPrevColumns = targetColumnIsRight ? columns7.slice(columnIndex + 1) : columns7.slice(0, columnIndex).reverse();
  const nextOrPrevColumnWidths = targetColumnIsRight ? widths.slice(columnIndex + 1) : widths.slice(0, columnIndex).reverse();
  let offset = 0;
  let adjacentStickyColumnIndex = 0;
  let nonSiblingStickyColumnCount = !areNextOnlyFixedOrHiddenColumns(that, nextOrPrevColumns) && targetColumnIsSticky && nextOrPrevColumns.length ? 1 : 0;
  nextOrPrevColumns.forEach(((col, colIndex) => {
    if (col.fixed && (!isDefined(offsets) || column.ownerBand === col.ownerBand)) {
      const columnIsSticky = col.fixedPosition === StickyPosition.Sticky;
      offset += nextOrPrevColumnWidths[colIndex] ?? col.visibleWidth;
      if (targetColumnIsSticky && columnIsSticky && !areNextOnlyFixedOrHiddenColumns(that, nextOrPrevColumns.slice(colIndex + 1))) {
        if (colIndex !== adjacentStickyColumnIndex) {
          nonSiblingStickyColumnCount += 1;
          adjacentStickyColumnIndex = colIndex + 1;
        } else {
          adjacentStickyColumnIndex += 1;
        }
      }
    } else if (!isVisibleColumn(that, col)) {
      adjacentStickyColumnIndex += 1;
    }
  }));
  if (isChildColumn && isDefined(offsets)) {
    var _offsets$column$owner;
    offset += (null === offsets || void 0 === offsets || null === (_offsets$column$owner = offsets[column.ownerBand]) || void 0 === _offsets$column$owner ? void 0 : _offsets$column$owner[fixedPosition]) ?? 0;
    return offset;
  }
  return offset - nonSiblingStickyColumnCount * STICKY_BORDER_WIDTH;
};
var isFirstOrLastColumn = function(that, column, rowIndex) {
  let onlyWithinBandColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;
  let isLast = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;
  let fixedPosition = arguments.length > 5 ? arguments[5] : void 0;
  const rtlEnabled = that.option("rtlEnabled");
  const methodName = rtlEnabled !== isLast ? "isLastColumn" : "isFirstColumn";
  if (column.fixedPosition === StickyPosition.Sticky) {
    const parentColumn = that.getParentColumn(column) ?? column;
    if (that[methodName](parentColumn, 0)) {
      return false;
    }
  }
  return that[methodName](column, rowIndex, onlyWithinBandColumn, fixedPosition);
};
var getPrevColumn = function(that, column, visibleColumns, rowIndex) {
  const visibleColumnIndex = that.getVisibleIndex(column.index, rowIndex);
  return null === visibleColumns || void 0 === visibleColumns ? void 0 : visibleColumns.slice(0, visibleColumnIndex).reverse().find(((col) => isVisibleColumn(that, col)));
};
var getStickyOffset = function(that, columns7, widths, columnIndex, offsets) {
  const result = {};
  const column = columns7[columnIndex];
  if (column) {
    const fixedPosition = getColumnFixedPosition(that, column);
    switch (fixedPosition) {
      case StickyPosition.Sticky: {
        const offsetLeft = getStickyOffsetCore(that, columns7, widths, columnIndex, StickyPosition.Left, offsets);
        const offsetRight = getStickyOffsetCore(that, columns7, widths, columnIndex, StickyPosition.Right, offsets);
        result.left = offsetLeft;
        result.right = offsetRight;
        break;
      }
      case StickyPosition.Right: {
        const offsetRight = getStickyOffsetCore(that, columns7, widths, columnIndex, StickyPosition.Right, offsets);
        result.right = offsetRight;
        break;
      }
      default: {
        const offsetLeft = getStickyOffsetCore(that, columns7, widths, columnIndex, StickyPosition.Left, offsets);
        result.left = offsetLeft;
      }
    }
  }
  return result;
};
var needToRemoveColumnBorderCore = function(that, column, visibleColumns, rowIndex) {
  const prevColumn = getPrevColumn(that, column, visibleColumns, rowIndex);
  const columnFixedPosition = getColumnFixedPosition(that, column);
  const prevColumnFixedPosition = prevColumn && getColumnFixedPosition(that, prevColumn);
  return !!(null !== prevColumn && void 0 !== prevColumn && prevColumn.fixed) && !needToDisableStickyColumn(that, prevColumn) && (!column.fixed || columnFixedPosition === StickyPosition.Sticky || prevColumnFixedPosition === StickyPosition.Sticky);
};
var needToRemoveColumnBorder = function(that, column, rowIndex) {
  let isDataColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;
  const visibleColumns = that.getVisibleColumns(isDataColumn ? null : rowIndex);
  const parentColumn = that.getParentColumn(column);
  if (parentColumn) {
    const isFirstColumn = that.isFirstColumn(column, rowIndex, true);
    return isFirstColumn && needToRemoveColumnBorderCore(that, parentColumn, that.getVisibleColumns(0), 0);
  }
  return needToRemoveColumnBorderCore(that, column, visibleColumns, rowIndex);
};
var normalizeOffset = function(offset) {
  const styleProps = {};
  if (isDefined(offset.left)) {
    styleProps.left = `${offset.left}px`;
  }
  if (isDefined(offset.right)) {
    styleProps.right = `${offset.right}px`;
  }
  return styleProps;
};
var isFirstFixedColumn = function(that, column, rowIndex) {
  let onlyWithinBandColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;
  let fixedPosition = arguments.length > 4 ? arguments[4] : void 0;
  return isFirstOrLastColumn(that, column, rowIndex, onlyWithinBandColumn, false, fixedPosition);
};
var isLastFixedColumn = function(that, column, rowIndex) {
  let onlyWithinBandColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;
  let fixedPosition = arguments.length > 4 ? arguments[4] : void 0;
  return isFirstOrLastColumn(that, column, rowIndex, onlyWithinBandColumn, true, fixedPosition);
};
var isFixedEdge = function(point, column, nextColumn) {
  const isSplitPoint = isDefined(point.isLeftBoundary) || isDefined(point.isRightBoundary);
  return !isSplitPoint && !!column && !!nextColumn && column.fixed !== nextColumn.fixed;
};

// node_modules/devextreme/esm/__internal/grids/grid_core/columns_controller/m_columns_controller_utils.js
var warnFixedInChildColumnsOnce = (controller, childColumns) => {
  if (null !== controller && void 0 !== controller && controller._isWarnedAboutUnsupportedProperties) {
    return;
  }
  if (!childColumns || !Array.isArray(childColumns) || 0 === (null === childColumns || void 0 === childColumns ? void 0 : childColumns.length)) {
    return;
  }
  let unsupportedProperty = null;
  for (const column of childColumns) {
    if (unsupportedProperty) {
      break;
    }
    if (!column || "object" !== typeof column || null === column) {
      continue;
    }
    for (const property of UNSUPPORTED_PROPERTIES_FOR_CHILD_COLUMNS) {
      if (property in column) {
        unsupportedProperty = property;
        break;
      }
    }
  }
  if (unsupportedProperty) {
    controller && (controller._isWarnedAboutUnsupportedProperties = true);
    ui_errors_default.log("W1028", unsupportedProperty);
  }
};
var setFilterOperationsAsDefaultValues = function(column) {
  column.filterOperations = column.defaultFilterOperations;
};
var globalColumnId = 1;
var createColumn = function(that, columnOptions, userStateColumnOptions, bandColumn) {
  let commonColumnOptions = {};
  if (columnOptions) {
    if (isString(columnOptions)) {
      columnOptions = {
        dataField: columnOptions
      };
    }
    that.setName(columnOptions);
    let result = {};
    if (columnOptions.command) {
      result = deepExtendArraySafe(commonColumnOptions, columnOptions);
    } else {
      commonColumnOptions = that.getCommonSettings(columnOptions);
      if (userStateColumnOptions && userStateColumnOptions.name && userStateColumnOptions.dataField) {
        columnOptions = extend({}, columnOptions, {
          dataField: userStateColumnOptions.dataField
        });
      }
      const calculatedColumnOptions = that._createCalculatedColumnOptions(columnOptions, bandColumn);
      if (!columnOptions.type) {
        result = {
          headerId: "dx-col-" + globalColumnId++
        };
      }
      result = deepExtendArraySafe(result, DEFAULT_COLUMN_OPTIONS, false, true);
      deepExtendArraySafe(result, commonColumnOptions, false, true);
      deepExtendArraySafe(result, calculatedColumnOptions, false, true);
      deepExtendArraySafe(result, columnOptions, false, true);
      deepExtendArraySafe(result, {
        selector: null
      }, false, true);
    }
    if (columnOptions.filterOperations === columnOptions.defaultFilterOperations) {
      setFilterOperationsAsDefaultValues(result);
    }
    return result;
  }
};
var createColumnsFromOptions = function(that, columnsOptions, bandColumn, createdColumnCount) {
  let result = [];
  if (columnsOptions) {
    each(columnsOptions, ((index, columnOptions) => {
      const currentIndex = (createdColumnCount ?? 0) + result.length;
      const userStateColumnOptions = that._columnsUserState && checkUserStateColumn(columnOptions, that._columnsUserState[currentIndex]) && that._columnsUserState[currentIndex];
      const column = createColumn(that, columnOptions, userStateColumnOptions, bandColumn);
      if (column) {
        if (bandColumn) {
          column.ownerBand = bandColumn;
        }
        result.push(column);
        if (column.columns) {
          warnFixedInChildColumnsOnce(that, column.columns);
          result = result.concat(createColumnsFromOptions(that, column.columns, column, result.length));
          delete column.columns;
          column.hasColumns = true;
        }
      }
    }));
  }
  return result;
};
var getParentBandColumns = function(columnIndex, columnParentByIndex) {
  const result = [];
  let parent = columnParentByIndex[columnIndex];
  while (parent) {
    result.unshift(parent);
    columnIndex = parent.index;
    parent = columnParentByIndex[columnIndex];
  }
  return result;
};
var getChildrenByBandColumn = function(columnIndex, columnChildrenByIndex, recursive) {
  let result = [];
  const children = columnChildrenByIndex[columnIndex];
  if (children) {
    for (let i = 0; i < children.length; i++) {
      const column = children[i];
      if (!isDefined(column.groupIndex) || column.showWhenGrouped) {
        result.push(column);
        if (recursive && column.isBand) {
          result = result.concat(getChildrenByBandColumn(column.index, columnChildrenByIndex, recursive));
        }
      }
    }
  }
  return result;
};
var getColumnByIndexes = function(that, columnIndexes) {
  let result;
  let columns7;
  const bandColumnsCache = that.getBandColumnsCache();
  const callbackFilter = function(column) {
    const ownerBand = result ? result.index : void 0;
    return column.ownerBand === ownerBand;
  };
  if (bandColumnsCache.isPlain) {
    result = that._columns[columnIndexes[0]];
  } else {
    columns7 = that._columns.filter(callbackFilter);
    for (let i = 0; i < columnIndexes.length; i++) {
      result = columns7[columnIndexes[i]];
      if (result) {
        columns7 = that._columns.filter(callbackFilter);
      }
    }
  }
  return result;
};
var getColumnFullPath = function(that, column) {
  let result = [];
  let columns7;
  const bandColumnsCache = that.getBandColumnsCache();
  const callbackFilter = function(item) {
    return item.ownerBand === column.ownerBand;
  };
  if (bandColumnsCache.isPlain) {
    const columnIndex = that._columns.indexOf(column);
    if (columnIndex >= 0) {
      result = [`columns[${columnIndex}]`];
    }
  } else {
    columns7 = that._columns.filter(callbackFilter);
    while (columns7.length && -1 !== columns7.indexOf(column)) {
      result.unshift(`columns[${columns7.indexOf(column)}]`);
      column = bandColumnsCache.columnParentByIndex[column.index];
      columns7 = column ? that._columns.filter(callbackFilter) : [];
    }
  }
  return result.join(".");
};
var calculateColspan = function(that, columnID) {
  let colspan = 0;
  const columns7 = that.getChildrenByBandColumn(columnID, true);
  each(columns7, ((_, column) => {
    if (column.isBand) {
      column.colspan = column.colspan || calculateColspan(that, column.index);
      colspan += column.colspan || 1;
    } else {
      colspan += 1;
    }
  }));
  return colspan;
};
var processBandColumns = function(that, columns7, bandColumnsCache) {
  let rowspan;
  for (let i = 0; i < columns7.length; i++) {
    const column = columns7[i];
    if (column.visible || column.command) {
      if (column.isBand) {
        column.colspan = column.colspan || calculateColspan(that, column.index);
      }
      if (!column.isBand || !column.colspan) {
        rowspan = that.getRowCount();
        if (!column.command && (!isDefined(column.groupIndex) || column.showWhenGrouped)) {
          rowspan -= getParentBandColumns(column.index, bandColumnsCache.columnParentByIndex).length;
        }
        if (rowspan > 1) {
          column.rowspan = rowspan;
        }
      }
    }
  }
};
var getValueDataType = function(value2) {
  let dataType = type(value2);
  if ("string" !== dataType && "boolean" !== dataType && "number" !== dataType && "date" !== dataType && "object" !== dataType) {
    dataType = void 0;
  }
  return dataType;
};
var getSerializationFormat = function(dataType, value2) {
  switch (dataType) {
    case "date":
    case "datetime":
      return date_serialization_default.getDateSerializationFormat(value2);
    case "number":
      if (isString(value2)) {
        return "string";
      }
      if (isNumeric(value2)) {
        return null;
      }
  }
};
var updateSerializers = function(options, dataType) {
  if (!options.deserializeValue) {
    if (m_utils_default.isDateType(dataType)) {
      options.deserializeValue = function(value2) {
        return date_serialization_default.deserializeDate(value2);
      };
      options.serializeValue = function(value2) {
        return isString(value2) ? value2 : date_serialization_default.serializeDate(value2, this.serializationFormat);
      };
    }
    if ("number" === dataType) {
      options.deserializeValue = function(value2) {
        const parsedValue = parseFloat(value2);
        return isNaN(parsedValue) ? value2 : parsedValue;
      };
      options.serializeValue = function(value2, target) {
        if ("filter" === target) {
          return value2;
        }
        return isDefined(value2) && "string" === this.serializationFormat ? value2.toString() : value2;
      };
    }
  }
};
var getAlignmentByDataType = function(dataType, isRTL) {
  switch (dataType) {
    case "number":
      return "right";
    case "boolean":
      return "center";
    default:
      return getDefaultAlignment(isRTL);
  }
};
var customizeTextForBooleanDataType = function(e) {
  if (true === e.value) {
    return this.trueText || "true";
  }
  if (false === e.value) {
    return this.falseText || "false";
  }
  return e.valueText || "";
};
var getCustomizeTextByDataType = function(dataType) {
  if ("boolean" === dataType) {
    return customizeTextForBooleanDataType;
  }
};
var createColumnsFromDataSource = function(that, dataSource) {
  const firstItems = that._getFirstItems(dataSource);
  let fieldName;
  const processedFields = {};
  const result = [];
  for (let i = 0; i < firstItems.length; i++) {
    if (firstItems[i]) {
      for (fieldName in firstItems[i]) {
        if (!isFunction(firstItems[i][fieldName]) || variable_wrapper_default.isWrapped(firstItems[i][fieldName])) {
          processedFields[fieldName] = true;
        }
      }
    }
  }
  for (fieldName in processedFields) {
    if (0 !== fieldName.indexOf("__")) {
      const column = createColumn(that, fieldName);
      result.push(column);
    }
  }
  return result;
};
var updateColumnIndexes = function(that) {
  each(that._columns, ((index, column) => {
    column.index = index;
  }));
  each(that._columns, ((index, column) => {
    if (isObject(column.ownerBand)) {
      column.ownerBand = column.ownerBand.index;
    }
  }));
  each(that._commandColumns, ((index, column) => {
    column.index = -(index + 1);
  }));
};
var updateColumnGroupIndexes = function(that, currentColumn) {
  normalizeIndexes(that._columns, "groupIndex", currentColumn, ((column) => {
    const {
      grouped
    } = column;
    delete column.grouped;
    return grouped;
  }));
};
var updateColumnSortIndexes = function(that, currentColumn) {
  each(that._columns, ((index, column) => {
    if (isDefined(column.sortIndex) && !isSortOrderValid(column.sortOrder)) {
      delete column.sortIndex;
    }
  }));
  normalizeIndexes(that._columns, "sortIndex", currentColumn, ((column) => !isDefined(column.groupIndex) && isSortOrderValid(column.sortOrder)));
};
var updateColumnVisibleIndexes = function(that, currentColumn) {
  let column;
  const result = [];
  const bandColumnsCache = that.getBandColumnsCache();
  const bandedColumns = [];
  const columns7 = that._columns.filter(((column2) => !column2.command));
  for (let i = 0; i < columns7.length; i++) {
    column = columns7[i];
    const parentBandColumns = getParentBandColumns(i, bandColumnsCache.columnParentByIndex);
    if (parentBandColumns.length) {
      bandedColumns.push(column);
    } else {
      result.push(column);
    }
  }
  normalizeIndexes(bandedColumns, "visibleIndex", currentColumn);
  normalizeIndexes(result, "visibleIndex", currentColumn);
};
var getColumnIndexByVisibleIndex = function(that, visibleIndex, location) {
  const rowIndex = isObject(visibleIndex) ? visibleIndex.rowIndex : null;
  const columns7 = location === GROUP_LOCATION ? that.getGroupColumns() : location === COLUMN_CHOOSER_LOCATION ? that.getChooserColumns() : that.getVisibleColumns(rowIndex, true);
  let column;
  visibleIndex = isObject(visibleIndex) ? visibleIndex.columnIndex : visibleIndex;
  column = columns7[visibleIndex];
  if (column && column.type === GROUP_COMMAND_COLUMN_NAME) {
    column = that._columns.filter(((col) => column.type === col.type))[0] || column;
  }
  return column && isDefined(column.index) ? column.index : -1;
};
var moveColumnToGroup = function(that, column, groupIndex) {
  const groupColumns = that.getGroupColumns();
  let i;
  if (groupIndex >= 0) {
    for (i = 0; i < groupColumns.length; i++) {
      if (groupColumns[i].groupIndex >= groupIndex) {
        groupColumns[i].groupIndex++;
      }
    }
  } else {
    groupIndex = 0;
    for (i = 0; i < groupColumns.length; i++) {
      groupIndex = Math.max(groupIndex, groupColumns[i].groupIndex + 1);
    }
  }
  return groupIndex;
};
function checkUserStateColumn(column, userStateColumn) {
  return column && userStateColumn && userStateColumn.name === (column.name || column.dataField) && (userStateColumn.dataField === column.dataField || column.name);
}
var applyUserState = function(that) {
  const columnsUserState = that._columnsUserState;
  const ignoreColumnOptionNames = that._ignoreColumnOptionNames || [];
  const columns7 = that._columns;
  const columnCountById = {};
  let resultColumns = [];
  let allColumnsHaveState = true;
  const userStateColumnIndexes = [];
  let column;
  let userStateColumnIndex;
  let i;
  function applyFieldsState(column2, userStateColumn) {
    if (!userStateColumn) {
      return;
    }
    for (let index = 0; index < USER_STATE_FIELD_NAMES.length; index++) {
      const fieldName = USER_STATE_FIELD_NAMES[index];
      if (ignoreColumnOptionNames.includes(fieldName)) {
        continue;
      }
      if ("dataType" === fieldName) {
        column2[fieldName] = column2[fieldName] || userStateColumn[fieldName];
      } else if (USER_STATE_FIELD_NAMES_15_1.includes(fieldName)) {
        if (fieldName in userStateColumn) {
          column2[fieldName] = userStateColumn[fieldName];
        }
      } else {
        if ("selectedFilterOperation" === fieldName && userStateColumn[fieldName]) {
          column2.defaultSelectedFilterOperation = column2[fieldName] || null;
        }
        column2[fieldName] = userStateColumn[fieldName];
      }
    }
  }
  function findUserStateColumn(columnsUserState2, column2) {
    const id = column2.name || column2.dataField;
    let count = columnCountById[id] || 0;
    for (let j = 0; j < columnsUserState2.length; j++) {
      if (checkUserStateColumn(column2, columnsUserState2[j])) {
        if (count) {
          count--;
        } else {
          columnCountById[id] = columnCountById[id] || 0;
          columnCountById[id]++;
          return j;
        }
      }
    }
    return -1;
  }
  if (columnsUserState) {
    for (i = 0; i < columns7.length; i++) {
      userStateColumnIndex = findUserStateColumn(columnsUserState, columns7[i]);
      allColumnsHaveState = allColumnsHaveState && userStateColumnIndex >= 0;
      userStateColumnIndexes.push(userStateColumnIndex);
    }
    for (i = 0; i < columns7.length; i++) {
      column = columns7[i];
      userStateColumnIndex = userStateColumnIndexes[i];
      if (that._hasUserState || allColumnsHaveState) {
        applyFieldsState(column, columnsUserState[userStateColumnIndex]);
      }
      if (userStateColumnIndex >= 0 && isDefined(columnsUserState[userStateColumnIndex].initialIndex)) {
        resultColumns[userStateColumnIndex] = column;
      } else {
        resultColumns.push(column);
      }
    }
    let hasAddedBands = false;
    for (i = 0; i < columnsUserState.length; i++) {
      const columnUserState = columnsUserState[i];
      if (columnUserState.added && findUserStateColumn(columns7, columnUserState) < 0) {
        column = createColumn(that, columnUserState.added);
        applyFieldsState(column, columnUserState);
        resultColumns.push(column);
        if (columnUserState.added.columns) {
          hasAddedBands = true;
        }
      }
    }
    if (hasAddedBands) {
      updateColumnIndexes(that);
      resultColumns = createColumnsFromOptions(that, resultColumns);
    }
    assignColumns(that, resultColumns);
  }
};
var updateIndexes = function(that, column) {
  updateColumnIndexes(that);
  updateColumnGroupIndexes(that, column);
  updateColumnSortIndexes(that, column);
  resetBandColumnsCache(that);
  updateColumnVisibleIndexes(that, column);
};
var resetColumnsCache = function(that) {
  that.resetColumnsCache();
};
function assignColumns(that, columns7) {
  that._previousColumns = that._columns;
  that._columns = columns7;
  resetColumnsCache(that);
  that.updateColumnDataTypes();
}
var updateColumnChanges = function(that, changeType, optionName, columnIndex) {
  const columnChanges = that._columnChanges || {
    optionNames: {
      length: 0
    },
    changeTypes: {
      length: 0
    },
    columnIndex
  };
  optionName = optionName || "all";
  optionName = optionName.split(".")[0];
  const {
    changeTypes
  } = columnChanges;
  if (changeType && !changeTypes[changeType]) {
    changeTypes[changeType] = true;
    changeTypes.length++;
  }
  const {
    optionNames
  } = columnChanges;
  if (optionName && !optionNames[optionName]) {
    optionNames[optionName] = true;
    optionNames.length++;
  }
  if (void 0 === columnIndex || columnIndex !== columnChanges.columnIndex) {
    if (isDefined(columnIndex)) {
      columnChanges.columnIndices ?? (columnChanges.columnIndices = []);
      if (isDefined(columnChanges.columnIndex)) {
        columnChanges.columnIndices.push(columnChanges.columnIndex);
      }
      columnChanges.columnIndices.push(columnIndex);
    }
    delete columnChanges.columnIndex;
  }
  that._columnChanges = columnChanges;
  resetColumnsCache(that);
};
var fireColumnsChanged = function(that) {
  const onColumnsChanging = that.option("onColumnsChanging");
  const columnChanges = that._columnChanges;
  const reinitOptionNames = ["dataField", "lookup", "dataType", "columns"];
  if (that.isInitialized() && !that._updateLockCount && columnChanges) {
    if (onColumnsChanging) {
      that._updateLockCount++;
      onColumnsChanging(extend({
        component: that.component
      }, columnChanges));
      that._updateLockCount--;
    }
    that._columnChanges = void 0;
    if (options = columnChanges.optionNames, options && reinitOptionNames.some(((name) => options[name]))) {
      that._reinitAfterLookupChanges = null === columnChanges || void 0 === columnChanges ? void 0 : columnChanges.optionNames.lookup;
      that.reinit();
      that._reinitAfterLookupChanges = void 0;
    } else {
      that.columnsChanged.fire(columnChanges);
    }
  }
  var options;
};
var updateSortOrderWhenGrouping = function(that, column, groupIndex, prevGroupIndex) {
  const columnWasGrouped = prevGroupIndex >= 0;
  if (groupIndex >= 0) {
    if (!columnWasGrouped) {
      column.lastSortOrder = column.sortOrder;
    }
  } else {
    const sortMode = that.option("sorting.mode");
    let sortOrder = column.lastSortOrder;
    if ("single" === sortMode) {
      const sortedByAnotherColumn = that._columns.some(((col) => col !== column && isDefined(col.sortIndex)));
      if (sortedByAnotherColumn) {
        sortOrder = void 0;
      }
    }
    column.sortOrder = sortOrder;
  }
};
var fireOptionChanged = function(that, options) {
  const {
    value: value2
  } = options;
  const {
    optionName
  } = options;
  const {
    prevValue
  } = options;
  const {
    fullOptionName
  } = options;
  const fullOptionPath = `${fullOptionName}.${optionName}`;
  if (!IGNORE_COLUMN_OPTION_NAMES[optionName] && that._skipProcessingColumnsChange !== fullOptionPath) {
    that._skipProcessingColumnsChange = fullOptionPath;
    that.component._notifyOptionChanged(fullOptionPath, value2, prevValue);
    that._skipProcessingColumnsChange = false;
  }
};
var columnOptionCore = function(that, column, optionName, value2, notFireEvent) {
  const optionGetter = compileGetter(optionName);
  const columnIndex = column.index;
  let columns7;
  let changeType;
  let initialColumn;
  if (3 === arguments.length) {
    return optionGetter(column, {
      functionsAsIs: true
    });
  }
  const prevValue = optionGetter(column, {
    functionsAsIs: true
  });
  if (!equalByValue(prevValue, value2, {
    maxDepth: 5
  })) {
    if ("groupIndex" === optionName) {
      changeType = "grouping";
      updateSortOrderWhenGrouping(that, column, value2, prevValue);
    } else if ("calculateGroupValue" === optionName) {
      changeType = "grouping";
    } else if ("sortIndex" === optionName || "sortOrder" === optionName || "calculateSortValue" === optionName) {
      changeType = "sorting";
    } else {
      changeType = "columns";
    }
    const optionSetter = compileSetter(optionName);
    optionSetter(column, value2, {
      functionsAsIs: true
    });
    const fullOptionName = getColumnFullPath(that, column);
    if (COLUMN_INDEX_OPTIONS[optionName]) {
      updateIndexes(that, column);
      value2 = optionGetter(column);
    }
    if ("name" === optionName || "allowEditing" === optionName) {
      that._checkColumns();
    }
    if (!isDefined(prevValue) && !isDefined(value2) && 0 !== optionName.indexOf("buffer") && false !== notFireEvent) {
      notFireEvent = true;
    }
    if (!notFireEvent) {
      if (!USER_STATE_FIELD_NAMES.includes(optionName) && "visibleWidth" !== optionName) {
        columns7 = that.option("columns");
        initialColumn = that.getColumnByPath(fullOptionName, columns7);
        if (isString(initialColumn)) {
          initialColumn = columns7[columnIndex] = {
            dataField: initialColumn
          };
        }
        if (initialColumn && checkUserStateColumn(initialColumn, column)) {
          optionSetter(initialColumn, value2, {
            functionsAsIs: true
          });
        }
      }
      updateColumnChanges(that, changeType, optionName, columnIndex);
    } else {
      resetColumnsCache(that);
    }
    fullOptionName && fireOptionChanged(that, {
      fullOptionName,
      optionName,
      value: value2,
      prevValue
    });
  }
};
function isSortOrderValid(sortOrder) {
  return "asc" === sortOrder || "desc" === sortOrder;
}
var addExpandColumn = function(that) {
  const options = that._getExpandColumnOptions();
  that.addCommandColumn(options);
};
var defaultSetCellValue = function(data17, value2) {
  if (!this.dataField) {
    return;
  }
  const path = this.dataField.split(".");
  const dotCount = path.length - 1;
  if (this.serializeValue) {
    value2 = this.serializeValue(value2);
  }
  for (let i = 0; i < dotCount; i++) {
    const name = path[i];
    data17 = data17[name] = data17[name] || {};
  }
  data17[path[dotCount]] = value2;
};
var getDataColumns = function(columns7, rowIndex, bandColumnID) {
  const result = [];
  rowIndex = rowIndex || 0;
  columns7[rowIndex] && each(columns7[rowIndex], ((_, column) => {
    if (column.ownerBand === bandColumnID || column.type === GROUP_COMMAND_COLUMN_NAME) {
      if (!column.isBand || !column.colspan) {
        if (!column.command || rowIndex < 1) {
          result.push(column);
        }
      } else {
        result.push.apply(result, getDataColumns(columns7, rowIndex + 1, column.index));
      }
    }
  }));
  return result;
};
var getRowCount = function(that) {
  let rowCount = 1;
  const bandColumnsCache = that.getBandColumnsCache();
  const {
    columnParentByIndex
  } = bandColumnsCache;
  that._columns.forEach(((column) => {
    const parents = getParentBandColumns(column.index, columnParentByIndex);
    const invisibleParents = parents.filter(((column2) => !column2.visible));
    if (column.visible && !invisibleParents.length) {
      rowCount = Math.max(rowCount, parents.length + 1);
    }
  }));
  return rowCount;
};
var getFixedPosition = function(that, column) {
  const rtlEnabled = that.option("rtlEnabled");
  if (column.command && !m_utils_default.isCustomCommandColumn(that._columns, column) || !column.fixedPosition) {
    return rtlEnabled ? "right" : "left";
  }
  return column.fixedPosition;
};
var processExpandColumns = function(columns7, expandColumns, type2, columnIndex) {
  let customColumnIndex;
  const rowCount = this.getRowCount();
  let rowspan = columns7[columnIndex] && columns7[columnIndex].rowspan;
  let expandColumnsByType = expandColumns.filter(((column) => column.type === type2));
  columns7.forEach(((column, index) => {
    if (column.type === type2) {
      customColumnIndex = index;
      rowspan = columns7[index + 1] ? columns7[index + 1].rowspan : rowCount;
    }
  }));
  if (rowspan > 1) {
    expandColumnsByType = map(expandColumnsByType, ((expandColumn) => extend({}, expandColumn, {
      rowspan
    })));
  }
  expandColumnsByType.unshift.apply(expandColumnsByType, isDefined(customColumnIndex) ? [customColumnIndex, 1] : [columnIndex, 0]);
  columns7.splice.apply(columns7, expandColumnsByType);
  return rowspan || 1;
};
var digitsCount = function(number) {
  let i;
  for (i = 0; number > 1; i++) {
    number /= 10;
  }
  return i;
};
var numberToString = function(number, digitsCount2) {
  let str = number ? number.toString() : "0";
  while (str.length < digitsCount2) {
    str = `0${str}`;
  }
  return str;
};
var mergeColumns = (that, columns7, commandColumns, needToExtend) => {
  let column;
  let commandColumnIndex;
  let result = columns7.slice().map(((column2) => extend({}, column2)));
  const isColumnFixing = that._isColumnFixing();
  let defaultCommandColumns = commandColumns.slice().map(((column2) => extend({
    fixed: isColumnFixing
  }, column2)));
  const getCommandColumnIndex = (column2) => commandColumns.reduce(((result2, commandColumn, index) => {
    const columnType = needToExtend && column2.type === GROUP_COMMAND_COLUMN_NAME ? "expand" : column2.type;
    return commandColumn.type === columnType || commandColumn.command === column2.command ? index : result2;
  }), -1);
  const callbackFilter = (commandColumn) => commandColumn.command !== commandColumns[commandColumnIndex].command;
  for (let i = 0; i < columns7.length; i++) {
    column = columns7[i];
    commandColumnIndex = column && (column.type || column.command) ? getCommandColumnIndex(column) : -1;
    if (commandColumnIndex >= 0) {
      if (needToExtend) {
        result[i] = extend({
          fixed: isColumnFixing
        }, commandColumns[commandColumnIndex], column);
        if (column.type !== GROUP_COMMAND_COLUMN_NAME) {
          defaultCommandColumns = defaultCommandColumns.filter(callbackFilter);
        }
      } else {
        const columnOptions = {
          visibleIndex: column.visibleIndex,
          index: column.index,
          headerId: column.headerId,
          allowFixing: 0 === column.groupIndex,
          allowReordering: 0 === column.groupIndex,
          groupIndex: column.groupIndex
        };
        result[i] = extend({}, column, commandColumns[commandColumnIndex], column.type === GROUP_COMMAND_COLUMN_NAME && columnOptions);
      }
    }
  }
  if (columns7.length && needToExtend && defaultCommandColumns.length) {
    result = result.concat(defaultCommandColumns);
  }
  return result;
};
var isColumnFixed = (that, column) => isDefined(column.fixed) || !column.type ? column.fixed && column.fixedPosition !== StickyPosition.Sticky : that._isColumnFixing();
var convertOwnerBandToColumnReference = (columns7) => {
  columns7.forEach(((column) => {
    if (isDefined(column.ownerBand)) {
      column.ownerBand = columns7[column.ownerBand];
    }
  }));
};
var resetBandColumnsCache = (that) => {
  that._bandColumnsCache = void 0;
};
var findColumn = (columns7, identifier) => {
  const identifierOptionName = isString(identifier) && identifier.substr(0, identifier.indexOf(":"));
  let column;
  if (void 0 === identifier) {
    return;
  }
  if (identifierOptionName) {
    identifier = identifier.substr(identifierOptionName.length + 1);
  }
  if (identifierOptionName) {
    column = columns7.filter(((column2) => `${column2[identifierOptionName]}` === identifier))[0];
  } else {
    ["index", "name", "dataField", "caption"].some(((optionName) => {
      column = columns7.filter(((column2) => column2[optionName] === identifier))[0];
      return !!column;
    }));
  }
  return column;
};
var sortColumns = (columns7, sortOrder) => {
  if ("asc" !== sortOrder && "desc" !== sortOrder) {
    return columns7;
  }
  const sign = "asc" === sortOrder ? 1 : -1;
  columns7.sort(((column1, column2) => {
    const caption1 = column1.caption || "";
    const caption2 = column2.caption || "";
    return sign * caption1.localeCompare(caption2);
  }));
  return columns7;
};
var strictParseNumber = function(text, format2) {
  const parsedValue = number_default.parse(text);
  if (isNumeric(parsedValue)) {
    const formattedValue = number_default.format(parsedValue, format2);
    const formattedValueWithDefaultFormat = number_default.format(parsedValue, "decimal");
    if (formattedValue === text || formattedValueWithDefaultFormat === text) {
      return parsedValue;
    }
  }
};
var isFirstOrLastBandColumn = function(that, bandColumns) {
  let onlyWithinBandColumn = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;
  let isLast = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;
  let fixedPosition = arguments.length > 4 ? arguments[4] : void 0;
  return bandColumns.every(((column, index) => onlyWithinBandColumn && 0 === index || isFirstOrLastColumnCore(that, column, index, onlyWithinBandColumn, isLast, fixedPosition)));
};
var isFirstOrLastColumnCore = function(that, column, rowIndex) {
  var _columns, _columns$;
  let onlyWithinBandColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;
  let isLast = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;
  let fixedPosition = arguments.length > 5 ? arguments[5] : void 0;
  const columnIndex = column.index;
  const columns7 = (index = rowIndex, that.getVisibleColumns(index).filter(((col) => {
    let res = true;
    if (col.visibleWidth === HIDDEN_COLUMNS_WIDTH) {
      return false;
    }
    if (onlyWithinBandColumn && column) {
      res && (res = col.ownerBand === column.ownerBand);
    } else if (fixedPosition) {
      res && (res = col.fixed && getColumnFixedPosition(that, col) === fixedPosition);
    }
    return res;
  })));
  var index;
  const visibleColumnIndex = that.getVisibleIndex(columnIndex, rowIndex);
  return isLast ? visibleColumnIndex === that.getVisibleIndex(null === (_columns = columns7[columns7.length - 1]) || void 0 === _columns ? void 0 : _columns.index, rowIndex) : visibleColumnIndex === that.getVisibleIndex(null === (_columns$ = columns7[0]) || void 0 === _columns$ ? void 0 : _columns$.index, rowIndex);
};
var isFirstOrLastColumn2 = function(that, targetColumn, rowIndex) {
  let onlyWithinBandColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;
  let isLast = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;
  let fixedPosition = arguments.length > 5 ? arguments[5] : void 0;
  const targetColumnIndex = targetColumn.index;
  const bandColumnsCache = that.getBandColumnsCache();
  const parentBandColumns = !isDefined(targetColumn.type) && getParentBandColumns(targetColumnIndex, bandColumnsCache.columnParentByIndex);
  if (null !== parentBandColumns && void 0 !== parentBandColumns && parentBandColumns.length) {
    return isFirstOrLastBandColumn(that, parentBandColumns.concat([targetColumn]), onlyWithinBandColumn, isLast, fixedPosition);
  }
  return onlyWithinBandColumn || isFirstOrLastColumnCore(that, targetColumn, rowIndex, onlyWithinBandColumn, isLast, fixedPosition);
};

// node_modules/devextreme/esm/__internal/grids/grid_core/columns_controller/m_columns_controller.js
var ColumnsController = class extends m_modules_default.Controller {
  init(isApplyingUserState) {
    this._dataController = this.getController("data");
    this._focusController = this.getController("focus");
    this._stateStoringController = this.getController("stateStoring");
    const columns7 = this.option("columns");
    this._commandColumns = this._commandColumns || [];
    this._columns = this._columns || [];
    this._isColumnsFromOptions = !!columns7;
    if (this._isColumnsFromOptions) {
      assignColumns(this, columns7 ? createColumnsFromOptions(this, columns7) : []);
      applyUserState(this);
    } else {
      assignColumns(this, this._columnsUserState ? createColumnsFromOptions(this, this._columnsUserState) : this._columns);
    }
    addExpandColumn(this);
    if (this._dataSourceApplied) {
      this.applyDataSource(this._dataSource, true, isApplyingUserState);
    } else {
      updateIndexes(this);
    }
    this._checkColumns();
  }
  _getExpandColumnOptions() {
    return {
      type: "expand",
      command: "expand",
      width: "auto",
      cssClass: COMMAND_EXPAND_CLASS2,
      allowEditing: false,
      allowGrouping: false,
      allowSorting: false,
      allowResizing: false,
      allowReordering: false,
      allowHiding: false
    };
  }
  _getFirstItems(dataSource) {
    let groupsCount;
    let items = [];
    const getFirstItemsCore = function(items2, groupsCount2) {
      if (!items2 || !groupsCount2) {
        return items2;
      }
      for (let i = 0; i < items2.length; i++) {
        const childItems = getFirstItemsCore(items2[i].items || items2[i].collapsedItems, groupsCount2 - 1);
        if (childItems && childItems.length) {
          return childItems;
        }
      }
    };
    if (dataSource && dataSource.items().length > 0) {
      groupsCount = m_utils_default.normalizeSortingInfo(dataSource.group()).length;
      items = getFirstItemsCore(dataSource.items(), groupsCount) || [];
    }
    return items;
  }
  _endUpdateCore() {
    !this._skipProcessingColumnsChange && fireColumnsChanged(this);
  }
  callbackNames() {
    return ["columnsChanged"];
  }
  getColumnByPath(path, columns7) {
    const that = this;
    let column;
    const columnIndexes = [];
    path.replace(COLUMN_OPTION_REGEXP, ((_, columnIndex) => {
      columnIndexes.push(parseInt(columnIndex));
      return "";
    }));
    if (columnIndexes.length) {
      if (columns7) {
        column = columnIndexes.reduce(((column2, index) => column2 && column2.columns && column2.columns[index]), {
          columns: columns7
        });
      } else {
        column = getColumnByIndexes(that, columnIndexes);
      }
    }
    return column;
  }
  optionChanged(args) {
    let needUpdateRequireResize;
    switch (args.name) {
      case "adaptColumnWidthByRatio":
        args.handled = true;
        break;
      case "dataSource":
        if (args.value !== args.previousValue && !this.option("columns") && (!Array.isArray(args.value) || !Array.isArray(args.previousValue))) {
          this._columns = [];
        }
        break;
      case "columns":
        needUpdateRequireResize = this._skipProcessingColumnsChange;
        args.handled = true;
        if (!this._skipProcessingColumnsChange) {
          if (args.name === args.fullName) {
            this._columnsUserState = null;
            this._ignoreColumnOptionNames = null;
            this.init();
          } else {
            this._columnOptionChanged(args);
            needUpdateRequireResize = true;
          }
        }
        if (needUpdateRequireResize) {
          this._updateRequireResize(args);
        }
        break;
      case "commonColumnSettings":
      case "columnAutoWidth":
      case "allowColumnResizing":
      case "allowColumnReordering":
      case "columnFixing":
      case "grouping":
      case "groupPanel":
      case "regenerateColumnsByVisibleItems":
      case "customizeColumns":
      case "columnHidingEnabled":
      case "dateSerializationFormat":
      case "columnResizingMode":
      case "columnMinWidth":
      case "columnWidth": {
        args.handled = true;
        const ignoreColumnOptionNames = "columnWidth" === args.fullName && ["width"];
        this.reinit(ignoreColumnOptionNames);
        break;
      }
      case "rtlEnabled":
        this.reinit();
        break;
      default:
        super.optionChanged(args);
    }
  }
  _columnOptionChanged(args) {
    let columnOptionValue = {};
    const column = this.getColumnByPath(args.fullName);
    const columnOptionName = args.fullName.replace(COLUMN_OPTION_REGEXP, "");
    if (column) {
      if (columnOptionName) {
        columnOptionValue[columnOptionName] = args.value;
      } else {
        columnOptionValue = args.value;
      }
      this._skipProcessingColumnsChange = args.fullName;
      this.columnOption(column.index, columnOptionValue);
      this._skipProcessingColumnsChange = false;
    }
  }
  _updateRequireResize(args) {
    const {
      component
    } = this;
    if ("width" === args.fullName.replace(COLUMN_OPTION_REGEXP, "") && component._updateLockCount) {
      component._requireResize = true;
    }
  }
  publicMethods() {
    return ["addColumn", "deleteColumn", "columnOption", "columnCount", "clearSorting", "clearGrouping", "getVisibleColumns", "getVisibleColumnIndex", "getColumns"];
  }
  applyDataSource(dataSource, forceApplying, isApplyingUserState) {
    const that = this;
    const isDataSourceLoaded = dataSource && dataSource.isLoaded();
    that._dataSource = dataSource;
    if (!that._dataSourceApplied || 0 === that._dataSourceColumnsCount || forceApplying || that.option("regenerateColumnsByVisibleItems")) {
      if (isDataSourceLoaded) {
        if (!that._isColumnsFromOptions) {
          const columnsFromDataSource = createColumnsFromDataSource(that, dataSource);
          if (columnsFromDataSource.length) {
            assignColumns(that, columnsFromDataSource);
            that._dataSourceColumnsCount = that._columns.length;
            applyUserState(that);
          }
        }
        return that.updateColumns(dataSource, forceApplying, isApplyingUserState);
      }
      that._dataSourceApplied = false;
      updateIndexes(that);
    } else if (isDataSourceLoaded && !that.isAllDataTypesDefined(true) && that.updateColumnDataTypes(dataSource)) {
      updateColumnChanges(that, "columns");
      fireColumnsChanged(that);
      return new Deferred().reject().promise();
    }
  }
  reset() {
    this._dataSource = null;
    this._dataSourceApplied = false;
    this._dataSourceColumnsCount = void 0;
    this.reinit();
  }
  resetColumnsCache() {
    this._visibleColumns = void 0;
    this._fixedColumns = void 0;
    this._rowCount = void 0;
    resetBandColumnsCache(this);
  }
  reinit(ignoreColumnOptionNames) {
    this._columnsUserState = this.getUserState();
    this._ignoreColumnOptionNames = ignoreColumnOptionNames || null;
    this.init();
    if (ignoreColumnOptionNames) {
      this._ignoreColumnOptionNames = null;
    }
  }
  isInitialized() {
    return !!this._columns.length || !!this.option("columns");
  }
  isDataSourceApplied() {
    return this._dataSourceApplied;
  }
  getCommonSettings(column) {
    const commonColumnSettings = (!column || !column.type) && this.option("commonColumnSettings") || {};
    const groupingOptions = this.option("grouping") ?? {};
    const groupPanelOptions = this.option("groupPanel") ?? {};
    return extend({
      allowFixing: this.option("columnFixing.enabled"),
      allowResizing: this.option("allowColumnResizing") || void 0,
      allowReordering: this.option("allowColumnReordering"),
      minWidth: this.option("columnMinWidth"),
      width: this.option("columnWidth"),
      autoExpandGroup: groupingOptions.autoExpandAll,
      allowCollapsing: groupingOptions.allowCollapsing,
      allowGrouping: groupPanelOptions.allowColumnDragging && groupPanelOptions.visible || groupingOptions.contextMenuEnabled
    }, commonColumnSettings);
  }
  isColumnOptionUsed(optionName) {
    for (let i = 0; i < this._columns.length; i++) {
      if (this._columns[i][optionName]) {
        return true;
      }
    }
  }
  isAllDataTypesDefined(checkSerializers) {
    const columns7 = this._columns;
    if (!columns7.length) {
      return false;
    }
    for (let i = 0; i < columns7.length; i++) {
      if (!columns7[i].dataField && columns7[i].calculateCellValue === columns7[i].defaultCalculateCellValue) {
        continue;
      }
      if (!columns7[i].dataType || checkSerializers && columns7[i].deserializeValue && void 0 === columns7[i].serializationFormat) {
        return false;
      }
    }
    return true;
  }
  getColumns() {
    return this._columns;
  }
  isBandColumnsUsed() {
    return this.getColumns().some(((column) => column.isBand));
  }
  getGroupColumns() {
    const result = [];
    each(this._columns, (function() {
      const column = this;
      if (isDefined(column.groupIndex)) {
        result[column.groupIndex] = column;
      }
    }));
    return result;
  }
  _shouldReturnVisibleColumns() {
    return true;
  }
  _compileVisibleColumns(rowIndex) {
    this._visibleColumns = this._visibleColumns || this._compileVisibleColumnsCore();
    rowIndex = isDefined(rowIndex) ? rowIndex : this._visibleColumns.length - 1;
    return this._visibleColumns[rowIndex] || [];
  }
  getVisibleColumns(rowIndex, isBase) {
    if (!this._shouldReturnVisibleColumns()) {
      return [];
    }
    return this._compileVisibleColumns.apply(this, arguments);
  }
  getFixedColumns(rowIndex) {
    this._fixedColumns = this._fixedColumns || this._getFixedColumnsCore();
    rowIndex = isDefined(rowIndex) ? rowIndex : this._fixedColumns.length - 1;
    return this._fixedColumns[rowIndex] || [];
  }
  getFilteringColumns() {
    return this.getColumns().filter(((item) => (item.dataField || item.name) && (item.allowFiltering || item.allowHeaderFiltering))).map(((item) => {
      const field = extend(true, {}, item);
      if (!isDefined(field.dataField)) {
        field.dataField = field.name;
      }
      field.filterOperations = item.filterOperations !== item.defaultFilterOperations ? field.filterOperations : null;
      return field;
    }));
  }
  getColumnIndexOffset() {
    return 0;
  }
  getStickyColumns(rowIndex) {
    const visibleColumns = this.getVisibleColumns(rowIndex, true);
    return visibleColumns.filter(((column) => column.fixed));
  }
  _getFixedColumnsCore() {
    const that = this;
    const result = [];
    const rowCount = that.getRowCount();
    const isColumnFixing = that._isColumnFixing();
    const transparentColumn = {
      command: "transparent"
    };
    let transparentColspan = 0;
    let notFixedColumnCount;
    let transparentColumnIndex;
    let lastFixedPosition;
    if (isColumnFixing) {
      for (let i = 0; i <= rowCount; i++) {
        notFixedColumnCount = 0;
        lastFixedPosition = null;
        transparentColumnIndex = null;
        const visibleColumns = that.getVisibleColumns(i, true);
        for (let j = 0; j < visibleColumns.length; j++) {
          const prevColumn = visibleColumns[j - 1];
          const column = visibleColumns[j];
          if (!column.fixed || column.fixedPosition === StickyPosition.Sticky) {
            if (0 === i) {
              if (column.isBand && column.colspan) {
                transparentColspan += column.colspan;
              } else {
                transparentColspan++;
              }
            }
            notFixedColumnCount++;
            if (!isDefined(transparentColumnIndex)) {
              transparentColumnIndex = j;
            }
          } else if (prevColumn && prevColumn.fixed && getFixedPosition(that, prevColumn) !== getFixedPosition(that, column)) {
            if (!isDefined(transparentColumnIndex)) {
              transparentColumnIndex = j;
            }
          } else {
            lastFixedPosition = column.fixedPosition;
          }
        }
        if (0 === i && (0 === notFixedColumnCount || notFixedColumnCount >= visibleColumns.length)) {
          return [];
        }
        if (!isDefined(transparentColumnIndex)) {
          transparentColumnIndex = "right" === lastFixedPosition ? 0 : visibleColumns.length;
        }
        result[i] = visibleColumns.slice(0);
        if (!transparentColumn.colspan) {
          transparentColumn.colspan = transparentColspan;
        }
        result[i].splice(transparentColumnIndex, notFixedColumnCount, transparentColumn);
      }
    }
    return result.map(((columns7) => columns7.map(((column) => {
      const newColumn = _extends({}, column);
      if (newColumn.headerId) {
        newColumn.headerId += "-fixed";
      }
      return newColumn;
    }))));
  }
  _isColumnFixing() {
    let isColumnFixing = this.option("columnFixing.enabled");
    !isColumnFixing && each(this._columns, ((_, column) => {
      if (column.fixed) {
        isColumnFixing = true;
        return false;
      }
    }));
    return isColumnFixing;
  }
  _getExpandColumnsCore() {
    return this.getGroupColumns();
  }
  getExpandColumns() {
    let expandColumns = this._getExpandColumnsCore();
    let expandColumn;
    const firstGroupColumn = expandColumns.filter(((column) => 0 === column.groupIndex))[0];
    const isFixedFirstGroupColumn = firstGroupColumn && firstGroupColumn.fixed;
    const isColumnFixing = this._isColumnFixing();
    const rtlEnabled = this.option("rtlEnabled");
    if (expandColumns.length) {
      expandColumn = this.columnOption("command:expand");
    }
    expandColumns = map(expandColumns, ((column) => extend({}, _extends({}, column, {
      ownerBand: void 0
    }), {
      visibleWidth: null,
      minWidth: null,
      cellTemplate: !isDefined(column.groupIndex) ? column.cellTemplate : null,
      headerCellTemplate: null,
      fixed: !isDefined(column.groupIndex) || !isFixedFirstGroupColumn ? isColumnFixing : true,
      fixedPosition: rtlEnabled ? "right" : "left"
    }, expandColumn, {
      index: column.index,
      type: column.type || GROUP_COMMAND_COLUMN_NAME
    })));
    return expandColumns;
  }
  getBandColumnsCache() {
    if (!this._bandColumnsCache) {
      const columns7 = this._columns;
      const columnChildrenByIndex = {};
      const columnParentByIndex = {};
      let isPlain = true;
      columns7.forEach(((column) => {
        const {
          ownerBand
        } = column;
        let parentIndex = isObject(ownerBand) ? ownerBand.index : ownerBand;
        const parent = columns7[parentIndex];
        if (column.hasColumns) {
          isPlain = false;
        }
        if (column.colspan) {
          column.colspan = void 0;
        }
        if (column.rowspan) {
          column.rowspan = void 0;
        }
        if (parent) {
          columnParentByIndex[column.index] = parent;
        } else {
          parentIndex = -1;
        }
        columnChildrenByIndex[parentIndex] = columnChildrenByIndex[parentIndex] || [];
        columnChildrenByIndex[parentIndex].push(column);
      }));
      this._bandColumnsCache = {
        isPlain,
        columnChildrenByIndex,
        columnParentByIndex
      };
    }
    return this._bandColumnsCache;
  }
  _isColumnVisible(column) {
    return column.visible && this.isParentColumnVisible(column.index);
  }
  _isColumnInGroupPanel(column) {
    return isDefined(column.groupIndex) && !column.showWhenGrouped;
  }
  hasVisibleDataColumns() {
    const columns7 = this._columns;
    return columns7.some(((column) => {
      const isVisible2 = this._isColumnVisible(column);
      const isInGroupPanel = this._isColumnInGroupPanel(column);
      const isCommand = !!column.command;
      return isVisible2 && !isInGroupPanel && !isCommand;
    }));
  }
  _compileVisibleColumnsCore() {
    const bandColumnsCache = this.getBandColumnsCache();
    const columns7 = mergeColumns(this, this._columns, this._commandColumns, true);
    processBandColumns(this, columns7, bandColumnsCache);
    const indexedColumns = this._getIndexedColumns(columns7);
    const visibleColumns = this._getVisibleColumnsFromIndexed(indexedColumns);
    const isDataColumnsInvisible = !this.hasVisibleDataColumns();
    if (isDataColumnsInvisible && this._columns.length) {
      visibleColumns[visibleColumns.length - 1].push({
        command: "empty",
        type: "empty"
      });
    }
    return visibleColumns;
  }
  _getIndexedColumns(columns7) {
    const rtlEnabled = this.option("rtlEnabled");
    const rowCount = this.getRowCount();
    const columnDigitsCount = digitsCount(columns7.length);
    const bandColumnsCache = this.getBandColumnsCache();
    const positiveIndexedColumns = [];
    const negativeIndexedColumns = [];
    for (let i = 0; i < rowCount; i += 1) {
      negativeIndexedColumns[i] = [{}];
      positiveIndexedColumns[i] = [{}, {}, {}];
    }
    columns7.forEach(((column) => {
      let {
        visibleIndex
      } = column;
      let indexedColumns;
      const parentBandColumns = getParentBandColumns(column.index, bandColumnsCache.columnParentByIndex);
      const isVisible2 = this._isColumnVisible(column);
      const isInGroupPanel = this._isColumnInGroupPanel(column);
      if (isVisible2 && !isInGroupPanel) {
        const rowIndex = parentBandColumns.length;
        if (visibleIndex < 0) {
          visibleIndex = -visibleIndex;
          indexedColumns = negativeIndexedColumns[rowIndex];
        } else {
          var _parentBandColumns$, _parentBandColumns$2;
          column.fixed = (null === (_parentBandColumns$ = parentBandColumns[0]) || void 0 === _parentBandColumns$ ? void 0 : _parentBandColumns$.fixed) ?? column.fixed;
          column.fixedPosition = (null === (_parentBandColumns$2 = parentBandColumns[0]) || void 0 === _parentBandColumns$2 ? void 0 : _parentBandColumns$2.fixedPosition) ?? column.fixedPosition;
          if (column.fixed && column.fixedPosition !== StickyPosition.Sticky) {
            const isDefaultCommandColumn = !!column.command && !m_utils_default.isCustomCommandColumn(this._columns, column);
            let isFixedToEnd = "right" === column.fixedPosition;
            if (rtlEnabled && !isDefaultCommandColumn) {
              isFixedToEnd = !isFixedToEnd;
            }
            indexedColumns = isFixedToEnd ? positiveIndexedColumns[rowIndex][2] : positiveIndexedColumns[rowIndex][0];
          } else {
            indexedColumns = positiveIndexedColumns[rowIndex][1];
          }
        }
        if (parentBandColumns.length) {
          visibleIndex = numberToString(visibleIndex, columnDigitsCount);
          for (let i = parentBandColumns.length - 1; i >= 0; i -= 1) {
            visibleIndex = numberToString(parentBandColumns[i].visibleIndex, columnDigitsCount) + visibleIndex;
          }
        }
        indexedColumns[visibleIndex] = indexedColumns[visibleIndex] || [];
        indexedColumns[visibleIndex].push(column);
      }
    }));
    return {
      positiveIndexedColumns,
      negativeIndexedColumns
    };
  }
  _getVisibleColumnsFromIndexed(_ref) {
    let {
      positiveIndexedColumns,
      negativeIndexedColumns
    } = _ref;
    const result = [];
    const rowCount = this.getRowCount();
    const expandColumns = mergeColumns(this, this.getExpandColumns(), this._columns);
    let rowspanGroupColumns = 0;
    let rowspanExpandColumns = 0;
    for (let rowIndex = 0; rowIndex < rowCount; rowIndex += 1) {
      result.push([]);
      orderEach(negativeIndexedColumns[rowIndex], ((_, columns7) => {
        result[rowIndex].unshift.apply(result[rowIndex], columns7);
      }));
      const firstPositiveIndexColumn = result[rowIndex].length;
      const positiveIndexedRowColumns = positiveIndexedColumns[rowIndex];
      positiveIndexedRowColumns.forEach(((columnsByFixing) => {
        orderEach(columnsByFixing, ((_, columnsByVisibleIndex) => {
          result[rowIndex].push.apply(result[rowIndex], columnsByVisibleIndex);
        }));
      }));
      if (rowspanExpandColumns <= rowIndex) {
        rowspanExpandColumns += processExpandColumns.call(this, result[rowIndex], expandColumns, DETAIL_COMMAND_COLUMN_NAME, firstPositiveIndexColumn);
      }
      if (rowspanGroupColumns <= rowIndex) {
        rowspanGroupColumns += processExpandColumns.call(this, result[rowIndex], expandColumns, GROUP_COMMAND_COLUMN_NAME, firstPositiveIndexColumn);
      }
    }
    result.push(getDataColumns(result));
    return result;
  }
  getInvisibleColumns(columns7, bandColumnIndex) {
    const that = this;
    let result = [];
    let hiddenColumnsByBand;
    columns7 = columns7 || that._columns;
    each(columns7, ((_, column) => {
      if (column.ownerBand !== bandColumnIndex) {
        return;
      }
      if (column.isBand) {
        if (!column.visible) {
          hiddenColumnsByBand = that.getChildrenByBandColumn(column.index);
        } else {
          hiddenColumnsByBand = that.getInvisibleColumns(that.getChildrenByBandColumn(column.index), column.index);
        }
        if (hiddenColumnsByBand.length) {
          result.push(column);
          result = result.concat(hiddenColumnsByBand);
        }
        return;
      }
      if (!column.visible) {
        result.push(column);
      }
    }));
    return result;
  }
  getChooserColumns(getAllColumns) {
    const columns7 = getAllColumns ? this.getColumns() : this.getInvisibleColumns();
    const columnChooserColumns = columns7.filter(((column) => column.showInColumnChooser));
    const sortOrder = this.option("columnChooser.sortOrder");
    return sortColumns(columnChooserColumns, sortOrder);
  }
  allowMoveColumn(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation) {
    const columnIndex = getColumnIndexByVisibleIndex(this, fromVisibleIndex, sourceLocation);
    const sourceColumn = this._columns[columnIndex];
    if (sourceColumn && (sourceColumn.allowReordering || sourceColumn.allowGrouping || sourceColumn.allowHiding)) {
      if (sourceLocation === targetLocation) {
        if (sourceLocation === COLUMN_CHOOSER_LOCATION) {
          return false;
        }
        fromVisibleIndex = isObject(fromVisibleIndex) ? fromVisibleIndex.columnIndex : fromVisibleIndex;
        toVisibleIndex = isObject(toVisibleIndex) ? toVisibleIndex.columnIndex : toVisibleIndex;
        return fromVisibleIndex !== toVisibleIndex && fromVisibleIndex + 1 !== toVisibleIndex;
      }
      if (sourceLocation === GROUP_LOCATION && targetLocation !== COLUMN_CHOOSER_LOCATION || targetLocation === GROUP_LOCATION) {
        return sourceColumn && sourceColumn.allowGrouping;
      }
      if (sourceLocation === COLUMN_CHOOSER_LOCATION || targetLocation === COLUMN_CHOOSER_LOCATION) {
        return sourceColumn && sourceColumn.allowHiding;
      }
      return true;
    }
    return false;
  }
  moveColumn(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation) {
    const that = this;
    const options = {};
    let prevGroupIndex;
    const fromIndex = getColumnIndexByVisibleIndex(that, fromVisibleIndex, sourceLocation);
    const toIndex = getColumnIndexByVisibleIndex(that, toVisibleIndex, targetLocation);
    let targetGroupIndex;
    if (fromIndex >= 0) {
      const column = that._columns[fromIndex];
      toVisibleIndex = isObject(toVisibleIndex) ? toVisibleIndex.columnIndex : toVisibleIndex;
      targetGroupIndex = toIndex >= 0 ? that._columns[toIndex].groupIndex : -1;
      if (isDefined(column.groupIndex) && sourceLocation === GROUP_LOCATION) {
        if (targetGroupIndex > column.groupIndex) {
          targetGroupIndex--;
        }
        if (targetLocation !== GROUP_LOCATION) {
          options.groupIndex = void 0;
        } else {
          prevGroupIndex = column.groupIndex;
          delete column.groupIndex;
          updateColumnGroupIndexes(that);
        }
      }
      if (targetLocation === GROUP_LOCATION) {
        options.groupIndex = moveColumnToGroup(that, column, targetGroupIndex);
        column.groupIndex = prevGroupIndex;
      } else if (toVisibleIndex >= 0) {
        const targetColumn = that._columns[toIndex];
        if (!targetColumn || column.ownerBand !== targetColumn.ownerBand) {
          options.visibleIndex = MAX_SAFE_INTEGER;
        } else if (isColumnFixed(that, column) ^ isColumnFixed(that, targetColumn)) {
          options.visibleIndex = MAX_SAFE_INTEGER;
        } else {
          options.visibleIndex = targetColumn.visibleIndex;
        }
      }
      const isVisible2 = targetLocation !== COLUMN_CHOOSER_LOCATION;
      if (column.visible !== isVisible2) {
        options.visible = isVisible2;
      }
      that.columnOption(column.index, options);
    }
  }
  allowColumnSorting(column) {
    const sortingOptions = this.option("sorting");
    const allowSorting = "single" === (null === sortingOptions || void 0 === sortingOptions ? void 0 : sortingOptions.mode) || "multiple" === (null === sortingOptions || void 0 === sortingOptions ? void 0 : sortingOptions.mode);
    return allowSorting && (null === column || void 0 === column ? void 0 : column.allowSorting);
  }
  changeSortOrder(columnIndex, sortOrder) {
    const that = this;
    const options = {};
    const sortingOptions = that.option("sorting");
    const sortingMode = null === sortingOptions || void 0 === sortingOptions ? void 0 : sortingOptions.mode;
    const needResetSorting = "single" === sortingMode || !sortOrder;
    const column = that._columns[columnIndex];
    if (this.allowColumnSorting(column)) {
      if (needResetSorting && !isDefined(column.groupIndex)) {
        each(that._columns, (function(index) {
          if (index !== columnIndex && this.sortOrder) {
            if (!isDefined(this.groupIndex)) {
              delete this.sortOrder;
            }
            delete this.sortIndex;
          }
        }));
      }
      if (isSortOrderValid(sortOrder)) {
        if (column.sortOrder !== sortOrder) {
          options.sortOrder = sortOrder;
        }
      } else if ("none" === sortOrder) {
        if (column.sortOrder) {
          options.sortIndex = void 0;
          options.sortOrder = void 0;
        }
      } else {
        !(function(column2) {
          if ("ctrl" === sortOrder) {
            if (!("sortOrder" in column2 && "sortIndex" in column2)) {
              return false;
            }
            options.sortOrder = void 0;
            options.sortIndex = void 0;
          } else if (isDefined(column2.groupIndex) || isDefined(column2.sortIndex)) {
            options.sortOrder = "desc" === column2.sortOrder ? "asc" : "desc";
          } else {
            options.sortOrder = "asc";
          }
          return true;
        })(column);
      }
    }
    that.columnOption(column.index, options);
  }
  getSortDataSourceParameters(useLocalSelector) {
    const sortColumns2 = [];
    const sort = [];
    each(this._columns, (function() {
      if ((this.dataField || this.selector || this.calculateCellValue) && isDefined(this.sortIndex) && !isDefined(this.groupIndex)) {
        sortColumns2[this.sortIndex] = this;
      }
    }));
    each(sortColumns2, (function() {
      const sortOrder = this && this.sortOrder;
      if (isSortOrderValid(sortOrder)) {
        const sortItem = {
          selector: this.calculateSortValue || this.displayField || this.calculateDisplayValue || useLocalSelector && this.selector || this.dataField || this.calculateCellValue,
          desc: "desc" === this.sortOrder
        };
        if (this.sortingMethod) {
          sortItem.compare = this.sortingMethod.bind(this);
        }
        sort.push(sortItem);
      }
    }));
    return sort.length > 0 ? sort : null;
  }
  getGroupDataSourceParameters(useLocalSelector) {
    const group = [];
    each(this.getGroupColumns(), (function() {
      const selector = this.calculateGroupValue || this.displayField || this.calculateDisplayValue || useLocalSelector && this.selector || this.dataField || this.calculateCellValue;
      if (selector) {
        const groupItem = {
          selector,
          desc: "desc" === this.sortOrder,
          isExpanded: !!this.autoExpandGroup
        };
        if (this.sortingMethod) {
          groupItem.compare = this.sortingMethod.bind(this);
        }
        group.push(groupItem);
      }
    }));
    return group.length > 0 ? group : null;
  }
  refresh(updateNewLookupsOnly) {
    const deferreds = [];
    each(this._columns, (function() {
      const {
        lookup
      } = this;
      if (lookup && !this.calculateDisplayValue) {
        if (updateNewLookupsOnly && lookup.valueMap) {
          return;
        }
        if (lookup.update) {
          deferreds.push(lookup.update());
        }
      }
    }));
    return when.apply(renderer_default, deferreds).done(resetColumnsCache.bind(null, this));
  }
  _updateColumnOptions(column, columnIndex) {
    var _this$_previousColumn, _this$_previousColumn2;
    const shouldTakeOriginalCallbackFromPrevious = this._reinitAfterLookupChanges && (null === (_this$_previousColumn = this._previousColumns) || void 0 === _this$_previousColumn ? void 0 : _this$_previousColumn[columnIndex]);
    column.selector = column.selector ?? ((data17) => column.calculateCellValue(data17));
    column.selector.columnIndex = columnIndex;
    column.selector.originalCallback = shouldTakeOriginalCallbackFromPrevious ? (null === (_this$_previousColumn2 = this._previousColumns[columnIndex].selector) || void 0 === _this$_previousColumn2 ? void 0 : _this$_previousColumn2.originalCallback) ?? column.selector : column.selector;
    each(["calculateSortValue", "calculateGroupValue", "calculateDisplayValue"], ((_, calculateCallbackName) => {
      const calculateCallback = column[calculateCallbackName];
      if (isFunction(calculateCallback)) {
        if (!calculateCallback.originalCallback) {
          const context = {
            column
          };
          column[calculateCallbackName] = function(data17) {
            return calculateCallback.call(context.column, data17);
          };
          column[calculateCallbackName].originalCallback = calculateCallback;
          column[calculateCallbackName].columnIndex = columnIndex;
          column[calculateCallbackName].context = context;
        } else {
          column[calculateCallbackName].context.column = column;
        }
      }
    }));
    if (isString(column.calculateDisplayValue)) {
      column.displayField = column.calculateDisplayValue;
      column.calculateDisplayValue = compileGetter(column.displayField);
    }
    if (column.calculateDisplayValue) {
      column.displayValueMap = column.displayValueMap || {};
    }
    updateSerializers(column, column.dataType);
    const {
      lookup
    } = column;
    if (lookup) {
      updateSerializers(lookup, lookup.dataType);
    }
    const dataType = lookup ? lookup.dataType : column.dataType;
    if (dataType) {
      column.alignment = column.alignment || getAlignmentByDataType(dataType, this.option("rtlEnabled"));
      column.format = column.format || m_utils_default.getFormatByDataType(dataType);
      column.customizeText = column.customizeText || getCustomizeTextByDataType(dataType);
      column.defaultFilterOperations = column.defaultFilterOperations || !lookup && DATATYPE_OPERATIONS[dataType] || [];
      if (!isDefined(column.filterOperations)) {
        setFilterOperationsAsDefaultValues(column);
      }
      column.defaultFilterOperation = column.filterOperations && column.filterOperations[0] || "=";
      column.showEditorAlways = isDefined(column.showEditorAlways) ? column.showEditorAlways : "boolean" === dataType && !column.cellTemplate && !column.lookup;
    }
  }
  updateColumnDataTypes(dataSource) {
    const that = this;
    const dateSerializationFormat = that.option("dateSerializationFormat");
    const firstItems = that._getFirstItems(dataSource);
    let isColumnDataTypesUpdated = false;
    each(that._columns, ((index, column) => {
      let i;
      let value2;
      let dataType;
      let lookupDataType;
      let valueDataType;
      const {
        lookup
      } = column;
      if (m_utils_default.isDateType(column.dataType) && void 0 === column.serializationFormat) {
        column.serializationFormat = dateSerializationFormat;
      }
      if (lookup && m_utils_default.isDateType(lookup.dataType) && void 0 === column.serializationFormat) {
        lookup.serializationFormat = dateSerializationFormat;
      }
      if (column.calculateCellValue && firstItems.length) {
        if (!column.dataType || lookup && !lookup.dataType) {
          for (i = 0; i < firstItems.length; i++) {
            value2 = column.calculateCellValue(firstItems[i]);
            if (!column.dataType) {
              valueDataType = getValueDataType(value2);
              dataType = dataType || valueDataType;
              if (dataType && valueDataType && dataType !== valueDataType) {
                dataType = "string";
              }
            }
            if (lookup && !lookup.dataType) {
              valueDataType = getValueDataType(m_utils_default.getDisplayValue(column, value2, firstItems[i]));
              lookupDataType = lookupDataType || valueDataType;
              if (lookupDataType && valueDataType && lookupDataType !== valueDataType) {
                lookupDataType = "string";
              }
            }
          }
          if (dataType || lookupDataType) {
            if (dataType) {
              column.dataType = dataType;
            }
            if (lookup && lookupDataType) {
              lookup.dataType = lookupDataType;
            }
            isColumnDataTypesUpdated = true;
          }
        }
        if (void 0 === column.serializationFormat || lookup && void 0 === lookup.serializationFormat) {
          for (i = 0; i < firstItems.length; i++) {
            value2 = column.calculateCellValue(firstItems[i], true);
            if (void 0 === column.serializationFormat) {
              column.serializationFormat = getSerializationFormat(column.dataType, value2);
            }
            if (lookup && void 0 === lookup.serializationFormat) {
              lookup.serializationFormat = getSerializationFormat(lookup.dataType, lookup.calculateCellValue(value2, true));
            }
          }
        }
      }
      that._updateColumnOptions(column, index);
    }));
    return isColumnDataTypesUpdated;
  }
  _customizeColumns(columns7) {
    const that = this;
    const customizeColumns = that.option("customizeColumns");
    if (customizeColumns) {
      const hasOwnerBand = columns7.some(((column) => isObject(column.ownerBand)));
      if (hasOwnerBand) {
        updateIndexes(that);
      }
      customizeColumns(columns7);
      assignColumns(that, createColumnsFromOptions(that, columns7));
    }
  }
  updateColumns(dataSource, forceApplying, isApplyingUserState) {
    if (!forceApplying) {
      this.updateSortingGrouping(dataSource);
    }
    if (!dataSource || dataSource.isLoaded()) {
      const sortParameters = dataSource ? dataSource.sort() || [] : this.getSortDataSourceParameters();
      const groupParameters = dataSource ? dataSource.group() || [] : this.getGroupDataSourceParameters();
      const filterParameters = null === dataSource || void 0 === dataSource ? void 0 : dataSource.lastLoadOptions().filter;
      if (!isApplyingUserState) {
        this._customizeColumns(this._columns);
      }
      updateIndexes(this);
      const columns7 = this._columns;
      return when(this.refresh(true)).always((() => {
        if (this._columns !== columns7) {
          return;
        }
        this._updateChanges(dataSource, {
          sorting: sortParameters,
          grouping: groupParameters,
          filtering: filterParameters
        });
        fireColumnsChanged(this);
      }));
    }
  }
  _updateChanges(dataSource, parameters) {
    var _dataSource$loadOptio;
    const langParams = null === dataSource || void 0 === dataSource || null === (_dataSource$loadOptio = dataSource.loadOptions) || void 0 === _dataSource$loadOptio || null === (_dataSource$loadOptio = _dataSource$loadOptio.call(dataSource)) || void 0 === _dataSource$loadOptio ? void 0 : _dataSource$loadOptio.langParams;
    if (dataSource) {
      this.updateColumnDataTypes(dataSource);
      this._dataSourceApplied = true;
    }
    if (!m_utils_default.equalSortParameters(parameters.sorting, this.getSortDataSourceParameters())) {
      updateColumnChanges(this, "sorting");
    }
    if (!m_utils_default.equalSortParameters(parameters.grouping, this.getGroupDataSourceParameters())) {
      updateColumnChanges(this, "grouping");
    }
    if (this._dataController && !m_utils_default.equalFilterParameters(parameters.filtering, this._dataController.getCombinedFilter(), langParams)) {
      updateColumnChanges(this, "filtering");
    }
    updateColumnChanges(this, "columns");
  }
  updateSortingGrouping(dataSource, fromDataSource) {
    const that = this;
    let isColumnsChanged;
    const updateSortGroupParameterIndexes = function(columns7, sortParameters, indexParameterName) {
      each(columns7, ((index, column) => {
        delete column[indexParameterName];
        if (sortParameters) {
          for (let i = 0; i < sortParameters.length; i++) {
            const {
              selector
            } = sortParameters[i];
            const {
              isExpanded
            } = sortParameters[i];
            if (selector === column.dataField || selector === column.name || selector === column.displayField || m_utils_default.isEqualSelectors(selector, column.selector) || m_utils_default.isSelectorEqualWithCallback(selector, column.calculateCellValue) || m_utils_default.isSelectorEqualWithCallback(selector, column.calculateGroupValue) || m_utils_default.isSelectorEqualWithCallback(selector, column.calculateDisplayValue)) {
              if (fromDataSource) {
                column.sortOrder = "sortOrder" in column ? column.sortOrder : sortParameters[i].desc ? "desc" : "asc";
              } else {
                column.sortOrder = column.sortOrder || (sortParameters[i].desc ? "desc" : "asc");
              }
              if (void 0 !== isExpanded) {
                column.autoExpandGroup = isExpanded;
              }
              column[indexParameterName] = i;
              break;
            }
          }
        }
      }));
    };
    if (dataSource) {
      var _this$_columnChanges;
      const sortParameters = m_utils_default.normalizeSortingInfo(dataSource.sort());
      const groupParameters = m_utils_default.normalizeSortingInfo(dataSource.group());
      const columnsGroupParameters = that.getGroupDataSourceParameters();
      const columnsSortParameters = that.getSortDataSourceParameters();
      const changeTypes = null === (_this$_columnChanges = this._columnChanges) || void 0 === _this$_columnChanges ? void 0 : _this$_columnChanges.changeTypes;
      const sortingChanged = !m_utils_default.equalSortParameters(sortParameters, columnsSortParameters);
      const needToApplySortingFromDataSource = fromDataSource && !(null !== changeTypes && void 0 !== changeTypes && changeTypes.sorting);
      const needToApplyGroupingFromDataSource = fromDataSource && !(null !== changeTypes && void 0 !== changeTypes && changeTypes.grouping);
      const groupingChanged = !m_utils_default.equalSortParameters(groupParameters, columnsGroupParameters, true);
      const groupExpandingChanged = !groupingChanged && !m_utils_default.equalSortParameters(groupParameters, columnsGroupParameters);
      if (!that._columns.length) {
        each(groupParameters, ((index, group) => {
          that._columns.push(group.selector);
        }));
        each(sortParameters, ((index, sort) => {
          if (!isFunction(sort.selector)) {
            that._columns.push(sort.selector);
          }
        }));
        assignColumns(that, createColumnsFromOptions(that, that._columns));
      }
      if ((needToApplyGroupingFromDataSource || !columnsGroupParameters && !that._hasUserState) && (groupingChanged || groupExpandingChanged)) {
        updateSortGroupParameterIndexes(that._columns, groupParameters, "groupIndex");
        if (fromDataSource) {
          groupingChanged && updateColumnChanges(that, "grouping");
          groupExpandingChanged && updateColumnChanges(that, "groupExpanding");
          isColumnsChanged = true;
        }
      }
      if ((needToApplySortingFromDataSource || !columnsSortParameters && !that._hasUserState) && sortingChanged) {
        updateSortGroupParameterIndexes(that._columns, sortParameters, "sortIndex");
        if (fromDataSource) {
          updateColumnChanges(that, "sorting");
          isColumnsChanged = true;
        }
      }
      if (isColumnsChanged) {
        fireColumnsChanged(that);
      }
    }
  }
  updateFilter(filter, remoteFiltering, columnIndex, filterValue) {
    const that = this;
    if (!Array.isArray(filter)) {
      return filter;
    }
    filter = extend([], filter);
    columnIndex = void 0 !== filter.columnIndex ? filter.columnIndex : columnIndex;
    filterValue = void 0 !== filter.filterValue ? filter.filterValue : filterValue;
    if (isString(filter[0]) && "!" !== filter[0]) {
      const column = that.columnOption(filter[0]);
      if (remoteFiltering) {
        if (config_default().forceIsoDateParsing && column && column.serializeValue && filter.length > 1) {
          filter[filter.length - 1] = column.serializeValue(filter[filter.length - 1], "filter");
        }
      } else if (column && column.selector) {
        filter[0] = column.selector;
        filter[0].columnIndex = column.index;
      }
    } else if (isFunction(filter[0])) {
      filter[0].columnIndex = columnIndex;
      filter[0].filterValue = filterValue;
      filter[0].selectedFilterOperation = filter.selectedFilterOperation;
    }
    for (let i = 0; i < filter.length; i++) {
      filter[i] = that.updateFilter(filter[i], remoteFiltering, columnIndex, filterValue);
    }
    return filter;
  }
  columnCount() {
    return this._columns ? this._columns.length : 0;
  }
  columnOption(identifier, option, value2, notFireEvent) {
    const that = this;
    const columns7 = that._columns.concat(that._commandColumns);
    const column = findColumn(columns7, identifier);
    if (column) {
      if (1 === arguments.length) {
        return extend({}, column);
      }
      if (isString(option)) {
        if (2 === arguments.length) {
          return columnOptionCore(that, column, option);
        }
        columnOptionCore(that, column, option, value2, notFireEvent);
      } else if (isObject(option)) {
        each(option, ((optionName, value3) => {
          columnOptionCore(that, column, optionName, value3, notFireEvent);
        }));
      }
      fireColumnsChanged(that);
    }
  }
  clearSorting() {
    const that = this;
    const columnCount = this.columnCount();
    that.beginUpdate();
    for (let i = 0; i < columnCount; i++) {
      that.columnOption(i, "sortOrder", void 0);
      delete findColumn(that._columns, i).sortOrder;
    }
    that.endUpdate();
  }
  clearGrouping() {
    const that = this;
    const columnCount = this.columnCount();
    that.beginUpdate();
    for (let i = 0; i < columnCount; i++) {
      that.columnOption(i, "groupIndex", void 0);
    }
    that.endUpdate();
  }
  getVisibleIndex(index, rowIndex) {
    const columns7 = this.getVisibleColumns(rowIndex);
    for (let i = columns7.length - 1; i >= 0; i--) {
      if (columns7[i].index === index) {
        return i;
      }
    }
    return -1;
  }
  getVisibleIndexByColumn(column, rowIndex) {
    const visibleColumns = this.getVisibleColumns(rowIndex);
    const visibleColumn = visibleColumns.filter(((col) => col.index === column.index && col.command === column.command))[0];
    return visibleColumns.indexOf(visibleColumn);
  }
  getVisibleColumnIndex(id, rowIndex) {
    const index = this.columnOption(id, "index");
    return this.getVisibleIndex(index, rowIndex);
  }
  addColumn(options) {
    const that = this;
    let column = createColumn(that, options);
    const index = that._columns.length;
    that._columns.push(column);
    if (column.isBand) {
      that._columns = createColumnsFromOptions(that, that._columns);
      column = that._columns[index];
    }
    column.added = options;
    updateIndexes(that, column);
    that.updateColumns(that._dataSource);
    that._checkColumns();
  }
  deleteColumn(id) {
    const that = this;
    const column = that.columnOption(id);
    if (column && column.index >= 0) {
      convertOwnerBandToColumnReference(that._columns);
      that._columns.splice(column.index, 1);
      if (column.isBand) {
        const childIndexes = that.getChildrenByBandColumn(column.index).map(((column2) => column2.index));
        that._columns = that._columns.filter(((column2) => childIndexes.indexOf(column2.index) < 0));
      }
      updateIndexes(that);
      that.updateColumns(that._dataSource);
    }
  }
  addCommandColumn(options) {
    let commandColumn = this._commandColumns.filter(((column) => column.command === options.command))[0];
    if (!commandColumn) {
      commandColumn = options;
      this._commandColumns.push(commandColumn);
    }
  }
  getUserState() {
    const columns7 = this._columns;
    const result = [];
    let i;
    function handleStateField(index, value2) {
      if (void 0 !== columns7[i][value2]) {
        result[i][value2] = columns7[i][value2];
      }
    }
    for (i = 0; i < columns7.length; i++) {
      result[i] = {};
      each(USER_STATE_FIELD_NAMES, handleStateField);
    }
    return result;
  }
  setName(column) {
    column.name = column.name || column.dataField || column.type;
  }
  setUserState(state) {
    const that = this;
    const dataSource = that._dataSource;
    let ignoreColumnOptionNames = that.option("stateStoring.ignoreColumnOptionNames");
    null === state || void 0 === state || state.forEach(this.setName);
    if (!ignoreColumnOptionNames) {
      ignoreColumnOptionNames = [];
      const commonColumnSettings = that.getCommonSettings();
      if (!that.option("columnChooser.enabled")) {
        ignoreColumnOptionNames.push("visible");
      }
      if ("none" === that.option("sorting.mode")) {
        ignoreColumnOptionNames.push("sortIndex", "sortOrder");
      }
      if (!commonColumnSettings.allowGrouping) {
        ignoreColumnOptionNames.push("groupIndex");
      }
      if (!commonColumnSettings.allowFixing) {
        ignoreColumnOptionNames.push("fixed", "fixedPosition");
      }
      if (!commonColumnSettings.allowResizing) {
        ignoreColumnOptionNames.push("width", "visibleWidth");
      }
      const isFilterPanelHidden = !that.option("filterPanel.visible");
      if (!that.option("filterRow.visible") && isFilterPanelHidden) {
        ignoreColumnOptionNames.push("filterValue", "selectedFilterOperation");
      }
      if (!that.option("headerFilter.visible") && isFilterPanelHidden) {
        ignoreColumnOptionNames.push("filterValues", "filterType");
      }
    }
    that._columnsUserState = state;
    that._ignoreColumnOptionNames = ignoreColumnOptionNames;
    that._hasUserState = !!state;
    updateColumnChanges(that, "filtering");
    that.init(true);
    if (dataSource) {
      dataSource.sort(that.getSortDataSourceParameters());
      dataSource.group(that.getGroupDataSourceParameters());
    }
  }
  _checkColumns() {
    const usedNames = {};
    let hasEditableColumnWithoutName = false;
    const duplicatedNames = [];
    this._columns.forEach(((column) => {
      var _column$columns;
      const {
        name
      } = column;
      const isBand = null === (_column$columns = column.columns) || void 0 === _column$columns ? void 0 : _column$columns.length;
      const isEditable2 = column.allowEditing && (column.dataField || column.setCellValue) && !isBand;
      if (name) {
        if (usedNames[name]) {
          duplicatedNames.push(`"${name}"`);
        }
        usedNames[name] = true;
      } else if (isEditable2) {
        hasEditableColumnWithoutName = true;
      }
    }));
    if (duplicatedNames.length) {
      ui_errors_default.log("E1059", duplicatedNames.join(", "));
    }
    if (hasEditableColumnWithoutName) {
      ui_errors_default.log("E1060");
    }
  }
  _createCalculatedColumnOptions(columnOptions, bandColumn) {
    let calculatedColumnOptions = {};
    let {
      dataField
    } = columnOptions;
    if (Array.isArray(columnOptions.columns) && columnOptions.columns.length || columnOptions.isBand) {
      calculatedColumnOptions.isBand = true;
      dataField = null;
    }
    if (dataField) {
      if (isString(dataField)) {
        const getter = compileGetter(dataField);
        calculatedColumnOptions = {
          caption: m_inflector_default.captionize(dataField),
          calculateCellValue(data17, skipDeserialization) {
            const value2 = getter(data17);
            return this.deserializeValue && !skipDeserialization ? this.deserializeValue(value2) : value2;
          },
          setCellValue: defaultSetCellValue,
          parseValue(text) {
            const column = this;
            let result;
            let parsedValue;
            if ("number" === column.dataType) {
              if (isString(text) && column.format) {
                result = strictParseNumber(text.trim(), column.format);
              } else if (isDefined(text) && isNumeric(text)) {
                result = Number(text);
              }
            } else if ("boolean" === column.dataType) {
              if (text === column.trueText) {
                result = true;
              } else if (text === column.falseText) {
                result = false;
              }
            } else if (m_utils_default.isDateType(column.dataType)) {
              parsedValue = date_default2.parse(text, column.format);
              if (parsedValue) {
                result = parsedValue;
              }
            } else {
              result = text;
            }
            return result;
          }
        };
      }
      calculatedColumnOptions.allowFiltering = true;
    } else {
      calculatedColumnOptions.allowFiltering = !!columnOptions.calculateFilterExpression;
    }
    calculatedColumnOptions.calculateFilterExpression = function() {
      return filtering_default.defaultCalculateFilterExpression.apply(this, arguments);
    };
    calculatedColumnOptions.defaultFilterOperation = "=";
    calculatedColumnOptions.createFilterExpression = function(filterValue, selectedFilterOperation) {
      let result;
      if (this.calculateFilterExpression) {
        result = this.calculateFilterExpression.apply(this, arguments);
      }
      if (isFunction(result)) {
        result = [result, "=", true];
      }
      if (result) {
        result.columnIndex = this.index;
        result.filterValue = filterValue;
        result.selectedFilterOperation = selectedFilterOperation;
      }
      return result;
    };
    if (!dataField || !isString(dataField)) {
      extend(true, calculatedColumnOptions, {
        allowSorting: false,
        allowGrouping: false,
        calculateCellValue: () => null
      });
    }
    if (bandColumn) {
      calculatedColumnOptions.allowFixing = false;
    }
    if (columnOptions.dataType) {
      calculatedColumnOptions.userDataType = columnOptions.dataType;
    }
    if (columnOptions.selectedFilterOperation && !("defaultSelectedFilterOperation" in calculatedColumnOptions)) {
      calculatedColumnOptions.defaultSelectedFilterOperation = columnOptions.selectedFilterOperation;
    }
    if (columnOptions.lookup) {
      calculatedColumnOptions.lookup = {
        calculateCellValue(value2, skipDeserialization) {
          if (this.valueExpr) {
            value2 = this.valueMap && this.valueMap[value2];
          }
          return this.deserializeValue && !skipDeserialization ? this.deserializeValue(value2) : value2;
        },
        updateValueMap() {
          this.valueMap = {};
          if (this.items) {
            const calculateValue = compileGetter(this.valueExpr);
            const calculateDisplayValue = compileGetter(this.displayExpr);
            for (let i = 0; i < this.items.length; i++) {
              const item = this.items[i];
              const displayValue = calculateDisplayValue(item);
              this.valueMap[calculateValue(item)] = displayValue;
              this.dataType = this.dataType || getValueDataType(displayValue);
            }
          }
        },
        update() {
          const that = this;
          let {
            dataSource
          } = that;
          if (dataSource) {
            if (isFunction(dataSource) && !variable_wrapper_default.isWrapped(dataSource)) {
              dataSource = dataSource({});
            }
            if (isPlainObject(dataSource) || dataSource instanceof m_abstract_store_default || Array.isArray(dataSource)) {
              if (that.valueExpr) {
                const dataSourceOptions = normalizeDataSourceOptions(dataSource);
                dataSourceOptions.paginate = false;
                dataSource = new DataSource(dataSourceOptions);
                return dataSource.load().done(((data17) => {
                  that.items = data17;
                  that.updateValueMap && that.updateValueMap();
                }));
              }
            } else {
              ui_errors_default.log("E1016");
            }
          } else {
            that.updateValueMap && that.updateValueMap();
          }
        }
      };
    }
    calculatedColumnOptions.resizedCallbacks = callbacks_default();
    if (columnOptions.resized) {
      calculatedColumnOptions.resizedCallbacks.add(columnOptions.resized.bind(columnOptions));
    }
    each(calculatedColumnOptions, ((optionName) => {
      if (isFunction(calculatedColumnOptions[optionName]) && 0 !== optionName.indexOf("default")) {
        const defaultOptionName = `default${optionName.charAt(0).toUpperCase()}${optionName.substr(1)}`;
        calculatedColumnOptions[defaultOptionName] = calculatedColumnOptions[optionName];
      }
    }));
    return calculatedColumnOptions;
  }
  getRowCount() {
    this._rowCount = this._rowCount || getRowCount(this);
    return this._rowCount;
  }
  getRowIndex(columnIndex, alwaysGetRowIndex) {
    const column = this._columns[columnIndex];
    const bandColumnsCache = this.getBandColumnsCache();
    return column && (alwaysGetRowIndex || column.visible && !(column.command || isDefined(column.groupIndex))) ? getParentBandColumns(columnIndex, bandColumnsCache.columnParentByIndex).length : 0;
  }
  getChildrenByBandColumn(bandColumnIndex, onlyVisibleDirectChildren) {
    const bandColumnsCache = this.getBandColumnsCache();
    const result = getChildrenByBandColumn(bandColumnIndex, bandColumnsCache.columnChildrenByIndex, !onlyVisibleDirectChildren);
    if (onlyVisibleDirectChildren) {
      return result.filter(((column) => column.visible && !column.command)).sort(((column1, column2) => column1.visibleIndex - column2.visibleIndex));
    }
    return result;
  }
  getVisibleDataColumnsByBandColumn(bandColumnIndex) {
    const bandColumnsCache = this.getBandColumnsCache();
    const result = this.getChildrenByBandColumn(bandColumnIndex, bandColumnsCache.columnChildrenByIndex);
    return result.filter(((column) => !column.isBand && column.visible));
  }
  isParentBandColumn(columnIndex, bandColumnIndex) {
    let result = false;
    const column = this._columns[columnIndex];
    const bandColumnsCache = this.getBandColumnsCache();
    const parentBandColumns = column && getParentBandColumns(columnIndex, bandColumnsCache.columnParentByIndex);
    if (parentBandColumns) {
      each(parentBandColumns, ((_, bandColumn) => {
        if (bandColumn.index === bandColumnIndex) {
          result = true;
          return false;
        }
      }));
    }
    return result;
  }
  isParentColumnVisible(columnIndex) {
    let result = true;
    const bandColumnsCache = this.getBandColumnsCache();
    const bandColumns = columnIndex >= 0 && getParentBandColumns(columnIndex, bandColumnsCache.columnParentByIndex);
    bandColumns && each(bandColumns, ((_, bandColumn) => {
      result = result && bandColumn.visible;
      return result;
    }));
    return result;
  }
  getParentColumn(column) {
    let needDirectParent = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;
    const bandColumnsCache = this.getBandColumnsCache();
    const parentColumns = getParentBandColumns(column.index, bandColumnsCache.columnParentByIndex);
    const parentColumnIndex = needDirectParent ? -1 : 0;
    return parentColumns.at(parentColumnIndex);
  }
  isFirstColumn(column, rowIndex) {
    let onlyWithinBandColumn = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;
    let fixedPosition = arguments.length > 3 ? arguments[3] : void 0;
    return isFirstOrLastColumn2(this, column, rowIndex, onlyWithinBandColumn, false, fixedPosition);
  }
  isLastColumn(column, rowIndex) {
    let onlyWithinBandColumn = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;
    let fixedPosition = arguments.length > 3 ? arguments[3] : void 0;
    return isFirstOrLastColumn2(this, column, rowIndex, onlyWithinBandColumn, true, fixedPosition);
  }
  isCustomCommandColumn(commandColumn) {
    return m_utils_default.isCustomCommandColumn(this._columns, commandColumn);
  }
  getColumnId(column) {
    if (column.command && column.type === GROUP_COMMAND_COLUMN_NAME) {
      if (m_utils_default.isCustomCommandColumn(this._columns, column)) {
        return `type:${column.type}`;
      }
      return `command:${column.command}`;
    }
    return column.index;
  }
  getCustomizeTextByDataType(dataType) {
    return getCustomizeTextByDataType(dataType);
  }
  getHeaderContentAlignment(columnAlignment) {
    const rtlEnabled = this.option("rtlEnabled");
    if (rtlEnabled) {
      return "left" === columnAlignment ? "right" : "left";
    }
    return columnAlignment;
  }
  isVirtualMode() {
    return false;
  }
  isNeedToRenderVirtualColumns(scrollPosition) {
    return false;
  }
};
var columnsControllerModule = {
  defaultOptions: () => ({
    commonColumnSettings: {
      allowFiltering: true,
      allowHiding: true,
      allowSorting: true,
      allowEditing: true,
      encodeHtml: true,
      trueText: message_default.format("dxDataGrid-trueText"),
      falseText: message_default.format("dxDataGrid-falseText")
    },
    allowColumnReordering: false,
    allowColumnResizing: false,
    columnResizingMode: "nextColumn",
    columnMinWidth: void 0,
    columnWidth: void 0,
    adaptColumnWidthByRatio: true,
    columns: void 0,
    regenerateColumnsByVisibleItems: false,
    customizeColumns: null,
    dateSerializationFormat: void 0
  }),
  controllers: {
    columns: ColumnsController
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/m_columns_controller.js
m_core_default.registerModule("columns", {
  defaultOptions: () => extend(true, {}, columnsControllerModule.defaultOptions(), {
    commonColumnSettings: {
      allowExporting: true
    }
  }),
  controllers: columnsControllerModule.controllers
});

// node_modules/devextreme/esm/__internal/grids/grid_core/data_controller/m_data_helper_mixin.js
var DATA_SOURCE_CHANGED_METHOD = "_dataSourceChangedHandler";
var SPECIFIC_DATA_SOURCE_OPTION = "_getSpecificDataSourceOption";
var NORMALIZE_DATA_SOURCE = "_normalizeDataSource";
var DataHelperMixin = (Base) => class extends Base {
  postCtor() {
    this.on("disposing", (() => {
      this._disposeDataSource();
    }));
  }
  _refreshDataSource() {
    this._initDataSource();
    this._loadDataSource();
  }
  _initDataSource() {
    let dataSourceOptions = SPECIFIC_DATA_SOURCE_OPTION in this ? this[SPECIFIC_DATA_SOURCE_OPTION]() : this.option("dataSource");
    let widgetDataSourceOptions;
    let dataSourceType;
    this._disposeDataSource();
    if (dataSourceOptions) {
      if (dataSourceOptions instanceof DataSource) {
        this._isSharedDataSource = true;
        this._dataSource = dataSourceOptions;
      } else {
        widgetDataSourceOptions = "_dataSourceOptions" in this ? this._dataSourceOptions() : {};
        dataSourceType = this._dataSourceType ? this._dataSourceType() : DataSource;
        dataSourceOptions = normalizeDataSourceOptions(dataSourceOptions, {
          fromUrlLoadMode: "_dataSourceFromUrlLoadMode" in this && this._dataSourceFromUrlLoadMode()
        });
        this._dataSource = new dataSourceType(extend(true, {}, widgetDataSourceOptions, dataSourceOptions));
      }
      if (NORMALIZE_DATA_SOURCE in this) {
        this._dataSource = this[NORMALIZE_DATA_SOURCE](this._dataSource);
      }
      this._addDataSourceHandlers();
      this._initDataController();
    }
  }
  _initDataController() {
    var _this$option;
    const dataController2 = null === (_this$option = this.option) || void 0 === _this$option ? void 0 : _this$option.call(this, "_dataController");
    const dataSource = this._dataSource;
    if (dataController2) {
      this._dataController = dataController2;
    } else {
      this._dataController = new m_data_controller_default(dataSource);
    }
  }
  _addDataSourceHandlers() {
    if (DATA_SOURCE_CHANGED_METHOD in this) {
      this._addDataSourceChangeHandler();
    }
    if ("_dataSourceLoadErrorHandler" in this) {
      this._addDataSourceLoadErrorHandler();
    }
    if ("_dataSourceLoadingChangedHandler" in this) {
      this._addDataSourceLoadingChangedHandler();
    }
    this._addReadyWatcher();
  }
  _addReadyWatcher() {
    this.readyWatcher = (function(isLoading) {
      this._ready && this._ready(!isLoading);
    }).bind(this);
    this._dataSource.on("loadingChanged", this.readyWatcher);
  }
  _addDataSourceChangeHandler() {
    const dataSource = this._dataSource;
    this._proxiedDataSourceChangedHandler = (function(e) {
      this[DATA_SOURCE_CHANGED_METHOD](dataSource.items(), e);
    }).bind(this);
    dataSource.on("changed", this._proxiedDataSourceChangedHandler);
  }
  _addDataSourceLoadErrorHandler() {
    this._proxiedDataSourceLoadErrorHandler = this._dataSourceLoadErrorHandler.bind(this);
    this._dataSource.on("loadError", this._proxiedDataSourceLoadErrorHandler);
  }
  _addDataSourceLoadingChangedHandler() {
    this._proxiedDataSourceLoadingChangedHandler = this._dataSourceLoadingChangedHandler.bind(this);
    this._dataSource.on("loadingChanged", this._proxiedDataSourceLoadingChangedHandler);
  }
  _loadDataSource() {
    const dataSource = this._dataSource;
    if (dataSource) {
      if (dataSource.isLoaded()) {
        this._proxiedDataSourceChangedHandler && this._proxiedDataSourceChangedHandler();
      } else {
        dataSource.load();
      }
    }
  }
  _loadSingle(key, value2) {
    key = "this" === key ? this._dataSource.key() || "this" : key;
    return this._dataSource.loadSingle(key, value2);
  }
  _isLastPage() {
    return !this._dataSource || this._dataSource.isLastPage() || !this._dataSource._pageSize;
  }
  _isDataSourceLoading() {
    return this._dataSource && this._dataSource.isLoading();
  }
  _disposeDataSource() {
    if (this._dataSource) {
      if (this._isSharedDataSource) {
        delete this._isSharedDataSource;
        this._proxiedDataSourceChangedHandler && this._dataSource.off("changed", this._proxiedDataSourceChangedHandler);
        this._proxiedDataSourceLoadErrorHandler && this._dataSource.off("loadError", this._proxiedDataSourceLoadErrorHandler);
        this._proxiedDataSourceLoadingChangedHandler && this._dataSource.off("loadingChanged", this._proxiedDataSourceLoadingChangedHandler);
        if (this._dataSource._eventsStrategy) {
          this._dataSource._eventsStrategy.off("loadingChanged", this.readyWatcher);
        }
      } else {
        this._dataSource.dispose();
      }
      delete this._dataSource;
      delete this._proxiedDataSourceChangedHandler;
      delete this._proxiedDataSourceLoadErrorHandler;
      delete this._proxiedDataSourceLoadingChangedHandler;
    }
  }
  getDataSource() {
    return this._dataSource || null;
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/data_controller/m_data_controller.js
var changePaging = function(that, optionName, value2) {
  const dataSource = that._dataSource;
  if (dataSource) {
    if (void 0 !== value2) {
      const oldValue = that._getPagingOptionValue(optionName);
      if (oldValue !== value2) {
        if ("pageSize" === optionName) {
          dataSource.pageIndex(0);
        }
        dataSource[optionName](value2);
        that._skipProcessingPagingChange = true;
        that.option(`paging.${optionName}`, value2);
        that._skipProcessingPagingChange = false;
        const pageIndex = dataSource.pageIndex();
        that._isPaging = "pageIndex" === optionName;
        return dataSource["pageIndex" === optionName ? "load" : "reload"]().done((() => {
          that._isPaging = false;
          that.pageChanged.fire(pageIndex);
        }));
      }
      return Deferred().resolve().promise();
    }
    return dataSource[optionName]();
  }
  if ("pageIndex" === optionName && void 0 !== value2) {
    return Deferred().resolve().promise();
  }
  return 0;
};
var DataController = class extends DataHelperMixin(m_modules_default.Controller) {
  init() {
    this._items = [];
    this._cachedProcessedItems = null;
    this._columnsController = this.getController("columns");
    this._adaptiveColumnsController = this.getController("adaptiveColumns");
    this._editingController = this.getController("editing");
    this._editorFactoryController = this.getController("editorFactory");
    this._errorHandlingController = this.getController("errorHandling");
    this._filterSyncController = this.getController("filterSync");
    this._applyFilterController = this.getController("applyFilter");
    this._keyboardNavigationController = this.getController("keyboardNavigation");
    this._focusController = this.getController("focus");
    this._headerFilterController = this.getController("headerFilter");
    this._selectionController = this.getController("selection");
    this._stateStoringController = this.getController("stateStoring");
    this._validatingController = this.getController("validating");
    this._isPaging = false;
    this._currentOperationTypes = null;
    this._dataChangedHandler = (e) => {
      this._currentOperationTypes = this._dataSource.operationTypes();
      this._handleDataChanged(e);
      this._currentOperationTypes = null;
    };
    this._columnsChangedHandler = this._handleColumnsChanged.bind(this);
    this._loadingChangedHandler = this._handleLoadingChanged.bind(this);
    this._loadErrorHandler = this._handleLoadError.bind(this);
    this._customizeStoreLoadOptionsHandler = this._handleCustomizeStoreLoadOptions.bind(this);
    this._changingHandler = this._handleChanging.bind(this);
    this._dataPushedHandler = this._handleDataPushed.bind(this);
    this._columnsController.columnsChanged.add(this._columnsChangedHandler);
    this._isLoading = false;
    this._isCustomLoading = false;
    this._repaintChangesOnly = void 0;
    this._changes = [];
    this.createAction("onDataErrorOccurred");
    this.dataErrorOccurred.add(((error) => this.executeAction("onDataErrorOccurred", {
      error
    })));
    this._refreshDataSource();
    this.postCtor();
  }
  _getPagingOptionValue(optionName) {
    return this._dataSource[optionName]();
  }
  callbackNames() {
    return ["changed", "loadingChanged", "dataErrorOccurred", "pageChanged", "dataSourceChanged", "pushed"];
  }
  callbackFlags(name) {
    if ("dataErrorOccurred" === name) {
      return {
        stopOnFalse: true
      };
    }
    return;
  }
  publicMethods() {
    return ["_disposeDataSource", "beginCustomLoading", "byKey", "clearFilter", "endCustomLoading", "filter", "getCombinedFilter", "getDataByKeys", "getDataSource", "getKeyByRowIndex", "getRowIndexByKey", "getVisibleRows", "keyOf", "pageCount", "pageIndex", "pageSize", "refresh", "repaintRows", "totalCount"];
  }
  reset() {
    this._columnsController.reset();
    this._items = [];
    this._refreshDataSource();
  }
  _handleDataSourceChange(args) {
    if (args.value === args.previousValue || this.option("columns") && Array.isArray(args.value) && Array.isArray(args.previousValue)) {
      const isValueChanged = args.value !== args.previousValue;
      if (isValueChanged) {
        const store = this.store();
        if (store) {
          store._array = args.value;
        }
      }
      if (this.needToRefreshOnDataSourceChange(args)) {
        this.refresh(this.option("repaintChangesOnly"));
      }
      return true;
    }
    return false;
  }
  needToRefreshOnDataSourceChange(args) {
    return true;
  }
  optionChanged(args) {
    const that = this;
    let dataSource;
    let changedPagingOptions;
    function handled() {
      args.handled = true;
    }
    if ("dataSource" === args.name && args.name === args.fullName && this._handleDataSourceChange(args)) {
      handled();
      return;
    }
    switch (args.name) {
      case "cacheEnabled":
      case "repaintChangesOnly":
      case "highlightChanges":
      case "loadingTimeout":
        handled();
        break;
      case "remoteOperations":
      case "keyExpr":
      case "dataSource":
      case "scrolling":
        handled();
        that.reset();
        break;
      case "paging":
        dataSource = that.dataSource();
        if (dataSource) {
          changedPagingOptions = that._setPagingOptions(dataSource);
          if (changedPagingOptions) {
            const pageIndex = dataSource.pageIndex();
            this._isPaging = changedPagingOptions.isPageIndexChanged;
            dataSource.load().done((() => {
              this._isPaging = false;
              that.pageChanged.fire(pageIndex);
            }));
          }
        }
        handled();
        break;
      case "rtlEnabled":
        that.reset();
        break;
      case "columns":
        dataSource = that.dataSource();
        if (dataSource && dataSource.isLoading() && args.name === args.fullName) {
          this._useSortingGroupingFromColumns = true;
          dataSource.load();
        }
        break;
      default:
        super.optionChanged(args);
    }
  }
  isReady() {
    return !this._isLoading;
  }
  getDataSource() {
    return this._dataSource && this._dataSource._dataSource;
  }
  getCombinedFilter(returnDataField) {
    return this.combinedFilter(void 0, returnDataField);
  }
  combinedFilter(filter, returnDataField) {
    if (!this._dataSource) {
      return filter;
    }
    let combined = filter ?? this._dataSource.filter();
    const isColumnsTypesDefined = this._columnsController.isDataSourceApplied() || this._columnsController.isAllDataTypesDefined();
    if (isColumnsTypesDefined) {
      const additionalFilter = this._calculateAdditionalFilter();
      combined = additionalFilter ? m_utils_default.combineFilters([additionalFilter, combined]) : combined;
    }
    const isRemoteFiltering = this._dataSource.remoteOperations().filtering || returnDataField;
    combined = this._columnsController.updateFilter(combined, isRemoteFiltering);
    return combined;
  }
  waitReady() {
    if (this._updateLockCount) {
      this._readyDeferred = new Deferred();
      return this._readyDeferred;
    }
    return when();
  }
  _endUpdateCore() {
    const changes = this._changes;
    if (changes.length) {
      this._changes = [];
      const repaintChangesOnly = changes.every(((change) => change.repaintChangesOnly));
      this.updateItems(1 === changes.length ? changes[0] : {
        repaintChangesOnly
      });
    }
    if (this._readyDeferred) {
      this._readyDeferred.resolve();
      this._readyDeferred = null;
    }
  }
  _handleCustomizeStoreLoadOptions(e) {
    var _storeLoadOptions$fil;
    const columnsController = this._columnsController;
    const dataSource = this._dataSource;
    const {
      storeLoadOptions
    } = e;
    if (e.isCustomLoading && !storeLoadOptions.isLoadingAll) {
      return;
    }
    storeLoadOptions.filter = this.combinedFilter(storeLoadOptions.filter);
    if (1 === (null === (_storeLoadOptions$fil = storeLoadOptions.filter) || void 0 === _storeLoadOptions$fil ? void 0 : _storeLoadOptions$fil.length) && "!" === storeLoadOptions.filter[0]) {
      e.data = [];
      e.extra = e.extra || {};
      e.extra.totalCount = 0;
    }
    if (!columnsController.isDataSourceApplied()) {
      columnsController.updateColumnDataTypes(dataSource);
    }
    this._columnsUpdating = true;
    columnsController.updateSortingGrouping(dataSource, !this._useSortingGroupingFromColumns);
    this._columnsUpdating = false;
    storeLoadOptions.sort = columnsController.getSortDataSourceParameters();
    storeLoadOptions.group = columnsController.getGroupDataSourceParameters();
    dataSource.sort(storeLoadOptions.sort);
    dataSource.group(storeLoadOptions.group);
    storeLoadOptions.sort = columnsController.getSortDataSourceParameters(!dataSource.remoteOperations().sorting);
    e.group = columnsController.getGroupDataSourceParameters(!dataSource.remoteOperations().grouping);
  }
  _handleColumnsChanged(e) {
    const that = this;
    const {
      changeTypes
    } = e;
    const {
      optionNames
    } = e;
    let filterValue;
    let filterValues;
    let filterApplied;
    const updateItemsHandler = function(change) {
      var _change$changeTypes, _change$changeTypes2;
      that._columnsController.columnsChanged.remove(updateItemsHandler);
      that.updateItems({
        repaintChangesOnly: false,
        event: null === change || void 0 === change || null === (_change$changeTypes = change.changeTypes) || void 0 === _change$changeTypes ? void 0 : _change$changeTypes.event,
        virtualColumnsScrolling: null === change || void 0 === change || null === (_change$changeTypes2 = change.changeTypes) || void 0 === _change$changeTypes2 ? void 0 : _change$changeTypes2.virtualColumnsScrolling
      });
    };
    if (changeTypes.sorting || changeTypes.grouping) {
      if (that._dataSource && !that._columnsUpdating) {
        that._dataSource.group(that._columnsController.getGroupDataSourceParameters());
        that._dataSource.sort(that._columnsController.getSortDataSourceParameters());
        that.reload();
      }
    } else if (changeTypes.columns) {
      filterValues = that._columnsController.columnOption(e.columnIndex, "filterValues");
      if (optionNames.filterValues || optionNames.filterType && Array.isArray(filterValues) || optionNames.filterValue || optionNames.selectedFilterOperation || optionNames.allowFiltering) {
        filterValue = that._columnsController.columnOption(e.columnIndex, "filterValue");
        if (Array.isArray(filterValues) || void 0 === e.columnIndex || isDefined(filterValue) || !optionNames.selectedFilterOperation || optionNames.filterValue) {
          that._applyFilter();
          filterApplied = true;
        }
      }
      if (!that._needApplyFilter && !m_utils_default.checkChanges(optionNames, ["width", "visibleWidth", "filterValue", "bufferedFilterValue", "selectedFilterOperation", "filterValues", "filterType"])) {
        that._columnsController.columnsChanged.add(updateItemsHandler);
      }
      if (isDefined(optionNames.visible)) {
        const column = that._columnsController.columnOption(e.columnIndex);
        if (column && (isDefined(column.filterValue) || isDefined(column.filterValues))) {
          that._applyFilter();
          filterApplied = true;
        }
      }
    }
    if (!filterApplied && changeTypes.filtering && !this._needApplyFilter) {
      that.reload();
    }
  }
  _handleDataChanged(e) {
    const that = this;
    const dataSource = that._dataSource;
    const columnsController = that._columnsController;
    let isAsyncDataSourceApplying = false;
    this._useSortingGroupingFromColumns = false;
    if (dataSource && !that._isDataSourceApplying) {
      that._isDataSourceApplying = true;
      when(that._columnsController.applyDataSource(dataSource)).done((() => {
        if (that._isLoading) {
          that._handleLoadingChanged(false);
        }
        if (isAsyncDataSourceApplying && e && e.isDelayed) {
          e.isDelayed = false;
        }
        that._isDataSourceApplying = false;
        const needApplyFilter = that._needApplyFilter;
        that._needApplyFilter = false;
        if (needApplyFilter && !that._isAllDataTypesDefined && (() => {
          const additionalFilter = that._calculateAdditionalFilter();
          return additionalFilter && additionalFilter.length;
        })()) {
          ui_errors_default.log("W1005", that.component.NAME);
          that._applyFilter();
        } else {
          that.updateItems(e, true);
        }
      })).fail((() => {
        that._isDataSourceApplying = false;
      }));
      if (that._isDataSourceApplying) {
        isAsyncDataSourceApplying = true;
        that._handleLoadingChanged(true);
      }
      that._needApplyFilter = !that._columnsController.isDataSourceApplied();
      that._isAllDataTypesDefined = columnsController.isAllDataTypesDefined();
    }
  }
  _handleLoadingChanged(isLoading) {
    this._isLoading = isLoading;
    this._fireLoadingChanged();
  }
  _handleLoadError(e) {
    this.dataErrorOccurred.fire(e);
  }
  _handleDataPushed(changes) {
    this.pushed.fire(changes);
  }
  fireError() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    this.dataErrorOccurred.fire(ui_errors_default.Error.apply(ui_errors_default, args));
  }
  _setPagingOptions(dataSource) {
    const pageIndex = this.option("paging.pageIndex");
    const pageSize = this.option("paging.pageSize");
    const pagingEnabled = this.option("paging.enabled");
    const scrollingMode = this.option("scrolling.mode");
    const appendMode = "infinite" === scrollingMode;
    const virtualMode = "virtual" === scrollingMode;
    const paginate = pagingEnabled || virtualMode || appendMode;
    let isPaginateChanged = false;
    let isPageSizeChanged = false;
    let isPageIndexChanged = false;
    dataSource.requireTotalCount(!appendMode);
    if (void 0 !== pagingEnabled && dataSource.paginate() !== paginate) {
      dataSource.paginate(paginate);
      isPaginateChanged = true;
    }
    if (void 0 !== pageSize && dataSource.pageSize() !== pageSize) {
      dataSource.pageSize(pageSize);
      isPageSizeChanged = true;
    }
    if (void 0 !== pageIndex && dataSource.pageIndex() !== pageIndex) {
      dataSource.pageIndex(pageIndex);
      isPageIndexChanged = true;
    }
    if (isPaginateChanged || isPageSizeChanged || isPageIndexChanged) {
      return {
        isPaginateChanged,
        isPageSizeChanged,
        isPageIndexChanged
      };
    }
    return false;
  }
  _getSpecificDataSourceOption() {
    const dataSource = this.option("dataSource");
    if (Array.isArray(dataSource)) {
      return {
        store: {
          type: "array",
          data: dataSource,
          key: this.option("keyExpr")
        }
      };
    }
    return dataSource;
  }
  _initDataSource() {
    const that = this;
    const oldDataSource = this._dataSource;
    super._initDataSource();
    const dataSource = that._dataSource;
    that._useSortingGroupingFromColumns = true;
    that._cachedProcessedItems = null;
    if (dataSource) {
      const changedPagingOptions = that._setPagingOptions(dataSource);
      this._isPaging = null === changedPagingOptions || void 0 === changedPagingOptions ? void 0 : changedPagingOptions.isPageIndexChanged;
      that.setDataSource(dataSource);
    } else if (oldDataSource) {
      that.updateItems();
    }
  }
  _loadDataSource() {
    const that = this;
    const dataSource = that._dataSource;
    const result = new Deferred();
    when(this._columnsController.refresh(true)).always((() => {
      if (dataSource) {
        dataSource.load().done((function() {
          that._isPaging = false;
          result.resolve.apply(result, arguments);
        })).fail(result.reject);
      } else {
        result.resolve();
      }
    }));
    return result.promise();
  }
  _beforeProcessItems(items) {
    return items.slice(0);
  }
  getRowIndexDelta() {
    return 0;
  }
  getDataIndex(change) {
    const visibleItems = this._items;
    const lastVisibleItem = "append" === change.changeType && visibleItems.length > 0 ? visibleItems[visibleItems.length - 1] : null;
    return isDefined(null === lastVisibleItem || void 0 === lastVisibleItem ? void 0 : lastVisibleItem.dataIndex) ? lastVisibleItem.dataIndex + 1 : 0;
  }
  _processItems(items, change) {
    const that = this;
    const rowIndexDelta = that.getRowIndexDelta();
    const {
      changeType
    } = change;
    const visibleColumns = that._columnsController.getVisibleColumns(null, "loadingAll" === changeType);
    const dataIndex = this.getDataIndex(change);
    const options = {
      visibleColumns,
      dataIndex
    };
    const result = [];
    each(items, ((index, item) => {
      if (isDefined(item)) {
        options.rowIndex = index - rowIndexDelta;
        item = that._processItem(item, options);
        result.push(item);
      }
    }));
    return result;
  }
  _processItem(item, options) {
    item = this._generateDataItem(item, options);
    item = this._processDataItem(item, options);
    item.dataIndex = options.dataIndex++;
    return item;
  }
  _generateDataItem(data17, options) {
    return {
      rowType: "data",
      data: data17,
      key: this.keyOf(data17)
    };
  }
  _processDataItem(dataItem, options) {
    dataItem.values = this.generateDataValues(dataItem.data, options.visibleColumns);
    return dataItem;
  }
  generateDataValues(data17, columns7, isModified) {
    const values = [];
    let value2;
    for (let i = 0; i < columns7.length; i++) {
      const column = columns7[i];
      value2 = isModified ? void 0 : null;
      if (!column.command) {
        if (column.calculateCellValue) {
          value2 = column.calculateCellValue(data17);
        } else if (column.dataField) {
          value2 = data17[column.dataField];
        }
      }
      values.push(value2);
    }
    return values;
  }
  _applyChange(change) {
    const that = this;
    if ("update" === change.changeType) {
      that._applyChangeUpdate(change);
    } else if (that.items().length && change.repaintChangesOnly && "refresh" === change.changeType) {
      that._applyChangesOnly(change);
    } else if ("refresh" === change.changeType) {
      that._applyChangeFull(change);
    }
  }
  _applyChangeFull(change) {
    this._items = change.items.slice(0);
  }
  _getRowIndices(change) {
    const rowIndices = change.rowIndices.slice(0);
    const rowIndexDelta = this.getRowIndexDelta();
    rowIndices.sort(((a, b) => a - b));
    for (let i = 0; i < rowIndices.length; i++) {
      let correctedRowIndex = rowIndices[i];
      if (change.allowInvisibleRowIndices) {
        correctedRowIndex += rowIndexDelta;
      }
      if (correctedRowIndex < 0) {
        rowIndices.splice(i, 1);
        i--;
      }
    }
    return rowIndices;
  }
  _applyChangeUpdate(change) {
    const that = this;
    const {
      items
    } = change;
    const rowIndices = that._getRowIndices(change);
    const rowIndexDelta = that.getRowIndexDelta();
    const repaintChangesOnly = that.option("repaintChangesOnly");
    let prevIndex = -1;
    let rowIndexCorrection = 0;
    let changeType;
    change.items = [];
    change.rowIndices = [];
    change.columnIndices = [];
    change.changeTypes = [];
    const equalItems = function(item1, item2, strict) {
      let result = item1 && item2 && equalByValue(item1.key, item2.key);
      if (result && strict) {
        result = item1.rowType === item2.rowType && ("detail" !== item2.rowType || item1.isEditing === item2.isEditing);
      }
      return result;
    };
    each(rowIndices, ((index, rowIndex) => {
      let columnIndices;
      rowIndex += rowIndexCorrection + rowIndexDelta;
      if (prevIndex === rowIndex) {
        return;
      }
      prevIndex = rowIndex;
      const oldItem = that._items[rowIndex];
      const oldNextItem = that._items[rowIndex + 1];
      const newItem = items[rowIndex];
      const newNextItem = items[rowIndex + 1];
      const strict = equalItems(oldItem, oldNextItem) || equalItems(newItem, newNextItem);
      if (newItem) {
        newItem.rowIndex = rowIndex;
        change.items.push(newItem);
      }
      if (oldItem && newItem && equalItems(oldItem, newItem, strict)) {
        changeType = "update";
        that._items[rowIndex] = newItem;
        if (oldItem.visible !== newItem.visible) {
          change.items.splice(-1, 1, {
            visible: newItem.visible
          });
        } else if (repaintChangesOnly && !change.isFullUpdate) {
          columnIndices = that._partialUpdateRow(oldItem, newItem, rowIndex - rowIndexDelta);
        }
      } else if (newItem && !oldItem || newNextItem && equalItems(oldItem, newNextItem, strict)) {
        changeType = "insert";
        that._items.splice(rowIndex, 0, newItem);
        rowIndexCorrection++;
      } else if (oldItem && !newItem || oldNextItem && equalItems(newItem, oldNextItem, strict)) {
        changeType = "remove";
        that._items.splice(rowIndex, 1);
        rowIndexCorrection--;
        prevIndex = -1;
      } else if (newItem) {
        changeType = "update";
        that._items[rowIndex] = newItem;
      } else {
        return;
      }
      change.rowIndices.push(rowIndex - rowIndexDelta);
      change.changeTypes.push(changeType);
      change.columnIndices.push(columnIndices);
    }));
  }
  _isCellChanged(oldRow, newRow, visibleRowIndex, columnIndex, isLiveUpdate) {
    if (JSON.stringify(oldRow.values[columnIndex]) !== JSON.stringify(newRow.values[columnIndex])) {
      return true;
    }
    function isCellModified(row, columnIndex2) {
      return row.modifiedValues ? void 0 !== row.modifiedValues[columnIndex2] : false;
    }
    if (isCellModified(oldRow, columnIndex) !== isCellModified(newRow, columnIndex)) {
      return true;
    }
    return false;
  }
  _getChangedColumnIndices(oldItem, newItem, visibleRowIndex, isLiveUpdate) {
    let columnIndices;
    if (oldItem.rowType === newItem.rowType) {
      if ("group" !== newItem.rowType && "groupFooter" !== newItem.rowType) {
        columnIndices = [];
        if ("detail" !== newItem.rowType) {
          for (let columnIndex = 0; columnIndex < oldItem.values.length; columnIndex++) {
            if (this._isCellChanged(oldItem, newItem, visibleRowIndex, columnIndex, isLiveUpdate)) {
              columnIndices.push(columnIndex);
            }
          }
        }
      }
      if ("group" === newItem.rowType && oldItem.cells) {
        const isRowStateEquals = newItem.isExpanded === oldItem.isExpanded && newItem.data.isContinuation === oldItem.data.isContinuation && newItem.data.isContinuationOnNextPage === oldItem.data.isContinuationOnNextPage;
        if (isRowStateEquals) {
          columnIndices = oldItem.cells.map(((cell, index) => {
            var _cell$column;
            return "groupExpand" !== (null === (_cell$column = cell.column) || void 0 === _cell$column ? void 0 : _cell$column.type) ? index : -1;
          })).filter(((index) => index >= 0));
        }
      }
    }
    return columnIndices;
  }
  _partialUpdateRow(oldItem, newItem, visibleRowIndex, isLiveUpdate) {
    var _changedColumnIndices;
    let changedColumnIndices = this._getChangedColumnIndices(oldItem, newItem, visibleRowIndex, isLiveUpdate);
    if (null !== (_changedColumnIndices = changedColumnIndices) && void 0 !== _changedColumnIndices && _changedColumnIndices.length && this.option("dataRowTemplate")) {
      changedColumnIndices = void 0;
    }
    if (changedColumnIndices) {
      oldItem.cells && oldItem.cells.forEach(((cell, columnIndex) => {
        const isCellChanged = changedColumnIndices.indexOf(columnIndex) >= 0;
        if (!isCellChanged && cell && cell.update) {
          cell.update(newItem);
        }
      }));
      newItem.update = oldItem.update;
      newItem.watch = oldItem.watch;
      newItem.cells = oldItem.cells;
      if (isLiveUpdate) {
        newItem.oldValues = oldItem.values;
      }
      oldItem.update && oldItem.update(newItem);
    }
    return changedColumnIndices;
  }
  _isItemEquals(item1, item2) {
    if (JSON.stringify(item1.values) !== JSON.stringify(item2.values)) {
      return false;
    }
    if (["modified", "isNewRow", "removed", "isEditing"].some(((field) => item1[field] !== item2[field]))) {
      return false;
    }
    if ("group" === item1.rowType || "groupFooter" === item1.rowType) {
      var _item1$data, _item2$data, _item1$data2, _item2$data2;
      const expandedMatch = item1.isExpanded === item2.isExpanded;
      const summaryCellsMatch = JSON.stringify(item1.summaryCells) === JSON.stringify(item2.summaryCells);
      const continuationMatch = (null === (_item1$data = item1.data) || void 0 === _item1$data ? void 0 : _item1$data.isContinuation) === (null === (_item2$data = item2.data) || void 0 === _item2$data ? void 0 : _item2$data.isContinuation) && (null === (_item1$data2 = item1.data) || void 0 === _item1$data2 ? void 0 : _item1$data2.isContinuationOnNextPage) === (null === (_item2$data2 = item2.data) || void 0 === _item2$data2 ? void 0 : _item2$data2.isContinuationOnNextPage);
      if (!expandedMatch || !summaryCellsMatch || !continuationMatch) {
        return false;
      }
    }
    return true;
  }
  _applyChangesOnly(change) {
    const rowIndices = [];
    const columnIndices = [];
    const changeTypes = [];
    const items = [];
    const newIndexByKey = {};
    const isLiveUpdate = (null === change || void 0 === change ? void 0 : change.isLiveUpdate) ?? true;
    function getRowKey(row) {
      if (row) {
        return `${row.rowType},${JSON.stringify(row.key)}`;
      }
      return;
    }
    const currentItems = this._items;
    const oldItems = currentItems.slice();
    change.items.forEach(((item, index) => {
      const key = getRowKey(item);
      newIndexByKey[key] = index;
      item.rowIndex = index;
    }));
    const result = findChanges({
      oldItems,
      newItems: change.items,
      getKey: getRowKey,
      isItemEquals: (item1, item2) => {
        if (!this._isItemEquals(item1, item2)) {
          return false;
        }
        if (item1.cells) {
          item1.update && item1.update(item2);
          item1.cells.forEach(((cell) => {
            if (cell && cell.update) {
              cell.update(item2, true);
            }
          }));
        }
        return true;
      }
    });
    if (!result) {
      this._applyChangeFull(change);
      return;
    }
    result.forEach(((change2) => {
      switch (change2.type) {
        case "update": {
          const {
            index
          } = change2;
          const newItem = change2.data;
          const {
            oldItem
          } = change2;
          const changedColumnIndices = this._partialUpdateRow(oldItem, newItem, index, isLiveUpdate);
          rowIndices.push(index);
          changeTypes.push("update");
          items.push(newItem);
          currentItems[index] = newItem;
          columnIndices.push(changedColumnIndices);
          break;
        }
        case "insert":
          rowIndices.push(change2.index);
          changeTypes.push("insert");
          items.push(change2.data);
          columnIndices.push(void 0);
          currentItems.splice(change2.index, 0, change2.data);
          break;
        case "remove":
          rowIndices.push(change2.index);
          changeTypes.push("remove");
          currentItems.splice(change2.index, 1);
          items.push(change2.oldItem);
          columnIndices.push(void 0);
      }
    }));
    change.repaintChangesOnly = true;
    change.changeType = "update";
    change.rowIndices = rowIndices;
    change.columnIndices = columnIndices;
    change.changeTypes = changeTypes;
    change.items = items;
    if (oldItems.length) {
      change.isLiveUpdate = true;
    }
    this._correctRowIndices(((rowIndex) => {
      const oldRowIndexOffset = this._rowIndexOffset || 0;
      const rowIndexOffset = this.getRowIndexOffset();
      const oldItem = oldItems[rowIndex - oldRowIndexOffset];
      const key = getRowKey(oldItem);
      const newVisibleRowIndex = newIndexByKey[key];
      return newVisibleRowIndex >= 0 ? newVisibleRowIndex + rowIndexOffset - rowIndex : 0;
    }));
  }
  _correctRowIndices(rowIndex) {
  }
  _afterProcessItems(items, change) {
    return items;
  }
  _updateItemsCore(change) {
    let items;
    const dataSource = this._dataSource;
    const changeType = change.changeType || "refresh";
    change.changeType = changeType;
    if (dataSource) {
      const cachedProcessedItems = this._cachedProcessedItems;
      if (change.useProcessedItemsCache && cachedProcessedItems) {
        items = cachedProcessedItems;
      } else {
        items = change.items || dataSource.items();
        items = this._beforeProcessItems(items);
        items = this._processItems(items, change);
        this._cachedProcessedItems = items;
      }
      items = this._afterProcessItems(items, change);
      change.items = items;
      const oldItems = this._items.length === items.length && this._items;
      this._applyChange(change);
      const rowIndexDelta = this.getRowIndexDelta();
      each(this._items, ((index, item) => {
        item.rowIndex = index - rowIndexDelta;
        if (oldItems) {
          item.cells = oldItems[index].cells ?? [];
        }
        const newItem = items[index];
        if (newItem) {
          item.loadIndex = newItem.loadIndex;
        }
      }));
      this._rowIndexOffset = this.getRowIndexOffset();
    } else {
      this._items = [];
    }
  }
  _handleChanging(e) {
    const rows = this.getVisibleRows();
    const dataSource = this.dataSource();
    if (dataSource) {
      e.changes.forEach(((change) => {
        if ("insert" === change.type && change.index >= 0) {
          let dataIndex = 0;
          for (let i = 0; i < change.index; i++) {
            const row = rows[i];
            if (row && ("data" === row.rowType || "group" === row.rowType)) {
              dataIndex++;
            }
          }
          change.index = dataIndex;
        }
      }));
    }
  }
  updateItems(change, isDataChanged) {
    change = change || {};
    const that = this;
    change.isFirstRender = !that.changed.fired();
    if (void 0 !== that._repaintChangesOnly) {
      change.repaintChangesOnly = change.repaintChangesOnly ?? that._repaintChangesOnly;
      change.needUpdateDimensions = change.needUpdateDimensions || that._needUpdateDimensions;
    } else if (change.changes) {
      change.repaintChangesOnly = that.option("repaintChangesOnly");
    } else if (isDataChanged) {
      const operationTypes = that.dataSource().operationTypes();
      change.repaintChangesOnly = operationTypes && !operationTypes.grouping && !operationTypes.filtering && that.option("repaintChangesOnly");
      change.isDataChanged = true;
      if (operationTypes && (operationTypes.reload || operationTypes.paging || operationTypes.groupExpanding)) {
        change.needUpdateDimensions = true;
      }
    }
    if (that._updateLockCount && !change.cancel) {
      that._changes.push(change);
      return;
    }
    that._updateItemsCore(change);
    if (change.cancel) {
      return;
    }
    that._fireChanged(change);
  }
  loadingOperationTypes() {
    const dataSource = this.dataSource();
    return dataSource && dataSource.loadingOperationTypes() || {};
  }
  _fireChanged(change) {
    if (this._currentOperationTypes) {
      change.operationTypes = this._currentOperationTypes;
      this._currentOperationTypes = null;
    }
    deferRender((() => {
      this.changed.fire(change);
    }));
  }
  isLoading() {
    return this._isLoading || this._isCustomLoading;
  }
  _fireLoadingChanged() {
    this.loadingChanged.fire(this.isLoading(), this._loadingText);
  }
  _calculateAdditionalFilter() {
    return null;
  }
  _applyFilter() {
    const dataSource = this._dataSource;
    if (dataSource) {
      dataSource.pageIndex(0);
      this._isFilterApplying = true;
      return this.reload().done((() => {
        if (this._isFilterApplying) {
          this.pageChanged.fire();
        }
      }));
    }
    return new Deferred().resolve();
  }
  resetFilterApplying() {
    this._isFilterApplying = false;
  }
  filter(filterExpr) {
    var _dataSource$loadOptio;
    const dataSource = this._dataSource;
    const filter = null === dataSource || void 0 === dataSource ? void 0 : dataSource.filter();
    const langParams = null === dataSource || void 0 === dataSource || null === (_dataSource$loadOptio = dataSource.loadOptions) || void 0 === _dataSource$loadOptio || null === (_dataSource$loadOptio = _dataSource$loadOptio.call(dataSource)) || void 0 === _dataSource$loadOptio ? void 0 : _dataSource$loadOptio.langParams;
    if (0 === arguments.length) {
      return filter;
    }
    filterExpr = arguments.length > 1 ? Array.prototype.slice.call(arguments, 0) : filterExpr;
    if (m_utils_default.equalFilterParameters(filter, filterExpr, langParams)) {
      return;
    }
    if (dataSource) {
      dataSource.filter(filterExpr);
    }
    this._applyFilter();
  }
  clearFilter(filterName) {
    const that = this;
    const columnsController = that._columnsController;
    const clearColumnOption = function(optionName) {
      const columnCount = columnsController.columnCount();
      for (let index = 0; index < columnCount; index++) {
        columnsController.columnOption(index, optionName, void 0);
      }
    };
    that.component.beginUpdate();
    if (arguments.length > 0) {
      switch (filterName) {
        case "dataSource":
          that.filter(null);
          break;
        case "search":
          that.searchByText("");
          break;
        case "header":
          clearColumnOption("filterValues");
          break;
        case "row":
          clearColumnOption("filterValue");
      }
    } else {
      that.filter(null);
      that.searchByText("");
      clearColumnOption("filterValue");
      clearColumnOption("bufferedFilterValue");
      clearColumnOption("filterValues");
    }
    that.component.endUpdate();
  }
  _fireDataSourceChanged() {
    const that = this;
    const changedHandler = function() {
      that.changed.remove(changedHandler);
      that.dataSourceChanged.fire();
    };
    that.changed.add(changedHandler);
  }
  _getDataSourceAdapter() {
  }
  _createDataSourceAdapterCore(dataSource, remoteOperations) {
    const dataSourceAdapterProvider = this._getDataSourceAdapter();
    const dataSourceAdapter = dataSourceAdapterProvider.create(this.component);
    dataSourceAdapter.init(dataSource, remoteOperations);
    return dataSourceAdapter;
  }
  isLocalStore() {
    let store = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.store();
    return store instanceof m_array_store_default;
  }
  isCustomStore(store) {
    store = store || this.store();
    return store instanceof m_custom_store_default;
  }
  _createDataSourceAdapter(dataSource) {
    let remoteOperations = this.option("remoteOperations");
    const store = dataSource.store();
    const enabledRemoteOperations = {
      filtering: true,
      sorting: true,
      paging: true,
      grouping: true,
      summary: true
    };
    if (isObject(remoteOperations) && remoteOperations.groupPaging) {
      remoteOperations = extend({}, enabledRemoteOperations, remoteOperations);
    }
    if ("auto" === remoteOperations) {
      remoteOperations = this.isLocalStore(store) || this.isCustomStore(store) ? {} : {
        filtering: true,
        sorting: true,
        paging: true
      };
    }
    if (true === remoteOperations) {
      remoteOperations = enabledRemoteOperations;
    }
    return this._createDataSourceAdapterCore(dataSource, remoteOperations);
  }
  setDataSource(dataSource) {
    const that = this;
    const oldDataSource = that._dataSource;
    if (!dataSource && oldDataSource) {
      oldDataSource.cancelAll();
      oldDataSource.changed.remove(that._dataChangedHandler);
      oldDataSource.loadingChanged.remove(that._loadingChangedHandler);
      oldDataSource.loadError.remove(that._loadErrorHandler);
      oldDataSource.customizeStoreLoadOptions.remove(that._customizeStoreLoadOptionsHandler);
      oldDataSource.changing.remove(that._changingHandler);
      oldDataSource.pushed.remove(that._dataPushedHandler);
      oldDataSource.dispose(that._isSharedDataSource);
    }
    if (dataSource) {
      dataSource = that._createDataSourceAdapter(dataSource);
    }
    that._dataSource = dataSource;
    if (dataSource) {
      that._fireDataSourceChanged();
      that._isLoading = !dataSource.isLoaded();
      that._needApplyFilter = true;
      that._isAllDataTypesDefined = that._columnsController.isAllDataTypesDefined();
      dataSource.changed.add(that._dataChangedHandler);
      dataSource.loadingChanged.add(that._loadingChangedHandler);
      dataSource.loadError.add(that._loadErrorHandler);
      dataSource.customizeStoreLoadOptions.add(that._customizeStoreLoadOptionsHandler);
      dataSource.changing.add(that._changingHandler);
      dataSource.pushed.add(that._dataPushedHandler);
    }
  }
  items(byLoaded) {
    return this._items;
  }
  isEmpty() {
    return !this.items().length;
  }
  pageCount() {
    return this._dataSource ? this._dataSource.pageCount() : 1;
  }
  dataSource() {
    return this._dataSource;
  }
  store() {
    const dataSource = this._dataSource;
    return dataSource && dataSource.store();
  }
  loadAll(data17) {
    let skipFilter = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;
    const that = this;
    const d = new Deferred();
    const dataSource = that._dataSource;
    if (dataSource) {
      if (data17) {
        const options = {
          data: data17,
          isCustomLoading: true,
          storeLoadOptions: {
            isLoadingAll: true
          },
          loadOptions: {
            filter: skipFilter ? null : that.getCombinedFilter(),
            group: dataSource.group(),
            sort: dataSource.sort()
          }
        };
        dataSource._handleDataLoaded(options);
        when(options.data).done(((data18) => {
          var _options$extra;
          data18 = that._beforeProcessItems(data18);
          d.resolve(that._processItems(data18, {
            changeType: "loadingAll"
          }), null === (_options$extra = options.extra) || void 0 === _options$extra ? void 0 : _options$extra.summary);
        })).fail(d.reject);
      } else if (!dataSource.isLoading()) {
        const loadOptions = extend({}, dataSource.loadOptions(), {
          isLoadingAll: true,
          requireTotalCount: false
        });
        dataSource.load(loadOptions).done(((items, extra) => {
          items = that._beforeProcessItems(items);
          items = that._processItems(items, {
            changeType: "loadingAll"
          });
          d.resolve(items, extra && extra.summary);
        })).fail(d.reject);
      } else {
        d.reject();
      }
    } else {
      d.resolve([]);
    }
    return d;
  }
  getKeyByRowIndex(rowIndex, byLoaded) {
    const item = this.items(byLoaded)[rowIndex];
    if (item) {
      return item.key;
    }
  }
  getRowIndexByKey(key, byLoaded) {
    return m_utils_default.getIndexByKey(key, this.items(byLoaded));
  }
  getRowByKey(key) {
    var _this$items;
    return null === (_this$items = this.items()) || void 0 === _this$items ? void 0 : _this$items[this.getRowIndexByKey(key)];
  }
  keyOf(data17) {
    const store = this.store();
    if (store) {
      return store.keyOf(data17);
    }
  }
  byKey(key) {
    const store = this.store();
    const rowIndex = this.getRowIndexByKey(key);
    let result;
    if (!store) {
      return;
    }
    if (rowIndex >= 0) {
      result = new Deferred().resolve(this.items()[rowIndex].data);
    }
    return result || store.byKey(key);
  }
  key() {
    const store = this.store();
    if (store) {
      return store.key();
    }
  }
  getRowIndexOffset(byLoadedRows) {
    return 0;
  }
  getDataByKeys(rowKeys) {
    const that = this;
    const result = new Deferred();
    const deferreds = [];
    const data17 = [];
    each(rowKeys, ((index, key) => {
      deferreds.push(that.byKey(key).done(((keyData) => {
        data17[index] = keyData;
      })));
    }));
    when.apply(renderer_default, deferreds).always((() => {
      result.resolve(data17);
    }));
    return result;
  }
  pageIndex(value2) {
    return changePaging(this, "pageIndex", value2);
  }
  pageSize(value2) {
    return changePaging(this, "pageSize", value2);
  }
  beginCustomLoading(messageText) {
    this._isCustomLoading = true;
    this._loadingText = messageText || "";
    this._fireLoadingChanged();
  }
  endCustomLoading() {
    this._isCustomLoading = false;
    this._loadingText = void 0;
    this._fireLoadingChanged();
  }
  refresh(options) {
    if (true === options) {
      options = {
        reload: true,
        changesOnly: true
      };
    } else if (!options) {
      options = {
        reload: true,
        lookup: true
      };
    }
    const that = this;
    const dataSource = that.getDataSource();
    const {
      changesOnly
    } = options;
    const d = new Deferred();
    const customizeLoadResult = function() {
      that._repaintChangesOnly = !!changesOnly;
    };
    when(!options.lookup || that._columnsController.refresh()).always((() => {
      if (options.load || options.reload) {
        dataSource && dataSource.on("customizeLoadResult", customizeLoadResult);
        when(that.reload(options.reload, changesOnly)).always((() => {
          dataSource && dataSource.off("customizeLoadResult", customizeLoadResult);
          that._repaintChangesOnly = void 0;
        })).done(d.resolve).fail(d.reject);
      } else {
        that.updateItems({
          repaintChangesOnly: options.changesOnly
        });
        d.resolve();
      }
    }));
    return d.promise();
  }
  getVisibleRows() {
    return this.items();
  }
  _disposeDataSource() {
    if (this._dataSource && this._dataSource._eventsStrategy) {
      this._dataSource._eventsStrategy.off("loadingChanged", this.readyWatcher);
    }
    this.setDataSource(null);
  }
  dispose() {
    this._disposeDataSource();
    super.dispose();
  }
  repaintRows(rowIndexes, changesOnly) {
    rowIndexes = Array.isArray(rowIndexes) ? rowIndexes : [rowIndexes];
    if (rowIndexes.length > 1 || isDefined(rowIndexes[0])) {
      this.updateItems({
        changeType: "update",
        rowIndices: rowIndexes,
        isFullUpdate: !changesOnly
      });
    }
  }
  skipProcessingPagingChange(fullName) {
    return this._skipProcessingPagingChange && ("paging.pageIndex" === fullName || "paging.pageSize" === fullName);
  }
  getUserState() {
    return {
      searchText: this.option("searchPanel.text"),
      pageIndex: this.pageIndex(),
      pageSize: this.pageSize()
    };
  }
  getCachedStoreData() {
    return this._dataSource && this._dataSource.getCachedStoreData();
  }
  isLastPageLoaded() {
    const pageIndex = this.pageIndex();
    const pageCount = this.pageCount();
    return pageIndex === pageCount - 1;
  }
  load() {
    var _this$_dataSource;
    return null === (_this$_dataSource = this._dataSource) || void 0 === _this$_dataSource ? void 0 : _this$_dataSource.load();
  }
  reload(reload, changesOnly) {
    var _this$_dataSource2;
    return null === (_this$_dataSource2 = this._dataSource) || void 0 === _this$_dataSource2 ? void 0 : _this$_dataSource2.reload(reload, changesOnly);
  }
  push() {
    var _this$_dataSource3;
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return null === (_this$_dataSource3 = this._dataSource) || void 0 === _this$_dataSource3 ? void 0 : _this$_dataSource3.push(...args);
  }
  itemsCount() {
    var _this$_dataSource4;
    return this._dataSource ? null === (_this$_dataSource4 = this._dataSource) || void 0 === _this$_dataSource4 ? void 0 : _this$_dataSource4.itemsCount() : 0;
  }
  totalItemsCount() {
    var _this$_dataSource5;
    return this._dataSource ? null === (_this$_dataSource5 = this._dataSource) || void 0 === _this$_dataSource5 ? void 0 : _this$_dataSource5.totalItemsCount() : 0;
  }
  hasKnownLastPage() {
    var _this$_dataSource6;
    return this._dataSource ? null === (_this$_dataSource6 = this._dataSource) || void 0 === _this$_dataSource6 ? void 0 : _this$_dataSource6.hasKnownLastPage() : true;
  }
  isLoaded() {
    var _this$_dataSource7;
    return this._dataSource ? null === (_this$_dataSource7 = this._dataSource) || void 0 === _this$_dataSource7 ? void 0 : _this$_dataSource7.isLoaded() : true;
  }
  totalCount() {
    var _this$_dataSource8;
    return this._dataSource ? null === (_this$_dataSource8 = this._dataSource) || void 0 === _this$_dataSource8 ? void 0 : _this$_dataSource8.totalCount() : 0;
  }
  hasLoadOperation() {
    var _this$_dataSource9;
    const operationTypes = (null === (_this$_dataSource9 = this._dataSource) || void 0 === _this$_dataSource9 ? void 0 : _this$_dataSource9.operationTypes()) ?? {};
    return Object.keys(operationTypes).some(((type2) => operationTypes[type2]));
  }
};
var dataControllerModule = {
  defaultOptions: () => ({
    loadingTimeout: 0,
    dataSource: null,
    cacheEnabled: true,
    repaintChangesOnly: false,
    highlightChanges: false,
    onDataErrorOccurred: null,
    remoteOperations: "auto",
    paging: {
      enabled: true,
      pageSize: void 0,
      pageIndex: void 0
    }
  }),
  controllers: {
    data: DataController
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/data_source_adapter/m_data_source_adapter_utils.js
var cloneItems = function(items, groupCount) {
  if (items) {
    items = items.slice(0);
    if (groupCount) {
      for (let i = 0; i < items.length; i++) {
        items[i] = extend({
          key: items[i].key
        }, items[i]);
        items[i].items = cloneItems(items[i].items, groupCount - 1);
      }
    }
  }
  return items;
};
var calculateOperationTypes = function(loadOptions, lastLoadOptions, isFullReload) {
  let operationTypes = {
    reload: true,
    fullReload: true
  };
  if (lastLoadOptions) {
    operationTypes = {
      sorting: !m_utils_default.equalSortParameters(loadOptions.sort, lastLoadOptions.sort),
      grouping: !m_utils_default.equalSortParameters(loadOptions.group, lastLoadOptions.group, true),
      groupExpanding: !m_utils_default.equalSortParameters(loadOptions.group, lastLoadOptions.group) || lastLoadOptions.groupExpand,
      filtering: !m_utils_default.equalFilterParameters(loadOptions.filter, lastLoadOptions.filter, loadOptions.langParams),
      pageIndex: loadOptions.pageIndex !== lastLoadOptions.pageIndex,
      skip: loadOptions.skip !== lastLoadOptions.skip,
      take: loadOptions.take !== lastLoadOptions.take,
      pageSize: loadOptions.pageSize !== lastLoadOptions.pageSize,
      fullReload: isFullReload,
      reload: false,
      paging: false
    };
    operationTypes.reload = isFullReload || operationTypes.sorting || operationTypes.grouping || operationTypes.filtering;
    operationTypes.paging = operationTypes.pageIndex || operationTypes.pageSize || operationTypes.take;
  }
  return operationTypes;
};
var executeTask = function(action, timeout) {
  if (isDefined(timeout)) {
    m_common_default.executeAsync(action, timeout);
  } else {
    action();
  }
};
var createEmptyCachedData = function() {
  return {
    items: {}
  };
};
var getPageDataFromCache = function(options, updatePaging) {
  const groupCount = m_utils_default.normalizeSortingInfo(options.group || options.storeLoadOptions.group || options.loadOptions.group).length;
  const items = [];
  if (fillItemsFromCache(items, options, groupCount)) {
    return items;
  }
  if (updatePaging) {
    updatePagingOptionsByCache(items, options, groupCount);
  }
};
var fillItemsFromCache = function(items, options, groupCount, fromEnd) {
  var _options$cachedData;
  const {
    storeLoadOptions
  } = options;
  const take = options.take ?? storeLoadOptions.take ?? 0;
  const cachedItems = null === (_options$cachedData = options.cachedData) || void 0 === _options$cachedData ? void 0 : _options$cachedData.items;
  if (take && cachedItems) {
    const skip = options.skip ?? storeLoadOptions.skip ?? 0;
    for (let i = 0; i < take; i += 1) {
      const localIndex = fromEnd ? take - 1 - i : i;
      const cacheItemIndex = localIndex + skip;
      const cacheItem = cachedItems[cacheItemIndex];
      if (void 0 === cacheItem && cacheItemIndex in cachedItems) {
        return true;
      }
      const item = getItemFromCache(options, cacheItem, groupCount, localIndex, take);
      if (item) {
        items.push(item);
      } else {
        return false;
      }
    }
    return true;
  }
  return false;
};
var getItemFromCache = function(options, cacheItem, groupCount, index, take) {
  if (groupCount && cacheItem) {
    const skips = 0 === index && options.skips || [];
    const takes = index === take - 1 && options.takes || [];
    return getGroupItemFromCache(cacheItem, groupCount, skips, takes);
  }
  return cacheItem;
};
var getGroupItemFromCache = function(cacheItem, groupCount, skips, takes) {
  if (groupCount && cacheItem) {
    const result = _extends({}, cacheItem);
    const skip = skips[0] || 0;
    const take = takes[0];
    const {
      items
    } = cacheItem;
    if (items) {
      if (void 0 === take && !items[skip]) {
        return;
      }
      result.items = [];
      if (skips.length) {
        result.isContinuation = true;
      }
      if (take) {
        result.isContinuationOnNextPage = cacheItem.count > take;
      }
      for (let i = 0; void 0 === take ? items[i + skip] : i < take; i += 1) {
        const childCacheItem = items[i + skip];
        const isLast = i + 1 === take;
        const item = getGroupItemFromCache(childCacheItem, groupCount - 1, 0 === i ? skips.slice(1) : [], isLast ? takes.slice(1) : []);
        if (void 0 !== item) {
          result.items.push(item);
        } else {
          return;
        }
      }
    }
    return result;
  }
  return cacheItem;
};
var updatePagingOptionsByCache = function(cacheItemsFromBegin, options, groupCount) {
  const cacheItemBeginCount = cacheItemsFromBegin.length;
  const {
    storeLoadOptions
  } = options;
  if (void 0 !== storeLoadOptions.skip && storeLoadOptions.take && !groupCount) {
    const cacheItemsFromEnd = [];
    fillItemsFromCache(cacheItemsFromEnd, options, groupCount, true);
    const cacheItemEndCount = cacheItemsFromEnd.length;
    if (cacheItemBeginCount || cacheItemEndCount) {
      options.skip = options.skip ?? storeLoadOptions.skip;
      options.take = options.take ?? storeLoadOptions.take;
    }
    if (cacheItemBeginCount) {
      storeLoadOptions.skip += cacheItemBeginCount;
      storeLoadOptions.take -= cacheItemBeginCount;
      options.cachedDataPartBegin = cacheItemsFromBegin;
    }
    if (cacheItemEndCount) {
      storeLoadOptions.take -= cacheItemEndCount;
      options.cachedDataPartEnd = cacheItemsFromEnd.reverse();
    }
  }
};
var setPageDataToCache = function(options, data17, groupCount) {
  const {
    storeLoadOptions
  } = options;
  const skip = options.skip ?? storeLoadOptions.skip ?? 0;
  const take = options.take ?? storeLoadOptions.take ?? 0;
  for (let i = 0; i < take; i += 1) {
    const globalIndex = i + skip;
    const cacheItems = options.cachedData.items;
    const skips = 0 === i && options.skips || [];
    cacheItems[globalIndex] = getCacheItem(cacheItems[globalIndex], data17[i], groupCount, skips);
  }
};
var getCacheItem = function(cacheItem, loadedItem, groupCount, skips) {
  if (groupCount && loadedItem) {
    const result = _extends({}, loadedItem);
    delete result.isContinuation;
    delete result.isContinuationOnNextPage;
    const skip = skips[0] || 0;
    if (loadedItem.items) {
      result.items = (null === cacheItem || void 0 === cacheItem ? void 0 : cacheItem.items) || {};
      loadedItem.items.forEach(((item, index) => {
        const globalIndex = index + skip;
        const childSkips = 0 === index ? skips.slice(1) : [];
        result.items[globalIndex] = getCacheItem(result.items[globalIndex], item, groupCount - 1, childSkips);
      }));
    }
    return result;
  }
  return loadedItem;
};

// node_modules/devextreme/esm/__internal/grids/grid_core/data_source_adapter/m_data_source_adapter.js
var DataSourceAdapter = class extends m_modules_default.Controller {
  init(dataSource, remoteOperations) {
    const that = this;
    that._dataSource = dataSource;
    that._remoteOperations = remoteOperations || {};
    that._isLastPage = !dataSource.isLastPage();
    that._hasLastPage = false;
    that._currentTotalCount = 0;
    that._cachedData = createEmptyCachedData();
    that._lastOperationTypes = {};
    that._eventsStrategy = dataSource._eventsStrategy;
    that._totalCountCorrection = 0;
    that._isLoadingAll = false;
    that.changed = callbacks_default();
    that.loadingChanged = callbacks_default();
    that.loadError = callbacks_default();
    that.customizeStoreLoadOptions = callbacks_default();
    that.changing = callbacks_default();
    that.pushed = callbacks_default();
    that._dataChangedHandler = that._handleDataChanged.bind(that);
    that._customizeStoreLoadOptionsHandler = that._handleCustomizeStoreLoadOptions.bind(that);
    that._dataLoadedHandler = that._handleDataLoaded.bind(that);
    that._loadingChangedHandler = that._handleLoadingChanged.bind(that);
    that._loadErrorHandler = that._handleLoadError.bind(that);
    that._pushHandler = that._handlePush.bind(that);
    that._changingHandler = that._handleChanging.bind(that);
    dataSource.on("changed", that._dataChangedHandler);
    dataSource.on("customizeStoreLoadOptions", that._customizeStoreLoadOptionsHandler);
    dataSource.on("customizeLoadResult", that._dataLoadedHandler);
    dataSource.on("loadingChanged", that._loadingChangedHandler);
    dataSource.on("loadError", that._loadErrorHandler);
    dataSource.on("changing", that._changingHandler);
    dataSource.store().on("beforePush", that._pushHandler);
    each(dataSource, ((memberName, member) => {
      if (!that[memberName] && isFunction(member)) {
        that[memberName] = function() {
          return this._dataSource[memberName].apply(this._dataSource, arguments);
        };
      }
    }));
  }
  dispose(isSharedDataSource) {
    const dataSource = this._dataSource;
    const store = dataSource.store();
    dataSource.off("changed", this._dataChangedHandler);
    dataSource.off("customizeStoreLoadOptions", this._customizeStoreLoadOptionsHandler);
    dataSource.off("customizeLoadResult", this._dataLoadedHandler);
    dataSource.off("loadingChanged", this._loadingChangedHandler);
    dataSource.off("loadError", this._loadErrorHandler);
    dataSource.off("changing", this._changingHandler);
    store && store.off("beforePush", this._pushHandler);
    if (!isSharedDataSource) {
      dataSource.dispose();
    }
  }
  remoteOperations() {
    return this._remoteOperations;
  }
  refresh(options, operationTypes) {
    const that = this;
    const dataSource = that._dataSource;
    if (operationTypes.reload) {
      that.resetCurrentTotalCount();
      that._isLastPage = !dataSource.paginate();
      that._hasLastPage = that._isLastPage;
    }
  }
  resetCurrentTotalCount() {
    this._currentTotalCount = 0;
    this._totalCountCorrection = 0;
  }
  resetCache() {
    this._cachedStoreData = void 0;
    this._cachedPagingData = void 0;
  }
  resetPagesCache(isLiveUpdate) {
    this._cachedData = createEmptyCachedData();
  }
  _needClearStoreDataCache() {
    const remoteOperations = this.remoteOperations();
    const operationTypes = calculateOperationTypes(this._lastLoadOptions || {}, {});
    const isLocalOperations = Object.keys(remoteOperations).every(((operationName) => !operationTypes[operationName] || !remoteOperations[operationName]));
    return !isLocalOperations;
  }
  push(changes, fromStore) {
    const store = this.store();
    if (this._needClearStoreDataCache()) {
      this._cachedStoreData = void 0;
    }
    this._cachedPagingData = void 0;
    this.resetPagesCache(true);
    if (this._cachedStoreData) {
      applyBatch({
        keyInfo: store,
        data: this._cachedStoreData,
        changes
      });
    }
    if (!fromStore) {
      this._applyBatch(changes);
    }
    this.pushed.fire(changes);
  }
  getDataIndexGetter() {
    if (!this._dataIndexGetter) {
      let indexByKey;
      let storeData;
      const store = this.store();
      this._dataIndexGetter = (data17) => {
        const isCacheUpdated = storeData && storeData !== this._cachedStoreData;
        if (!indexByKey || isCacheUpdated) {
          storeData = this._cachedStoreData || [];
          indexByKey = {};
          for (let i = 0; i < storeData.length; i++) {
            indexByKey[getKeyHash(store.keyOf(storeData[i]))] = i;
          }
        }
        return indexByKey[getKeyHash(store.keyOf(data17))];
      };
    }
    return this._dataIndexGetter;
  }
  _getKeyInfo() {
    return this.store();
  }
  _needToCopyDataObject() {
    return true;
  }
  _applyBatch(changes, fromStore) {
    const keyInfo = this._getKeyInfo();
    const dataSource = this._dataSource;
    const groupCount = m_utils_default.normalizeSortingInfo(this.group()).length;
    const isReshapeMode = "reshape" === this.option("editing.refreshMode");
    const isVirtualMode3 = "virtual" === this.option("scrolling.mode");
    changes = changes.filter(((change) => !dataSource.paginate() || "insert" !== change.type || void 0 !== change.index));
    const getItemCount2 = () => groupCount ? this.itemsCount() : this.items().length;
    const oldItemCount = getItemCount2();
    applyBatch({
      keyInfo,
      data: this._items,
      changes,
      groupCount,
      useInsertIndex: true,
      skipCopying: !this._needToCopyDataObject()
    });
    applyBatch({
      keyInfo,
      data: dataSource.items(),
      changes,
      groupCount,
      useInsertIndex: true,
      skipCopying: !this._needToCopyDataObject()
    });
    const needUpdateTotalCountCorrection = this._currentTotalCount > 0 || (fromStore || !isReshapeMode) && isVirtualMode3;
    if (needUpdateTotalCountCorrection) {
      this._totalCountCorrection += getItemCount2() - oldItemCount;
    }
    changes.splice(0, changes.length);
  }
  _handlePush(_ref) {
    let {
      changes
    } = _ref;
    this.push(changes, true);
  }
  _handleChanging(e) {
    this.changing.fire(e);
    this._applyBatch(e.changes, true);
  }
  _needCleanCacheByOperation(operationType, remoteOperations) {
    const operationTypesByOrder = ["filtering", "sorting", "paging"];
    const operationTypeIndex = operationTypesByOrder.indexOf(operationType);
    const currentOperationTypes = operationTypeIndex >= 0 ? operationTypesByOrder.slice(operationTypeIndex) : [operationType];
    return currentOperationTypes.some(((operationType2) => remoteOperations[operationType2]));
  }
  _customizeRemoteOperations(options, operationTypes) {
    let cachedStoreData = this._cachedStoreData;
    let cachedPagingData = this._cachedPagingData;
    let cachedData = this._cachedData;
    if (options.storeLoadOptions.filter && !options.remoteOperations.filtering || options.storeLoadOptions.sort && !options.remoteOperations.sorting) {
      options.remoteOperations = {
        filtering: options.remoteOperations.filtering,
        summary: options.remoteOperations.summary
      };
    }
    if (operationTypes.fullReload) {
      cachedStoreData = void 0;
      cachedPagingData = void 0;
      cachedData = createEmptyCachedData();
    } else {
      if (operationTypes.reload) {
        cachedPagingData = void 0;
        cachedData = createEmptyCachedData();
      } else if (operationTypes.groupExpanding) {
        cachedData = createEmptyCachedData();
      }
      each(operationTypes, ((operationType, value2) => {
        if (value2 && this._needCleanCacheByOperation(operationType, options.remoteOperations)) {
          cachedStoreData = void 0;
          cachedPagingData = void 0;
        }
      }));
    }
    if (cachedPagingData) {
      options.remoteOperations.paging = false;
    }
    options.cachedStoreData = cachedStoreData;
    options.cachedPagingData = cachedPagingData;
    options.cachedData = cachedData;
    if (!options.isCustomLoading) {
      this._cachedStoreData = cachedStoreData;
      this._cachedPagingData = cachedPagingData;
      this._cachedData = cachedData;
    }
  }
  _handleCustomizeStoreLoadOptions(options) {
    var _options$data;
    this._handleDataLoading(options);
    if (!(0 === (null === (_options$data = options.data) || void 0 === _options$data ? void 0 : _options$data.length))) {
      options.data = getPageDataFromCache(options, true) || options.cachedStoreData;
    }
  }
  _handleDataLoading(options) {
    const dataSource = this._dataSource;
    const lastLoadOptions = this._lastLoadOptions;
    this.customizeStoreLoadOptions.fire(options);
    options.delay = this.option("loadingTimeout");
    options.originalStoreLoadOptions = options.storeLoadOptions;
    options.remoteOperations = extend({}, this.remoteOperations());
    const isFullReload = !this.isLoaded() && !this._isRefreshing;
    if (this.option("integrationOptions.renderedOnServer") && !this.isLoaded()) {
      options.delay = void 0;
    }
    const loadOptions = extend({
      pageIndex: this.pageIndex(),
      pageSize: this.pageSize()
    }, options.storeLoadOptions);
    const operationTypes = calculateOperationTypes(loadOptions, lastLoadOptions, isFullReload);
    this._customizeRemoteOperations(options, operationTypes);
    if (!options.isCustomLoading) {
      const isRefreshing = this._isRefreshing;
      options.pageIndex = dataSource.pageIndex();
      options.lastLoadOptions = loadOptions;
      options.operationTypes = operationTypes;
      this._loadingOperationTypes = operationTypes;
      this._isRefreshing = true;
      when(isRefreshing || this._isRefreshed || this.refresh(options, operationTypes)).done((() => {
        if (this._lastOperationId === options.operationId) {
          this._isRefreshed = true;
          this.load().always((() => {
            this._isRefreshed = false;
          }));
        }
      })).fail((() => {
        dataSource.cancel(options.operationId);
      })).always((() => {
        this._isRefreshing = false;
      }));
      dataSource.cancel(this._lastOperationId);
      this._lastOperationId = options.operationId;
      if (this._isRefreshing) {
        dataSource.cancel(this._lastOperationId);
      }
    }
    this._handleDataLoadingCore(options);
  }
  _handleDataLoadingCore(options) {
    const {
      remoteOperations
    } = options;
    options.loadOptions = {};
    const cachedExtra = options.cachedData.extra;
    const localLoadOptionNames = {
      filter: !remoteOperations.filtering,
      sort: !remoteOperations.sorting,
      group: !remoteOperations.grouping,
      summary: !remoteOperations.summary,
      skip: !remoteOperations.paging,
      take: !remoteOperations.paging,
      requireTotalCount: cachedExtra && "totalCount" in cachedExtra || !remoteOperations.paging,
      langParams: !remoteOperations.filtering || !remoteOperations.sorting
    };
    each(options.storeLoadOptions, ((optionName, optionValue) => {
      if (localLoadOptionNames[optionName]) {
        options.loadOptions[optionName] = optionValue;
        delete options.storeLoadOptions[optionName];
      }
    }));
    if (cachedExtra) {
      options.extra = cachedExtra;
    }
  }
  _handleDataLoaded(options) {
    const {
      loadOptions
    } = options;
    const localPaging = options.remoteOperations && !options.remoteOperations.paging;
    const {
      cachedData
    } = options;
    const {
      storeLoadOptions
    } = options;
    const needCache = false !== this.option("cacheEnabled") && storeLoadOptions;
    const needPageCache = needCache && !options.isCustomLoading && cachedData && (!localPaging || storeLoadOptions.group);
    const needPagingCache = needCache && localPaging;
    const needStoreCache = needPagingCache && !options.isCustomLoading;
    if (!loadOptions) {
      this._dataSource.cancel(options.operationId);
      return;
    }
    if (localPaging) {
      options.skip = loadOptions.skip;
      options.take = loadOptions.take;
      delete loadOptions.skip;
      delete loadOptions.take;
    }
    if (loadOptions.group) {
      loadOptions.group = options.group || loadOptions.group;
    }
    const groupCount = m_utils_default.normalizeSortingInfo(options.group || storeLoadOptions.group || loadOptions.group).length;
    if (options.cachedDataPartBegin) {
      options.data = options.cachedDataPartBegin.concat(options.data);
    }
    if (options.cachedDataPartEnd) {
      options.data = options.data.concat(options.cachedDataPartEnd);
    }
    if (!needPageCache || !getPageDataFromCache(options)) {
      var _options$extra;
      if (needPagingCache && options.cachedPagingData) {
        options.data = cloneItems(options.cachedPagingData, groupCount);
      } else {
        if (needStoreCache) {
          if (!this._cachedStoreData) {
            this._cachedStoreData = cloneItems(options.data, m_utils_default.normalizeSortingInfo(storeLoadOptions.group).length);
          } else if (options.mergeStoreLoadData) {
            options.data = this._cachedStoreData = this._cachedStoreData.concat(options.data);
          }
        }
        new m_array_store_default(options.data).load(loadOptions).done(((data17) => {
          options.data = data17;
          if (needStoreCache) {
            this._cachedPagingData = cloneItems(options.data, groupCount);
          }
        })).fail(((error) => {
          options.data = new Deferred().reject(error);
        }));
      }
      if (loadOptions.requireTotalCount && localPaging) {
        options.extra = isPlainObject(options.extra) ? options.extra : {};
        options.extra.totalCount = options.data.length;
      }
      if (options.extra && options.extra.totalCount >= 0 && (false === storeLoadOptions.requireTotalCount || false === loadOptions.requireTotalCount)) {
        options.extra.totalCount = -1;
      }
      if (!loadOptions.data && (storeLoadOptions.requireTotalCount || ((null === (_options$extra = options.extra) || void 0 === _options$extra ? void 0 : _options$extra.totalCount) ?? -1) >= 0)) {
        this._totalCountCorrection = 0;
      }
      this._handleDataLoadedCore(options);
      if (needPageCache) {
        cachedData.extra = cachedData.extra || extend({}, options.extra);
        when(options.data).done(((data17) => {
          setPageDataToCache(options, data17, groupCount);
        }));
      }
    }
    when(options.data).done((() => {
      if (options.lastLoadOptions) {
        this._lastLoadOptions = options.lastLoadOptions;
        Object.keys(options.operationTypes).forEach(((operationType) => {
          this._lastOperationTypes[operationType] = this._lastOperationTypes[operationType] || options.operationTypes[operationType];
        }));
      }
    }));
    options.storeLoadOptions = options.originalStoreLoadOptions;
  }
  _handleDataLoadedCore(options) {
    if (options.remoteOperations && !options.remoteOperations.paging && Array.isArray(options.data)) {
      if (void 0 !== options.skip) {
        options.data = options.data.slice(options.skip);
      }
      if (void 0 !== options.take) {
        options.data = options.data.slice(0, options.take);
      }
    }
  }
  _handleLoadingChanged(isLoading) {
    this.loadingChanged.fire(isLoading);
  }
  _handleLoadError(error) {
    this.loadError.fire(error);
    this.changed.fire({
      changeType: "loadError",
      error
    });
  }
  _loadPageSize() {
    return this.pageSize();
  }
  _handleDataChanged(args) {
    let currentTotalCount;
    const dataSource = this._dataSource;
    let isLoading = false;
    const isDataLoading = !args || isDefined(args.changeType);
    const itemsCount = this.itemsCount();
    if (isDataLoading) {
      this._isLastPage = !itemsCount || !this._loadPageSize() || itemsCount < this._loadPageSize();
      if (this._isLastPage) {
        this._hasLastPage = true;
      }
    }
    if (dataSource.totalCount() >= 0) {
      if (dataSource.pageIndex() >= this.pageCount()) {
        dataSource.pageIndex(this.pageCount() - 1);
        this.pageIndex(dataSource.pageIndex());
        this.resetPagesCache();
        dataSource.load();
        isLoading = true;
      }
    } else if (isDataLoading) {
      currentTotalCount = dataSource.pageIndex() * this.pageSize() + itemsCount;
      if (currentTotalCount > this._currentTotalCount) {
        this._currentTotalCount = currentTotalCount;
        if (0 === dataSource.pageIndex() || !this.option("scrolling.legacyMode")) {
          this._totalCountCorrection = 0;
        }
      }
      if (0 === itemsCount && dataSource.pageIndex() >= this.pageCount()) {
        dataSource.pageIndex(this.pageCount() - 1);
        if ("infinite" !== this.option("scrolling.mode")) {
          dataSource.load();
          isLoading = true;
        }
      }
    }
    if (!isLoading) {
      this._operationTypes = this._lastOperationTypes;
      this._lastOperationTypes = {};
      this.component._optionCache = {};
      this.changed.fire(args);
      this.component._optionCache = void 0;
    }
  }
  _scheduleCustomLoadCallbacks(deferred) {
    const that = this;
    that._isCustomLoading = true;
    deferred.always((() => {
      that._isCustomLoading = false;
    }));
  }
  loadingOperationTypes() {
    return this._loadingOperationTypes;
  }
  operationTypes() {
    return this._operationTypes;
  }
  lastLoadOptions() {
    return this._lastLoadOptions || {};
  }
  isLastPage() {
    return this._isLastPage;
  }
  _dataSourceTotalCount() {
    return this._dataSource.totalCount();
  }
  _changeRowExpandCore(path) {
  }
  changeRowExpand(path) {
  }
  totalCount() {
    return parseInt((this._currentTotalCount || this._dataSourceTotalCount()) + this._totalCountCorrection);
  }
  totalCountCorrection() {
    return this._totalCountCorrection;
  }
  items() {
  }
  itemsCount() {
    return this._dataSource.items().length;
  }
  totalItemsCount() {
    return this.totalCount();
  }
  pageSize() {
    const dataSource = this._dataSource;
    if (!arguments.length && !dataSource.paginate()) {
      return 0;
    }
    return dataSource.pageSize.apply(dataSource, arguments);
  }
  pageCount() {
    const count = this.totalItemsCount() - this._totalCountCorrection;
    const pageSize = this.pageSize();
    if (pageSize && count > 0) {
      return Math.max(1, Math.ceil(count / pageSize));
    }
    return 1;
  }
  hasKnownLastPage() {
    return this._hasLastPage || this._dataSource.totalCount() >= 0;
  }
  loadFromStore(loadOptions, store) {
    const dataSource = this._dataSource;
    const d = new Deferred();
    if (!dataSource) {
      return;
    }
    store = store || dataSource.store();
    store.load(loadOptions).done(((data17, extra) => {
      if (data17 && !Array.isArray(data17) && Array.isArray(data17.data)) {
        extra = data17;
        data17 = data17.data;
      }
      d.resolve(data17, extra);
    })).fail(d.reject);
    return d;
  }
  isCustomLoading() {
    return !!this._isCustomLoading;
  }
  load(options) {
    const that = this;
    const dataSource = that._dataSource;
    const d = new Deferred();
    if (options) {
      const store = dataSource.store();
      const dataSourceLoadOptions = dataSource.loadOptions();
      const loadResult = {
        storeLoadOptions: extend({}, options, {
          langParams: null === dataSourceLoadOptions || void 0 === dataSourceLoadOptions ? void 0 : dataSourceLoadOptions.langParams
        }),
        isCustomLoading: true
      };
      each(store._customLoadOptions() || [], ((_, optionName) => {
        if (!(optionName in loadResult.storeLoadOptions)) {
          loadResult.storeLoadOptions[optionName] = dataSourceLoadOptions[optionName];
        }
      }));
      this._isLoadingAll = options.isLoadingAll;
      that._scheduleCustomLoadCallbacks(d);
      dataSource._scheduleLoadCallbacks(d);
      that._handleCustomizeStoreLoadOptions(loadResult);
      executeTask((() => {
        if (!dataSource.store()) {
          return d.reject("canceled");
        }
        when(loadResult.data || that.loadFromStore(loadResult.storeLoadOptions)).done(((data17, extra) => {
          loadResult.data = data17;
          loadResult.extra = extra || {};
          that._handleDataLoaded(loadResult);
          if (options.requireTotalCount && void 0 === loadResult.extra.totalCount) {
            loadResult.extra.totalCount = store.totalCount(loadResult.storeLoadOptions);
          }
          when(loadResult.data, loadResult.extra.totalCount).done(((data18, totalCount) => {
            loadResult.extra.totalCount = totalCount;
            d.resolve(data18, loadResult.extra);
          })).fail(d.reject);
        })).fail(d.reject);
      }), that.option("loadingTimeout"));
      return d.fail((function() {
        that._eventsStrategy.fireEvent("loadError", arguments);
      })).always((() => {
        this._isLoadingAll = false;
      })).promise();
    }
    return dataSource.load();
  }
  reload(full) {
    return full ? this._dataSource.reload() : this._dataSource.load();
  }
  getCachedStoreData() {
    return this._cachedStoreData;
  }
  isLoaded() {
  }
  pageIndex(pageIndex) {
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/m_data_source_adapter.js
var DataSourceAdapterType = DataSourceAdapter;
var m_data_source_adapter_default = {
  extend(extender) {
    DataSourceAdapterType = extender(DataSourceAdapterType);
  },
  create: (component) => new DataSourceAdapterType(component)
};

// node_modules/devextreme/esm/__internal/grids/data_grid/m_data_controller.js
var DataGridDataController = class extends DataController {
  _getDataSourceAdapter() {
    return m_data_source_adapter_default;
  }
  _getSpecificDataSourceOption() {
    const dataSource = this.option("dataSource");
    if (dataSource && !Array.isArray(dataSource) && this.option("keyExpr")) {
      ui_errors_default.log("W1011");
    }
    return super._getSpecificDataSourceOption();
  }
};
m_core_default.registerModule("data", {
  defaultOptions: dataControllerModule.defaultOptions,
  controllers: {
    data: DataGridDataController
  }
});

// node_modules/devextreme/esm/__internal/grids/grid_core/sorting/m_sorting_mixin.js
var sortingMixin = (Base) => class extends Base {
  _applyColumnState(options) {
    const that = this;
    let ariaSortState;
    let $sortIndicator;
    const sortingMode = that.option("sorting.mode");
    const {
      rootElement
    } = options;
    const {
      column
    } = options;
    const $indicatorsContainer = that._getIndicatorContainer(rootElement);
    if ("sort" === options.name) {
      rootElement.find(".dx-sort").remove();
      !$indicatorsContainer.children().length && $indicatorsContainer.remove();
      const isSortingAllowed = "none" !== sortingMode && column.allowSorting;
      const hasSeveralSortIndexes = that.getController && !!that.getController("columns").columnOption("sortIndex:1");
      if (!isDefined(column.groupIndex) && (isSortingAllowed || isDefined(column.sortOrder))) {
        ariaSortState = "asc" === column.sortOrder ? "ascending" : "descending";
        $sortIndicator = super._applyColumnState(options).toggleClass("dx-sort-up", "asc" === column.sortOrder).toggleClass("dx-sort-down", "desc" === column.sortOrder);
        if (hasSeveralSortIndexes && that.option("sorting.showSortIndexes") && column.sortIndex >= 0) {
          renderer_default("<span>").addClass("dx-sort-index-icon").text(column.sortIndex + 1).appendTo($sortIndicator);
          $sortIndicator.addClass("dx-sort-index");
        }
        if (isSortingAllowed) {
          options.rootElement.addClass(that.addWidgetPrefix("action"));
        }
      }
      this._setAriaSortAttribute(column, ariaSortState, rootElement, hasSeveralSortIndexes);
      return $sortIndicator;
    }
    return super._applyColumnState(options);
  }
  _setAriaSortAttribute(column, ariaSortState, $rootElement, hasSeveralSortIndexes) {
    $rootElement.removeAttr("aria-roledescription");
    if (column.isGrouped) {
      let description = this.localize("dxDataGrid-ariaNotSortedColumn");
      if (isDefined(column.sortOrder)) {
        description = "asc" === column.sortOrder ? this.localize("dxDataGrid-ariaSortedAscendingColumn") : this.localize("dxDataGrid-ariaSortedDescendingColumn");
      }
      this.setAria("roledescription", description, $rootElement);
    } else if (!isDefined(column.sortOrder)) {
      this.setAria("sort", "none", $rootElement);
    } else {
      this.setAria("sort", ariaSortState, $rootElement);
      if (hasSeveralSortIndexes && column.sortIndex >= 0) {
        const ariaColumnHeader = message_default.format("dxDataGrid-ariaColumnHeader");
        const ariaSortIndex = message_default.format("dxDataGrid-ariaSortIndex", column.sortIndex + 1);
        const description = `${ariaColumnHeader}, ${ariaSortIndex}`;
        this.setAria("roledescription", description, $rootElement);
      }
    }
  }
  _getIndicatorClassName(name) {
    if ("sort" === name) {
      return "dx-sort";
    }
    if ("sortIndex" === name) {
      return "dx-sort-index-icon";
    }
    return super._getIndicatorClassName(name);
  }
  _renderIndicator(options) {
    const {
      column
    } = options;
    const $container = options.container;
    const $indicator = options.indicator;
    if ("sort" === options.name) {
      const rtlEnabled = this.option("rtlEnabled");
      if (!isDefined(column.sortOrder)) {
        $indicator && $indicator.addClass("dx-sort-none");
      }
      if ($container.children().length && (!rtlEnabled && "left" === options.columnAlignment || rtlEnabled && "right" === options.columnAlignment)) {
        $container.prepend($indicator);
        return;
      }
    }
    super._renderIndicator(options);
  }
  _updateIndicator($cell, column, indicatorName) {
    if ("sort" === indicatorName && isDefined(column.groupIndex)) {
      return;
    }
    return super._updateIndicator.apply(this, arguments);
  }
  _getIndicatorElements($cell, returnAll) {
    const $indicatorElements = super._getIndicatorElements($cell);
    return returnAll ? $indicatorElements : $indicatorElements && $indicatorElements.not(".dx-sort-none");
  }
};
var m_sorting_mixin_default = sortingMixin;

// node_modules/devextreme/esm/__internal/grids/grid_core/sorting/m_sorting.js
var columnHeadersView = (Base) => class extends m_sorting_mixin_default(Base) {
  optionChanged(args) {
    const that = this;
    if ("sorting" === args.name) {
      that._invalidate();
      args.handled = true;
    } else {
      super.optionChanged(args);
    }
  }
  _createRow(row) {
    const $row = super._createRow(row);
    if ("header" === row.rowType) {
      m_events_engine_default.on($row, addNamespace(CLICK_EVENT_NAME, "dxDataGridColumnHeadersView"), "td", this.createAction(((e) => {
        this._processHeaderAction(e.event, $row);
      })));
    }
    return $row;
  }
  _processHeaderAction(event, $row) {
    if (renderer_default(event.currentTarget).parent().get(0) !== $row.get(0)) {
      return;
    }
    const that = this;
    let keyName = null;
    const $cellElementFromEvent = renderer_default(event.currentTarget);
    const rowIndex = $cellElementFromEvent.parent().index();
    let columnIndex = -1;
    [].slice.call(that.getCellElements(rowIndex)).some((($cellElement, index) => {
      if ($cellElement === $cellElementFromEvent.get(0)) {
        columnIndex = index;
        return true;
      }
      return;
    }));
    const visibleColumns = that._columnsController.getVisibleColumns(rowIndex);
    const column = visibleColumns[columnIndex];
    const editingController = that.getController("editing");
    const editingMode = that.option("editing.mode");
    const isCellEditing = editingController && editingController.isEditing() && ("batch" === editingMode || "cell" === editingMode);
    if (isCellEditing || !that._isSortableElement(renderer_default(event.target))) {
      return;
    }
    if (column && !isDefined(column.groupIndex) && !column.command) {
      if (event.shiftKey) {
        keyName = "shift";
      } else if (isCommandKeyPressed(event)) {
        keyName = "ctrl";
      }
      setTimeout((() => {
        that._columnsController.changeSortOrder(column.index, keyName);
      }));
    }
  }
  _renderCellContent($cell, options) {
    const that = this;
    const {
      column
    } = options;
    if (!column.command && "header" === options.rowType) {
      that._applyColumnState({
        name: "sort",
        rootElement: $cell,
        column,
        showColumnLines: that.option("showColumnLines")
      });
    }
    super._renderCellContent.apply(this, arguments);
  }
  _columnOptionChanged(e) {
    const {
      changeTypes
    } = e;
    if (1 === changeTypes.length && changeTypes.sorting) {
      this._updateIndicators("sort");
      return;
    }
    super._columnOptionChanged(e);
  }
};
var headerPanel = (Base) => class extends m_sorting_mixin_default(Base) {
  optionChanged(args) {
    const that = this;
    if ("sorting" === args.name) {
      that._invalidate();
      args.handled = true;
    } else {
      super.optionChanged(args);
    }
  }
  _createGroupPanelItem($rootElement, groupColumn) {
    const that = this;
    const $item = super._createGroupPanelItem(...arguments);
    m_events_engine_default.on($item, addNamespace(CLICK_EVENT_NAME, "dxDataGridHeaderPanel"), that.createAction((() => {
      that._processGroupItemAction(groupColumn.index);
    })));
    that._applyColumnState({
      name: "sort",
      rootElement: $item,
      column: {
        alignment: that.option("rtlEnabled") ? "right" : "left",
        allowSorting: groupColumn.allowSorting,
        sortOrder: "desc" === groupColumn.sortOrder ? "desc" : "asc",
        isGrouped: true
      },
      showColumnLines: true
    });
    return $item;
  }
  _processGroupItemAction(groupColumnIndex) {
    setTimeout((() => this.getController("columns").changeSortOrder(groupColumnIndex)));
  }
};
var sortingModule = {
  defaultOptions: () => ({
    sorting: {
      mode: "single",
      ascendingText: message_default.format("dxDataGrid-sortingAscendingText"),
      descendingText: message_default.format("dxDataGrid-sortingDescendingText"),
      clearText: message_default.format("dxDataGrid-sortingClearText"),
      showSortIndexes: true
    }
  }),
  extenders: {
    views: {
      columnHeadersView,
      headerPanel
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/sorting.js
m_core_default.registerModule("sorting", sortingModule);

// node_modules/devextreme/esm/ui/scroll_view/ui.scrollable.js
var ui_scrollable_default = scrollable_default;

// node_modules/devextreme/esm/__internal/grids/grid_core/views/m_rows_view.js
var FREE_SPACE_CLASS = "dx-freespace-row";
var LAST_ROW_BORDER = "dx-last-row-border";
function getMaxHorizontalScrollOffset(scrollable) {
  return scrollable ? Math.round(scrollable.scrollWidth() - scrollable.clientWidth()) : 0;
}
function isGroupRow(_ref) {
  let {
    rowType,
    column
  } = _ref;
  return "group" === rowType && isDefined(column.groupIndex) && !column.showWhenGrouped && !column.command;
}
function setWatcher(_ref2) {
  let {
    element,
    watch,
    getter,
    callBack
  } = _ref2;
  if (watch) {
    const dispose = watch(getter, callBack);
    m_events_engine_default.on(element, removeEvent, dispose);
  }
}
var defaultCellTemplate = function($container, options) {
  const isDataTextEmpty = isEmpty(options.text) && "data" === options.rowType;
  const {
    text
  } = options;
  const container = $container.get(0);
  if (isDataTextEmpty) {
    m_utils_default.setEmptyText($container);
  } else if (options.column.encodeHtml) {
    container.textContent = text;
  } else {
    container.innerHTML = text;
  }
};
var getScrollableBottomPadding = function(that) {
  const scrollable = that.getScrollable();
  return scrollable ? Math.ceil(parseFloat(renderer_default(scrollable.content()).css("paddingBottom"))) : 0;
};
var RowsView = class extends ColumnsView {
  init() {
    super.init();
    this._editingController = this.getController("editing");
    this._resizingController = this.getController("resizing");
    this._columnsResizerController = this.getController("columnsResizer");
    this._focusController = this.getController("focus");
    this._keyboardNavigationController = this.getController("keyboardNavigation");
    this._validatingController = this.getController("validating");
    this._errorHandlingController = this.getController("errorHandling");
    this._columnHeadersView = this.getView("columnHeadersView");
    this._rowHeight = 0;
    this._scrollTop = 0;
    this._scrollLeft = -1;
    this._scrollRight = 0;
    this._hasHeight = void 0;
    this._contentChanges = [];
    this._dataController.loadingChanged.add(((isLoading, messageText) => {
      this.setLoading(isLoading, messageText);
    }));
    this._dataController.dataSourceChanged.add((() => {
      if (this._scrollLeft >= 0 && !this._dataController.isLoading()) {
        this._handleScroll({
          component: this.getScrollable(),
          forceUpdateScrollPosition: true,
          scrollOffset: {
            top: this._scrollTop,
            left: this._scrollLeft
          }
        });
      }
    }));
  }
  _getDefaultTemplate(column) {
    if ("empty" === column.command) {
      return function(container) {
        container.html("&nbsp;");
      };
    } else {
      return defaultCellTemplate;
    }
  }
  renderFocusState(params) {
  }
  _getDefaultGroupTemplate(column) {
    const summaryTexts = this.option("summary.texts");
    return function($container, options) {
      const {
        data: data17
      } = options;
      let text = `${options.column.caption}: ${options.text}`;
      const container = $container.get(0);
      if (options.summaryItems && options.summaryItems.length) {
        text += ` ${m_utils_default.getGroupRowSummaryText(options.summaryItems, summaryTexts)}`;
      }
      if (data17) {
        if (options.groupContinuedMessage && options.groupContinuesMessage) {
          text += ` (${options.groupContinuedMessage}. ${options.groupContinuesMessage})`;
        } else if (options.groupContinuesMessage) {
          text += ` (${options.groupContinuesMessage})`;
        } else if (options.groupContinuedMessage) {
          text += ` (${options.groupContinuedMessage})`;
        }
      }
      if (column.encodeHtml) {
        container.textContent = text;
      } else {
        container.innerHTML = text;
      }
    };
  }
  _update(change) {
  }
  _updateCell($cell, options) {
    if (isGroupRow(options)) {
      const isGroupContainer = $cell.is(`.${this.addWidgetPrefix(CLASSES3.groupRowContainer)}`);
      const $groupCell = isGroupContainer ? $cell.parent() : $cell;
      $groupCell.addClass("dx-group-cell");
    }
    super._updateCell.apply(this, arguments);
  }
  _getCellTemplate(options) {
    const that = this;
    const {
      column
    } = options;
    let template;
    if (isGroupRow(options)) {
      template = column.groupCellTemplate || {
        allowRenderToDetachedContainer: true,
        render: that._getDefaultGroupTemplate(column)
      };
    } else if (("data" === options.rowType || column.command) && column.cellTemplate) {
      template = column.cellTemplate;
    } else {
      template = {
        allowRenderToDetachedContainer: true,
        render: that._getDefaultTemplate(column)
      };
    }
    return template;
  }
  _createRow(row, tag) {
    const $row = super._createRow.apply(this, arguments);
    if (row) {
      const isGroup2 = "group" === row.rowType;
      const isDataRow2 = "data" === row.rowType;
      isDataRow2 && $row.addClass("dx-data-row");
      isDataRow2 && this.option("showRowLines") && $row.addClass("dx-row-lines");
      this.option("showColumnLines") && $row.addClass("dx-column-lines");
      if (false === row.visible) {
        $row.hide();
      }
      if (isGroup2) {
        $row.addClass("dx-group-row");
        this.setAriaExpandedAttribute($row, row);
      }
    }
    return $row;
  }
  _rowPrepared($row, rowOptions, row) {
    if ("data" === rowOptions.rowType) {
      if (this.option("rowAlternationEnabled")) {
        this._isAltRow(row) && $row.addClass("dx-row-alt");
        setWatcher({
          element: $row.get(0),
          watch: rowOptions.watch,
          getter: () => this._isAltRow(this._dataController.getRowByKey(row.key)),
          callBack: (value2) => {
            $row.toggleClass("dx-row-alt", value2);
          }
        });
      }
      this._setAriaRowIndex(rowOptions, $row);
      setWatcher({
        element: $row.get(0),
        watch: rowOptions.watch,
        getter: () => rowOptions.rowIndex,
        callBack: () => this._setAriaRowIndex(rowOptions, $row)
      });
    }
    super._rowPrepared.apply(this, arguments);
  }
  _setAriaRowIndex(row, $row) {
    if (!$row.is("tr")) {
      return;
    }
    const {
      component
    } = this;
    const isPagerMode = "standard" === component.option("scrolling.mode") && !m_utils_default.isVirtualRowRendering(component);
    let rowIndex = row.rowIndex + 1;
    if (isPagerMode) {
      rowIndex = component.pageIndex() * component.pageSize() + rowIndex;
    } else {
      rowIndex += this._dataController.getRowIndexOffset();
    }
    this.setAria("rowindex", rowIndex, $row);
  }
  setAriaExpandedAttribute($row, row) {
    const description = row.isExpanded ? this.localize("dxDataGrid-ariaExpandedRow") : this.localize("dxDataGrid-ariaCollapsedRow");
    this.setAria("roledescription", description, $row);
  }
  _afterRowPrepared(e) {
    const arg = e.args[0];
    const dataController2 = this._dataController;
    const row = dataController2.getVisibleRows()[arg.rowIndex];
    const watch = this.option("integrationOptions.watchMethod");
    if (!arg.data || "data" !== arg.rowType || arg.isNewRow || !this.option("twoWayBindingEnabled") || !watch || !row) {
      return;
    }
    const dispose = watch((() => dataController2.generateDataValues(arg.data, arg.columns)), (() => {
      dataController2.repaintRows([row.rowIndex], this.option("repaintChangesOnly"));
    }), {
      deep: true,
      skipImmediate: true
    });
    m_events_engine_default.on(arg.rowElement, removeEvent, dispose);
  }
  _renderScrollable(force) {
    const that = this;
    const $element = that.element();
    if (!$element.children().length) {
      $element.append("<div>");
    }
    if (force || !that._loadPanel) {
      that._renderLoadPanel($element, $element.parent(), that._dataController.isLocalStore());
    }
    if ((force || !that.getScrollable()) && that._dataController.isLoaded()) {
      const columns7 = that.getColumns();
      let allColumnsHasWidth = true;
      for (let i = 0; i < columns7.length; i++) {
        if (!columns7[i].width && !columns7[i].minWidth) {
          allColumnsHasWidth = false;
          break;
        }
      }
      if (that.option("columnAutoWidth") || that._hasHeight || allColumnsHasWidth || that._columnsController._isColumnFixing()) {
        that._renderScrollableCore($element);
      }
    }
  }
  _handleScroll(e) {
    const rtlEnabled = this.option("rtlEnabled");
    const isNativeScrolling = e.component.option("useNative");
    this._scrollTop = e.scrollOffset.top;
    this._scrollLeft = e.scrollOffset.left;
    let scrollLeft = e.scrollOffset.left;
    if (rtlEnabled) {
      this._scrollRight = getMaxHorizontalScrollOffset(e.component) - this._scrollLeft;
      if (isNativeScrolling) {
        scrollLeft = -this._scrollRight;
      }
      if (!this.isScrollbarVisible(true)) {
        this._scrollLeft = -1;
      }
    }
    this.scrollChanged.fire(_extends({}, e.scrollOffset, {
      left: scrollLeft
    }), this.name);
  }
  _renderScrollableCore($element) {
    const dxScrollableOptions = this._createScrollableOptions();
    const scrollHandler = this._handleScroll.bind(this);
    dxScrollableOptions.onScroll = scrollHandler;
    this._scrollable = this._createComponent($element, ui_scrollable_default, dxScrollableOptions);
    this._scrollableContainer = this._scrollable && renderer_default(this._scrollable.container());
  }
  _renderLoadPanel() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return m_utils_default.renderLoadPanel.apply(this, arguments);
  }
  _renderContent(contentElement, tableElement, isFixedTableRendering) {
    contentElement.empty().append(tableElement);
    return this._findContentElement();
  }
  _updateContent(newTableElement, change, isFixedTableRendering) {
    this._contentChanges.push({
      newTableElement,
      change,
      isFixedTableRendering
    });
    return this.waitAsyncTemplates().done((() => {
      const contentChanges = this._contentChanges;
      this._contentChanges = [];
      contentChanges.forEach(((_ref3) => {
        let {
          newTableElement: newTableElement2,
          change: change2,
          isFixedTableRendering: isFixedTableRendering2
        } = _ref3;
        const tableElement = this.getTableElement(isFixedTableRendering2);
        const contentElement = this._findContentElement(isFixedTableRendering2);
        const changeType = null === change2 || void 0 === change2 ? void 0 : change2.changeType;
        const executors = [];
        const highlightChanges = this.option("highlightChanges");
        const rowInsertedClass = this.addWidgetPrefix("row-inserted-animation");
        if ("update" === changeType) {
          each(change2.rowIndices, ((index, rowIndex) => {
            var _change$changeTypes;
            const $newRowElement = this._getRowElements(newTableElement2).eq(index);
            const dataChangeType = null === (_change$changeTypes = change2.changeTypes) || void 0 === _change$changeTypes ? void 0 : _change$changeTypes[index];
            const item = change2.items && change2.items[index];
            executors.push((() => {
              const $rowElements = this._getRowElements(tableElement);
              const $rowElement = $rowElements.eq(rowIndex);
              switch (dataChangeType) {
                case "update":
                  if (item) {
                    var _change$columnIndices;
                    const columnIndices = null === (_change$columnIndices = change2.columnIndices) || void 0 === _change$columnIndices ? void 0 : _change$columnIndices[index];
                    if (isDefined(item.visible) && item.visible !== $rowElement.is(":visible")) {
                      $rowElement.toggle(item.visible);
                    } else if (columnIndices) {
                      this._updateCells($rowElement, $newRowElement, columnIndices, item);
                    } else {
                      $rowElement.replaceWith($newRowElement);
                    }
                  }
                  break;
                case "insert":
                  if (!$rowElements.length) {
                    if (tableElement) {
                      const target = $newRowElement.is("tbody") ? tableElement : tableElement.children("tbody");
                      $newRowElement.prependTo(target);
                    }
                  } else if ($rowElement.length) {
                    $newRowElement.insertBefore($rowElement);
                  } else {
                    $newRowElement.insertAfter($rowElements.last());
                  }
                  if (highlightChanges && change2.isLiveUpdate) {
                    $newRowElement.addClass(rowInsertedClass);
                  }
                  break;
                case "remove":
                  $rowElement.remove();
              }
            }));
          }));
          each(executors, (function() {
            this();
          }));
          newTableElement2.remove();
        } else {
          this.setTableElement(newTableElement2, isFixedTableRendering2);
          contentElement.addClass(this.addWidgetPrefix("content"));
          this._setGridRole(contentElement);
          this._renderContent(contentElement, newTableElement2, isFixedTableRendering2);
        }
      }));
    })).fail((() => {
      this._contentChanges = [];
    }));
  }
  _getGridRoleName() {
    return "grid";
  }
  _setGridRole($element) {
    var _this$_dataController;
    const hasData = !(null !== (_this$_dataController = this._dataController) && void 0 !== _this$_dataController && _this$_dataController.isEmpty());
    const gridRoleName = this._getGridRoleName();
    if (null !== $element && void 0 !== $element && $element.length && hasData) {
      this.setAria("role", gridRoleName, $element);
    }
  }
  _createEmptyRow(className, isFixed, height) {
    const that = this;
    let $cell;
    const $row = that._createRow();
    const columns7 = isFixed ? this.getFixedColumns() : this.getColumns();
    $row.addClass(className).toggleClass("dx-column-lines", that.option("showColumnLines"));
    for (let i = 0; i < columns7.length; i++) {
      $cell = that._createCell({
        column: columns7[i],
        rowType: "freeSpace",
        columnIndex: i,
        columns: columns7
      });
      isNumeric(height) && $cell.css("height", height);
      $row.append($cell);
    }
    that.setAria("role", "presentation", $row);
    return $row;
  }
  getFixedColumns() {
    throw new Error("Method not implemented.");
  }
  _appendEmptyRow($table, $emptyRow, location) {
    const $tBodies = this._getBodies($table);
    const isTableContainer = !$tBodies.length || $emptyRow.is("tbody");
    const $container = isTableContainer ? $table : $tBodies;
    if ("top" === location) {
      $container.first().prepend($emptyRow);
      if (isTableContainer) {
        const $colgroup = $container.children("colgroup");
        $container.prepend($colgroup);
      }
    } else {
      $container.last().append($emptyRow);
    }
  }
  _renderFreeSpaceRow($tableElement, change) {
    let $freeSpaceRowElement = this._createEmptyRow(FREE_SPACE_CLASS);
    $freeSpaceRowElement = this._wrapRowIfNeed($tableElement, $freeSpaceRowElement, "refresh" === (null === change || void 0 === change ? void 0 : change.changeType));
    this._appendEmptyRow($tableElement, $freeSpaceRowElement);
  }
  _checkRowKeys(options) {
    const that = this;
    const rows = that._getRows(options);
    const keyExpr = that._dataController.store() && that._dataController.store().key();
    keyExpr && rows.some(((row) => {
      if ("data" === row.rowType && void 0 === row.key) {
        that._dataController.fireError("E1046", keyExpr);
        return true;
      }
      return;
    }));
  }
  _needUpdateRowHeight(itemsCount) {
    return itemsCount > 0 && !this._rowHeight;
  }
  _getRowsHeight($tableElement) {
    $tableElement = $tableElement || this._tableElement;
    const $rowElements = $tableElement.children("tbody").children().not(".dx-virtual-row").not(`.${FREE_SPACE_CLASS}`);
    return $rowElements.toArray().reduce(((sum, row) => sum + getBoundingRect(row).height), 0);
  }
  _updateRowHeight() {
    const that = this;
    const $tableElement = that.getTableElement();
    const itemsCount = that._dataController.items().length;
    if ($tableElement && that._needUpdateRowHeight(itemsCount)) {
      const rowsHeight = that._getRowsHeight($tableElement);
      that._rowHeight = rowsHeight / itemsCount;
    }
  }
  _findContentElement(isFixedTableRendering) {
    let $content = this.element();
    const scrollable = this.getScrollable();
    if ($content) {
      if (scrollable) {
        $content = renderer_default(scrollable.content());
      }
      return $content.children().first();
    }
  }
  _getRowElements(tableElement) {
    const $rows = super._getRowElements(tableElement);
    return $rows && $rows.not(`.${FREE_SPACE_CLASS}`);
  }
  _getFreeSpaceRowElements($table) {
    const tableElements = $table || this.getTableElements();
    return tableElements && tableElements.children("tbody").children(`.${FREE_SPACE_CLASS}`);
  }
  _getNoDataText() {
    return this.option("noDataText");
  }
  _rowClick(e) {
    const item = this._dataController.items()[e.rowIndex] || {};
    this.executeAction("onRowClick", extend({
      evaluate(expr) {
        const getter = compileGetter(expr);
        return getter(item.data);
      }
    }, e, item));
  }
  _rowDblClick(e) {
    const item = this._dataController.items()[e.rowIndex] || {};
    this.executeAction("onRowDblClick", extend({}, e, item));
  }
  _getColumnsCountBeforeGroups(columns7) {
    for (let i = 0; i < columns7.length; i++) {
      if ("groupExpand" === columns7[i].type) {
        return i;
      }
    }
    return 0;
  }
  _getGroupCellOptions(options) {
    const columnsCountBeforeGroups = this._getColumnsCountBeforeGroups(options.columns);
    const columnIndex = (options.row.groupIndex || 0) + columnsCountBeforeGroups;
    return {
      columnIndex,
      colspan: options.columns.length - columnIndex - 1
    };
  }
  _needWrapRow() {
    return super._needWrapRow.apply(this, arguments) || !!this.option("dataRowTemplate");
  }
  _renderCells($row, options) {
    if ("group" === options.row.rowType) {
      this._renderGroupedCells($row, options);
    } else if (options.row.values) {
      super._renderCells($row, options);
    }
  }
  _renderGroupedCells($row, options) {
    const {
      row
    } = options;
    let expandColumn;
    const {
      columns: columns7
    } = options;
    const {
      rowIndex
    } = row;
    let isExpanded;
    const groupCellOptions = this._getGroupCellOptions(options);
    for (let i = 0; i <= groupCellOptions.columnIndex; i++) {
      if (i === groupCellOptions.columnIndex && columns7[i].allowCollapsing && "infinite" !== options.scrollingMode) {
        isExpanded = !!row.isExpanded;
        expandColumn = columns7[i];
      } else {
        isExpanded = null;
        expandColumn = {
          command: "expand",
          cssClass: columns7[i].cssClass,
          fixed: columns7[i].fixed
        };
      }
      if (this._needRenderCell(i, options.columnIndices)) {
        this._renderCell($row, {
          value: isExpanded,
          row,
          rowIndex,
          column: expandColumn,
          columnIndex: i,
          columnIndices: options.columnIndices,
          change: options.change
        });
      }
    }
    const groupColumnAlignment = getDefaultAlignment(this.option("rtlEnabled"));
    const groupColumn = extend({}, columns7[groupCellOptions.columnIndex], {
      command: null,
      type: null,
      cssClass: null,
      width: null,
      showWhenGrouped: false,
      alignment: groupColumnAlignment
    });
    if (groupCellOptions.colspan > 1) {
      groupColumn.colspan = groupCellOptions.colspan;
    }
    if (this._needRenderCell(groupCellOptions.columnIndex + 1, options.columnIndices)) {
      this._renderCell($row, {
        value: row.values[row.groupIndex],
        row,
        rowIndex,
        column: groupColumn,
        columnIndex: groupCellOptions.columnIndex + 1,
        columnIndices: options.columnIndices,
        change: options.change
      });
    }
  }
  _renderRows($table, options) {
    const that = this;
    const scrollingMode = that.option("scrolling.mode");
    super._renderRows($table, extend({
      scrollingMode
    }, options));
    that._checkRowKeys(options.change);
    that._renderFreeSpaceRow($table, options.change);
    if (!that._hasHeight) {
      that.updateFreeSpaceRowHeight($table);
    }
  }
  _renderDataRowByTemplate($table, options, dataRowTemplate) {
    const {
      row
    } = options;
    const rowOptions = extend({
      columns: options.columns
    }, row);
    const $tbody = this._createRow(row, "tbody");
    $tbody.appendTo($table);
    this.renderTemplate($tbody, dataRowTemplate, rowOptions, true, options.change);
    this._rowPrepared($tbody, rowOptions, options.row);
  }
  _renderRow($table, options) {
    const {
      row
    } = options;
    const {
      rowTemplate
    } = this.option();
    const dataRowTemplate = this.option("dataRowTemplate");
    if ("data" === row.rowType && dataRowTemplate) {
      this._renderDataRowByTemplate($table, options, dataRowTemplate);
    } else if (("data" === row.rowType || "group" === row.rowType) && !isDefined(row.groupIndex) && rowTemplate) {
      this.renderTemplate($table, rowTemplate, extend({
        columns: options.columns
      }, row), true);
    } else {
      super._renderRow($table, options);
    }
  }
  _renderTable(options) {
    const that = this;
    const $table = super._renderTable(options);
    const resizeCompletedHandler = function() {
      const scrollableInstance = that.getScrollable();
      if (scrollableInstance && that.element().closest(getWindow().document).length) {
        that.resizeCompleted.remove(resizeCompletedHandler);
        scrollableInstance._visibilityChanged(true);
      }
    };
    if (!isDefined(that.getTableElement())) {
      that.setTableElement($table);
      that._renderScrollable(true);
      that.resizeCompleted.add(resizeCompletedHandler);
    } else {
      that._renderScrollable();
    }
    return $table;
  }
  _createTable() {
    const $table = super._createTable.apply(this, arguments);
    if (this.option().rowTemplate || this.option().dataRowTemplate) {
      $table.appendTo(this.component.$element());
    }
    return $table;
  }
  _renderCore(change) {
    const $element = this.element();
    $element.addClass(this.addWidgetPrefix("rowsview")).toggleClass(this.addWidgetPrefix("nowrap"), !this.option("wordWrapEnabled"));
    $element.toggleClass("dx-empty", this._dataController.isEmpty());
    this.setAria("role", "presentation", $element);
    const $table = this._renderTable({
      change
    });
    const deferred = this._updateContent($table, change);
    super._renderCore(change);
    this._lastColumnWidths = null;
    return deferred;
  }
  _getRows(change) {
    return change && change.items || this._dataController.items();
  }
  _getCellOptions(options) {
    const that = this;
    const {
      column
    } = options;
    const {
      row
    } = options;
    const {
      data: data17
    } = row;
    const summaryCells = row && row.summaryCells;
    const {
      value: value2
    } = options;
    const displayValue = m_utils_default.getDisplayValue(column, value2, data17, row.rowType);
    const parameters = super._getCellOptions(options);
    parameters.value = value2;
    parameters.oldValue = options.oldValue;
    parameters.displayValue = displayValue;
    parameters.row = row;
    parameters.key = row.key;
    parameters.data = data17;
    parameters.rowType = row.rowType;
    parameters.values = row.values;
    parameters.text = !column.command ? m_utils_default.formatValue(displayValue, column) : "";
    parameters.rowIndex = row.rowIndex;
    parameters.summaryItems = summaryCells && summaryCells[options.columnIndex];
    parameters.resized = column.resizedCallbacks;
    if (isDefined(column.groupIndex) && !column.command) {
      const groupingTextsOptions = that.option("grouping.texts");
      const scrollingMode = that.option("scrolling.mode");
      if ("virtual" !== scrollingMode && "infinite" !== scrollingMode) {
        parameters.groupContinuesMessage = data17 && data17.isContinuationOnNextPage && groupingTextsOptions && groupingTextsOptions.groupContinuesMessage;
        parameters.groupContinuedMessage = data17 && data17.isContinuation && groupingTextsOptions && groupingTextsOptions.groupContinuedMessage;
      }
    }
    return parameters;
  }
  _toggleDraggableSourceColumnClass($rows, visibleColumns, columnIndex, value2) {
    const columnsController = this._columnsController;
    const columns7 = columnsController.getColumns();
    const column = columns7 && columns7[columnIndex];
    const columnID = column && column.isBand && column.index;
    each($rows, ((rowIndex, row) => {
      if (!renderer_default(row).hasClass("dx-group-row")) {
        for (let i = 0; i < visibleColumns.length; i++) {
          if (isNumeric(columnID) && columnsController.isParentBandColumn(visibleColumns[i].index, columnID) || visibleColumns[i].index === columnIndex) {
            $rows.eq(rowIndex).children().eq(i).toggleClass(this.addWidgetPrefix(CLASSES.draggableColumn), value2);
            if (!isNumeric(columnID)) {
              break;
            }
          }
        }
      }
    }));
  }
  _getDevicePixelRatio() {
    return getWindow().devicePixelRatio;
  }
  renderNoDataText() {
    return m_utils_default.renderNoDataText.apply(this, arguments);
  }
  getCellOptions(rowIndex, columnIdentifier) {
    const rowOptions = this._dataController.items()[rowIndex];
    let cellOptions;
    let column;
    if (rowOptions) {
      if (isString(columnIdentifier)) {
        column = this._columnsController.columnOption(columnIdentifier);
      } else {
        column = this._columnsController.getVisibleColumns()[columnIdentifier];
      }
      if (column) {
        cellOptions = this._getCellOptions({
          value: column.calculateCellValue(rowOptions.data),
          rowIndex: rowOptions.rowIndex,
          row: rowOptions,
          column
        });
      }
    }
    return cellOptions;
  }
  getRow(index) {
    if (index >= 0) {
      const rows = this._getRowElements();
      if (rows.length > index) {
        return renderer_default(rows[index]);
      }
    }
    return;
  }
  updateFreeSpaceRowHeight($table) {
    const dataController2 = this._dataController;
    const itemCount = dataController2.items(true).length;
    const contentElement = this._findContentElement();
    const freeSpaceRowElements = this._getFreeSpaceRowElements($table);
    if (freeSpaceRowElements && contentElement && dataController2.totalCount() >= 0) {
      let isFreeSpaceRowVisible = false;
      if (itemCount > 0) {
        if (!this._hasHeight) {
          const freeSpaceRowCount = dataController2.pageSize() - itemCount;
          const scrollingMode = this.option("scrolling.mode");
          if (freeSpaceRowCount > 0 && dataController2.pageCount() > 1 && "virtual" !== scrollingMode && "infinite" !== scrollingMode) {
            setHeight2(freeSpaceRowElements, freeSpaceRowCount * this._rowHeight);
            isFreeSpaceRowVisible = true;
          }
          if (!isFreeSpaceRowVisible && $table) {
            setHeight2(freeSpaceRowElements, 0);
          } else {
            freeSpaceRowElements.toggle(isFreeSpaceRowVisible);
          }
          this._updateLastRowBorder(isFreeSpaceRowVisible);
        } else {
          freeSpaceRowElements.hide();
          deferUpdate((() => {
            const scrollbarWidth = this.getScrollbarWidth(true);
            const elementHeightWithoutScrollbar = getHeight(this.element()) - scrollbarWidth;
            const contentHeight = getOuterHeight(contentElement);
            const showFreeSpaceRow = elementHeightWithoutScrollbar - contentHeight > 0;
            const rowsHeight = this._getRowsHeight(contentElement.children().first());
            const $tableElement = $table || this.getTableElements();
            const borderTopWidth = Math.ceil(parseFloat($tableElement.css("borderTopWidth")));
            const heightCorrection = this._getHeightCorrection();
            const resultHeight = elementHeightWithoutScrollbar - rowsHeight - borderTopWidth - heightCorrection;
            if (showFreeSpaceRow) {
              deferRender((() => {
                freeSpaceRowElements.css("height", resultHeight);
                isFreeSpaceRowVisible = true;
                freeSpaceRowElements.show();
              }));
            }
            deferRender((() => this._updateLastRowBorder(isFreeSpaceRowVisible)));
          }));
        }
      } else {
        freeSpaceRowElements.css("height", 0);
        freeSpaceRowElements.show();
        this._updateLastRowBorder(true);
      }
    }
  }
  _getHeightCorrection() {
    const isZoomedWebkit = browser_default.webkit && this._getDevicePixelRatio() >= 2;
    const isChromeLatest = browser_default.chrome && browser_default.version >= 91;
    const hasExtraBorderTop = browser_default.mozilla && browser_default.version >= 70 && !this.option("showRowLines");
    return isZoomedWebkit || hasExtraBorderTop || isChromeLatest ? 1 : 0;
  }
  _columnOptionChanged(e) {
    const {
      optionNames
    } = e;
    if (e.changeTypes.grouping) {
      return;
    }
    if (optionNames.width || optionNames.visibleWidth) {
      super._columnOptionChanged(e);
      this._fireColumnResizedCallbacks();
    }
  }
  getScrollable() {
    return this._scrollable;
  }
  _handleDataChanged(change) {
    const that = this;
    switch (change.changeType) {
      case "refresh":
      case "prepend":
      case "append":
      case "update":
        that.render(null, change);
        break;
      default:
        that._update(change);
    }
  }
  publicMethods() {
    return ["isScrollbarVisible", "getTopVisibleRowData", "getScrollbarWidth", "getCellElement", "getRowElement", "getScrollable"];
  }
  contentWidth() {
    return getWidth(this.element()) - this.getScrollbarWidth();
  }
  getScrollbarWidth(isHorizontal) {
    const scrollableContainer = this._scrollableContainer && this._scrollableContainer.get(0);
    let scrollbarWidth = 0;
    if (scrollableContainer) {
      if (!isHorizontal) {
        scrollbarWidth = scrollableContainer.clientWidth ? scrollableContainer.offsetWidth - scrollableContainer.clientWidth : 0;
      } else {
        scrollbarWidth = scrollableContainer.clientHeight ? scrollableContainer.offsetHeight - scrollableContainer.clientHeight : 0;
        scrollbarWidth += getScrollableBottomPadding(this);
      }
    }
    return scrollbarWidth > 0 ? scrollbarWidth : 0;
  }
  _fireColumnResizedCallbacks() {
    const lastColumnWidths = this._lastColumnWidths || [];
    const columnWidths = [];
    const columns7 = this.getColumns();
    for (let i = 0; i < columns7.length; i++) {
      columnWidths[i] = columns7[i].visibleWidth;
      if (columns7[i].resizedCallbacks && !isDefined(columns7[i].groupIndex) && lastColumnWidths[i] !== columnWidths[i]) {
        columns7[i].resizedCallbacks.fire(columnWidths[i]);
      }
    }
    this._lastColumnWidths = columnWidths;
  }
  _updateLastRowBorder(isFreeSpaceRowVisible) {
    if (this.option("showBorders") && !isFreeSpaceRowVisible) {
      this.element().addClass(LAST_ROW_BORDER);
    } else {
      this.element().removeClass(LAST_ROW_BORDER);
    }
  }
  _updateScrollable() {
    const scrollable = ui_scrollable_default.getInstance(this.element());
    if (scrollable) {
      scrollable.update();
      this._updateHorizontalScrollPosition();
    }
  }
  _updateHorizontalScrollPosition() {
    const scrollable = this.getScrollable();
    const scrollLeft = scrollable && scrollable.scrollOffset().left;
    const rtlEnabled = this.option("rtlEnabled");
    if (rtlEnabled) {
      const maxHorizontalScrollOffset = getMaxHorizontalScrollOffset(scrollable);
      const scrollRight = maxHorizontalScrollOffset - scrollLeft;
      if (scrollRight !== this._scrollRight) {
        this._scrollLeft = maxHorizontalScrollOffset - this._scrollRight;
      }
    }
    if (this._scrollLeft >= 0 && scrollLeft !== this._scrollLeft) {
      scrollable.scrollTo({
        x: this._scrollLeft
      });
    }
  }
  _resizeCore() {
    const that = this;
    that._fireColumnResizedCallbacks();
    that._updateRowHeight();
    deferRender((() => {
      that._renderScrollable();
      that.renderNoDataText();
      that.updateFreeSpaceRowHeight();
      deferUpdate((() => {
        that._updateScrollable();
      }));
    }));
  }
  scrollTo(location) {
    const $element = this.element();
    const dxScrollable = $element && ui_scrollable_default.getInstance($element);
    if (dxScrollable) {
      dxScrollable.scrollTo(location);
    }
  }
  height(height) {
    const that = this;
    const $element = this.element();
    if (0 === arguments.length) {
      return $element ? getOuterHeight($element, true) : 0;
    }
    if (isDefined(height) && $element) {
      that.hasHeight("auto" !== height);
      setHeight2($element, height);
    }
  }
  hasHeight(hasHeight) {
    if (0 === arguments.length) {
      return !!this._hasHeight;
    }
    this._hasHeight = hasHeight;
    return;
  }
  setLoading(isLoading, messageText) {
    const that = this;
    let loadPanel = that._loadPanel;
    const dataController2 = that._dataController;
    const loadPanelOptions = that.option("loadPanel") || {};
    const animation = dataController2.isLoaded() ? loadPanelOptions.animation : null;
    const $element = that.element();
    if (!hasWindow()) {
      return;
    }
    if (!loadPanel && void 0 !== messageText && dataController2.isLocalStore() && "auto" === loadPanelOptions.enabled && $element) {
      that._renderLoadPanel($element, $element.parent());
      loadPanel = that._loadPanel;
    }
    if (loadPanel) {
      const visibilityOptions = {
        message: messageText || loadPanelOptions.text,
        animation,
        visible: isLoading
      };
      if (isLoading) {
        visibilityOptions.position = m_utils_default.calculateLoadPanelPosition($element);
      }
      clearTimeout(that._hideLoadingTimeoutID);
      if (loadPanel.option("visible") && !isLoading) {
        that._hideLoadingTimeoutID = setTimeout((() => {
          loadPanel.option(visibilityOptions);
        }), 200);
      } else {
        loadPanel.option(visibilityOptions);
      }
    }
  }
  toggleDraggableColumnClass(columnIndex, value2) {
    const $rows = this._getRowElements().not(".dx-group-row") || [];
    this._toggleDraggableSourceColumnClass($rows, this.getColumns(), columnIndex, value2);
  }
  _getCellElementsCore(rowIndex) {
    const $cells = super._getCellElementsCore.apply(this, arguments);
    if ($cells) {
      const groupCellIndex = $cells.filter(".dx-group-cell").index();
      if (groupCellIndex >= 0 && $cells.length > groupCellIndex + 1) {
        return $cells.slice(0, groupCellIndex + 1);
      }
    }
    return $cells;
  }
  _getBoundaryVisibleItemIndex(isTop, isFloor) {
    const that = this;
    let itemIndex = 0;
    let prevOffset = 0;
    let offset = 0;
    let viewportBoundary = that._scrollTop;
    const $contentElement = that._findContentElement();
    const contentElementOffsetTop = $contentElement && $contentElement.offset().top;
    const items = this._dataController.items();
    const tableElement = that.getTableElement();
    if (items.length && tableElement) {
      const rowElements = that._getRowElements(tableElement).filter(":visible");
      if (!isTop) {
        const height = getOuterHeight(this._hasHeight ? this.element() : getWindow());
        viewportBoundary += height;
      }
      for (itemIndex = 0; itemIndex < items.length; itemIndex++) {
        prevOffset = offset;
        const $rowElement = renderer_default(rowElements).eq(itemIndex);
        if ($rowElement.length) {
          offset = $rowElement.offset();
          offset = (isTop ? offset.top : offset.top + getOuterHeight($rowElement)) - contentElementOffsetTop;
          if (offset > viewportBoundary) {
            if (itemIndex) {
              if (isFloor || 2 * viewportBoundary < Math.round(offset + prevOffset)) {
                itemIndex--;
              }
            }
            break;
          }
        }
      }
      if (itemIndex && itemIndex === items.length) {
        itemIndex--;
      }
    }
    return itemIndex;
  }
  getTopVisibleItemIndex(isFloor) {
    return this._getBoundaryVisibleItemIndex(true, isFloor);
  }
  getBottomVisibleItemIndex(isFloor) {
    return this._getBoundaryVisibleItemIndex(false, isFloor);
  }
  getTopVisibleRowData() {
    const itemIndex = this.getTopVisibleItemIndex();
    const items = this._dataController.items();
    if (items[itemIndex]) {
      return items[itemIndex].data;
    }
    return;
  }
  _scrollToElement($element, offset) {
    const scrollable = this.getScrollable();
    scrollable && scrollable.scrollToElement($element, offset);
  }
  optionChanged(args) {
    const that = this;
    super.optionChanged(args);
    switch (args.name) {
      case "wordWrapEnabled":
      case "showColumnLines":
      case "showRowLines":
      case "rowAlternationEnabled":
      case "rowTemplate":
      case "dataRowTemplate":
      case "twoWayBindingEnabled":
        that._invalidate(true, true);
        args.handled = true;
        break;
      case "scrolling":
        that._rowHeight = null;
        that._tableElement = null;
        args.handled = true;
        break;
      case "rtlEnabled":
        that._rowHeight = null;
        that._tableElement = null;
        break;
      case "loadPanel":
        that._tableElement = null;
        that._invalidate(true, "loadPanel.enabled" !== args.fullName);
        args.handled = true;
        break;
      case "noDataText":
        that.renderNoDataText();
        args.handled = true;
    }
  }
  setAriaOwns(headerTableId, footerTableId, isFixed) {
    const $contentElement = this._findContentElement();
    const $tableElement = this.getTableElement();
    if (null !== $tableElement && void 0 !== $tableElement && $tableElement.length) {
      this.setAria("owns", `${headerTableId ?? ""} ${$tableElement.attr("id") ?? ""} ${footerTableId ?? ""}`.trim(), $contentElement);
    }
  }
  dispose() {
    super.dispose();
    clearTimeout(this._hideLoadingTimeoutID);
    this._scrollable && this._scrollable.dispose();
  }
  setScrollerSpacing(vScrollbarWidth, hScrollbarWidth) {
  }
  getFixedContentElement() {
    var _this$element;
    const fixedContentClass = this.addWidgetPrefix("content-fixed");
    return null === (_this$element = this.element()) || void 0 === _this$element ? void 0 : _this$element.children(`.${fixedContentClass}`);
  }
  _restoreErrorRow(contentTable) {
  }
  isElementInside($element) {
    const $rowsViewElement = $element.closest(`.${this.addWidgetPrefix("rowsview")}`);
    return $rowsViewElement.is(this.element());
  }
  _renderIcons($iconContainer, options) {
    return $iconContainer;
  }
};
var rowsModule = {
  defaultOptions: () => ({
    hoverStateEnabled: false,
    scrolling: {
      useNative: "auto"
    },
    loadPanel: {
      enabled: "auto",
      text: message_default.format("Loading"),
      width: 200,
      height: 90,
      showIndicator: true,
      indicatorSrc: "",
      showPane: true
    },
    dataRowTemplate: null,
    columnAutoWidth: false,
    noDataText: message_default.format("dxDataGrid-noDataText"),
    wordWrapEnabled: false,
    showColumnLines: true,
    showRowLines: false,
    rowAlternationEnabled: false,
    activeStateEnabled: false,
    twoWayBindingEnabled: true
  }),
  views: {
    rowsView: RowsView
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/rows.js
var RowsView2 = rowsModule.views.rowsView;
m_core_default.registerModule("rows", rowsModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/context_menu/m_context_menu.js
var CONTEXT_MENU = "dx-context-menu";
var viewName = {
  columnHeadersView: "header",
  rowsView: "content",
  footerView: "footer",
  headerPanel: "toolbar"
};
var VIEW_NAMES = ["columnHeadersView", "rowsView", "footerView", "headerPanel"];
var ContextMenuController = class extends m_modules_default.ViewController {
  init() {
    this.createAction("onContextMenuPreparing");
  }
  getContextMenuItems(dxEvent) {
    if (!dxEvent) {
      return false;
    }
    const that = this;
    const $targetElement = renderer_default(dxEvent.target);
    let menuItems;
    each(VIEW_NAMES, (function() {
      const view = that.getView(this);
      if (!view) {
        return;
      }
      const $viewElement = view.element();
      const isTargetElementInsideView = (null === $viewElement || void 0 === $viewElement ? void 0 : $viewElement.is($targetElement)) || (null === $viewElement || void 0 === $viewElement ? void 0 : $viewElement.find($targetElement).length);
      if (isTargetElementInsideView) {
        var _$targetCellElement$, _rowOptions$cells, _view$getContextMenuI;
        const isGroupRow3 = $targetElement.hasClass("dx-group-row");
        const $targetCellElement = isGroupRow3 ? $targetElement.find(".dx-group-cell").first() : $targetElement.closest(".dx-row > td, .dx-row > tr");
        const $targetRowElement = $targetCellElement.parent();
        const rowIndex = view.getRowIndex($targetRowElement);
        const columnIndex = null === (_$targetCellElement$ = $targetCellElement[0]) || void 0 === _$targetCellElement$ ? void 0 : _$targetCellElement$.cellIndex;
        const rowOptions = $targetRowElement.data("options");
        const options = {
          event: dxEvent,
          targetElement: getPublicElement($targetElement),
          target: viewName[this],
          rowIndex,
          row: view._getRows()[rowIndex],
          columnIndex,
          column: null === rowOptions || void 0 === rowOptions || null === (_rowOptions$cells = rowOptions.cells) || void 0 === _rowOptions$cells || null === (_rowOptions$cells = _rowOptions$cells[columnIndex]) || void 0 === _rowOptions$cells ? void 0 : _rowOptions$cells.column
        };
        options.items = null === (_view$getContextMenuI = view.getContextMenuItems) || void 0 === _view$getContextMenuI ? void 0 : _view$getContextMenuI.call(view, options);
        that.executeAction("onContextMenuPreparing", options);
        that._contextMenuPrepared(options);
        menuItems = options.items;
        if (menuItems) {
          return false;
        }
      }
      return;
    }));
    return menuItems;
  }
  _contextMenuPrepared(options) {
  }
};
var ContextMenuView = class extends m_modules_default.View {
  init() {
    super.init();
    this._contextMenuController = this.getController("contextMenu");
  }
  _renderCore() {
    const $element = this.element().addClass(CONTEXT_MENU);
    this.setAria("role", "presentation", $element);
    this._createComponent($element, context_menu_default2, {
      onPositioning: (actionArgs) => {
        const {
          event
        } = actionArgs;
        const contextMenuInstance = actionArgs.component;
        const items = this._contextMenuController.getContextMenuItems(event);
        if (items) {
          contextMenuInstance.option("items", items);
          event.stopPropagation();
        } else {
          actionArgs.cancel = true;
        }
      },
      onItemClick(params) {
        var _params$itemData, _params$itemData$onIt;
        null === (_params$itemData = params.itemData) || void 0 === _params$itemData || null === (_params$itemData$onIt = _params$itemData.onItemClick) || void 0 === _params$itemData$onIt || _params$itemData$onIt.call(_params$itemData, params);
      },
      cssClass: this.getWidgetContainerClass(),
      target: this.component.$element()
    });
  }
};
var contextMenuModule = {
  defaultOptions: () => ({
    onContextMenuPreparing: null
  }),
  controllers: {
    contextMenu: ContextMenuController
  },
  views: {
    contextMenuView: ContextMenuView
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/context_menu.js
m_core_default.registerModule("contextMenu", contextMenuModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/error_handling/m_error_handling.js
var ErrorHandlingController = class extends m_modules_default.ViewController {
  init() {
    this._resizingController = this.getController("resizing");
    this._columnsController = this.getController("columns");
    this._columnHeadersView = this.getView("columnHeadersView");
    this._rowsView = this.getView("rowsView");
  }
  _createErrorRow(error, $tableElements) {
    let $errorRow;
    let $closeButton;
    const $errorMessage = this._renderErrorMessage(error);
    if ($tableElements) {
      $errorRow = renderer_default("<tr>").attr("role", "row").addClass("dx-error-row");
      $closeButton = renderer_default("<div>").addClass("dx-closebutton").addClass(this.addWidgetPrefix("action"));
      m_events_engine_default.on($closeButton, CLICK_EVENT_NAME, this.createAction(((args) => {
        var _this$_resizingContro, _this$_resizingContro2;
        const e = args.event;
        let $errorRow2;
        const errorRowIndex = renderer_default(e.currentTarget).closest(".dx-error-row").index();
        e.stopPropagation();
        each($tableElements, ((_, tableElement) => {
          $errorRow2 = renderer_default(tableElement).children("tbody").children("tr").eq(errorRowIndex);
          this.removeErrorRow($errorRow2);
        }));
        null === (_this$_resizingContro = this._resizingController) || void 0 === _this$_resizingContro || null === (_this$_resizingContro2 = _this$_resizingContro.fireContentReadyAction) || void 0 === _this$_resizingContro2 || _this$_resizingContro2.call(_this$_resizingContro);
      })));
      renderer_default("<td>").attr({
        colSpan: this._columnsController.getVisibleColumns().length,
        role: "gridcell"
      }).prepend($closeButton).append($errorMessage).appendTo($errorRow);
      return $errorRow;
    }
    return $errorMessage;
  }
  _renderErrorMessage(error) {
    const message = error.url ? error.message.replace(error.url, "") : error.message || error;
    const $message = renderer_default("<div>").attr("role", "alert").attr("aria-roledescription", message_default.format("dxDataGrid-ariaError")).addClass("dx-error-message").text(message);
    if (error.url) {
      renderer_default("<a>").attr("href", error.url).text(error.url).appendTo($message);
    }
    return $message;
  }
  renderErrorRow(error, rowIndex, $popupContent) {
    var _this$_resizingContro3, _this$_resizingContro4;
    const that = this;
    let $errorMessageElement;
    let $firstErrorRow;
    if ($popupContent) {
      $popupContent.find(".dx-error-message").remove();
      $errorMessageElement = that._createErrorRow(error);
      $popupContent.prepend($errorMessageElement);
      return $errorMessageElement;
    }
    const viewElement = rowIndex >= 0 || !that._columnHeadersView.isVisible() ? that._rowsView : that._columnHeadersView;
    const $tableElements = viewElement.getTableElements();
    each($tableElements, ((_, tableElement) => {
      $errorMessageElement = that._createErrorRow(error, $tableElements);
      $firstErrorRow = $firstErrorRow || $errorMessageElement;
      if (rowIndex >= 0) {
        const $row = viewElement._getRowElements(renderer_default(tableElement)).eq(rowIndex);
        that.removeErrorRow($row.next());
        $errorMessageElement.insertAfter($row);
      } else {
        const $tbody = renderer_default(tableElement).children("tbody");
        const rowElements = $tbody.children("tr");
        if (that._columnHeadersView.isVisible()) {
          that.removeErrorRow(rowElements.last());
          renderer_default(tableElement).append($errorMessageElement);
        } else {
          that.removeErrorRow(rowElements.first());
          $tbody.first().prepend($errorMessageElement);
        }
      }
    }));
    null === (_this$_resizingContro3 = this._resizingController) || void 0 === _this$_resizingContro3 || null === (_this$_resizingContro4 = _this$_resizingContro3.fireContentReadyAction) || void 0 === _this$_resizingContro4 || _this$_resizingContro4.call(_this$_resizingContro3);
    return $firstErrorRow;
  }
  removeErrorRow($row) {
    if (!$row) {
      const $columnHeaders = this._columnHeadersView && this._columnHeadersView.element();
      $row = $columnHeaders && $columnHeaders.find(".dx-error-row");
      if (!$row || !$row.length) {
        const $rowsViewElement = this._rowsView.element();
        $row = $rowsViewElement && $rowsViewElement.find(".dx-error-row");
      }
    }
    $row && $row.hasClass("dx-error-row") && $row.remove();
  }
  optionChanged(args) {
    if ("errorRowEnabled" === args.name) {
      args.handled = true;
    } else {
      super.optionChanged(args);
    }
  }
};
var data2 = (Base) => class extends Base {
  init() {
    super.init();
    this.dataErrorOccurred.add(((error, $popupContent) => {
      if (this.option("errorRowEnabled")) {
        this._errorHandlingController.renderErrorRow(error, void 0, $popupContent);
      }
    }));
    this.changed.add(((e) => {
      if (e && "loadError" === e.changeType) {
        return;
      }
      if (this._editingController && !this._editingController.hasChanges()) {
        var _this$_errorHandlingC, _this$_errorHandlingC2;
        null === (_this$_errorHandlingC = this._errorHandlingController) || void 0 === _this$_errorHandlingC || null === (_this$_errorHandlingC2 = _this$_errorHandlingC.removeErrorRow) || void 0 === _this$_errorHandlingC2 || _this$_errorHandlingC2.call(_this$_errorHandlingC);
      }
    }));
  }
};
var errorHandlingModule = {
  defaultOptions: () => ({
    errorRowEnabled: true
  }),
  controllers: {
    errorHandling: ErrorHandlingController
  },
  extenders: {
    controllers: {
      data: data2
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/error_handling.js
m_core_default.registerModule("errorHandling", errorHandlingModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/views/a11y_status_container_component.js
var CLASSES4 = {
  container: "dx-gridbase-a11y-status-container"
};
var A11yStatusContainerComponent = (_ref) => {
  let {
    statusText
  } = _ref;
  return renderer_default("<div>").text(statusText ?? "").addClass(CLASSES4.container).attr("role", "status");
};

// node_modules/devextreme/esm/__internal/grids/grid_core/views/m_grid_view.js
var VIEW_NAMES2 = ["columnsSeparatorView", "blockSeparatorView", "trackerView", "headerPanel", "columnHeadersView", "rowsView", "footerView", "columnChooserView", "filterPanelView", "pagerView", "draggingHeaderView", "contextMenuView", "errorView", "headerFilterView", "filterBuilderView"];
var E2E_ATTRIBUTES = {
  a11yStatusContainer: "e2e-a11y-general-status-container"
};
var isPercentWidth = function(width) {
  return isString(width) && width.endsWith("%");
};
var isPixelWidth = function(width) {
  return isString(width) && width.endsWith("px");
};
var calculateFreeWidth = function(that, widths) {
  const contentWidth = that._rowsView.contentWidth();
  const totalWidth = that._getTotalWidth(widths, contentWidth);
  return contentWidth - totalWidth;
};
var calculateFreeWidthWithCurrentMinWidth = function(that, columnIndex, currentMinWidth, widths) {
  return calculateFreeWidth(that, widths.map(((width, index) => index === columnIndex ? currentMinWidth : width)));
};
var restoreFocus2 = function(focusedElement, selectionRange) {
  hiddenFocus(focusedElement, true);
  m_utils_default.setSelectionRange(focusedElement, selectionRange);
};
var ResizingController = class extends m_modules_default.ViewController {
  callbackNames() {
    return ["resizeCompleted"];
  }
  init() {
    this._prevContentMinHeight = null;
    this._dataController = this.getController("data");
    this._columnsController = this.getController("columns");
    this._columnHeadersView = this.getView("columnHeadersView");
    this._adaptiveColumnsController = this.getController("adaptiveColumns");
    this._editorFactoryController = this.getController("editorFactory");
    this._footerView = this.getView("footerView");
    this._rowsView = this.getView("rowsView");
    this._gridView = this.getView("gridView");
  }
  _initPostRenderHandlers() {
    if (!this._refreshSizesHandler) {
      this._refreshSizesHandler = (e) => {
        let resizeDeferred = new Deferred().resolve(null);
        const changeType = null === e || void 0 === e ? void 0 : e.changeType;
        const isDelayed = null === e || void 0 === e ? void 0 : e.isDelayed;
        const needFireContentReady = changeType && "updateSelection" !== changeType && "updateFocusedRow" !== changeType && "pageIndex" !== changeType && !isDelayed;
        this._dataController.changed.remove(this._refreshSizesHandler);
        if (this._checkSize()) {
          resizeDeferred = this._refreshSizes(e);
        }
        if (needFireContentReady) {
          when(resizeDeferred).done((() => {
            this._setAriaLabel(e);
            this.fireContentReadyAction();
          }));
        }
      };
      this._dataController.changed.add((() => {
        this._dataController.changed.add(this._refreshSizesHandler);
      }));
    }
  }
  _refreshSizes(e) {
    let resizeDeferred = new Deferred().resolve(null);
    const changeType = null === e || void 0 === e ? void 0 : e.changeType;
    const isDelayed = null === e || void 0 === e ? void 0 : e.isDelayed;
    const items = this._dataController.items();
    if (!e || "refresh" === changeType || "prepend" === changeType || "append" === changeType) {
      if (!isDelayed) {
        resizeDeferred = this.resize();
      }
    } else if ("update" === changeType) {
      var _e$changeTypes;
      if (0 === (null === (_e$changeTypes = e.changeTypes) || void 0 === _e$changeTypes ? void 0 : _e$changeTypes.length)) {
        return resizeDeferred;
      }
      if ((items.length > 1 || "insert" !== e.changeTypes[0]) && !(0 === items.length && "remove" === e.changeTypes[0]) && !e.needUpdateDimensions) {
        resizeDeferred = new Deferred();
        this._waitAsyncTemplates().done((() => {
          deferUpdate((() => deferRender((() => deferUpdate((() => {
            this._setScrollerSpacing();
            this._rowsView.resize();
            resizeDeferred.resolve();
          }))))));
        })).fail(resizeDeferred.reject);
      } else {
        resizeDeferred = this.resize();
      }
    }
    return resizeDeferred;
  }
  fireContentReadyAction() {
    this.component._fireContentReadyAction();
  }
  _getWidgetAriaLabel() {
    return "dxDataGrid-ariaDataGrid";
  }
  _setAriaLabel(e) {
    var _this$_columnsControl;
    let widgetStatusText = "";
    let labelParts = [];
    const columnCount = (null === (_this$_columnsControl = this._columnsController) || void 0 === _this$_columnsControl || null === (_this$_columnsControl = _this$_columnsControl._columns) || void 0 === _this$_columnsControl ? void 0 : _this$_columnsControl.filter(((_ref) => {
      let {
        visible
      } = _ref;
      return !!visible;
    })).length) ?? 0;
    const totalItemsCount = Math.max(0, this._dataController.totalItemsCount());
    const widgetAriaLabel = this._getWidgetAriaLabel();
    widgetStatusText = message_default.format(widgetAriaLabel, totalItemsCount, columnCount);
    const expandableWidgetAriaLabel = message_default.format(this._expandableWidgetAriaId);
    labelParts = [widgetStatusText];
    if (expandableWidgetAriaLabel) {
      labelParts.push(expandableWidgetAriaLabel);
    }
    const $ariaLabelElement = this.component.$element().children(".dx-gridbase-container");
    this.component.setAria("label", labelParts.join(". "), $ariaLabelElement);
    if (!(null !== e && void 0 !== e && e.isFirstRender)) {
      this._gridView.setWidgetA11yStatusText(widgetStatusText);
    }
  }
  _getBestFitWidths() {
    var _widths;
    const rowsView18 = this._rowsView;
    const columnHeadersView10 = this._columnHeadersView;
    let widths = rowsView18.getColumnWidths();
    if (!(null !== (_widths = widths) && void 0 !== _widths && _widths.length)) {
      var _rowsView$getTableEle;
      const headersTableElement = columnHeadersView10.getTableElement();
      columnHeadersView10.setTableElement(null === (_rowsView$getTableEle = rowsView18.getTableElement()) || void 0 === _rowsView$getTableEle ? void 0 : _rowsView$getTableEle.children(".dx-header"));
      widths = columnHeadersView10.getColumnWidths();
      columnHeadersView10.setTableElement(headersTableElement);
    }
    return widths;
  }
  _setVisibleWidths(visibleColumns, widths) {
    const columnsController = this._columnsController;
    columnsController.beginUpdate();
    each(visibleColumns, ((index, column) => {
      const columnId = columnsController.getColumnId(column);
      columnsController.columnOption(columnId, "visibleWidth", widths[index]);
    }));
    columnsController.endUpdate();
  }
  _toggleBestFitModeForView(view, className, isBestFit) {
    if (!view || !view.isVisible()) {
      return;
    }
    const $rowsTables = this._rowsView.getTableElements();
    const $viewTables = view.getTableElements();
    each($rowsTables, ((index, tableElement) => {
      let $tableBody;
      const $rowsTable = renderer_default(tableElement);
      const $viewTable = $viewTables.eq(index);
      if ($viewTable && $viewTable.length) {
        if (isBestFit) {
          $tableBody = $viewTable.children("tbody").appendTo($rowsTable);
        } else {
          $tableBody = $rowsTable.children(`.${className}`).appendTo($viewTable);
        }
        $tableBody.toggleClass(className, isBestFit);
        $tableBody.toggleClass(this.addWidgetPrefix("best-fit"), isBestFit);
      }
    }));
  }
  _toggleBestFitMode(isBestFit) {
    const $rowsTable = this._rowsView.getTableElement();
    const $rowsFixedTable = this._rowsView.getTableElements().eq(1);
    if (!$rowsTable) {
      return;
    }
    $rowsTable.css("tableLayout", isBestFit ? "auto" : "fixed");
    $rowsTable.children("colgroup").css("display", isBestFit ? "none" : "");
    each($rowsFixedTable.find("tr.dx-group-row"), ((idx, item) => {
      renderer_default(item).css("display", isBestFit ? "none" : "");
    }));
    $rowsFixedTable.toggleClass(this.addWidgetPrefix("table-fixed"), !isBestFit);
    this._toggleBestFitModeForView(this._columnHeadersView, "dx-header", isBestFit);
    this._toggleBestFitModeForView(this._footerView, "dx-footer", isBestFit);
    if (this._needStretch()) {
      $rowsTable.get(0).style.width = isBestFit ? "auto" : "";
    }
  }
  _toggleContentMinHeight(value2) {
    const scrollable = this._rowsView.getScrollable();
    const $contentElement = this._rowsView._findContentElement();
    if (false === (null === scrollable || void 0 === scrollable ? void 0 : scrollable.option("useNative"))) {
      if (true === value2) {
        this._prevContentMinHeight = $contentElement.get(0).style.minHeight;
      }
      if (isDefined(this._prevContentMinHeight)) {
        $contentElement.css({
          minHeight: value2 ? m_utils_default.getContentHeightLimit(browser_default) : this._prevContentMinHeight
        });
      }
    }
  }
  _synchronizeColumns() {
    const columnsController = this._columnsController;
    const visibleColumns = columnsController.getVisibleColumns();
    const columnAutoWidth = this.option("columnAutoWidth");
    const hasUndefinedColumnWidth = visibleColumns.some(((column) => !isDefined(column.width)));
    let needBestFit = this._needBestFit();
    let hasMinWidth = false;
    let resetBestFitMode;
    let isColumnWidthsCorrected = false;
    let resultWidths = [];
    let focusedElement;
    let selectionRange;
    !needBestFit && each(visibleColumns, ((index, column) => {
      if ("auto" === column.width) {
        needBestFit = true;
        return false;
      }
      return;
    }));
    each(visibleColumns, ((index, column) => {
      if (column.minWidth) {
        hasMinWidth = true;
        return false;
      }
      return;
    }));
    this._toggleContentMinHeight(this._hasHeight);
    this._setVisibleWidths(visibleColumns, []);
    const $element = this.component.$element();
    if (needBestFit) {
      focusedElement = dom_adapter_default.getActiveElement($element.get(0));
      selectionRange = m_utils_default.getSelectionRange(focusedElement);
      this._toggleBestFitMode(true);
      resetBestFitMode = true;
    }
    if ($element && $element.get(0) && this._maxWidth) {
      delete this._maxWidth;
      $element[0].style.maxWidth = "";
    }
    deferUpdate((() => {
      if (needBestFit) {
        resultWidths = this._getBestFitWidths();
        each(visibleColumns, ((index, column) => {
          const columnId = columnsController.getColumnId(column);
          columnsController.columnOption(columnId, "bestFitWidth", resultWidths[index], true);
        }));
      } else if (hasMinWidth) {
        resultWidths = this._getBestFitWidths();
      }
      each(visibleColumns, (function(index) {
        const {
          width
        } = this;
        if ("auto" !== width) {
          if (isDefined(width)) {
            resultWidths[index] = isNumeric(width) || isPixelWidth(width) ? parseFloat(width) : width;
          } else if (!columnAutoWidth) {
            resultWidths[index] = void 0;
          }
        }
      }));
      if (resetBestFitMode) {
        this._toggleBestFitMode(false);
        resetBestFitMode = false;
        if (focusedElement && focusedElement !== dom_adapter_default.getActiveElement()) {
          const isFocusOutsideWindow = getBoundingRect(focusedElement).bottom < 0;
          if (!isFocusOutsideWindow) {
            restoreFocus2(focusedElement, selectionRange);
          }
        }
      }
      isColumnWidthsCorrected = this._correctColumnWidths(resultWidths, visibleColumns);
      if (columnAutoWidth) {
        !(function() {
          let expandColumnWidth;
          each(visibleColumns, ((index, column) => {
            if ("groupExpand" === column.type) {
              expandColumnWidth = resultWidths[index];
            }
          }));
          each(visibleColumns, ((index, column) => {
            if ("groupExpand" === column.type && expandColumnWidth) {
              resultWidths[index] = expandColumnWidth;
            }
          }));
        })();
        if (this._needStretch()) {
          this._processStretch(resultWidths, visibleColumns);
        }
      }
      deferRender((() => {
        if (needBestFit || isColumnWidthsCorrected || hasUndefinedColumnWidth) {
          this._setVisibleWidths(visibleColumns, resultWidths);
        }
        this._toggleContentMinHeight(false);
      }));
    }));
  }
  _needBestFit() {
    return this.option("columnAutoWidth");
  }
  _needStretch() {
    return this._columnsController.getVisibleColumns().some(((c) => "auto" === c.width && !c.command));
  }
  _getAverageColumnsWidth(resultWidths) {
    const freeWidth = calculateFreeWidth(this, resultWidths);
    const columnCountWithoutWidth = resultWidths.filter(((width) => void 0 === width)).length;
    return freeWidth / columnCountWithoutWidth;
  }
  _correctColumnWidths(resultWidths, visibleColumns) {
    const that = this;
    let i;
    let hasPercentWidth = false;
    let hasAutoWidth = false;
    let isColumnWidthsCorrected = false;
    const $element = that.component.$element();
    const hasWidth = that._hasWidth;
    for (i = 0; i < visibleColumns.length; i++) {
      const index = i;
      const column = visibleColumns[index];
      const isHiddenColumn = "adaptiveHidden" === resultWidths[index];
      let width = resultWidths[index];
      const {
        minWidth
      } = column;
      if (minWidth) {
        if (void 0 === width) {
          const averageColumnsWidth = that._getAverageColumnsWidth(resultWidths);
          width = averageColumnsWidth;
        } else if (isPercentWidth(width)) {
          const freeWidth = calculateFreeWidthWithCurrentMinWidth(that, index, minWidth, resultWidths);
          if (freeWidth < 0) {
            width = -1;
          }
        }
      }
      const realColumnWidth = that._getRealColumnWidth(index, resultWidths.map(((columnWidth, columnIndex) => index === columnIndex ? width : columnWidth)));
      if (minWidth && !isHiddenColumn && realColumnWidth < minWidth) {
        resultWidths[index] = minWidth;
        isColumnWidthsCorrected = true;
        i = -1;
      }
      if (!isDefined(column.width)) {
        hasAutoWidth = true;
      }
      if (isPercentWidth(column.width)) {
        hasPercentWidth = true;
      }
    }
    if (!hasAutoWidth && resultWidths.length) {
      const $rowsViewElement = that._rowsView.element();
      const contentWidth = that._rowsView.contentWidth();
      const scrollbarWidth = that._rowsView.getScrollbarWidth();
      const totalWidth = that._getTotalWidth(resultWidths, contentWidth);
      if (totalWidth < contentWidth) {
        const lastColumnIndex = m_utils_default.getLastResizableColumnIndex(visibleColumns, resultWidths);
        if (lastColumnIndex >= 0) {
          resultWidths[lastColumnIndex] = "auto";
          isColumnWidthsCorrected = true;
          if (false === hasWidth && !hasPercentWidth) {
            const borderWidth = m_utils_default.getComponentBorderWidth(this, $rowsViewElement);
            that._maxWidth = totalWidth + scrollbarWidth + borderWidth;
            $element.css("maxWidth", that._maxWidth);
          }
        }
      }
    }
    return isColumnWidthsCorrected;
  }
  _processStretch(resultSizes, visibleColumns) {
    const groupSize = this._rowsView.contentWidth();
    const tableSize = this._getTotalWidth(resultSizes, groupSize);
    const unusedIndexes = {
      length: 0
    };
    if (!resultSizes.length) {
      return;
    }
    each(visibleColumns, (function(index) {
      if (this.width || "adaptiveHidden" === resultSizes[index]) {
        unusedIndexes[index] = true;
        unusedIndexes.length++;
      }
    }));
    const diff = groupSize - tableSize;
    const diffElement = Math.floor(diff / (resultSizes.length - unusedIndexes.length));
    let onePixelElementsCount = diff - diffElement * (resultSizes.length - unusedIndexes.length);
    if (diff >= 0) {
      for (let i = 0; i < resultSizes.length; i++) {
        if (unusedIndexes[i]) {
          continue;
        }
        resultSizes[i] += diffElement;
        if (onePixelElementsCount > 0) {
          if (onePixelElementsCount < 1) {
            resultSizes[i] += onePixelElementsCount;
            onePixelElementsCount = 0;
          } else {
            resultSizes[i]++;
            onePixelElementsCount--;
          }
        }
      }
    }
  }
  _getRealColumnWidth(columnIndex, columnWidths, groupWidth) {
    let ratio = 1;
    const width = columnWidths[columnIndex];
    if (!isPercentWidth(width)) {
      return parseFloat(width);
    }
    const percentTotalWidth = columnWidths.reduce(((sum, width2, index) => {
      if (!isPercentWidth(width2)) {
        return sum;
      }
      return sum + parseFloat(width2);
    }), 0);
    const pixelTotalWidth = columnWidths.reduce(((sum, width2) => {
      if (!width2 || "adaptiveHidden" === width2 || isPercentWidth(width2)) {
        return sum;
      }
      return sum + parseFloat(width2);
    }), 0);
    groupWidth = groupWidth || this._rowsView.contentWidth();
    const freeSpace = groupWidth - pixelTotalWidth;
    const percentTotalWidthInPixel = percentTotalWidth * groupWidth / 100;
    if (pixelTotalWidth > 0 && percentTotalWidthInPixel + pixelTotalWidth >= groupWidth) {
      ratio = percentTotalWidthInPixel > freeSpace ? freeSpace / percentTotalWidthInPixel : 1;
    }
    return parseFloat(width) * groupWidth * ratio / 100;
  }
  _getTotalWidth(widths, groupWidth) {
    let result = 0;
    for (let i = 0; i < widths.length; i++) {
      const width = widths[i];
      if (width && "adaptiveHidden" !== width) {
        result += this._getRealColumnWidth(i, widths, groupWidth);
      }
    }
    return Math.ceil(result);
  }
  _getGroupElement() {
    return this.component.$element().children().get(0);
  }
  updateSize(rootElement) {
    const that = this;
    const $rootElement = renderer_default(rootElement);
    const importantMarginClass = that.addWidgetPrefix("important-margin");
    if (void 0 === that._hasHeight && $rootElement && $rootElement.is(":visible") && getWidth($rootElement)) {
      const $groupElement = $rootElement.children(`.${that.getWidgetContainerClass()}`);
      if ($groupElement.length) {
        $groupElement.detach();
      }
      that._hasHeight = !!getHeight($rootElement);
      const width = getWidth($rootElement);
      $rootElement.addClass(importantMarginClass);
      that._hasWidth = getWidth($rootElement) === width;
      $rootElement.removeClass(importantMarginClass);
      if ($groupElement.length) {
        $groupElement.appendTo($rootElement);
      }
    }
  }
  publicMethods() {
    return ["resize", "updateDimensions"];
  }
  _waitAsyncTemplates() {
    var _this$_columnHeadersV, _this$_rowsView, _this$_footerView;
    return when(null === (_this$_columnHeadersV = this._columnHeadersView) || void 0 === _this$_columnHeadersV ? void 0 : _this$_columnHeadersV.waitAsyncTemplates(true), null === (_this$_rowsView = this._rowsView) || void 0 === _this$_rowsView ? void 0 : _this$_rowsView.waitAsyncTemplates(true), null === (_this$_footerView = this._footerView) || void 0 === _this$_footerView ? void 0 : _this$_footerView.waitAsyncTemplates(true));
  }
  resize() {
    if (this.component._requireResize) {
      return new Deferred().resolve();
    }
    const d = new Deferred();
    this._waitAsyncTemplates().done((() => {
      when(this.updateDimensions()).done(d.resolve).fail(d.reject);
    })).fail(d.reject);
    return d.promise().done((() => {
      this.resizeCompleted.fire();
    }));
  }
  updateDimensions(checkSize) {
    const that = this;
    that._initPostRenderHandlers();
    if (!that._checkSize(checkSize)) {
      return;
    }
    const prevResult = that._resizeDeferred;
    const result = that._resizeDeferred = new Deferred();
    when(prevResult).always((() => {
      deferRender((() => {
        if (that._dataController.isLoaded()) {
          that._synchronizeColumns();
        }
        that._resetGroupElementHeight();
        deferUpdate((() => {
          deferRender((() => {
            deferUpdate((() => {
              that._updateDimensionsCore();
            }));
          }));
        }));
      })).done(result.resolve).fail(result.reject);
    }));
    return result.promise();
  }
  _resetGroupElementHeight() {
    const groupElement = this._getGroupElement();
    const scrollable = this._rowsView.getScrollable();
    if (groupElement && groupElement.style.height && (!scrollable || !scrollable.scrollTop())) {
      groupElement.style.height = "";
    }
  }
  _checkSize(checkSize) {
    const $rootElement = this.component.$element();
    const isWidgetVisible = $rootElement.is(":visible");
    const isGridSizeChanged = this._lastWidth !== getWidth($rootElement) || this._lastHeight !== getHeight($rootElement) || this._devicePixelRatio !== getWindow().devicePixelRatio;
    return isWidgetVisible && (!checkSize || isGridSizeChanged);
  }
  _setScrollerSpacingCore() {
    const that = this;
    const vScrollbarWidth = that._rowsView.getScrollbarWidth();
    const hScrollbarWidth = that._rowsView.getScrollbarWidth(true);
    deferRender((() => {
      that._columnHeadersView && that._columnHeadersView.setScrollerSpacing(vScrollbarWidth);
      that._footerView && that._footerView.setScrollerSpacing(vScrollbarWidth);
      that._rowsView.setScrollerSpacing(vScrollbarWidth, hScrollbarWidth);
    }));
  }
  _setScrollerSpacing() {
    const scrollable = this._rowsView.getScrollable();
    const isNativeScrolling = true === this.option("scrolling.useNative");
    if (!scrollable || isNativeScrolling) {
      deferRender((() => {
        deferUpdate((() => {
          this._setScrollerSpacingCore();
        }));
      }));
    } else {
      this._setScrollerSpacingCore();
    }
  }
  _setAriaOwns() {
    var _this$_columnHeadersV2, _this$_footerView2, _this$_rowsView2;
    const headerTable = null === (_this$_columnHeadersV2 = this._columnHeadersView) || void 0 === _this$_columnHeadersV2 ? void 0 : _this$_columnHeadersV2.getTableElement();
    const footerTable = null === (_this$_footerView2 = this._footerView) || void 0 === _this$_footerView2 ? void 0 : _this$_footerView2.getTableElement();
    null === (_this$_rowsView2 = this._rowsView) || void 0 === _this$_rowsView2 || _this$_rowsView2.setAriaOwns(null === headerTable || void 0 === headerTable ? void 0 : headerTable.attr("id"), null === footerTable || void 0 === footerTable ? void 0 : footerTable.attr("id"));
  }
  _updateDimensionsCore() {
    const that = this;
    const dataController2 = that._dataController;
    const rowsView18 = that._rowsView;
    const $rootElement = that.component.$element();
    const groupElement = this._getGroupElement();
    const rootElementHeight = getHeight($rootElement);
    const height = that.option("height") ?? $rootElement.get(0).style.height;
    const isHeightSpecified = !!height && "auto" !== height;
    const maxHeight = parseInt($rootElement.css("maxHeight"));
    const maxHeightHappened = maxHeight && rootElementHeight >= maxHeight;
    const isMaxHeightApplied = groupElement && groupElement.scrollHeight === groupElement.offsetHeight;
    that.updateSize($rootElement);
    deferRender((() => {
      const hasHeight = that._hasHeight || !!maxHeight || isHeightSpecified;
      rowsView18.hasHeight(hasHeight);
      this._setAriaOwns();
      if (maxHeightHappened && !isMaxHeightApplied) {
        renderer_default(groupElement).css("height", maxHeight);
      }
      if (!dataController2.isLoaded()) {
        rowsView18.setLoading(dataController2.isLoading());
        return;
      }
      deferUpdate((() => {
        that._updateLastSizes($rootElement);
        that._setScrollerSpacing();
        each(VIEW_NAMES2, ((index, viewName2) => {
          const view = that.getView(viewName2);
          if (view) {
            view.resize();
          }
        }));
        this._editorFactoryController && this._editorFactoryController.resize();
      }));
    }));
  }
  _updateLastSizes($rootElement) {
    this._lastWidth = getWidth($rootElement);
    this._lastHeight = getHeight($rootElement);
    this._devicePixelRatio = getWindow().devicePixelRatio;
  }
  optionChanged(args) {
    switch (args.name) {
      case "width":
      case "height":
        this.component._renderDimensions();
        this.resize();
      case "renderAsync":
        args.handled = true;
        return;
      default:
        super.optionChanged(args);
    }
  }
  resetLastResizeTime() {
  }
};
var SynchronizeScrollingController = class extends m_modules_default.ViewController {
  _scrollChangedHandler(views, pos, viewName2) {
    for (let j = 0; j < views.length; j++) {
      if (views[j] && views[j].name !== viewName2) {
        views[j].scrollTo({
          left: pos.left,
          top: pos.top
        });
      }
    }
  }
  init() {
    const views = [this.getView("columnHeadersView"), this.getView("footerView"), this.getView("rowsView")];
    for (let i = 0; i < views.length; i++) {
      const view = views[i];
      if (view) {
        view.scrollChanged.add(this._scrollChangedHandler.bind(this, views));
      }
    }
  }
};
var GridView = class extends m_modules_default.View {
  init() {
    this._resizingController = this.getController("resizing");
    this._dataController = this.getController("data");
  }
  _endUpdateCore() {
    if (this.component._requireResize) {
      this.component._requireResize = false;
      this._resizingController.resize();
    }
  }
  getView(name) {
    return this.component._views[name];
  }
  element() {
    return this._groupElement;
  }
  optionChanged(args) {
    const that = this;
    if (isDefined(that._groupElement) && "showBorders" === args.name) {
      that._groupElement.toggleClass(that.addWidgetPrefix("borders"), !!args.value);
      args.handled = true;
    } else {
      super.optionChanged(args);
    }
  }
  _renderViews($groupElement) {
    const that = this;
    each(VIEW_NAMES2, ((index, viewName2) => {
      const view = that.getView(viewName2);
      if (view) {
        view.render($groupElement);
      }
    }));
  }
  _getTableRoleName() {
    return "group";
  }
  render($rootElement) {
    const isFirstRender = !this._groupElement;
    const $groupElement = this._groupElement || renderer_default("<div>").addClass(this.getWidgetContainerClass());
    $groupElement.addClass("dx-gridbase-container");
    $groupElement.toggleClass(this.addWidgetPrefix("borders"), !!this.option("showBorders"));
    this.setAria("role", "presentation", $rootElement);
    this.component.setAria("role", this._getTableRoleName(), $groupElement);
    this._rootElement = $rootElement || this._rootElement;
    if (isFirstRender) {
      this._groupElement = $groupElement;
      hasWindow() && this._resizingController.updateSize($rootElement);
      $groupElement.appendTo($rootElement);
    }
    if (!this._a11yGeneralStatusElement) {
      this._a11yGeneralStatusElement = A11yStatusContainerComponent({});
      this._a11yGeneralStatusElement.attr(E2E_ATTRIBUTES.a11yStatusContainer, "true");
      $groupElement.append(this._a11yGeneralStatusElement);
    }
    this._renderViews($groupElement);
  }
  update() {
    const that = this;
    const $rootElement = that._rootElement;
    const $groupElement = that._groupElement;
    if ($rootElement && $groupElement) {
      this._resizingController.resize();
      if (that._dataController.isLoaded()) {
        that._resizingController.fireContentReadyAction();
      }
    }
  }
  setWidgetA11yStatusText(statusText) {
    var _this$_a11yGeneralSta;
    null === (_this$_a11yGeneralSta = this._a11yGeneralStatusElement) || void 0 === _this$_a11yGeneralSta || _this$_a11yGeneralSta.text(statusText);
  }
};
var gridViewModule = {
  defaultOptions: () => ({
    showBorders: false,
    renderAsync: false
  }),
  controllers: {
    resizing: ResizingController,
    synchronizeScrolling: SynchronizeScrollingController
  },
  views: {
    gridView: GridView
  },
  VIEW_NAMES: VIEW_NAMES2
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/grid_view.js
m_core_default.registerModule("gridView", gridViewModule);

// node_modules/devextreme/esm/__internal/grids/new/grid_core/toolbar/const.js
var DEFAULT_TOOLBAR_ITEMS = ["selectAllButton", "clearSelectionButton", "addCardButton", "columnChooserButton", "searchPanel"];

// node_modules/devextreme/esm/__internal/grids/new/grid_core/toolbar/utils.js
function isVisible(visibleConfig, items) {
  if (void 0 === visibleConfig) {
    return items.length > 0;
  }
  return visibleConfig;
}
function normalizeToolbarItem(item, defaultButtonsMap, defaultItemNames) {
  let button = item;
  if (isString(button)) {
    button = {
      name: button
    };
  }
  if (isDefined(button.name)) {
    if (isDefined(defaultButtonsMap[button.name])) {
      button = extend(true, {}, defaultButtonsMap[button.name], button);
    } else if (defaultItemNames.includes(button.name)) {
      button = _extends({}, button, {
        visible: false
      });
    }
  }
  return extend(true, {}, {
    location: "after"
  }, button);
}
function getSortedToolbarItems(defaultItemsCollection) {
  return Object.values(defaultItemsCollection).sort(((a, b) => {
    const aIndex = DEFAULT_TOOLBAR_ITEMS.indexOf(a.name);
    const bIndex = DEFAULT_TOOLBAR_ITEMS.indexOf(b.name);
    return aIndex - bIndex;
  }));
}
function normalizeToolbarItems(sortedDefaultItems, userItems, defaultItemNames) {
  if (!isDefined(userItems)) {
    return sortedDefaultItems;
  }
  const defaultButtonsMap = {};
  sortedDefaultItems.forEach(((button) => {
    defaultButtonsMap[button.name] = button;
  }));
  return userItems.map(((item) => normalizeToolbarItem(item, defaultButtonsMap, defaultItemNames)));
}

// node_modules/devextreme/esm/__internal/grids/grid_core/header_panel/m_header_panel.js
var DEFAULT_TOOLBAR_ITEM_NAMES = ["addRowButton", "applyFilterButton", "columnChooserButton", "exportButton", "groupPanel", "revertButton", "saveButton", "searchPanel"];
var HeaderPanel = class extends ColumnsView {
  init() {
    super.init();
    this._editingController = this.getController("editing");
    this._headerFilterController = this.getController("headerFilter");
    this.createAction("onToolbarPreparing", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _getToolbarItems() {
    return [];
  }
  _getButtonContainer() {
    return renderer_default("<div>").addClass(this.addWidgetPrefix("toolbar-button"));
  }
  _getToolbarButtonClass(specificClass) {
    const secondClass = specificClass ? ` ${specificClass}` : "";
    return this.addWidgetPrefix("toolbar-button") + secondClass;
  }
  _getToolbarOptions() {
    const userToolbarOptions = this.option("toolbar");
    const options = {
      toolbarOptions: {
        items: this._getToolbarItems(),
        visible: null === userToolbarOptions || void 0 === userToolbarOptions ? void 0 : userToolbarOptions.visible,
        disabled: null === userToolbarOptions || void 0 === userToolbarOptions ? void 0 : userToolbarOptions.disabled,
        onItemRendered(e) {
          const itemRenderedCallback = e.itemData.onItemRendered;
          if (itemRenderedCallback) {
            itemRenderedCallback(e);
          }
        }
      }
    };
    const userItems = null === userToolbarOptions || void 0 === userToolbarOptions ? void 0 : userToolbarOptions.items;
    options.toolbarOptions.items = normalizeToolbarItems(options.toolbarOptions.items, userItems, DEFAULT_TOOLBAR_ITEM_NAMES);
    this.executeAction("onToolbarPreparing", options);
    if (options.toolbarOptions && !isDefined(options.toolbarOptions.visible)) {
      const toolbarItems = options.toolbarOptions.items;
      options.toolbarOptions.visible = !!(null !== toolbarItems && void 0 !== toolbarItems && toolbarItems.length);
    }
    return options.toolbarOptions;
  }
  _renderCore() {
    if (!this._toolbar) {
      const $headerPanel = this.element();
      $headerPanel.addClass(this.addWidgetPrefix("header-panel"));
      const label = message_default.format(this.component.NAME + "-ariaToolbar");
      const $toolbar = renderer_default("<div>").attr("aria-label", label).appendTo($headerPanel);
      this._toolbar = this._createComponent($toolbar, toolbar_default, this._toolbarOptions);
    } else {
      this._toolbar.option(this._toolbarOptions);
    }
  }
  _columnOptionChanged() {
  }
  _handleDataChanged() {
    if (this._requireReady) {
      this.render();
    }
  }
  _isDisabledDefinedByUser(name) {
    var _this$option;
    const userItems = null === (_this$option = this.option("toolbar")) || void 0 === _this$option ? void 0 : _this$option.items;
    const userItem = null === userItems || void 0 === userItems ? void 0 : userItems.find(((item) => (null === item || void 0 === item ? void 0 : item.name) === name));
    return isDefined(null === userItem || void 0 === userItem ? void 0 : userItem.disabled);
  }
  render() {
    this._toolbarOptions = this._getToolbarOptions();
    super.render.apply(this, arguments);
  }
  setToolbarItemDisabled(name, disabled) {
    const toolbar = this._toolbar;
    const isDefinedByUser = this._isDisabledDefinedByUser(name);
    if (!toolbar || isDefinedByUser) {
      return;
    }
    const items = toolbar.option("items") ?? [];
    const itemIndex = items.findIndex(((item2) => item2.name === name));
    if (itemIndex < 0) {
      return;
    }
    const item = toolbar.option(`items[${itemIndex}]`);
    toolbar.option(`items[${itemIndex}].disabled`, disabled);
    if (item.options) {
      toolbar.option(`items[${itemIndex}].options.disabled`, disabled);
    }
  }
  updateToolbarDimensions() {
    var _this$_toolbar;
    null === (_this$_toolbar = this._toolbar) || void 0 === _this$_toolbar || _this$_toolbar.updateDimensions();
  }
  getHeaderPanel() {
    return this.element();
  }
  getHeight() {
    return this.getElementHeight();
  }
  optionChanged(args) {
    if ("onToolbarPreparing" === args.name) {
      this._invalidate();
      args.handled = true;
    }
    if ("toolbar" === args.name) {
      const parts = getPathParts(args.fullName);
      const optionName = args.fullName.replace(/^toolbar\./, "");
      if (1 === parts.length || "visible" === parts[1]) {
        this._invalidate();
      } else if ("items" === parts[1]) {
        if (2 === parts.length) {
          this._invalidate();
        } else if (3 === parts.length) {
          var _this$_toolbar2;
          const normalizedItem = normalizeToolbarItems(this._getToolbarItems(), [args.value], DEFAULT_TOOLBAR_ITEM_NAMES)[0];
          null === (_this$_toolbar2 = this._toolbar) || void 0 === _this$_toolbar2 || _this$_toolbar2.option(optionName, normalizedItem);
        } else if (parts.length >= 4) {
          var _this$_toolbar3;
          null === (_this$_toolbar3 = this._toolbar) || void 0 === _this$_toolbar3 || _this$_toolbar3.option(optionName, args.value);
        }
      } else {
        var _this$_toolbar4;
        null === (_this$_toolbar4 = this._toolbar) || void 0 === _this$_toolbar4 || _this$_toolbar4.option(optionName, args.value);
      }
      args.handled = true;
    }
    super.optionChanged(args);
  }
  isVisible() {
    return !!(this._toolbarOptions && this._toolbarOptions.visible);
  }
  allowDragging(column) {
    return false;
  }
  hasGroupedColumns() {
  }
  getContextMenuItems(options) {
    return;
  }
};
var resizing = (Base) => class extends Base {
  _updateDimensionsCore() {
    super._updateDimensionsCore.apply(this, arguments);
    this.getView("headerPanel").updateToolbarDimensions();
  }
};
var headerPanelModule = {
  defaultOptions: () => ({}),
  views: {
    headerPanel: HeaderPanel
  },
  extenders: {
    controllers: {
      resizing
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/header_panel.js
var HeaderPanel2 = headerPanelModule.views.headerPanel;
m_core_default.registerModule("headerPanel", headerPanelModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/m_widget_base.js
var GridCoreWidget = class extends ui_widget_default {
  _activeStateUnit() {
    return ".dx-row";
  }
  _getDefaultOptions() {
    const result = super._getDefaultOptions();
    each(this.getGridCoreHelper().modules, (function() {
      if (isFunction(this.defaultOptions)) {
        extend(true, result, this.defaultOptions());
      }
    }));
    return result;
  }
  _init() {
    super._init();
  }
  _setDeprecatedOptions() {
    super._setDeprecatedOptions();
    extend(this._deprecatedOptions, {
      "columnChooser.allowSearch": {
        since: "23.1",
        message: 'Use the "columnChooser.search.enabled" option instead'
      },
      "columnChooser.searchTimeout": {
        since: "23.1",
        message: 'Use the "columnChooser.search.timeout" option instead'
      }
    });
  }
  _clean() {
  }
  _optionChanged(args) {
    this.getGridCoreHelper().callModuleItemsMethod(this, "optionChanged", [args]);
    if (!args.handled) {
      super._optionChanged(args);
    }
  }
  _dimensionChanged() {
    this.updateDimensions(true);
  }
  _visibilityChanged(visible) {
    if (visible) {
      this.updateDimensions();
    }
  }
  _renderContentImpl() {
    this.getView("gridView").update();
  }
  _renderContent() {
    const that = this;
    deferRender((() => {
      that._renderContentImpl();
    }));
  }
  _dispose() {
    super._dispose();
    this.getGridCoreHelper().callModuleItemsMethod(this, "dispose");
  }
  isReady() {
    return this.getController("data").isReady();
  }
  getController(name) {
    return this._controllers[name];
  }
  getView(name) {
    return this._views[name];
  }
  getGridCoreHelper() {
  }
  beginUpdate() {
    super.beginUpdate();
    this.getGridCoreHelper().callModuleItemsMethod(this, "beginUpdate");
  }
  endUpdate() {
    this.getGridCoreHelper().callModuleItemsMethod(this, "endUpdate");
    super.endUpdate();
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/m_widget_base.js
var DATAGRID_DEPRECATED_TEMPLATE_WARNING = "Specifying grid templates with the jQuery selector name is now deprecated. Use the DOM Node or the jQuery object that references this selector instead.";
m_core_default.registerModulesOrder(["stateStoring", "columns", "selection", "editorFactory", "columnChooser", "grouping", "editing", "editingRowBased", "editingFormBased", "editingCellBased", "masterDetail", "validating", "adaptivity", "data", "virtualScrolling", "columnHeaders", "filterRow", "headerPanel", "headerFilter", "sorting", "search", "rows", "pager", "columnsResizingReordering", "contextMenu", "keyboardNavigation", "headersKeyboardNavigation", "groupPanelKeyboardNavigation", "errorHandling", "summary", "columnFixing", "export", "gridView"]);
var DataGrid = class extends GridCoreWidget {
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: {
        platform: "ios"
      },
      options: {
        showRowLines: true
      }
    }, {
      device: () => isMaterialBased(),
      options: {
        showRowLines: true,
        showColumnLines: false,
        headerFilter: {
          height: 315
        },
        editing: {
          useIcons: true
        },
        selection: {
          showCheckBoxesMode: "always"
        }
      }
    }, {
      device: () => browser_default.webkit,
      options: {
        loadingTimeout: 30,
        loadPanel: {
          animation: {
            show: {
              easing: "cubic-bezier(1, 0, 1, 0)",
              duration: 500,
              from: {
                opacity: 0
              },
              to: {
                opacity: 1
              }
            }
          }
        }
      }
    }, {
      device: (device) => "desktop" !== device.deviceType,
      options: {
        grouping: {
          expandMode: "rowClick"
        }
      }
    }]);
  }
  _init() {
    super._init();
    m_utils_default.logHeaderFilterDeprecatedWarningIfNeed(this);
    m_core_default.processModules(this, m_core_default);
    m_core_default.callModuleItemsMethod(this, "init");
  }
  _initMarkup() {
    super._initMarkup.apply(this, arguments);
    this.getView("gridView").render(this.$element());
  }
  _setDeprecatedOptions() {
    super._setDeprecatedOptions();
    extend(this._deprecatedOptions, {
      useKeyboard: {
        since: "19.2",
        alias: "keyboardNavigation.enabled"
      },
      rowTemplate: {
        since: "21.2",
        message: 'Use the "dataRowTemplate" option instead'
      }
    });
  }
  static registerModule(name, module) {
    m_core_default.registerModule(name, module);
  }
  getGridCoreHelper() {
    return m_core_default;
  }
  _getTemplate(templateName) {
    let template = templateName;
    if (isString(template) && template.startsWith("#")) {
      template = renderer_default(templateName);
      logger.warn(DATAGRID_DEPRECATED_TEMPLATE_WARNING);
    }
    return super._getTemplate(template);
  }
  focus(element) {
    this.getController("keyboardNavigation").focus(element);
  }
};
component_registrator_default("dxDataGrid", DataGrid);
var m_widget_base_default = DataGrid;

// node_modules/devextreme/esm/__internal/grids/grid_core/state_storing/m_state_storing_core.js
var DATE_REGEX = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/;
var parseDates = function(state) {
  if (!state) {
    return;
  }
  each(state, ((key, value2) => {
    if (isPlainObject(value2) || Array.isArray(value2)) {
      parseDates(value2);
    } else if ("string" === typeof value2) {
      const date = DATE_REGEX.exec(value2);
      if (date) {
        state[key] = new Date(Date.UTC(+date[1], +date[2] - 1, +date[3], +date[4], +date[5], +date[6]));
      }
    }
  }));
};
var getStorage = function(options) {
  const storage = "sessionStorage" === options.type ? getSessionStorage() : getWindow().localStorage;
  if (!storage) {
    throw new Error("E1007");
  }
  return storage;
};
var getUniqueStorageKey = function(options) {
  return isDefined(options.storageKey) ? options.storageKey : "storage";
};
var StateStoringController = class extends m_modules_default.ViewController {
  getDataController() {
    return this.getController("data");
  }
  getExportController() {
    return this.getController("export");
  }
  getColumnsController() {
    return this.getController("columns");
  }
  init() {
    this._state = {};
    this._isLoaded = false;
    this._isLoading = false;
    this._windowUnloadHandler = () => {
      if (void 0 !== this._savingTimeoutID) {
        this._saveState(this.state());
      }
    };
    m_events_engine_default.on(getWindow(), "visibilitychange", this._windowUnloadHandler);
    return this;
  }
  optionChanged(args) {
    const that = this;
    if ("stateStoring" === args.name) {
      if (that.isEnabled() && !that.isLoading()) {
        that.load();
      }
      args.handled = true;
    } else {
      super.optionChanged(args);
    }
  }
  dispose() {
    clearTimeout(this._savingTimeoutID);
    m_events_engine_default.off(getWindow(), "visibilitychange", this._windowUnloadHandler);
  }
  _loadState() {
    const options = this.option("stateStoring");
    if ("custom" === options.type) {
      return options.customLoad && options.customLoad();
    }
    try {
      return JSON.parse(getStorage(options).getItem(getUniqueStorageKey(options)));
    } catch (e) {
      ui_errors_default.log("W1022", "State storing", e.message);
    }
  }
  _saveState(state) {
    const options = this.option("stateStoring");
    if ("custom" === options.type) {
      options.customSave && options.customSave(state);
      return;
    }
    try {
      getStorage(options).setItem(getUniqueStorageKey(options), JSON.stringify(state));
    } catch (e) {
      ui_errors_default.log(e.message);
    }
  }
  publicMethods() {
    return ["state"];
  }
  isEnabled() {
    return this.option("stateStoring.enabled");
  }
  isLoaded() {
    return this._isLoaded;
  }
  isLoading() {
    return this._isLoading;
  }
  load() {
    this._isLoading = true;
    const loadResult = fromPromise(this._loadState());
    loadResult.always((() => {
      this._isLoaded = true;
      this._isLoading = false;
    })).done(((state) => {
      if (null !== state && !isEmptyObject(state)) {
        this.state(state);
      }
    }));
    return loadResult;
  }
  state(state) {
    const that = this;
    if (!arguments.length) {
      return extend(true, {}, that._state);
    }
    that._state = extend({}, state);
    parseDates(that._state);
  }
  save() {
    const that = this;
    clearTimeout(that._savingTimeoutID);
    that._savingTimeoutID = setTimeout((() => {
      that._saveState(that.state());
      that._savingTimeoutID = void 0;
    }), that.option("stateStoring.savingTimeout"));
  }
};
var m_state_storing_core_default = {
  StateStoringController
};

// node_modules/devextreme/esm/__internal/grids/grid_core/state_storing/m_state_storing.js
var getDataState = (that) => {
  const pagerView = that.getView("pagerView");
  const dataController2 = that.getController("data");
  const state = {
    allowedPageSizes: pagerView ? pagerView.getPageSizes() : void 0,
    filterPanel: {
      filterEnabled: that.option("filterPanel.filterEnabled")
    },
    filterValue: that.option("filterValue"),
    focusedRowKey: that.option("focusedRowEnabled") ? that.option("focusedRowKey") : void 0
  };
  return extend(state, dataController2.getUserState());
};
var processLoadState = (that) => {
  const columnsController = that.getController("columns");
  const selectionController = that.getController("selection");
  const exportController = that.getController("export");
  const dataController2 = that.getController("data");
  if (columnsController) {
    columnsController.columnsChanged.add((() => {
      that.updateState({
        columns: columnsController.getUserState()
      });
    }));
  }
  if (selectionController) {
    selectionController.selectionChanged.add(((e) => {
      that.updateState({
        selectedRowKeys: e.selectedRowKeys,
        selectionFilter: e.selectionFilter
      });
    }));
  }
  if (dataController2) {
    that._initialPageSize = that.option("paging.pageSize");
    that._initialFilterValue = that.option("filterValue");
    dataController2.changed.add((() => {
      const state = getDataState(that);
      that.updateState(state);
    }));
  }
  if (exportController) {
    exportController.selectionOnlyChanged.add((() => {
      that.updateState({
        exportSelectionOnly: exportController.selectionOnly()
      });
    }));
  }
};
var getFilterValue = (that, state) => {
  var _filterSyncController;
  const filterSyncController = that.getController("filterSync");
  if (!filterSyncController) {
    return null;
  }
  if (void 0 !== state.filterValue) {
    return state.filterValue;
  }
  const filterValueFromColumns = null === (_filterSyncController = filterSyncController.getFilterValueFromColumns) || void 0 === _filterSyncController ? void 0 : _filterSyncController.call(filterSyncController, state.columns);
  if ((null === filterValueFromColumns || void 0 === filterValueFromColumns ? void 0 : filterValueFromColumns.length) > 0) {
    return filterValueFromColumns;
  }
  const columns7 = that.getController("columns").getColumns();
  return that._initialFilterValue ?? filterSyncController.getFilterValueFromColumns(columns7);
};
var rowsView = (Base) => class extends Base {
  init() {
    super.init();
    this._dataController.stateLoaded.add((() => {
      if (this._dataController.isLoaded() && !this._dataController.getDataSource()) {
        this.setLoading(false);
        this.renderNoDataText();
        const columnHeadersView10 = this.component.getView("columnHeadersView");
        columnHeadersView10 && columnHeadersView10.render();
        this.component._fireContentReadyAction();
      }
    }));
  }
};
var stateStoring = (Base) => class extends Base {
  init() {
    super.init.apply(this, arguments);
    processLoadState(this);
    return this;
  }
  isLoading() {
    return super.isLoading() || this.getDataController().isStateLoading();
  }
  state(state) {
    const result = super.state.apply(this, arguments);
    if (void 0 !== state) {
      this.applyState(extend(true, {}, state));
    }
    return result;
  }
  updateState(state) {
    if (this.isEnabled()) {
      const oldState = this.state();
      const newState = extend({}, oldState, state);
      const oldStateHash = getKeyHash(oldState);
      const newStateHash = getKeyHash(newState);
      if (!equalByValue(oldStateHash, newStateHash)) {
        state = extend(true, {}, state);
        extend(this._state, state);
        this.save();
      }
    } else {
      extend(this._state, state);
    }
  }
  applyState(state) {
    var _this$getView;
    const {
      allowedPageSizes
    } = state;
    const {
      searchText
    } = state;
    const {
      selectedRowKeys
    } = state;
    const {
      selectionFilter
    } = state;
    const scrollingMode = this.option("scrolling.mode");
    const isVirtualScrollingMode = "virtual" === scrollingMode || "infinite" === scrollingMode;
    const showPageSizeSelector = true === this.option("pager.visible") && this.option("pager.showPageSizeSelector");
    const hasHeight = null === (_this$getView = this.getView("rowsView")) || void 0 === _this$getView ? void 0 : _this$getView.hasHeight();
    this.component.beginUpdate();
    if (this.getColumnsController()) {
      this.getColumnsController().setUserState(state.columns);
    }
    if (this.getExportController()) {
      this.getExportController().selectionOnly(state.exportSelectionOnly);
    }
    if (!this.option("selection.deferred")) {
      this.option("selectedRowKeys", selectedRowKeys || []);
    }
    this.option("selectionFilter", selectionFilter);
    if (allowedPageSizes && "auto" === this.option("pager.allowedPageSizes")) {
      this.option("pager").allowedPageSizes = allowedPageSizes;
    }
    if (this.option("focusedRowEnabled")) {
      this.option("focusedRowIndex", -1);
      this.option("focusedRowKey", state.focusedRowKey ?? null);
    }
    this.component.endUpdate();
    this.option("searchPanel.text", searchText || "");
    this.option("filterValue", getFilterValue(this, state));
    this.option("filterPanel.filterEnabled", state.filterPanel ? state.filterPanel.filterEnabled : true);
    this.option("paging.pageIndex", (!isVirtualScrollingMode || hasHeight) && state.pageIndex || 0);
    this.option("paging.pageSize", (!isVirtualScrollingMode || showPageSizeSelector) && isDefined(state.pageSize) ? state.pageSize : this._initialPageSize);
    this.getDataController() && this.getDataController().reset();
  }
};
var columns = (Base) => class extends Base {
  _shouldReturnVisibleColumns() {
    const result = super._shouldReturnVisibleColumns.apply(this, arguments);
    return result && (!this._stateStoringController.isEnabled() || this._stateStoringController.isLoaded());
  }
};
var data3 = (Base) => class extends Base {
  dispose() {
    clearTimeout(this._restoreStateTimeoutID);
    super.dispose();
  }
  callbackNames() {
    return super.callbackNames().concat(["stateLoaded"]);
  }
  _refreshDataSource() {
    if (this._stateStoringController.isEnabled() && !this._stateStoringController.isLoaded()) {
      clearTimeout(this._restoreStateTimeoutID);
      const deferred = new Deferred();
      this._restoreStateTimeoutID = setTimeout((() => {
        this._stateStoringController.load().always((() => {
          this._restoreStateTimeoutID = null;
        })).done((() => {
          super._refreshDataSource();
          this.stateLoaded.fire();
          deferred.resolve();
        })).fail(((error) => {
          this.stateLoaded.fire();
          this._handleLoadError(error || "Unknown error");
          deferred.reject();
        }));
      }));
      return deferred.promise();
    }
    if (!this.isStateLoading()) {
      super._refreshDataSource();
    }
  }
  isLoading() {
    return super.isLoading() || this._stateStoringController.isLoading();
  }
  isStateLoading() {
    return isDefined(this._restoreStateTimeoutID);
  }
  isLoaded() {
    return super.isLoaded() && !this.isStateLoading();
  }
};
var selection = (Base) => class extends Base {
  _fireSelectionChanged(options) {
    const isDeferredSelection = this.option("selection.deferred");
    if (this._stateStoringController.isLoading() && isDeferredSelection) {
      return;
    }
    super._fireSelectionChanged.apply(this, arguments);
  }
};
var stateStoringModule = {
  defaultOptions: () => ({
    stateStoring: {
      enabled: false,
      storageKey: null,
      type: "localStorage",
      customLoad: null,
      customSave: null,
      savingTimeout: 2e3
    }
  }),
  controllers: {
    stateStoring: StateStoringController
  },
  extenders: {
    views: {
      rowsView
    },
    controllers: {
      stateStoring,
      columns,
      data: data3,
      selection
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/state_storing.js
m_core_default.registerModule("stateStoring", stateStoringModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/selection/m_selection.js
var CHECKBOXES_HIDDEN_CLASS = "dx-select-checkboxes-hidden";
var SHOW_CHECKBOXES_MODE = "selection.showCheckBoxesMode";
var SELECTION_MODE = "selection.mode";
var processLongTap = function(that, dxEvent) {
  const rowsView18 = that.getView("rowsView");
  const selectionController = that.getController("selection");
  const $row = renderer_default(dxEvent.target).closest(".dx-data-row");
  const rowIndex = rowsView18.getRowIndex($row);
  if (rowIndex < 0) {
    return;
  }
  if ("onLongTap" === that.option(SHOW_CHECKBOXES_MODE)) {
    if (selectionController.isSelectionWithCheckboxes()) {
      selectionController.stopSelectionWithCheckboxes();
    } else {
      selectionController.startSelectionWithCheckboxes();
    }
  } else {
    if ("onClick" === that.option(SHOW_CHECKBOXES_MODE)) {
      selectionController.startSelectionWithCheckboxes();
    }
    if ("always" !== that.option(SHOW_CHECKBOXES_MODE)) {
      selectionController.changeItemSelection(rowIndex, {
        control: true
      });
    }
  }
};
var isSeveralRowsSelected = function(that, selectionFilter) {
  let keyIndex = 0;
  const store = that._dataController.store();
  const key = null === store || void 0 === store ? void 0 : store.key();
  const isComplexKey = Array.isArray(key);
  if (!selectionFilter.length) {
    return false;
  }
  if (isComplexKey && Array.isArray(selectionFilter[0]) && "and" === selectionFilter[1]) {
    for (let i = 0; i < selectionFilter.length; i++) {
      if (Array.isArray(selectionFilter[i])) {
        if (selectionFilter[i][0] !== key[keyIndex] || "=" !== selectionFilter[i][1]) {
          return true;
        }
        keyIndex++;
      }
    }
    return false;
  }
  return key !== selectionFilter[0];
};
var selectionCellTemplate = (container, options) => {
  const {
    component
  } = options;
  const rowsView18 = component.getView("rowsView");
  if (component.option("renderAsync") && !component.option("selection.deferred")) {
    options.value = component.isRowSelected(options.row.key);
  }
  rowsView18.renderSelectCheckBoxContainer(renderer_default(container), options);
};
var selectionHeaderTemplate = (container, options) => {
  const {
    column
  } = options;
  const $cellElement = renderer_default(container);
  const columnHeadersView10 = options.component.getView("columnHeadersView");
  $cellElement.addClass("dx-editor-cell");
  columnHeadersView10._renderSelectAllCheckBox($cellElement, column);
  columnHeadersView10._attachSelectAllCheckBoxClickEvent($cellElement);
};
var SelectionController = class extends m_modules_default.Controller {
  init() {
    const {
      deferred,
      selectAllMode,
      mode
    } = this.option("selection") ?? {};
    if ("infinite" === this.option("scrolling.mode") && !deferred && "multiple" === mode && "allPages" === selectAllMode) {
      ui_errors_default.log("W1018");
    }
    this._dataController = this.getController("data");
    this._columnsController = this.getController("columns");
    this._stateStoringController = this.getController("stateStoring");
    this._selectionMode = mode;
    this._isSelectionWithCheckboxes = false;
    this._selection = this._createSelection();
    this._updateSelectColumn();
    this.createAction("onSelectionChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
    if (!this._dataPushedHandler) {
      this._dataPushedHandler = this._handleDataPushed.bind(this);
      this._dataController.pushed.add(this._dataPushedHandler);
    }
  }
  _handleDataPushed(changes) {
    this._deselectRemovedOnPush(changes);
    this._updateSelectedOnPush(changes);
  }
  _deselectRemovedOnPush(changes) {
    const isDeferredSelection = this.option("selection.deferred");
    let removedKeys = changes.filter(((change) => "remove" === change.type)).map(((change) => change.key));
    if (isDeferredSelection) {
      const selectedKeys = this._dataController.items().filter(((item) => item.isSelected)).map(((item) => item.key));
      removedKeys = removedKeys.filter(((key) => selectedKeys.find(((selectedKey) => equalByValue(selectedKey, key)))));
    }
    removedKeys.length && this.deselectRows(removedKeys);
  }
  _updateSelectedOnPush(changes) {
    const isDeferredSelection = this.option("selection.deferred");
    if (isDeferredSelection) {
      return;
    }
    const updateChanges = changes.filter(((change) => "update" === change.type));
    const data17 = this.getSelectedRowsData();
    applyBatch({
      keyInfo: this._selection.options,
      data: data17,
      changes: updateChanges
    });
  }
  _getSelectionConfig() {
    const dataController2 = this._dataController;
    const columnsController = this._columnsController;
    const selectionOptions = this.option("selection") ?? {};
    const {
      deferred
    } = selectionOptions;
    const scrollingMode = this.option("scrolling.mode");
    const virtualPaging = "virtual" === scrollingMode || "infinite" === scrollingMode;
    const allowSelectAll = this.option("selection.allowSelectAll");
    const legacyScrollingMode = this.option("scrolling.legacyMode");
    return {
      selectedKeys: this.option("selectedRowKeys"),
      mode: this._selectionMode,
      deferred,
      alwaysSelectByShift: selectionOptions.alwaysSelectByShift,
      maxFilterLengthInRequest: selectionOptions.maxFilterLengthInRequest,
      selectionFilter: this.option("selectionFilter"),
      ignoreDisabledItems: true,
      isVirtualPaging: virtualPaging,
      sensitivity: this.option("selection.sensitivity"),
      allowLoadByRange() {
        const hasGroupColumns = columnsController.getGroupColumns().length > 0;
        return virtualPaging && !legacyScrollingMode && !hasGroupColumns && allowSelectAll && !deferred;
      },
      key: () => null === dataController2 || void 0 === dataController2 ? void 0 : dataController2.key(),
      keyOf: (item) => null === dataController2 || void 0 === dataController2 ? void 0 : dataController2.keyOf(item),
      dataFields() {
        var _dataController$dataS;
        return null === (_dataController$dataS = dataController2.dataSource()) || void 0 === _dataController$dataS ? void 0 : _dataController$dataS.select();
      },
      load(options) {
        var _dataController$dataS2;
        return (null === (_dataController$dataS2 = dataController2.dataSource()) || void 0 === _dataController$dataS2 ? void 0 : _dataController$dataS2.load(options)) || new Deferred().resolve([]);
      },
      plainItems: (cached) => dataController2.items(true),
      isItemSelected: (item) => item.selected,
      isSelectableItem: (item) => "data" === (null === item || void 0 === item ? void 0 : item.rowType) && !item.isNewRow,
      getItemData: (item) => isDefined(null === item || void 0 === item ? void 0 : item.rowType) ? (null === item || void 0 === item ? void 0 : item.oldData) || (null === item || void 0 === item ? void 0 : item.data) : item,
      filter: () => dataController2.getCombinedFilter(deferred),
      totalCount: () => dataController2.totalCount(),
      getLoadOptions(loadItemIndex, focusedItemIndex, shiftItemIndex) {
        var _dataController$dataS3;
        const {
          sort,
          filter
        } = (null === (_dataController$dataS3 = dataController2.dataSource()) || void 0 === _dataController$dataS3 ? void 0 : _dataController$dataS3.lastLoadOptions()) ?? {};
        let minIndex = Math.min(loadItemIndex, focusedItemIndex);
        let maxIndex = Math.max(loadItemIndex, focusedItemIndex);
        if (isDefined(shiftItemIndex)) {
          minIndex = Math.min(shiftItemIndex, minIndex);
          maxIndex = Math.max(shiftItemIndex, maxIndex);
        }
        const take = maxIndex - minIndex + 1;
        return {
          skip: minIndex,
          take,
          filter,
          sort
        };
      },
      onSelectionChanged: this._updateSelectedItems.bind(this)
    };
  }
  _updateSelectColumn() {
    const columnsController = this._columnsController;
    const isSelectColumnVisible = this.isSelectColumnVisible();
    columnsController.addCommandColumn({
      type: "selection",
      command: "select",
      visible: isSelectColumnVisible,
      visibleIndex: -1,
      dataType: "boolean",
      alignment: "center",
      cssClass: "dx-command-select",
      width: "auto",
      cellTemplate: selectionCellTemplate,
      headerCellTemplate: selectionHeaderTemplate
    });
    columnsController.columnOption("command:select", "visible", isSelectColumnVisible);
  }
  _createSelection() {
    const options = this._getSelectionConfig();
    return new Selection(options);
  }
  _fireSelectionChanged(options) {
    const argument = this.option("selection.deferred") ? {
      selectionFilter: this.option("selectionFilter")
    } : {
      selectedRowKeys: this.option("selectedRowKeys")
    };
    this.selectionChanged.fire(argument);
    if (options) {
      this.executeAction("onSelectionChanged", options);
    }
  }
  _updateCheckboxesState(options) {
    const {
      isDeferredMode
    } = options;
    const {
      selectionFilter
    } = options;
    const {
      selectedItemKeys
    } = options;
    const {
      removedItemKeys
    } = options;
    if ("onClick" === this.option(SHOW_CHECKBOXES_MODE)) {
      if (isDeferredMode ? selectionFilter && isSeveralRowsSelected(this, selectionFilter) : selectedItemKeys.length > 1) {
        this.startSelectionWithCheckboxes();
      } else if (isDeferredMode ? selectionFilter && !selectionFilter.length : 0 === selectedItemKeys.length && removedItemKeys.length) {
        this.stopSelectionWithCheckboxes();
      }
    }
  }
  _updateSelectedItems(args) {
    const that = this;
    let selectionChangedOptions;
    const isDeferredMode = that.option("selection.deferred");
    const selectionFilter = that._selection.selectionFilter();
    const dataController2 = that._dataController;
    const items = dataController2.items(true);
    const visibleItems = dataController2.items();
    if (!items) {
      return;
    }
    const isSelectionWithCheckboxes = that.isSelectionWithCheckboxes();
    const changedItemIndexes = that.getChangedItemIndexes(items);
    const visibleChangedItemIndexes = that.getChangedItemIndexes(visibleItems);
    that._updateCheckboxesState({
      selectedItemKeys: args.selectedItemKeys,
      removedItemKeys: args.removedItemKeys,
      selectionFilter,
      isDeferredMode
    });
    if (changedItemIndexes.length || isSelectionWithCheckboxes !== that.isSelectionWithCheckboxes()) {
      dataController2.updateItems({
        changeType: "updateSelection",
        itemIndexes: visibleChangedItemIndexes
      });
    }
    if (isDeferredMode) {
      that.option("selectionFilter", selectionFilter);
      selectionChangedOptions = {};
    } else if (args.addedItemKeys.length || args.removedItemKeys.length) {
      that._selectedItemsInternalChange = true;
      that.option("selectedRowKeys", args.selectedItemKeys.slice(0));
      that._selectedItemsInternalChange = false;
      selectionChangedOptions = {
        selectedRowsData: args.selectedItems.slice(0),
        selectedRowKeys: args.selectedItemKeys.slice(0),
        currentSelectedRowKeys: args.addedItemKeys.slice(0),
        currentDeselectedRowKeys: args.removedItemKeys.slice(0)
      };
    }
    that._fireSelectionChanged(selectionChangedOptions);
  }
  getChangedItemIndexes(items) {
    const that = this;
    const itemIndexes = [];
    const isDeferredSelection = this.option("selection.deferred");
    for (let i = 0, {
      length
    } = items; i < length; i++) {
      const row = items[i];
      const isItemSelected = that.isRowSelected(isDeferredSelection ? row.data : row.key);
      if (that._selection.isDataItem(row) && row.isSelected !== isItemSelected) {
        itemIndexes.push(i);
      }
    }
    return itemIndexes;
  }
  callbackNames() {
    return ["selectionChanged"];
  }
  optionChanged(args) {
    var _this$_selection;
    super.optionChanged(args);
    const selectionOptionsExists = !!(null !== (_this$_selection = this._selection) && void 0 !== _this$_selection && _this$_selection.options);
    switch (args.name) {
      case "selection": {
        const oldSelectionMode = this._selectionMode;
        this.init();
        if (selectionOptionsExists && "selection.sensitivity" === args.fullName) {
          this._selection.options.sensitivity = args.value;
        }
        if ("selection.showCheckBoxesMode" !== args.fullName) {
          const selectionMode = this._selectionMode;
          let selectedRowKeys = this.option("selectedRowKeys");
          if (oldSelectionMode !== selectionMode) {
            if ("single" === selectionMode) {
              if (selectedRowKeys.length > 1) {
                selectedRowKeys = [selectedRowKeys[0]];
              }
            } else if ("multiple" !== selectionMode) {
              selectedRowKeys = [];
            }
          }
          this.selectRows(selectedRowKeys).always((() => {
            this._fireSelectionChanged();
          }));
        }
        this._columnsController.updateColumns();
        args.handled = true;
        break;
      }
      case "selectionFilter":
        this._selection.selectionFilter(args.value);
        args.handled = true;
        break;
      case "selectedRowKeys": {
        const value2 = args.value || [];
        if (Array.isArray(value2) && !this._selectedItemsInternalChange && (this.component.getDataSource() || !value2.length)) {
          this.selectRows(value2);
        }
        args.handled = true;
        break;
      }
    }
  }
  publicMethods() {
    return ["selectRows", "deselectRows", "selectRowsByIndexes", "getSelectedRowKeys", "getSelectedRowsData", "clearSelection", "selectAll", "deselectAll", "startSelectionWithCheckboxes", "stopSelectionWithCheckboxes", "isRowSelected"];
  }
  isRowSelected(arg) {
    return this._selection.isItemSelected(arg);
  }
  isSelectColumnVisible() {
    return "multiple" === this.option(SELECTION_MODE) && ("always" === this.option(SHOW_CHECKBOXES_MODE) || "onClick" === this.option(SHOW_CHECKBOXES_MODE) || this._isSelectionWithCheckboxes);
  }
  _isOnePageSelectAll() {
    return "page" === this.option("selection.selectAllMode");
  }
  isSelectAll() {
    return this._selection.getSelectAllState(this._isOnePageSelectAll());
  }
  selectAll() {
    if ("onClick" === this.option(SHOW_CHECKBOXES_MODE)) {
      this.startSelectionWithCheckboxes();
    }
    return this._selection.selectAll(this._isOnePageSelectAll());
  }
  deselectAll() {
    return this._selection.deselectAll(this._isOnePageSelectAll());
  }
  clearSelection() {
    return this.selectedItemKeys([]);
  }
  refresh() {
    const selectedRowKeys = this.option("selectedRowKeys") ?? [];
    if (!this.option("selection.deferred") && selectedRowKeys.length) {
      return this.selectedItemKeys(selectedRowKeys);
    }
    return new Deferred().resolve().promise();
  }
  selectedItemKeys(value2, preserve, isDeselect, isSelectAll) {
    return this._selection.selectedItemKeys(value2, preserve, isDeselect, isSelectAll);
  }
  getSelectedRowKeys(mode) {
    return this._selection.getSelectedItemKeys();
  }
  selectRows(keys, preserve) {
    return this.selectedItemKeys(keys, preserve);
  }
  deselectRows(keys) {
    return this.selectedItemKeys(keys, true, true);
  }
  selectRowsByIndexes(indexes) {
    const items = this._dataController.items();
    const keys = [];
    if (!Array.isArray(indexes)) {
      indexes = Array.prototype.slice.call(arguments, 0);
    }
    each(indexes, (function() {
      const item = items[this];
      if (item && "data" === item.rowType) {
        keys.push(item.key);
      }
    }));
    return this.selectRows(keys);
  }
  getSelectedRowsData(mode) {
    return this._selection.getSelectedItems();
  }
  loadSelectedItemsWithFilter() {
    return this._selection.loadSelectedItemsWithFilter();
  }
  changeItemSelection(visibleItemIndex, keys, setFocusOnly) {
    keys = keys || {};
    if (this.isSelectionWithCheckboxes()) {
      keys.control = true;
    }
    const loadedItemIndex = visibleItemIndex + this._dataController.getRowIndexOffset() - this._dataController.getRowIndexOffset(true);
    return this._selection.changeItemSelection(loadedItemIndex, keys, setFocusOnly);
  }
  focusedItemIndex(itemIndex) {
    const that = this;
    if (isDefined(itemIndex)) {
      that._selection._focusedItemIndex = itemIndex;
    } else {
      return that._selection._focusedItemIndex;
    }
    return;
  }
  isSelectionWithCheckboxes() {
    return "multiple" === this.option(SELECTION_MODE) && ("always" === this.option(SHOW_CHECKBOXES_MODE) || this._isSelectionWithCheckboxes);
  }
  startSelectionWithCheckboxes() {
    const that = this;
    if ("multiple" === that.option(SELECTION_MODE) && !that.isSelectionWithCheckboxes()) {
      that._isSelectionWithCheckboxes = true;
      that._updateSelectColumn();
      return true;
    }
    return false;
  }
  stopSelectionWithCheckboxes() {
    const that = this;
    if (that._isSelectionWithCheckboxes) {
      that._isSelectionWithCheckboxes = false;
      that._updateSelectColumn();
      return true;
    }
    return false;
  }
};
var dataSelectionExtenderMixin = (Base) => class extends Base {
  init() {
    const isDeferredMode = this.option("selection.deferred");
    super.init.apply(this, arguments);
    if (isDeferredMode) {
      this._selectionController._updateCheckboxesState({
        isDeferredMode: true,
        selectionFilter: this.option("selectionFilter")
      });
    }
  }
  _loadDataSource() {
    const that = this;
    return super._loadDataSource().always((() => {
      that._selectionController.refresh();
    }));
  }
  _processDataItem(item, options) {
    const hasSelectColumn = this._selectionController.isSelectColumnVisible();
    const isDeferredSelection = options.isDeferredSelection = void 0 === options.isDeferredSelection ? this.option("selection.deferred") : options.isDeferredSelection;
    const dataItem = super._processDataItem.apply(this, arguments);
    dataItem.isSelected = this._selectionController.isRowSelected(isDeferredSelection ? dataItem.data : dataItem.key);
    if (hasSelectColumn && dataItem.values) {
      for (let i = 0; i < options.visibleColumns.length; i++) {
        if ("select" === options.visibleColumns[i].command) {
          dataItem.values[i] = dataItem.isSelected;
          break;
        }
      }
    }
    return dataItem;
  }
  refresh(options) {
    const d = new Deferred();
    super.refresh(options).done((() => {
      const skipSelectionRefresh = isObject(options) && !options.selection;
      if (skipSelectionRefresh) {
        d.resolve();
        return;
      }
      this._selectionController.refresh().done(d.resolve).fail(d.reject);
    })).fail(d.reject);
    return d.promise();
  }
  _handleDataChanged(e) {
    const hasLoadOperation = this.hasLoadOperation();
    super._handleDataChanged.apply(this, arguments);
    if (hasLoadOperation && !this._repaintChangesOnly) {
      this._selectionController.focusedItemIndex(-1);
    }
  }
  _applyChange(change) {
    if (change && "updateSelection" === change.changeType) {
      change.items.forEach(((item, index) => {
        const currentItem = this._items[index];
        if (currentItem) {
          currentItem.isSelected = item.isSelected;
          currentItem.values = item.values;
        }
      }));
      return;
    }
    return super._applyChange.apply(this, arguments);
  }
  _endUpdateCore() {
    const changes = this._changes;
    const isUpdateSelection = changes.length > 1 && changes.every(((change) => "updateSelection" === change.changeType));
    if (isUpdateSelection) {
      const itemIndexes = changes.map(((change) => change.itemIndexes || [])).reduce(((a, b) => a.concat(b)));
      this._changes = [{
        changeType: "updateSelection",
        itemIndexes
      }];
    }
    super._endUpdateCore.apply(this, arguments);
  }
};
var contextMenu = (Base) => class extends Base {
  _contextMenuPrepared(options) {
    const dxEvent = options.event;
    if (dxEvent.originalEvent && "dxhold" !== dxEvent.originalEvent.type || options.items && options.items.length > 0) {
      return;
    }
    processLongTap(this, dxEvent);
  }
};
var columnHeadersSelectionExtenderMixin = (Base) => class extends Base {
  init() {
    super.init();
    this._selectionController.selectionChanged.add(this._updateSelectAllValue.bind(this));
  }
  _isSelectAllCheckBoxVisible() {
    const isEmptyData = this._dataController.isEmpty();
    const allowSelectAll = this.option("selection.allowSelectAll");
    const isSelectAll = this._selectionController.isSelectAll();
    return !isEmptyData && (allowSelectAll || false !== isSelectAll);
  }
  _updateSelectAllValue() {
    const $element = this.element();
    const $editor = null === $element || void 0 === $element ? void 0 : $element.find(".dx-select-checkbox");
    if ($element && $editor.length && "multiple" === this.option("selection.mode")) {
      const selectAllValue = this._selectionController.isSelectAll();
      const isVisible2 = this._isSelectAllCheckBoxVisible();
      $editor.dxCheckBox("instance").option({
        visible: isVisible2,
        value: selectAllValue
      });
    }
  }
  _handleDataChanged(e) {
    super._handleDataChanged(e);
    if (!e || "refresh" === e.changeType || e.repaintChangesOnly && "update" === e.changeType) {
      this.waitAsyncTemplates().done((() => {
        this._updateSelectAllValue();
      }));
    }
  }
  _renderSelectAllCheckBox($container, column) {
    const $checkbox = this._createSelectAllCheckboxElement(column);
    $checkbox.appendTo($container);
    return $checkbox;
  }
  _createSelectAllCheckboxElement(column) {
    const $groupElement = renderer_default("<div>").addClass("dx-select-checkbox");
    this.setAria("label", message_default.format("dxDataGrid-ariaSelectAll"), $groupElement);
    this._editorFactoryController.createEditor($groupElement, extend({}, column, {
      parentType: "headerRow",
      dataType: "boolean",
      value: this._selectionController.isSelectAll(),
      editorOptions: {
        visible: this._isSelectAllCheckBoxVisible()
      },
      tabIndex: this.option("useLegacyKeyboardNavigation") ? -1 : this.option("tabIndex") || 0,
      setValue: (value2, e) => {
        const allowSelectAll = this.option("selection.allowSelectAll");
        e.component.option("visible", allowSelectAll || false !== e.component.option("value"));
        if (!e.event || this._selectionController.isSelectAll() === value2) {
          return;
        }
        if (e.value && !allowSelectAll) {
          e.component.option("value", false);
        } else {
          e.value ? this._selectionController.selectAll() : this._selectionController.deselectAll();
        }
        e.event.preventDefault();
      }
    }));
    return $groupElement;
  }
  _attachSelectAllCheckBoxClickEvent($element) {
    m_events_engine_default.on($element, CLICK_EVENT_NAME, this.createAction(((e) => {
      const {
        event
      } = e;
      if (!this._isSelectAllCheckBoxVisible()) {
        event.preventDefault();
        return;
      }
      if (!renderer_default(event.target).closest(".dx-select-checkbox").length) {
        m_events_engine_default.trigger(renderer_default(event.currentTarget).children(".dx-select-checkbox"), CLICK_EVENT_NAME);
      }
      event.preventDefault();
    })));
  }
};
var rowsViewSelectionExtenderMixin = (Base) => class extends Base {
  renderSelectCheckBoxContainer($container, options) {
    if ("data" === options.rowType && !options.row.isNewRow) {
      $container.addClass("dx-editor-cell");
      this._attachCheckBoxClickEvent($container);
      this._renderSelectCheckBox($container, options);
    } else {
      m_utils_default.setEmptyText($container);
    }
  }
  _renderSelectCheckBox(container, options) {
    const groupElement = renderer_default("<div>").addClass("dx-select-checkbox").appendTo(container);
    this.setAria("label", message_default.format("dxDataGrid-ariaSelectRow"), groupElement);
    this._editorFactoryController.createEditor(groupElement, extend({}, options.column, {
      parentType: "dataRow",
      dataType: "boolean",
      lookup: null,
      value: options.value,
      setValue(value2, e) {
        var _e$event;
        if ("keydown" === (null === e || void 0 === e || null === (_e$event = e.event) || void 0 === _e$event ? void 0 : _e$event.type)) {
          m_events_engine_default.trigger(e.element, CLICK_EVENT_NAME, e);
        }
      },
      row: options.row
    }));
    return groupElement;
  }
  _attachCheckBoxClickEvent($element) {
    m_events_engine_default.on($element, CLICK_EVENT_NAME, this.createAction((function(e) {
      const {
        event
      } = e;
      const rowIndex = this.getRowIndex(renderer_default(event.currentTarget).closest(".dx-row"));
      if (rowIndex >= 0) {
        this._selectionController.startSelectionWithCheckboxes();
        this._selectionController.changeItemSelection(rowIndex, {
          shift: event.shiftKey
        });
        if (renderer_default(event.target).closest(".dx-select-checkbox").length) {
          this._dataController.updateItems({
            changeType: "updateSelection",
            itemIndexes: [rowIndex]
          });
        }
      }
    })));
  }
  _update(change) {
    const that = this;
    const tableElements = that.getTableElements();
    if ("updateSelection" === change.changeType) {
      if (tableElements.length > 0) {
        each(tableElements, ((_, tableElement) => {
          each(change.itemIndexes || [], ((_2, index) => {
            let $row;
            if (change.items[index]) {
              $row = that._getRowElements(renderer_default(tableElement)).eq(index);
              if ($row.length) {
                const {
                  isSelected
                } = change.items[index];
                $row.toggleClass("dx-selection", void 0 === isSelected ? false : isSelected).find(".dx-select-checkbox").dxCheckBox("option", "value", isSelected);
                that.setAria("selected", isSelected, $row);
              }
            }
          }));
        }));
        that._updateCheckboxesClass();
      }
    } else {
      super._update(change);
    }
  }
  _createTable() {
    const that = this;
    const selectionMode = that.option("selection.mode");
    const $table = super._createTable.apply(that, arguments);
    if ("none" !== selectionMode) {
      if ("onLongTap" === that.option(SHOW_CHECKBOXES_MODE) || !m_support_default.touch) {
        m_events_engine_default.on($table, addNamespace(m_hold_default.name, "dxDataGridRowsView"), ".dx-data-row", that.createAction(((e) => {
          processLongTap(that.component, e.event);
          e.event.stopPropagation();
        })));
      }
      m_events_engine_default.on($table, "mousedown selectstart", that.createAction(((e) => {
        const {
          event
        } = e;
        if (event.shiftKey) {
          event.preventDefault();
        }
      })));
    }
    return $table;
  }
  _createRow(row) {
    const $row = super._createRow.apply(this, arguments);
    if (row) {
      const {
        isSelected
      } = row;
      if (isSelected) {
        $row.addClass("dx-selection");
      }
      const selectionMode = this.option(SELECTION_MODE);
      if ("none" !== selectionMode) {
        this.setAria("selected", isSelected, $row);
      }
    }
    return $row;
  }
  _rowClickForTreeList(e) {
    super._rowClick(e);
  }
  _rowClick(e) {
    const that = this;
    const dxEvent = e.event;
    const isSelectionDisabled = renderer_default(dxEvent.target).closest(".dx-selection-disabled").length;
    if (!that.isClickableElement(renderer_default(dxEvent.target))) {
      if (!isSelectionDisabled && ("multiple" !== that.option(SELECTION_MODE) || "always" !== that.option(SHOW_CHECKBOXES_MODE))) {
        if (that._selectionController.changeItemSelection(e.rowIndex, {
          control: isCommandKeyPressed(dxEvent),
          shift: dxEvent.shiftKey
        })) {
          dxEvent.preventDefault();
          e.handled = true;
        }
      }
      super._rowClick(e);
    }
  }
  isClickableElement($target) {
    const isCommandSelect = $target.closest(".dx-command-select").length;
    return !!isCommandSelect;
  }
  _renderCore(change) {
    const deferred = super._renderCore(change);
    this._updateCheckboxesClass();
    return deferred;
  }
  _updateCheckboxesClass() {
    const tableElements = this.getTableElements();
    const isCheckBoxesHidden = this._selectionController.isSelectColumnVisible() && !this._selectionController.isSelectionWithCheckboxes();
    each(tableElements, ((_, tableElement) => {
      renderer_default(tableElement).toggleClass(CHECKBOXES_HIDDEN_CLASS, isCheckBoxesHidden);
    }));
  }
};
var selectionModule = {
  defaultOptions: () => ({
    selection: {
      mode: "none",
      showCheckBoxesMode: "onClick",
      allowSelectAll: true,
      selectAllMode: "allPages",
      deferred: false,
      maxFilterLengthInRequest: 1500,
      alwaysSelectByShift: false
    },
    selectionFilter: [],
    selectedRowKeys: []
  }),
  controllers: {
    selection: SelectionController
  },
  extenders: {
    controllers: {
      data: dataSelectionExtenderMixin,
      contextMenu
    },
    views: {
      columnHeadersView: columnHeadersSelectionExtenderMixin,
      rowsView: rowsViewSelectionExtenderMixin
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/selection.js
m_core_default.registerModule("selection", selectionModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/column_chooser/const.js
var defaultOptions = {
  columnChooser: {
    enabled: false,
    search: {
      enabled: false,
      timeout: 500,
      editorOptions: {}
    },
    selection: {
      allowSelectAll: false,
      selectByClick: false,
      recursive: false
    },
    position: void 0,
    sortOrder: void 0,
    mode: "dragAndDrop",
    width: 250,
    height: 260,
    get title() {
      return message_default.format("dxDataGrid-columnChooserTitle");
    },
    get emptyPanelText() {
      return message_default.format("dxDataGrid-columnChooserEmptyText");
    },
    container: void 0
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/column_chooser/m_column_chooser.js
var COLUMN_CHOOSER_DRAG_CLASS = "column-chooser-mode-drag";
var COLUMN_CHOOSER_SELECT_CLASS = "column-chooser-mode-select";
var COLUMN_OPTIONS_USED_IN_ITEMS = ["showInColumnChooser", "caption", "allowHiding", "visible", "cssClass", "ownerBand"];
var processItems = function(that, chooserColumns) {
  const items = [];
  const isSelectMode = that.isSelectMode();
  const isRecursive = that.option("columnChooser.selection.recursive");
  if (chooserColumns.length) {
    each(chooserColumns, ((index, column) => {
      const item = {
        text: column.caption,
        cssClass: column.cssClass,
        allowHiding: column.allowHiding,
        expanded: true,
        id: column.index,
        disabled: false === column.allowHiding,
        parentId: isDefined(column.ownerBand) ? column.ownerBand : null
      };
      const isRecursiveWithColumns = isRecursive && column.hasColumns;
      if (isSelectMode && !isRecursiveWithColumns) {
        item.selected = column.visible;
      }
      items.push(item);
    }));
  }
  return items;
};
var ColumnChooserController = class extends m_modules_default.ViewController {
  init() {
    super.init();
    this._rowsView = this.getView("rowsView");
  }
  renderShowColumnChooserButton($element) {
    const that = this;
    const columnChooserButtonClass = that.addWidgetPrefix("column-chooser-button");
    const columnChooserEnabled = that.option("columnChooser.enabled");
    const $showColumnChooserButton = $element.find(`.${columnChooserButtonClass}`);
    let $columnChooserButton;
    if (columnChooserEnabled) {
      if (!$showColumnChooserButton.length) {
        $columnChooserButton = renderer_default("<div>").addClass(columnChooserButtonClass).appendTo($element);
        that._createComponent($columnChooserButton, button_default, {
          icon: "column-chooser",
          onClick() {
            that.getView("columnChooserView").showColumnChooser();
          },
          hint: that.option("columnChooser.title"),
          integrationOptions: {}
        });
      } else {
        $showColumnChooserButton.show();
      }
    } else {
      $showColumnChooserButton.hide();
    }
  }
  getPosition() {
    var _this$_rowsView;
    const position = this.option("columnChooser.position");
    return isDefined(position) ? position : {
      my: "right bottom",
      at: "right bottom",
      of: null === (_this$_rowsView = this._rowsView) || void 0 === _this$_rowsView ? void 0 : _this$_rowsView.element(),
      collision: "fit",
      offset: "-2 -2",
      boundaryOffset: "2 2"
    };
  }
};
var ColumnChooserView = class extends ColumnsView {
  optionChanged(args) {
    if ("columnChooser" === args.name) {
      this._initializePopupContainer();
      this.render(null, "full");
    } else {
      super.optionChanged(args);
    }
  }
  publicMethods() {
    return ["showColumnChooser", "hideColumnChooser"];
  }
  _resizeCore() {
  }
  _isWinDevice() {
    return !!devices_default.real().win;
  }
  _initializePopupContainer() {
    const that = this;
    const columnChooserClass = that.addWidgetPrefix("column-chooser");
    const $element = that.element().addClass(columnChooserClass);
    const columnChooserOptions = that.option("columnChooser");
    const popupPosition = this._columnChooserController.getPosition();
    const dxPopupOptions = {
      visible: false,
      shading: false,
      showCloseButton: true,
      dragEnabled: true,
      resizeEnabled: true,
      wrapperAttr: {
        class: columnChooserClass
      },
      toolbarItems: [{
        text: columnChooserOptions.title,
        toolbar: "top",
        location: "before"
      }],
      position: popupPosition,
      width: columnChooserOptions.width,
      height: columnChooserOptions.height,
      rtlEnabled: that.option("rtlEnabled"),
      onHidden() {
        if (that._isWinDevice()) {
          renderer_default("body").removeClass(that.addWidgetPrefix("notouch-action"));
        }
      },
      container: columnChooserOptions.container,
      _loopFocus: true
    };
    if (!isDefined(this._popupContainer)) {
      that._popupContainer = that._createComponent($element, ui_popup_default, dxPopupOptions);
      that._popupContainer.on("optionChanged", ((args) => {
        if ("visible" === args.name) {
          that.renderCompleted.fire();
        }
      }));
    } else {
      this._popupContainer.option(dxPopupOptions);
    }
    this.setPopupAttributes();
  }
  setPopupAttributes() {
    const isSelectMode = this.isSelectMode();
    const isBandColumnsUsed = this._columnsController.isBandColumnsUsed();
    this._popupContainer.setAria({
      role: "dialog",
      label: message_default.format("dxDataGrid-columnChooserTitle")
    });
    this._popupContainer.$wrapper().toggleClass(this.addWidgetPrefix(COLUMN_CHOOSER_DRAG_CLASS), !isSelectMode).toggleClass(this.addWidgetPrefix(COLUMN_CHOOSER_SELECT_CLASS), isSelectMode);
    this._popupContainer.$content().addClass(this.addWidgetPrefix("column-chooser-list"));
    if (isSelectMode && !isBandColumnsUsed) {
      this._popupContainer.$content().addClass(this.addWidgetPrefix("column-chooser-plain"));
    }
  }
  _renderCore(change) {
    if (this._popupContainer) {
      const isDragMode = !this.isSelectMode();
      if (!this._columnChooserList || "full" === change) {
        this._renderTreeView();
      } else if (isDragMode) {
        this._updateItems();
      }
    }
  }
  _renderTreeView() {
    var _columnChooser$search, _columnChooser$search2, _columnChooser$search3;
    const that = this;
    const $container = this._popupContainer.$content();
    const columnChooser = this.option("columnChooser");
    const isSelectMode = this.isSelectMode();
    const searchEnabled = isDefined(columnChooser.allowSearch) ? columnChooser.allowSearch : null === (_columnChooser$search = columnChooser.search) || void 0 === _columnChooser$search ? void 0 : _columnChooser$search.enabled;
    const searchTimeout = isDefined(columnChooser.searchTimeout) ? columnChooser.searchTimeout : null === (_columnChooser$search2 = columnChooser.search) || void 0 === _columnChooser$search2 ? void 0 : _columnChooser$search2.timeout;
    const treeViewConfig = {
      dataStructure: "plain",
      activeStateEnabled: true,
      focusStateEnabled: true,
      hoverStateEnabled: true,
      itemTemplate: "item",
      showCheckBoxesMode: "none",
      rootValue: null,
      searchEnabled,
      searchTimeout,
      searchEditorOptions: null === (_columnChooser$search3 = columnChooser.search) || void 0 === _columnChooser$search3 ? void 0 : _columnChooser$search3.editorOptions
    };
    if (this._isWinDevice()) {
      treeViewConfig.useNativeScrolling = false;
    }
    extend(treeViewConfig, isSelectMode ? this._prepareSelectModeConfig() : this._prepareDragModeConfig());
    if (this._columnChooserList) {
      if (!treeViewConfig.searchEnabled) {
        treeViewConfig.searchValue = "";
      }
      this._columnChooserList.option(treeViewConfig);
      this._updateItems();
    } else {
      this._columnChooserList = this._createComponent($container, tree_view_default, treeViewConfig);
      this._updateItems();
      let scrollTop = 0;
      this._columnChooserList.on("optionChanged", ((e) => {
        const scrollable = e.component.getScrollable();
        scrollTop = scrollable.scrollTop();
      }));
      this._columnChooserList.on("contentReady", ((e) => {
        deferUpdate((() => {
          const scrollable = e.component.getScrollable();
          scrollable.scrollTo({
            y: scrollTop
          });
          that.renderCompleted.fire();
        }));
      }));
    }
  }
  _prepareDragModeConfig() {
    const columnChooserOptions = this.option("columnChooser");
    return {
      noDataText: columnChooserOptions.emptyPanelText,
      activeStateEnabled: false,
      hoverStateEnabled: false,
      itemTemplate(data17, index, item) {
        renderer_default(item).text(data17.text).parent().addClass(data17.cssClass).addClass("dx-column-chooser-item");
      }
    };
  }
  _prepareSelectModeConfig() {
    const that = this;
    const selectionOptions = this.option("columnChooser.selection") ?? {};
    let isUpdatingSelection = false;
    return {
      selectByClick: selectionOptions.selectByClick,
      selectNodesRecursive: selectionOptions.recursive,
      showCheckBoxesMode: selectionOptions.allowSelectAll ? "selectAll" : "normal",
      onSelectionChanged: (e) => {
        if (isUpdatingSelection) {
          return;
        }
        const nodes = ((nodes2) => {
          const addNodesToArray = (nodes3, flatNodesArray) => nodes3.reduce(((result, node) => {
            result.push(node);
            if (node.children.length) {
              addNodesToArray(node.children, result);
            }
            return result;
          }), flatNodesArray);
          return addNodesToArray(nodes2, []);
        })(e.component.getNodes());
        e.component.beginUpdate();
        isUpdatingSelection = true;
        ((e2, nodes2) => {
          nodes2.filter(((node) => false === node.itemData.allowHiding)).forEach(((node) => e2.component.selectItem(node.key)));
        })(e, nodes);
        e.component.endUpdate();
        isUpdatingSelection = false;
        that.component.beginUpdate();
        this._isUpdatingColumnVisibility = true;
        ((nodes2) => {
          nodes2.forEach(((node) => {
            const columnIndex = node.itemData.id;
            const isVisible2 = false !== node.selected;
            that._columnsController.columnOption(columnIndex, "visible", isVisible2);
          }));
        })(nodes);
        that.component.endUpdate();
        this._isUpdatingColumnVisibility = false;
      }
    };
  }
  _updateItems() {
    const isSelectMode = this.isSelectMode();
    const chooserColumns = this._columnsController.getChooserColumns(isSelectMode);
    const items = processItems(this, chooserColumns);
    this._columnChooserList.option("items", items);
  }
  _updateItemsSelection(columnIndices) {
    const changedColumns = null === columnIndices || void 0 === columnIndices ? void 0 : columnIndices.map(((columnIndex) => this._columnsController.columnOption(columnIndex)));
    this._columnChooserList.beginUpdate();
    null === changedColumns || void 0 === changedColumns || changedColumns.forEach(((_ref) => {
      let {
        visible,
        index
      } = _ref;
      if (visible) {
        this._columnChooserList.selectItem(index);
      } else {
        this._columnChooserList.unselectItem(index);
      }
    }));
    this._columnChooserList.endUpdate();
  }
  _columnOptionChanged(changes) {
    super._columnOptionChanged(changes);
    const {
      optionNames
    } = changes;
    const isSelectMode = this.isSelectMode();
    const onlyVisibleChanged = this.isColumnVisibilityOnlyUpdated(optionNames);
    const isOnlyColumnVisibilityUpdated = this._isUpdatingColumnVisibility && onlyVisibleChanged;
    if (!isSelectMode || !this._columnChooserList || isOnlyColumnVisibilityUpdated) {
      return;
    }
    const columnIndices = isDefined(changes.columnIndex) ? [changes.columnIndex] : changes.columnIndices;
    const hasItemsOptionNames = COLUMN_OPTIONS_USED_IN_ITEMS.some(((optionName) => optionNames[optionName]));
    const needUpdate = hasItemsOptionNames || changes.changeTypes.columns && optionNames.all;
    if (!needUpdate) {
      return;
    }
    this._updateItemsSelection(columnIndices);
    if (!onlyVisibleChanged) {
      this._updateItems();
    }
  }
  isColumnVisibilityOnlyUpdated(optionNames) {
    const optionKeys = Object.keys(optionNames ?? {}).filter(((key) => "length" !== key));
    return 1 === optionKeys.length && "visible" === optionKeys[0];
  }
  getColumnElements() {
    var _this$_popupContainer;
    const result = [];
    const isSelectMode = this.isSelectMode();
    const chooserColumns = this._columnsController.getChooserColumns(isSelectMode);
    const $content = null === (_this$_popupContainer = this._popupContainer) || void 0 === _this$_popupContainer ? void 0 : _this$_popupContainer.$content();
    const $nodes = null === $content || void 0 === $content ? void 0 : $content.find(".dx-treeview-node");
    if ($nodes) {
      chooserColumns.forEach(((column) => {
        const $node = $nodes.filter(`[data-item-id = '${column.index}']`);
        const item = $node.length ? $node.children(".dx-column-chooser-item").get(0) : null;
        result.push(item);
      }));
    }
    return renderer_default(result);
  }
  getName() {
    return "columnChooser";
  }
  getColumns() {
    return this._columnsController.getChooserColumns();
  }
  allowDragging(column) {
    const isParentColumnVisible = this._columnsController.isParentColumnVisible(column.index);
    const isColumnHidden = !column.visible && column.allowHiding;
    return this.isColumnChooserVisible() && isParentColumnVisible && isColumnHidden;
  }
  allowColumnHeaderDragging(column) {
    const isDragMode = !this.isSelectMode();
    return isDragMode && this.isColumnChooserVisible() && column.allowHiding;
  }
  getBoundingRect() {
    var _that$_popupContainer;
    const container = null === (_that$_popupContainer = this._popupContainer) || void 0 === _that$_popupContainer ? void 0 : _that$_popupContainer.$overlayContent();
    if (null !== container && void 0 !== container && container.is(":visible")) {
      const offset = container.offset();
      return {
        left: offset.left,
        top: offset.top,
        right: offset.left + getOuterWidth(container),
        bottom: offset.top + getOuterHeight(container)
      };
    }
    return null;
  }
  showColumnChooser() {
    if (!this._popupContainer) {
      this._initializePopupContainer();
      this.render();
    }
    this._popupContainer.show();
    if (this._isWinDevice()) {
      renderer_default("body").addClass(this.addWidgetPrefix("notouch-action"));
    }
  }
  hideColumnChooser() {
    if (this._popupContainer) {
      this._popupContainer.hide();
    }
  }
  isColumnChooserVisible() {
    const popupContainer = this._popupContainer;
    return null === popupContainer || void 0 === popupContainer ? void 0 : popupContainer.option("visible");
  }
  isSelectMode() {
    return "select" === this.option("columnChooser.mode");
  }
  hasHiddenColumns() {
    const isEnabled = this.option("columnChooser.enabled");
    const hiddenColumns = this.getColumns().filter(((column) => !column.visible));
    return isEnabled && hiddenColumns.length;
  }
};
var headerPanel2 = (Base) => class extends Base {
  _getToolbarItems() {
    const items = super._getToolbarItems();
    return this._appendColumnChooserItem(items);
  }
  _appendColumnChooserItem(items) {
    const that = this;
    const columnChooserEnabled = that.option("columnChooser.enabled");
    if (columnChooserEnabled) {
      const onClickHandler = function() {
        that.component.getView("columnChooserView").showColumnChooser();
      };
      const onInitialized = function(e) {
        renderer_default(e.element).addClass(that._getToolbarButtonClass(that.addWidgetPrefix("column-chooser-button")));
      };
      const hintText = that.option("columnChooser.title");
      const toolbarItem = {
        widget: "dxButton",
        options: {
          icon: "column-chooser",
          onClick: onClickHandler,
          hint: hintText,
          text: hintText,
          onInitialized,
          elementAttr: {
            "aria-haspopup": "dialog"
          }
        },
        showText: "inMenu",
        location: "after",
        name: "columnChooserButton",
        locateInMenu: "auto",
        sortIndex: 40
      };
      items.push(toolbarItem);
    }
    return items;
  }
  optionChanged(args) {
    if ("columnChooser" === args.name) {
      this._invalidate();
      args.handled = true;
    } else {
      super.optionChanged(args);
    }
  }
};
var columns2 = (Base) => class extends Base {
  allowMoveColumn(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation) {
    const isSelectMode = "select" === this.option("columnChooser.mode");
    const isMoveColumnDisallowed = isSelectMode && "columnChooser" === targetLocation;
    return isMoveColumnDisallowed ? false : super.allowMoveColumn(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation);
  }
};
var columnHeadersView2 = (Base) => class extends Base {
  allowDragging(column) {
    const isDragMode = !this._columnChooserView.isSelectMode();
    const isColumnChooserVisible = this._columnChooserView.isColumnChooserVisible();
    return isDragMode && isColumnChooserVisible && column.allowHiding || super.allowDragging(column);
  }
};
var columnChooserModule = {
  defaultOptions: () => defaultOptions,
  controllers: {
    columnChooser: ColumnChooserController
  },
  views: {
    columnChooserView: ColumnChooserView
  },
  extenders: {
    views: {
      headerPanel: headerPanel2,
      columnHeadersView: columnHeadersView2
    },
    controllers: {
      columns: columns2
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/column_chooser.js
var ColumnChooserController2 = columnChooserModule.controllers.columnChooser;
var ColumnChooserView2 = columnChooserModule.views.columnChooserView;
m_core_default.registerModule("columnChooser", columnChooserModule);

// node_modules/devextreme/esm/__internal/grids/data_grid/grouping/const.js
var CLASSES5 = {
  groupPanel: "dx-datagrid-group-panel",
  groupPanelMessage: "dx-group-panel-message",
  groupPanelItem: "dx-group-panel-item",
  groupPanelLabel: "dx-toolbar-label",
  groupPanelContainer: "dx-toolbar-item"
};
var CONTEXT_MENU_GROUP_BY_COLUMN_ICON_NAME = "groupbycolumn";
var CONTEXT_MENU_UNGROUP_COLUMN_ICON_NAME = "ungroupcolumn";
var CONTEXT_MENU_UNGROUP_ALL_COLUMNS_ICON_NAME = "ungroupallcolumns";

// node_modules/devextreme/esm/__internal/grids/data_grid/m_utils.js
function createGroupFilter(path, storeLoadOptions) {
  const groups = normalizeSortingInfo(storeLoadOptions.group);
  const filter = [];
  for (let i = 0; i < path.length; i++) {
    filter.push([groups[i].selector, "=", path[i]]);
  }
  if (storeLoadOptions.filter) {
    filter.push(storeLoadOptions.filter);
  }
  return m_utils_default.combineFilters(filter);
}

// node_modules/devextreme/esm/__internal/grids/data_grid/grouping/m_grouping_core.js
function createOffsetFilter(path, storeLoadOptions, lastLevelOnly) {
  const groups = normalizeSortingInfo(storeLoadOptions.group);
  let filter = [];
  for (let i = lastLevelOnly ? path.length - 1 : 0; i < path.length; i++) {
    const filterElement = [];
    for (let j = 0; j <= i; j++) {
      const {
        selector
      } = groups[j];
      if (i === j && (null === path[j] || false === path[j] || true === path[j])) {
        if (false === path[j]) {
          filterElement.push([selector, "=", groups[j].desc ? true : null]);
        } else if (path[j] ? !groups[j].desc : groups[j].desc) {
          filterElement.push([selector, "<>", path[j]]);
        } else {
          filterElement.push([selector, "<>", null]);
          filterElement.push([selector, "=", null]);
        }
      } else {
        const currentFilter = [selector, i === j ? groups[j].desc ? ">" : "<" : "=", path[j]];
        if ("<" === currentFilter[1]) {
          filterElement.push([currentFilter, "or", [selector, "=", null]]);
        } else {
          filterElement.push(currentFilter);
        }
      }
    }
    filter.push(m_core_default.combineFilters(filterElement));
  }
  filter = m_core_default.combineFilters(filter, "or");
  return m_core_default.combineFilters([filter, storeLoadOptions.filter]);
}
var findGroupInfoByKey = function(groupsInfo, key) {
  const {
    hash
  } = groupsInfo;
  return hash && hash[JSON.stringify(key)];
};
var getGroupInfoIndexByOffset = function(groupsInfo, offset) {
  let leftIndex = 0;
  let rightIndex = groupsInfo.length - 1;
  if (!groupsInfo.length) {
    return 0;
  }
  do {
    const middleIndex = rightIndex + leftIndex >> 1;
    if (groupsInfo[middleIndex].offset > offset) {
      rightIndex = middleIndex;
    } else {
      leftIndex = middleIndex;
    }
  } while (rightIndex - leftIndex > 1);
  let index;
  for (index = leftIndex; index <= rightIndex; index++) {
    if (groupsInfo[index].offset > offset) {
      break;
    }
  }
  return index;
};
var cleanGroupsInfo = function(groupsInfo, groupIndex, groupsCount) {
  for (let i = 0; i < groupsInfo.length; i++) {
    if (groupIndex + 1 >= groupsCount) {
      groupsInfo[i].children = [];
    } else {
      cleanGroupsInfo(groupsInfo[i].children, groupIndex + 1, groupsCount);
    }
  }
};
var calculateItemsCount = function(that, items, groupsCount) {
  let result = 0;
  if (items) {
    if (!groupsCount) {
      result = items.length;
    } else {
      for (let i = 0; i < items.length; i++) {
        if (that.isGroupItemCountable(items[i])) {
          result++;
        }
        result += calculateItemsCount(that, items[i].items, groupsCount - 1);
      }
    }
  }
  return result;
};
var GroupingHelper = class {
  constructor(dataSourceAdapter) {
    this._dataSource = dataSourceAdapter;
    this.reset();
  }
  reset() {
    this._groupsInfo = [];
    this._totalCountCorrection = 0;
  }
  totalCountCorrection() {
    return this._totalCountCorrection;
  }
  updateTotalItemsCount(totalCountCorrection) {
    this._totalCountCorrection = totalCountCorrection || 0;
  }
  isGroupItemCountable(item) {
    return !this._isVirtualPaging() || !item.isContinuation;
  }
  _isVirtualPaging() {
    const scrollingMode = this._dataSource.option("scrolling.mode");
    return "virtual" === scrollingMode || "infinite" === scrollingMode;
  }
  itemsCount() {
    const dataSourceAdapter = this._dataSource;
    const dataSource = dataSourceAdapter._dataSource;
    const groupCount = m_core_default.normalizeSortingInfo(dataSource.group() || []).length;
    const itemsCount = calculateItemsCount(this, dataSource.items(), groupCount);
    return itemsCount;
  }
  foreachGroups(callback, childrenAtFirst, foreachCollapsedGroups2, updateOffsets, updateParentOffsets) {
    const that = this;
    return (function foreachGroupsCore(groupsInfo, callback2, childrenAtFirst2, parents) {
      const callbackResults = [];
      function executeCallback(callback3, data17, parents2, callbackResults2) {
        const callbackResult = data17 && callback3(data17, parents2);
        callbackResult && callbackResults2.push(callbackResult);
        return callbackResult;
      }
      for (let i = 0; i < groupsInfo.length; i++) {
        parents.push(groupsInfo[i].data);
        if (!childrenAtFirst2 && false === executeCallback(callback2, groupsInfo[i].data, parents, callbackResults)) {
          return false;
        }
        if (!groupsInfo[i].data || groupsInfo[i].data.isExpanded || foreachCollapsedGroups2) {
          const {
            children
          } = groupsInfo[i];
          const callbackResult = children.length && foreachGroupsCore(children, callback2, childrenAtFirst2, parents);
          callbackResult && callbackResults.push(callbackResult);
          if (false === callbackResult) {
            return false;
          }
        }
        if (childrenAtFirst2 && false === executeCallback(callback2, groupsInfo[i].data, parents, callbackResults)) {
          return false;
        }
        if (!groupsInfo[i].data || groupsInfo[i].data.offset !== groupsInfo[i].offset) {
          updateOffsets = true;
        }
        parents.pop();
      }
      const currentParents = updateParentOffsets && parents.slice(0);
      return updateOffsets && when.apply(renderer_default, callbackResults).always((() => {
        that._updateGroupInfoOffsets(groupsInfo, currentParents);
      }));
    })(that._groupsInfo, callback, childrenAtFirst, []);
  }
  _updateGroupInfoOffsets(groupsInfo, parents) {
    parents = parents || [];
    for (let index = 0; index < groupsInfo.length; index++) {
      const groupInfo = groupsInfo[index];
      if (groupInfo.data && groupInfo.data.offset !== groupInfo.offset) {
        groupInfo.offset = groupInfo.data.offset;
        for (let parentIndex = 0; parentIndex < parents.length; parentIndex++) {
          parents[parentIndex].offset = groupInfo.offset;
        }
      }
    }
    groupsInfo.sort(((a, b) => a.offset - b.offset));
  }
  findGroupInfo(path) {
    let groupInfo;
    let groupsInfo = this._groupsInfo;
    for (let pathIndex = 0; groupsInfo && pathIndex < path.length; pathIndex++) {
      groupInfo = findGroupInfoByKey(groupsInfo, path[pathIndex]);
      groupsInfo = groupInfo && groupInfo.children;
    }
    return groupInfo && groupInfo.data;
  }
  addGroupInfo(groupInfoData) {
    const that = this;
    let groupInfo;
    const {
      path
    } = groupInfoData;
    let groupsInfo = that._groupsInfo;
    for (let pathIndex = 0; pathIndex < path.length; pathIndex++) {
      groupInfo = findGroupInfoByKey(groupsInfo, path[pathIndex]);
      if (!groupInfo) {
        groupInfo = {
          key: path[pathIndex],
          offset: groupInfoData.offset,
          data: {
            offset: groupInfoData.offset,
            isExpanded: true,
            path: path.slice(0, pathIndex + 1)
          },
          children: []
        };
        const index = getGroupInfoIndexByOffset(groupsInfo, groupInfoData.offset);
        groupsInfo.splice(index, 0, groupInfo);
        groupsInfo.hash = groupsInfo.hash || {};
        groupsInfo.hash[JSON.stringify(groupInfo.key)] = groupInfo;
      }
      if (pathIndex === path.length - 1) {
        groupInfo.data = groupInfoData;
        if (groupInfo.offset !== groupInfoData.offset) {
          that._updateGroupInfoOffsets(groupsInfo);
        }
      }
      groupsInfo = groupInfo.children;
    }
  }
  allowCollapseAll() {
    return true;
  }
  refresh(options) {
    const that = this;
    const {
      storeLoadOptions
    } = options;
    const groups = normalizeSortingInfo(storeLoadOptions.group || []);
    const oldGroups = "_group" in that ? normalizeSortingInfo(that._group || []) : groups;
    let groupsCount = Math.min(oldGroups.length, groups.length);
    that._group = storeLoadOptions.group;
    for (let groupIndex = 0; groupIndex < groupsCount; groupIndex++) {
      if (!m_utils_default.isEqualSelectors(oldGroups[groupIndex].selector, groups[groupIndex].selector)) {
        groupsCount = groupIndex;
        break;
      }
    }
    if (!groupsCount) {
      that.reset();
    } else {
      cleanGroupsInfo(that._groupsInfo, 0, groupsCount);
    }
  }
  handleDataLoading() {
  }
  handleDataLoaded(options, callBase) {
    callBase(options);
  }
  handleDataLoadedCore(options, callBase) {
    callBase(options);
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/grouping/m_grouping_collapsed.js
function getContinuationGroupCount(groupOffset, pageSize, groupSize, groupIndex) {
  groupIndex = groupIndex || 0;
  if (pageSize > 1 && groupSize > 0) {
    let pageOffset = groupOffset - Math.floor(groupOffset / pageSize) * pageSize || pageSize;
    pageOffset += groupSize - groupIndex - 2;
    if (pageOffset < 0) {
      pageOffset += pageSize;
    }
    return Math.floor(pageOffset / (pageSize - groupIndex - 1));
  }
  return 0;
}
var foreachExpandedGroups = function(that, callback, updateGroups) {
  return that.foreachGroups(((groupInfo, parents) => {
    if (groupInfo.isExpanded) {
      return callback(groupInfo, parents);
    }
  }), true, false, updateGroups, updateGroups);
};
var processGroupItems = function(that, items, groupsCount, expandedInfo, path, isCustomLoading, isLastGroupExpanded) {
  let isExpanded;
  expandedInfo.items = expandedInfo.items || [];
  expandedInfo.paths = expandedInfo.paths || [];
  expandedInfo.count = expandedInfo.count || 0;
  expandedInfo.lastCount = expandedInfo.lastCount || 0;
  if (!groupsCount) {
    return;
  }
  for (let i = 0; i < items.length; i++) {
    const item = items[i];
    if (void 0 !== item.items) {
      path.push(item.key);
      if (isCustomLoading) {
        isExpanded = true;
      } else {
        const groupInfo = that.findGroupInfo(path);
        isExpanded = groupInfo && groupInfo.isExpanded;
      }
      if (!isExpanded) {
        item.collapsedItems = item.items;
        item.items = null;
      } else if (item.items) {
        processGroupItems(that, item.items, groupsCount - 1, expandedInfo, path, isCustomLoading, isLastGroupExpanded);
      } else if (1 === groupsCount && item.count && (!isCustomLoading || isLastGroupExpanded)) {
        expandedInfo.items.push(item);
        expandedInfo.paths.push(path.slice(0));
        expandedInfo.count += expandedInfo.lastCount;
        expandedInfo.lastCount = item.count;
      }
      path.pop();
    }
  }
};
var updateGroupInfoItem = function(that, item, isLastGroupLevel, path, offset) {
  const groupInfo = that.findGroupInfo(path);
  let count;
  if (!groupInfo) {
    if (isLastGroupLevel) {
      count = item.count > 0 ? item.count : item.items.length;
    }
    that.addGroupInfo({
      isExpanded: that._isGroupExpanded(path.length - 1),
      path: path.slice(0),
      offset,
      count: count || 0
    });
  } else {
    if (isLastGroupLevel) {
      groupInfo.count = item.count > 0 ? item.count : item.items && item.items.length || 0;
    } else {
      item.count = groupInfo.count || item.count;
    }
    groupInfo.offset = offset;
  }
};
var updateGroupInfos = function(that, options, items, loadedGroupCount, groupIndex, path, parentIndex) {
  const groupCount = options.group ? options.group.length : 0;
  const isLastGroupLevel = groupCount === loadedGroupCount;
  const remotePaging = options.remoteOperations.paging;
  let offset = 0;
  let totalCount = 0;
  let count;
  groupIndex = groupIndex || 0;
  path = path || [];
  if (remotePaging && !parentIndex) {
    offset = 0 === groupIndex ? options.skip || 0 : options.skips[groupIndex - 1] || 0;
  }
  if (groupIndex >= loadedGroupCount) {
    return items.length;
  }
  for (let i = 0; i < items.length; i++) {
    const item = items[i];
    if (item) {
      path.push(item.key);
      if (!item.count && !item.items || void 0 === item.items) {
        return -1;
      }
      updateGroupInfoItem(that, item, isLastGroupLevel, path, offset + i);
      count = item.items ? updateGroupInfos(that, options, item.items, loadedGroupCount, groupIndex + 1, path, i) : item.count || -1;
      if (count < 0) {
        return -1;
      }
      totalCount += count;
      path.pop();
    }
  }
  return totalCount;
};
var isGroupExpanded = function(groups, groupIndex) {
  return groups && groups.length && groups[groupIndex] && !!groups[groupIndex].isExpanded;
};
var getTotalOffset = function(groupInfos, pageSize, offset) {
  let groupSize;
  let totalOffset = offset;
  for (let groupIndex = 0; groupIndex < groupInfos.length; groupIndex++) {
    groupSize = groupInfos[groupIndex].offset + 1;
    if (groupIndex > 0) {
      groupSize += groupInfos[groupIndex - 1].childrenTotalCount;
      if (pageSize) {
        groupSize += getContinuationGroupCount(totalOffset, pageSize, groupSize, groupIndex - 1) * groupIndex;
      }
    }
    totalOffset += groupSize;
  }
  return totalOffset;
};
function applyContinuationToGroupItem(options, expandedInfo, groupLevel, expandedItemIndex) {
  const item = expandedInfo.items[expandedItemIndex];
  const skip = options.skips && options.skips[groupLevel];
  const take = options.takes && options.takes[groupLevel];
  const isLastExpandedItem = expandedItemIndex === expandedInfo.items.length - 1;
  const isFirstExpandedItem = 0 === expandedItemIndex;
  const lastExpandedItemSkip = isFirstExpandedItem && skip || 0;
  const isItemsTruncatedByTake = item.count > take + lastExpandedItemSkip;
  if (isFirstExpandedItem && void 0 !== skip) {
    item.isContinuation = true;
  }
  if (isLastExpandedItem && void 0 !== take && isItemsTruncatedByTake) {
    item.isContinuationOnNextPage = true;
  }
}
function fillSkipTakeInExpandedInfo(options, expandedInfo, currentGroupCount) {
  const currentGroupIndex = currentGroupCount - 1;
  const groupCount = options.group ? options.group.length : 0;
  expandedInfo.skip = options.skips && options.skips[currentGroupIndex];
  if (options.takes && void 0 !== options.takes[currentGroupIndex]) {
    if (groupCount === currentGroupCount) {
      expandedInfo.take = expandedInfo.count ? expandedInfo.count - (expandedInfo.skip || 0) : 0;
    } else {
      expandedInfo.take = 0;
    }
    expandedInfo.take += options.takes[currentGroupIndex];
  }
}
function isDataDeferred(data17) {
  return !Array.isArray(data17);
}
function makeDataDeferred(options) {
  if (!isDataDeferred(options.data)) {
    options.data = new Deferred();
  }
}
function loadGroupItems(that, options, loadedGroupCount, expandedInfo, groupLevel, data17) {
  if (!options.isCustomLoading) {
    expandedInfo = {};
    processGroupItems(that, data17, loadedGroupCount, expandedInfo, []);
    fillSkipTakeInExpandedInfo(options, expandedInfo, loadedGroupCount);
  }
  const groupCount = options.group ? options.group.length : 0;
  if (expandedInfo.paths.length && groupCount - loadedGroupCount > 0) {
    makeDataDeferred(options);
    loadExpandedGroups(that, options, expandedInfo, loadedGroupCount, groupLevel, data17);
  } else if (expandedInfo.paths.length && options.storeLoadOptions.group) {
    makeDataDeferred(options);
    loadLastLevelGroupItems(that, options, expandedInfo, data17);
  } else if (isDataDeferred(options.data)) {
    options.data.resolve(data17);
  }
}
function loadExpandedGroups(that, options, expandedInfo, loadedGroupCount, groupLevel, data17) {
  const groups = options.group || [];
  const currentGroup = groups[groupLevel + 1];
  const deferreds = [];
  each(expandedInfo.paths, ((expandedItemIndex) => {
    var _options$storeLoadOpt;
    const loadOptions = {
      requireTotalCount: false,
      requireGroupCount: true,
      group: [currentGroup],
      groupSummary: options.storeLoadOptions.groupSummary,
      filter: createGroupFilter(expandedInfo.paths[expandedItemIndex], {
        filter: options.storeLoadOptions.filter,
        group: groups
      }),
      select: options.storeLoadOptions.select,
      langParams: null === (_options$storeLoadOpt = options.storeLoadOptions) || void 0 === _options$storeLoadOpt ? void 0 : _options$storeLoadOpt.langParams
    };
    if (0 === expandedItemIndex) {
      loadOptions.skip = expandedInfo.skip || 0;
    }
    if (expandedItemIndex === expandedInfo.paths.length - 1) {
      loadOptions.take = expandedInfo.take;
    }
    const loadResult = 0 === loadOptions.take ? [] : that._dataSource.loadFromStore(loadOptions);
    when(loadResult).done(((data18) => {
      const item = expandedInfo.items[expandedItemIndex];
      applyContinuationToGroupItem(options, expandedInfo, groupLevel, expandedItemIndex);
      item.items = data18;
    }));
    deferreds.push(loadResult);
  }));
  when.apply(null, deferreds).done((() => {
    updateGroupInfos(that, options, data17, loadedGroupCount + 1);
    loadGroupItems(that, options, loadedGroupCount + 1, expandedInfo, groupLevel + 1, data17);
  }));
}
function loadLastLevelGroupItems(that, options, expandedInfo, data17) {
  const expandedFilters = [];
  const groups = options.group || [];
  each(expandedInfo.paths, ((_, expandedPath) => {
    expandedFilters.push(createGroupFilter(expandedPath, {
      group: options.isCustomLoading ? options.storeLoadOptions.group : groups
    }));
  }));
  let {
    filter
  } = options.storeLoadOptions;
  if (!options.storeLoadOptions.isLoadingAll) {
    filter = m_core_default.combineFilters([filter, m_core_default.combineFilters(expandedFilters, "or")]);
  }
  const loadOptions = extend({}, options.storeLoadOptions, {
    requireTotalCount: false,
    requireGroupCount: false,
    group: null,
    sort: groups.concat(m_core_default.normalizeSortingInfo(options.storeLoadOptions.sort || [])),
    filter
  });
  const isPagingLocal = that._dataSource.isLastLevelGroupItemsPagingLocal();
  if (!isPagingLocal) {
    loadOptions.skip = expandedInfo.skip;
    loadOptions.take = expandedInfo.take;
  }
  when(0 === expandedInfo.take ? [] : that._dataSource.loadFromStore(loadOptions)).done(((items) => {
    if (isPagingLocal) {
      items = that._dataSource.sortLastLevelGroupItems(items, groups, expandedInfo.paths);
      items = expandedInfo.skip ? items.slice(expandedInfo.skip) : items;
      items = expandedInfo.take ? items.slice(0, expandedInfo.take) : items;
    }
    each(expandedInfo.items, ((index, item) => {
      const itemCount = item.count - (0 === index && expandedInfo.skip || 0);
      const expandedItems = items.splice(0, itemCount);
      applyContinuationToGroupItem(options, expandedInfo, groups.length - 1, index);
      item.items = expandedItems;
    }));
    options.data.resolve(data17);
  })).fail(options.data.reject);
}
var loadGroupTotalCount = function(dataSource, options) {
  const d = new Deferred();
  const isGrouping = !!(options.group && options.group.length);
  const loadOptions = extend({
    skip: 0,
    take: 1,
    requireGroupCount: isGrouping,
    requireTotalCount: !isGrouping
  }, options, {
    group: isGrouping ? options.group : null
  });
  dataSource.load(loadOptions).done(((data17, extra) => {
    const count = extra && (isGrouping ? extra.groupCount : extra.totalCount);
    if (!isFinite(count)) {
      d.reject(errors.Error(isGrouping ? "E4022" : "E4021"));
      return;
    }
    d.resolve(count);
  })).fail(d.reject.bind(d));
  return d;
};
var GroupingHelper2 = class extends GroupingHelper {
  updateTotalItemsCount(options) {
    let totalItemsCount = 0;
    const totalCount = options.extra && options.extra.totalCount || 0;
    const groupCount = options.extra && options.extra.groupCount || 0;
    const pageSize = this._dataSource.pageSize();
    const isVirtualPaging2 = this._isVirtualPaging();
    foreachExpandedGroups(this, ((groupInfo) => {
      groupInfo.childrenTotalCount = 0;
    }));
    foreachExpandedGroups(this, ((groupInfo, parents) => {
      const totalOffset = getTotalOffset(parents, isVirtualPaging2 ? 0 : pageSize, totalItemsCount);
      let count = groupInfo.count + groupInfo.childrenTotalCount;
      if (!isVirtualPaging2) {
        count += getContinuationGroupCount(totalOffset, pageSize, count, parents.length - 1);
      }
      if (parents[parents.length - 2]) {
        parents[parents.length - 2].childrenTotalCount += count;
      } else {
        totalItemsCount += count;
      }
    }));
    super.updateTotalItemsCount(totalItemsCount - totalCount + groupCount);
  }
  _isGroupExpanded(groupIndex) {
    const groups = this._dataSource.group();
    return isGroupExpanded(groups, groupIndex);
  }
  _updatePagingOptions(options, callback) {
    const that = this;
    const isVirtualPaging2 = that._isVirtualPaging();
    const pageSize = that._dataSource.pageSize();
    const skips = [];
    const takes = [];
    let skipChildrenTotalCount = 0;
    let childrenTotalCount = 0;
    if (options.take) {
      foreachExpandedGroups(this, ((groupInfo) => {
        groupInfo.childrenTotalCount = 0;
        groupInfo.skipChildrenTotalCount = 0;
      }));
      foreachExpandedGroups(that, ((groupInfo, parents) => {
        let take;
        let takeCorrection = 0;
        let parentTakeCorrection = 0;
        const totalOffset = getTotalOffset(parents, isVirtualPaging2 ? 0 : pageSize, childrenTotalCount);
        let continuationGroupCount = 0;
        let skipContinuationGroupCount = 0;
        let groupInfoCount = groupInfo.count + groupInfo.childrenTotalCount;
        let childrenGroupInfoCount = groupInfoCount;
        callback && callback(groupInfo, totalOffset);
        const skip = options.skip - totalOffset;
        if (totalOffset <= options.skip + options.take && groupInfoCount) {
          take = options.take;
          if (!isVirtualPaging2) {
            continuationGroupCount = getContinuationGroupCount(totalOffset, pageSize, groupInfoCount, parents.length - 1);
            groupInfoCount += continuationGroupCount * parents.length;
            childrenGroupInfoCount += continuationGroupCount;
            if (pageSize && skip >= 0) {
              takeCorrection = parents.length;
              parentTakeCorrection = parents.length - 1;
              skipContinuationGroupCount = Math.floor(skip / pageSize);
            }
          }
          if (skip >= 0) {
            if (totalOffset + groupInfoCount > options.skip) {
              skips.unshift(skip - skipContinuationGroupCount * takeCorrection - groupInfo.skipChildrenTotalCount);
            }
            if (totalOffset + groupInfoCount >= options.skip + take) {
              takes.unshift(take - takeCorrection - groupInfo.childrenTotalCount + groupInfo.skipChildrenTotalCount);
            }
          } else if (totalOffset + groupInfoCount >= options.skip + take) {
            takes.unshift(take + skip - groupInfo.childrenTotalCount);
          }
        }
        if (totalOffset <= options.skip) {
          if (parents[parents.length - 2]) {
            parents[parents.length - 2].skipChildrenTotalCount += Math.min(childrenGroupInfoCount, skip + 1 - skipContinuationGroupCount * parentTakeCorrection);
          } else {
            skipChildrenTotalCount += Math.min(childrenGroupInfoCount, skip + 1);
          }
        }
        if (totalOffset <= options.skip + take) {
          groupInfoCount = Math.min(childrenGroupInfoCount, skip + take - (skipContinuationGroupCount + 1) * parentTakeCorrection);
          if (parents[parents.length - 2]) {
            parents[parents.length - 2].childrenTotalCount += groupInfoCount;
          } else {
            childrenTotalCount += groupInfoCount;
          }
        }
      }));
      options.skip -= skipChildrenTotalCount;
      options.take -= childrenTotalCount - skipChildrenTotalCount;
    }
    options.skips = skips;
    options.takes = takes;
  }
  changeRowExpand(path) {
    const groupInfo = this.findGroupInfo(path);
    const dataSource = this._dataSource;
    const remoteGroupPaging = dataSource.remoteOperations().groupPaging;
    const groups = m_core_default.normalizeSortingInfo(dataSource.group());
    if (groupInfo) {
      groupInfo.isExpanded = !groupInfo.isExpanded;
      if (remoteGroupPaging && groupInfo.isExpanded && path.length < groups.length) {
        return loadGroupTotalCount(dataSource, {
          filter: createGroupFilter(path, {
            filter: dataSource.lastLoadOptions().filter,
            group: dataSource.group()
          }),
          group: [groups[path.length]],
          select: dataSource.select()
        }).done(((groupCount) => {
          groupInfo.count = groupCount;
        }));
      }
      return new Deferred().resolve();
    }
    return new Deferred().reject();
  }
  handleDataLoading(options) {
    const that = this;
    const {
      storeLoadOptions
    } = options;
    const groups = m_core_default.normalizeSortingInfo(storeLoadOptions.group || options.loadOptions.group);
    if (options.isCustomLoading || !groups.length) {
      return;
    }
    if (options.remoteOperations.grouping) {
      const remotePaging = that._dataSource.remoteOperations().paging;
      storeLoadOptions.group = m_core_default.normalizeSortingInfo(storeLoadOptions.group);
      storeLoadOptions.group.forEach(((group, index) => {
        const isLastGroup = index === storeLoadOptions.group.length - 1;
        group.isExpanded = !remotePaging || !isLastGroup;
      }));
    }
    options.group = options.group || groups;
    if (options.remoteOperations.paging) {
      options.skip = storeLoadOptions.skip;
      options.take = storeLoadOptions.take;
      storeLoadOptions.requireGroupCount = true;
      storeLoadOptions.group = groups.slice(0, 1);
      that._updatePagingOptions(options);
      storeLoadOptions.skip = options.skip;
      storeLoadOptions.take = options.take;
    } else {
      options.skip = options.loadOptions.skip;
      options.take = options.loadOptions.take;
      that._updatePagingOptions(options);
    }
  }
  handleDataLoadedCore(options, callBase) {
    const that = this;
    const loadedGroupCount = m_core_default.normalizeSortingInfo(options.storeLoadOptions.group || options.loadOptions.group).length;
    const groupCount = options.group ? options.group.length : 0;
    let totalCount;
    const expandedInfo = {};
    if (options.isCustomLoading) {
      callBase(options);
      processGroupItems(that, options.data, loadedGroupCount, expandedInfo, [], options.isCustomLoading, options.storeLoadOptions.isLoadingAll);
    } else {
      if (!options.remoteOperations.paging) {
        that.foreachGroups(((groupInfo) => {
          groupInfo.count = 0;
        }));
      }
      totalCount = updateGroupInfos(that, options, options.data, loadedGroupCount);
      if (totalCount < 0) {
        options.data = new Deferred().reject(ui_errors_default.Error("E1037"));
        return;
      }
      if (!options.remoteOperations.paging) {
        if (loadedGroupCount && options.extra && options.loadOptions.requireTotalCount) {
          options.extra.totalCount = totalCount;
          options.extra.groupCount = options.data.length;
        }
      }
      if (groupCount && options.storeLoadOptions.requireGroupCount && !isFinite(options.extra.groupCount)) {
        options.data = new Deferred().reject(errors.Error("E4022"));
        return;
      }
      that.updateTotalItemsCount(options);
      if (!options.remoteOperations.paging) {
        that._updatePagingOptions(options);
        options.lastLoadOptions.skips = options.skips;
        options.lastLoadOptions.takes = options.takes;
      }
      callBase(options);
      if (!options.remoteOperations.paging) {
        that._processPaging(options, loadedGroupCount);
      }
    }
    loadGroupItems(that, options, loadedGroupCount, expandedInfo, 0, options.data);
  }
  _processSkips(items, skips, groupCount) {
    if (!groupCount) {
      return;
    }
    const firstItem = items[0];
    const skip = skips[0];
    const children = firstItem && firstItem.items;
    if (void 0 !== skip) {
      firstItem.isContinuation = true;
      if (children) {
        firstItem.items = children.slice(skip);
        this._processSkips(firstItem.items, skips.slice(1), groupCount - 1);
      }
    }
  }
  _processTakes(items, skips, takes, groupCount, parents) {
    if (!groupCount || !items) {
      return;
    }
    parents = parents || [];
    const lastItem = items[items.length - 1];
    let children = lastItem && lastItem.items;
    const take = takes[0];
    const skip = skips[0];
    if (lastItem) {
      const maxTakeCount = lastItem.count - (lastItem.isContinuation && skip || 0) || children.length;
      if (void 0 !== take && maxTakeCount > take) {
        lastItem.isContinuationOnNextPage = true;
        parents.forEach(((parent) => {
          parent.isContinuationOnNextPage = true;
        }));
        if (children) {
          children = children.slice(0, take);
          lastItem.items = children;
        }
      }
      parents.push(lastItem);
      this._processTakes(children, skips.slice(1), takes.slice(1), groupCount - 1, parents);
    }
  }
  _processPaging(options, groupCount) {
    this._processSkips(options.data, options.skips, groupCount);
    this._processTakes(options.data, options.skips, options.takes, groupCount);
  }
  isLastLevelGroupItemsPagingLocal() {
    return false;
  }
  sortLastLevelGroupItems(items) {
    return items;
  }
  refresh(options, operationTypes) {
    const that = this;
    const dataSource = that._dataSource;
    const {
      storeLoadOptions
    } = options;
    const group = options.group || options.storeLoadOptions.group;
    const oldGroups = m_core_default.normalizeSortingInfo(that._group);
    let isExpanded;
    let groupIndex;
    function handleGroup(groupInfo, parents) {
      if (parents.length === groupIndex + 1) {
        groupInfo.isExpanded = isExpanded;
      }
    }
    for (groupIndex = 0; groupIndex < oldGroups.length; groupIndex++) {
      isExpanded = isGroupExpanded(group, groupIndex);
      if (isGroupExpanded(that._group, groupIndex) !== isExpanded) {
        that.foreachGroups(handleGroup);
      }
    }
    super.refresh.apply(this, arguments);
    if (group && options.remoteOperations.paging && operationTypes.reload) {
      return foreachExpandedGroups(that, ((groupInfo) => {
        const groupCountQuery = loadGroupTotalCount(dataSource, {
          filter: createGroupFilter(groupInfo.path, {
            filter: storeLoadOptions.filter,
            group
          }),
          group: group.slice(groupInfo.path.length),
          select: storeLoadOptions.select
        });
        const groupOffsetQuery = loadGroupTotalCount(dataSource, {
          filter: createOffsetFilter(groupInfo.path, {
            filter: storeLoadOptions.filter,
            group
          }, true),
          group: group.slice(groupInfo.path.length - 1, groupInfo.path.length),
          select: storeLoadOptions.select
        });
        return when(groupOffsetQuery, groupCountQuery).done(((offset, count) => {
          offset = parseInt(offset.length ? offset[0] : offset);
          count = parseInt(count.length ? count[0] : count);
          groupInfo.offset = offset;
          if (groupInfo.count !== count) {
            groupInfo.count = count;
            that.updateTotalItemsCount(options);
          }
        }));
      }), true);
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/grouping/m_grouping_expanded.js
var loadTotalCount = function(dataSource, options) {
  const d = new Deferred();
  const loadOptions = extend({
    skip: 0,
    take: 1,
    requireTotalCount: true
  }, options);
  dataSource.load(loadOptions).done(((data17, extra) => {
    d.resolve(extra && extra.totalCount);
  })).fail(d.reject.bind(d));
  return d;
};
var foreachCollapsedGroups = function(that, callback, updateOffsets) {
  return that.foreachGroups(((groupInfo) => {
    if (!groupInfo.isExpanded) {
      return callback(groupInfo);
    }
  }), false, false, updateOffsets, true);
};
var correctSkipLoadOption = function(that, skip) {
  let skipCorrection = 0;
  let resultSkip = skip || 0;
  if (skip) {
    foreachCollapsedGroups(that, ((groupInfo) => {
      if (groupInfo.offset - skipCorrection >= skip) {
        return false;
      }
      skipCorrection += groupInfo.count - 1;
    }));
    resultSkip += skipCorrection;
  }
  return resultSkip;
};
var processGroupItems2 = function(that, items, path, offset, skipFirstItem, take) {
  let removeLastItemsCount = 0;
  let needRemoveFirstItem = false;
  for (let i = 0; i < items.length; i++) {
    const item = items[i];
    if (void 0 !== item.items) {
      path.push(item.key);
      const groupInfo = that.findGroupInfo(path);
      if (groupInfo && !groupInfo.isExpanded) {
        item.collapsedItems = item.items;
        item.items = null;
        offset += groupInfo.count;
        take--;
        if (take < 0) {
          removeLastItemsCount++;
        }
        if (skipFirstItem) {
          needRemoveFirstItem = true;
        }
      } else if (item.items) {
        const offsetInfo = processGroupItems2(that, item.items, path, offset, skipFirstItem, take);
        if (skipFirstItem) {
          if (offsetInfo.offset - offset > 1) {
            item.isContinuation = true;
          } else {
            needRemoveFirstItem = true;
          }
        }
        offset = offsetInfo.offset;
        take = offsetInfo.take;
        if (take < 0) {
          if (item.items.length) {
            item.isContinuationOnNextPage = true;
          } else {
            removeLastItemsCount++;
          }
        }
      }
      path.pop();
    } else {
      if (skipFirstItem) {
        needRemoveFirstItem = true;
      }
      offset++;
      take--;
      if (take < 0) {
        removeLastItemsCount++;
      }
    }
    skipFirstItem = false;
  }
  if (needRemoveFirstItem) {
    items.splice(0, 1);
  }
  if (removeLastItemsCount) {
    items.splice(-removeLastItemsCount, removeLastItemsCount);
  }
  return {
    offset,
    take
  };
};
var pathEquals = function(path1, path2) {
  if (path1.length !== path2.length) {
    return false;
  }
  for (let i = 0; i < path1.length; i++) {
    if (!keysEqual(null, path1[i], path2[i])) {
      return false;
    }
  }
  return true;
};
var updateGroupOffsets = function(that, items, path, offset, additionalGroupInfo) {
  if (!items) {
    return;
  }
  for (let i = 0; i < items.length; i++) {
    const item = items[i];
    if ("key" in item && void 0 !== item.items) {
      path.push(item.key);
      if (additionalGroupInfo && pathEquals(additionalGroupInfo.path, path) && !item.isContinuation) {
        additionalGroupInfo.offset = offset;
      }
      const groupInfo = that.findGroupInfo(path);
      if (groupInfo && !item.isContinuation) {
        groupInfo.offset = offset;
      }
      if (groupInfo && !groupInfo.isExpanded) {
        offset += groupInfo.count;
      } else {
        offset = updateGroupOffsets(that, item.items, path, offset, additionalGroupInfo);
      }
      path.pop();
    } else {
      offset++;
    }
  }
  return offset;
};
var removeGroupLoadOption = function(storeLoadOptions, loadOptions) {
  if (loadOptions.group) {
    const groups = m_core_default.normalizeSortingInfo(loadOptions.group);
    const sorts = m_core_default.normalizeSortingInfo(storeLoadOptions.sort);
    storeLoadOptions.sort = m_store_helper_default.arrangeSortingInfo(groups, sorts);
    delete loadOptions.group;
  }
};
var createNotGroupFilter = function(path, storeLoadOptions, group) {
  const groups = m_core_default.normalizeSortingInfo(group || storeLoadOptions.group);
  let filter = [];
  for (let i = 0; i < path.length; i++) {
    const filterElement = [];
    for (let j = 0; j <= i; j++) {
      filterElement.push([groups[j].selector, i === j ? "<>" : "=", path[j]]);
    }
    filter.push(m_core_default.combineFilters(filterElement));
  }
  filter = m_core_default.combineFilters(filter, "or");
  return m_core_default.combineFilters([filter, storeLoadOptions.filter]);
};
var getGroupCount = function(item, groupCount) {
  let count = item.count || item.items.length;
  if (!item.count && groupCount > 1) {
    count = 0;
    for (let i = 0; i < item.items.length; i++) {
      count += getGroupCount(item.items[i], groupCount - 1);
    }
  }
  return count;
};
var GroupingHelper3 = class extends GroupingHelper {
  handleDataLoading(options) {
    const {
      storeLoadOptions
    } = options;
    const collapsedGroups = [];
    let collapsedItemsCount = 0;
    let skipFirstItem = false;
    let take;
    const {
      group
    } = options.loadOptions;
    let skipCorrection = 0;
    removeGroupLoadOption(storeLoadOptions, options.loadOptions);
    options.group = options.group || group;
    if (options.isCustomLoading) {
      return;
    }
    const loadOptions = extend({}, storeLoadOptions);
    loadOptions.skip = correctSkipLoadOption(this, storeLoadOptions.skip);
    if (loadOptions.skip && loadOptions.take && group) {
      loadOptions.skip--;
      loadOptions.take++;
      skipFirstItem = true;
    }
    if (loadOptions.take && group) {
      take = loadOptions.take;
      loadOptions.take++;
    }
    foreachCollapsedGroups(this, ((groupInfo) => {
      if (groupInfo.offset >= loadOptions.skip + loadOptions.take + skipCorrection) {
        return false;
      }
      if (groupInfo.offset >= loadOptions.skip + skipCorrection && groupInfo.count) {
        skipCorrection += groupInfo.count - 1;
        collapsedGroups.push(groupInfo);
        collapsedItemsCount += groupInfo.count;
      }
    }));
    each(collapsedGroups, (function() {
      loadOptions.filter = createNotGroupFilter(this.path, loadOptions, group);
    }));
    options.storeLoadOptions = loadOptions;
    options.collapsedGroups = collapsedGroups;
    options.collapsedItemsCount = collapsedItemsCount;
    options.skip = loadOptions.skip || 0;
    options.skipFirstItem = skipFirstItem;
    options.take = take;
  }
  handleDataLoaded(options, callBase) {
    const that = this;
    const {
      collapsedGroups
    } = options;
    const groups = m_core_default.normalizeSortingInfo(options.group);
    const groupCount = groups.length;
    function appendCollapsedPath(data17, path, groups2, collapsedGroup, offset) {
      if (!data17 || !path.length || !groups2.length) {
        return;
      }
      let keyValue;
      let i;
      const pathValue = toComparable(path[0], true);
      for (i = 0; i < data17.length; i++) {
        keyValue = toComparable(data17[i].key, true);
        if (offset >= collapsedGroup.offset || pathValue === keyValue) {
          break;
        } else {
          offset += getGroupCount(data17[i], groups2.length);
        }
      }
      if (!data17.length || pathValue !== keyValue) {
        data17.splice(i, 0, {
          key: path[0],
          items: [],
          count: 1 === path.length ? collapsedGroup.count : void 0
        });
      }
      appendCollapsedPath(data17[i].items, path.slice(1), groups2.slice(1), collapsedGroup, offset);
    }
    if (options.collapsedItemsCount && options.extra && options.extra.totalCount >= 0) {
      if (!options.extra._totalCountWasIncreasedByCollapsedItems) {
        options.extra.totalCount += options.collapsedItemsCount;
        options.extra._totalCountWasIncreasedByCollapsedItems = true;
      }
    }
    callBase(options);
    if (groupCount) {
      let {
        data: data17
      } = options;
      const query = m_query_default(data17);
      m_store_helper_default.multiLevelGroup(query, groups).enumerate().done(((groupedData) => {
        data17 = groupedData;
      }));
      if (collapsedGroups) {
        for (let pathIndex = 0; pathIndex < collapsedGroups.length; pathIndex++) {
          appendCollapsedPath(data17, collapsedGroups[pathIndex].path, groups, collapsedGroups[pathIndex], options.skip);
        }
      }
      if (!options.isCustomLoading) {
        processGroupItems2(that, data17, [], options.skip, options.skipFirstItem, options.take);
      }
      options.data = data17;
    }
  }
  isGroupItemCountable(item) {
    return null === item.items;
  }
  updateTotalItemsCount() {
    let itemsCountCorrection = 0;
    foreachCollapsedGroups(this, ((groupInfo) => {
      if (groupInfo.count) {
        itemsCountCorrection -= groupInfo.count - 1;
      }
    }));
    super.updateTotalItemsCount(itemsCountCorrection);
  }
  changeRowExpand(path) {
    const that = this;
    const dataSource = that._dataSource;
    const beginPageIndex = dataSource.beginPageIndex ? dataSource.beginPageIndex() : dataSource.pageIndex();
    const dataSourceItems = dataSource.items();
    const offset = correctSkipLoadOption(that, beginPageIndex * dataSource.pageSize());
    let groupInfo = that.findGroupInfo(path);
    let groupCountQuery;
    if (groupInfo && !groupInfo.isExpanded) {
      groupCountQuery = new Deferred().resolve(groupInfo.count);
    } else {
      groupCountQuery = loadTotalCount(dataSource, {
        filter: createGroupFilter(path, {
          filter: dataSource.filter(),
          group: dataSource.group()
        })
      });
    }
    return when(groupCountQuery).done(((count) => {
      count = parseInt(count.length ? count[0] : count);
      if (groupInfo) {
        updateGroupOffsets(that, dataSourceItems, [], offset);
        groupInfo.isExpanded = !groupInfo.isExpanded;
        groupInfo.count = count;
      } else {
        groupInfo = {
          offset: -1,
          count,
          path,
          isExpanded: false
        };
        updateGroupOffsets(that, dataSourceItems, [], offset, groupInfo);
        if (groupInfo.offset >= 0) {
          that.addGroupInfo(groupInfo);
        }
      }
      that.updateTotalItemsCount();
    })).fail((function() {
      dataSource._eventsStrategy.fireEvent("loadError", arguments);
    }));
  }
  allowCollapseAll() {
    return false;
  }
  refresh(options, operationTypes) {
    const that = this;
    const {
      storeLoadOptions
    } = options;
    const dataSource = that._dataSource;
    super.refresh.apply(this, arguments);
    if (operationTypes.reload) {
      return foreachCollapsedGroups(that, ((groupInfo) => {
        const groupCountQuery = loadTotalCount(dataSource, {
          filter: createGroupFilter(groupInfo.path, storeLoadOptions)
        });
        const groupOffsetQuery = loadTotalCount(dataSource, {
          filter: createOffsetFilter(groupInfo.path, storeLoadOptions)
        });
        return when(groupOffsetQuery, groupCountQuery).done(((offset, count) => {
          offset = parseInt(offset.length ? offset[0] : offset);
          count = parseInt(count.length ? count[0] : count);
          groupInfo.offset = offset;
          if (groupInfo.count !== count) {
            groupInfo.count = count;
            that.updateTotalItemsCount();
          }
        }));
      }), true);
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/grouping/m_grouping.js
var dataSourceAdapterExtender = (Base) => class extends Base {
  init() {
    super.init.apply(this, arguments);
    this._initGroupingHelper();
  }
  _initGroupingHelper(options) {
    const grouping = this._grouping;
    const isAutoExpandAll = this.option("grouping.autoExpandAll");
    const isFocusedRowEnabled = this.option("focusedRowEnabled");
    const remoteOperations = options ? options.remoteOperations : this.remoteOperations();
    const isODataRemoteOperations = remoteOperations.filtering && remoteOperations.sorting && remoteOperations.paging;
    if (isODataRemoteOperations && !remoteOperations.grouping && (isAutoExpandAll || !isFocusedRowEnabled)) {
      if (!grouping || grouping instanceof GroupingHelper2) {
        this._grouping = new GroupingHelper3(this);
      }
    } else if (!grouping || grouping instanceof GroupingHelper3) {
      this._grouping = new GroupingHelper2(this);
    }
  }
  totalItemsCount() {
    const totalCount = super.totalItemsCount();
    return totalCount > 0 && this._dataSource.group() && this._dataSource.requireTotalCount() ? totalCount + this._grouping.totalCountCorrection() : totalCount;
  }
  itemsCount() {
    return this._dataSource.group() ? this._grouping.itemsCount() || 0 : super.itemsCount.apply(this, arguments);
  }
  allowCollapseAll() {
    return this._grouping.allowCollapseAll();
  }
  isGroupItemCountable(item) {
    return this._grouping.isGroupItemCountable(item);
  }
  isRowExpanded(key) {
    const groupInfo = this._grouping.findGroupInfo(key);
    return groupInfo ? groupInfo.isExpanded : !this._grouping.allowCollapseAll();
  }
  collapseAll(groupIndex) {
    return this._collapseExpandAll(groupIndex, false);
  }
  expandAll(groupIndex) {
    return this._collapseExpandAll(groupIndex, true);
  }
  _collapseExpandAll(groupIndex, isExpand) {
    const that = this;
    const dataSource = that._dataSource;
    const group = dataSource.group();
    const groups = m_core_default.normalizeSortingInfo(group || []);
    if (groups.length) {
      for (let i = 0; i < groups.length; i++) {
        if (void 0 === groupIndex || groupIndex === i) {
          groups[i].isExpanded = isExpand;
        } else if (null !== group && void 0 !== group && group[i]) {
          groups[i].isExpanded = group[i].isExpanded;
        }
      }
      dataSource.group(groups);
      that._grouping.foreachGroups(((groupInfo, parents) => {
        if (void 0 === groupIndex || groupIndex === parents.length - 1) {
          groupInfo.isExpanded = isExpand;
        }
      }), false, true);
      that.resetPagesCache();
    }
    return true;
  }
  refresh() {
    super.refresh.apply(this, arguments);
    return this._grouping.refresh.apply(this._grouping, arguments);
  }
  changeRowExpand(path) {
    const that = this;
    const dataSource = that._dataSource;
    if (dataSource.group()) {
      dataSource.beginLoading();
      if (that._lastLoadOptions) {
        that._lastLoadOptions.groupExpand = true;
      }
      return that._changeRowExpandCore(path).always((() => {
        dataSource.endLoading();
      }));
    }
  }
  _changeRowExpandCore(path) {
    return this._grouping.changeRowExpand(path);
  }
  _hasGroupLevelsExpandState(group, isExpanded) {
    if (group && Array.isArray(group)) {
      for (let i = 0; i < group.length; i++) {
        if (group[i].isExpanded === isExpanded) {
          return true;
        }
      }
    }
  }
  _customizeRemoteOperations(options, operationTypes) {
    const {
      remoteOperations
    } = options;
    if (options.storeLoadOptions.group) {
      if (remoteOperations.grouping && !options.isCustomLoading) {
        if (!remoteOperations.groupPaging || this._hasGroupLevelsExpandState(options.storeLoadOptions.group, true)) {
          remoteOperations.paging = false;
        }
      }
      if (!remoteOperations.grouping && (!remoteOperations.sorting || !remoteOperations.filtering || options.isCustomLoading || this._hasGroupLevelsExpandState(options.storeLoadOptions.group, false))) {
        remoteOperations.paging = false;
      }
    } else if (!options.isCustomLoading && remoteOperations.paging && operationTypes.grouping) {
      this.resetCache();
    }
    super._customizeRemoteOperations.apply(this, arguments);
  }
  _handleDataLoading(options) {
    super._handleDataLoading(options);
    this._initGroupingHelper(options);
    return this._grouping.handleDataLoading(options);
  }
  _handleDataLoaded(options) {
    return this._grouping.handleDataLoaded(options, super._handleDataLoaded.bind(this));
  }
  _handleDataLoadedCore(options) {
    return this._grouping.handleDataLoadedCore(options, super._handleDataLoadedCore.bind(this));
  }
};
m_data_source_adapter_default.extend(dataSourceAdapterExtender);
var GroupingDataControllerExtender = (Base) => class extends Base {
  init() {
    super.init();
    this.createAction("onRowExpanding");
    this.createAction("onRowExpanded");
    this.createAction("onRowCollapsing");
    this.createAction("onRowCollapsed");
  }
  _beforeProcessItems(items) {
    const groupColumns = this._columnsController.getGroupColumns();
    items = super._beforeProcessItems(items);
    if (items.length && groupColumns.length) {
      items = this._processGroupItems(items, groupColumns.length);
    }
    return items;
  }
  _processItem(item, options) {
    if (isDefined(item.groupIndex) && isString(item.rowType) && 0 === item.rowType.indexOf("group")) {
      item = this._processGroupItem(item, options);
      options.dataIndex = 0;
    } else {
      item = super._processItem.apply(this, arguments);
    }
    return item;
  }
  _processGroupItem(item, options) {
    return item;
  }
  _processGroupItems(items, groupsCount, options) {
    const that = this;
    const groupedColumns = that._columnsController.getGroupColumns();
    const column = groupedColumns[groupedColumns.length - groupsCount];
    if (!options) {
      const scrollingMode = that.option("scrolling.mode");
      options = {
        collectContinuationItems: "virtual" !== scrollingMode && "infinite" !== scrollingMode,
        resultItems: [],
        path: [],
        values: []
      };
    }
    const {
      resultItems
    } = options;
    if (options.data) {
      if (options.collectContinuationItems || !options.data.isContinuation) {
        resultItems.push({
          rowType: "group",
          data: options.data,
          groupIndex: options.path.length - 1,
          isExpanded: !!options.data.items,
          key: options.path.slice(0),
          values: options.values.slice(0)
        });
      }
    }
    if (items) {
      if (0 === groupsCount) {
        resultItems.push.apply(resultItems, items);
      } else {
        for (let i = 0; i < items.length; i++) {
          const item = items[i];
          if (item && "items" in item) {
            options.data = item;
            options.path.push(item.key);
            options.values.push(column && column.deserializeValue && !column.calculateDisplayValue ? column.deserializeValue(item.key) : item.key);
            that._processGroupItems(item.items, groupsCount - 1, options);
            options.data = void 0;
            options.path.pop();
            options.values.pop();
          } else {
            resultItems.push(item);
          }
        }
      }
    }
    return resultItems;
  }
  publicMethods() {
    return super.publicMethods().concat(["collapseAll", "expandAll", "isRowExpanded", "expandRow", "collapseRow"]);
  }
  collapseAll(groupIndex) {
    const dataSource = this._dataSource;
    if (dataSource && dataSource.collapseAll(groupIndex)) {
      dataSource.pageIndex(0);
      dataSource.reload();
    }
  }
  expandAll(groupIndex) {
    const dataSource = this._dataSource;
    if (dataSource && dataSource.expandAll(groupIndex)) {
      dataSource.pageIndex(0);
      dataSource.reload();
    }
  }
  changeRowExpand(key) {
    const that = this;
    const expanded = that.isRowExpanded(key);
    const args = {
      key,
      expanded
    };
    that.executeAction(expanded ? "onRowCollapsing" : "onRowExpanding", args);
    if (!args.cancel) {
      return when(that._changeRowExpandCore(key)).done((() => {
        args.expanded = !expanded;
        that.executeAction(expanded ? "onRowCollapsed" : "onRowExpanded", args);
      }));
    }
    return new Deferred().resolve();
  }
  _changeRowExpandCore(key) {
    const that = this;
    const dataSource = this._dataSource;
    const d = new Deferred();
    if (!dataSource) {
      d.resolve();
    } else {
      when(dataSource.changeRowExpand(key)).done((() => {
        that.load().done(d.resolve).fail(d.reject);
      })).fail(d.reject);
    }
    return d;
  }
  isRowExpanded(key) {
    const dataSource = this._dataSource;
    return dataSource && dataSource.isRowExpanded(key);
  }
  expandRow(key) {
    if (!this.isRowExpanded(key)) {
      return this.changeRowExpand(key);
    }
    return new Deferred().resolve();
  }
  collapseRow(key) {
    if (this.isRowExpanded(key)) {
      return this.changeRowExpand(key);
    }
    return new Deferred().resolve();
  }
  optionChanged(args) {
    if ("grouping" === args.name) {
      args.name = "dataSource";
    }
    super.optionChanged(args);
  }
};
var onGroupingMenuItemClick = function(column, rowIndex, params) {
  var _this$getKeyboardNavi, _keyboardNavigationCo2;
  const keyboardNavigationController = null === (_this$getKeyboardNavi = this.getKeyboardNavigationController) || void 0 === _this$getKeyboardNavi ? void 0 : _this$getKeyboardNavi.call(this);
  switch (params.itemData.value) {
    case "group":
      var _keyboardNavigationCo;
      this.isNeedToFocusColumn = true;
      null === keyboardNavigationController || void 0 === keyboardNavigationController || null === (_keyboardNavigationCo = keyboardNavigationController.groupColumn) || void 0 === _keyboardNavigationCo || _keyboardNavigationCo.call(keyboardNavigationController, column, rowIndex);
      break;
    case "ungroup":
      this.isNeedToFocusColumn = true;
      null === keyboardNavigationController || void 0 === keyboardNavigationController || null === (_keyboardNavigationCo2 = keyboardNavigationController.ungroupColumn) || void 0 === _keyboardNavigationCo2 || _keyboardNavigationCo2.call(keyboardNavigationController, column, rowIndex);
      break;
    case "ungroupAll":
      this.isNeedToFocusColumn = true;
      null === keyboardNavigationController || void 0 === keyboardNavigationController || keyboardNavigationController.ungroupAllColumns();
  }
};
var isGroupPanelVisible = (groupPanelOptions) => {
  const visible = null === groupPanelOptions || void 0 === groupPanelOptions ? void 0 : groupPanelOptions.visible;
  return "auto" === visible ? "desktop" === devices_default.current().deviceType : !!visible;
};
var allowDragging = (groupPanelOptions, column) => {
  const isVisible2 = isGroupPanelVisible(groupPanelOptions);
  const canDrag = (null === groupPanelOptions || void 0 === groupPanelOptions ? void 0 : groupPanelOptions.allowColumnDragging) && (null === column || void 0 === column ? void 0 : column.allowGrouping);
  return isVisible2 && !!canDrag;
};
var GroupingHeaderPanelExtender = (Base) => class extends ColumnContextMenuMixin(Base) {
  _getToolbarItems() {
    const items = super._getToolbarItems();
    return this._appendGroupingItem(items);
  }
  _appendGroupingItem(items) {
    if (this._isGroupPanelVisible()) {
      let isRendered = false;
      const toolbarItem = {
        template: () => {
          const $groupPanel = renderer_default("<div>").addClass(CLASSES5.groupPanel);
          this._updateGroupPanelContent($groupPanel);
          registerKeyboardAction2("groupPanel", this, $groupPanel, void 0, this._handleActionKeyDown.bind(this));
          return $groupPanel;
        },
        name: "groupPanel",
        onItemRendered: () => {
          isRendered && this.renderCompleted.fire();
          isRendered = true;
        },
        location: "before",
        locateInMenu: "never",
        sortIndex: 1
      };
      items.push(toolbarItem);
      this.updateToolbarDimensions();
    }
    return items;
  }
  _handleActionKeyDown(args) {
    const {
      event
    } = args;
    const $target = renderer_default(event.target);
    const groupColumnIndex = $target.closest(`.${CLASSES5.groupPanelItem}`).index();
    const column = this._columnsController.getGroupColumns()[groupColumnIndex];
    const columnIndex = column && column.index;
    if ($target.is(".dx-header-filter")) {
      this._headerFilterController.showHeaderFilterMenu(columnIndex, true);
    } else {
      this._processGroupItemAction(columnIndex);
    }
    event.preventDefault();
  }
  _isGroupPanelVisible() {
    return isGroupPanelVisible(this.option("groupPanel"));
  }
  _renderGroupPanelItems($groupPanel, groupColumns) {
    const that = this;
    $groupPanel.empty();
    each(groupColumns, ((index, groupColumn) => {
      that._createGroupPanelItem($groupPanel, groupColumn);
    }));
    restoreFocus(this);
  }
  _createGroupPanelItem($rootElement, groupColumn) {
    const $groupPanelItem = renderer_default("<div>").addClass(groupColumn.cssClass).addClass(CLASSES5.groupPanelItem).data("columnData", groupColumn).appendTo($rootElement).text(groupColumn.caption);
    setTabIndex(this, $groupPanelItem);
    return $groupPanelItem;
  }
  getGroupAndUngroupItems(options) {
    const {
      column
    } = options;
    const contextMenuEnabled = this.option("grouping.contextMenuEnabled");
    if (contextMenuEnabled && column) {
      const isGroupingAllowed = isDefined(column.allowGrouping) ? column.allowGrouping : true;
      if (isGroupingAllowed) {
        const isColumnGrouped = isDefined(column.groupIndex) && column.groupIndex > -1;
        const groupingTexts = this.option("grouping.texts");
        const onItemClick = onGroupingMenuItemClick.bind(this, column, 0);
        return [{
          text: groupingTexts.ungroup,
          value: "ungroup",
          disabled: !isColumnGrouped,
          onItemClick,
          icon: CONTEXT_MENU_UNGROUP_COLUMN_ICON_NAME
        }, {
          text: groupingTexts.ungroupAll,
          value: "ungroupAll",
          onItemClick,
          icon: CONTEXT_MENU_UNGROUP_ALL_COLUMNS_ICON_NAME
        }];
      }
    }
    return [];
  }
  _columnOptionChanged(e) {
    if (!this._requireReady && !m_core_default.checkChanges(e.optionNames, ["width", "visibleWidth"])) {
      const $toolbarElement = this.element();
      const $groupPanel = null === $toolbarElement || void 0 === $toolbarElement ? void 0 : $toolbarElement.find(`.${CLASSES5.groupPanel}`);
      if ($groupPanel && $groupPanel.length) {
        this._updateGroupPanelContent($groupPanel);
        this.updateToolbarDimensions();
        this.renderCompleted.fire();
      }
    }
    super._columnOptionChanged();
  }
  _updateGroupPanelContent($groupPanel) {
    const groupColumns = this.getColumns();
    const groupPanelOptions = this.option("groupPanel");
    this._renderGroupPanelItems($groupPanel, groupColumns);
    if (groupPanelOptions.allowColumnDragging && !groupColumns.length) {
      renderer_default("<div>").addClass(CLASSES5.groupPanelMessage).text(groupPanelOptions.emptyPanelText).appendTo($groupPanel);
      $groupPanel.closest(`.${CLASSES5.groupPanelContainer}`).addClass(CLASSES5.groupPanelLabel);
      $groupPanel.closest(`.${CLASSES5.groupPanelLabel}`).css("maxWidth", "none");
    }
  }
  allowDragging(column) {
    const groupPanelOptions = this.option("groupPanel");
    return allowDragging(groupPanelOptions, column);
  }
  getColumnElements() {
    const $element = this.element();
    return null === $element || void 0 === $element ? void 0 : $element.find(`.${CLASSES5.groupPanelItem}`);
  }
  getColumns() {
    return this._columnsController.getGroupColumns();
  }
  getBoundingRect() {
    const $element = this.element();
    if (null !== $element && void 0 !== $element && $element.find(`.${CLASSES5.groupPanel}`).length) {
      const offset = $element.offset();
      return {
        top: offset.top,
        bottom: offset.top + getHeight($element)
      };
    }
    return null;
  }
  getName() {
    return "group";
  }
  hasGroupedColumns() {
    return this._isGroupPanelVisible() && !!this.getColumns().length;
  }
  optionChanged(args) {
    if ("groupPanel" === args.name) {
      this._invalidate();
      args.handled = true;
    } else {
      super.optionChanged(args);
    }
  }
  getKeyboardNavigationController() {
    return this.getController("groupPanelKeyboardNavigation");
  }
  isColumnReorderingEnabled(column) {
    return this.allowDragging(column);
  }
  getContextMenuItems(options) {
    let items = super.getContextMenuItems(options);
    const $groupedColumnElement = renderer_default(options.targetElement).closest(`.${CLASSES5.groupPanelItem}`);
    if (!$groupedColumnElement.length) {
      return;
    }
    options.column = this._columnsController.columnOption(`groupIndex:${$groupedColumnElement.index()}`);
    const groupAndUngroupItems = this.getGroupAndUngroupItems(options);
    if (null !== groupAndUngroupItems && void 0 !== groupAndUngroupItems && groupAndUngroupItems.length) {
      items = items ?? [];
      items.push(...groupAndUngroupItems);
    }
    const moveColumnItems = this.getMoveColumnContextMenuItems(options);
    if (null !== moveColumnItems && void 0 !== moveColumnItems && moveColumnItems.length) {
      items = items ?? [];
      items.push(...moveColumnItems);
    }
    return items;
  }
};
var GroupingRowsViewExtender = (Base) => class extends Base {
  getContextMenuItems(options) {
    const that = this;
    const contextMenuEnabled = that.option("grouping.contextMenuEnabled");
    let items;
    if (contextMenuEnabled && options.row && "group" === options.row.rowType) {
      const columnsController = that._columnsController;
      const column = columnsController.columnOption(`groupIndex:${options.row.groupIndex}`);
      if (column && column.allowGrouping) {
        const groupingTexts = that.option("grouping.texts");
        const onItemClick = (e) => {
          var _e$itemData, _e$itemData2;
          if ("ungroup" === (null === (_e$itemData = e.itemData) || void 0 === _e$itemData ? void 0 : _e$itemData.value)) {
            columnsController.columnOption(column.dataField, "groupIndex", -1);
          } else if ("ungroupAll" === (null === (_e$itemData2 = e.itemData) || void 0 === _e$itemData2 ? void 0 : _e$itemData2.value)) {
            columnsController.clearGrouping();
          }
        };
        items = [];
        items.push({
          text: groupingTexts.ungroup,
          value: "ungroup",
          onItemClick,
          icon: CONTEXT_MENU_UNGROUP_COLUMN_ICON_NAME
        }, {
          text: groupingTexts.ungroupAll,
          value: "ungroupAll",
          onItemClick,
          icon: CONTEXT_MENU_UNGROUP_ALL_COLUMNS_ICON_NAME
        });
      }
    }
    return items;
  }
  _rowClick(e) {
    const that = this;
    const expandMode = that.option("grouping.expandMode");
    const scrollingMode = that.option("scrolling.mode");
    const isGroupRowStateChanged = "infinite" !== scrollingMode && "rowClick" === expandMode && renderer_default(e.event.target).closest(".dx-group-row").length;
    const isExpandButtonClicked = renderer_default(e.event.target).closest(".dx-datagrid-expand").length;
    if (isGroupRowStateChanged || isExpandButtonClicked) {
      that._changeGroupRowState(e);
    }
    super._rowClick(e);
  }
  _changeGroupRowState(e) {
    const row = this._dataController.items()[e.rowIndex];
    const allowCollapsing = this._columnsController.columnOption(`groupIndex:${row.groupIndex}`, "allowCollapsing");
    if ("data" === row.rowType || "group" === row.rowType && false !== allowCollapsing) {
      this._dataController.changeRowExpand(row.key, true);
      e.event.preventDefault();
      e.handled = true;
    }
  }
};
var columnHeadersViewExtender = (Base) => class extends Base {
  getContextMenuItems(options) {
    const that = this;
    const groupItems = [];
    const contextMenuEnabled = that.option("grouping.contextMenuEnabled");
    let items = super.getContextMenuItems(options);
    if (contextMenuEnabled && options.row && ("header" === options.row.rowType || "detailAdaptive" === options.row.rowType)) {
      const {
        column,
        rowIndex
      } = options;
      if (!column.command && (!isDefined(column.allowGrouping) || column.allowGrouping)) {
        const groupingTexts = that.option("grouping.texts");
        const isColumnGrouped = isDefined(column.groupIndex) && column.groupIndex > -1;
        const onItemClick = onGroupingMenuItemClick.bind(that, column, rowIndex);
        groupItems.push({
          text: groupingTexts.groupByThisColumn,
          value: "group",
          beginGroup: true,
          disabled: isColumnGrouped,
          onItemClick,
          icon: CONTEXT_MENU_GROUP_BY_COLUMN_ICON_NAME
        });
        if (column.showWhenGrouped) {
          groupItems.push({
            text: groupingTexts.ungroup,
            value: "ungroup",
            disabled: !isColumnGrouped,
            onItemClick,
            icon: CONTEXT_MENU_UNGROUP_COLUMN_ICON_NAME
          });
        }
        groupItems.push({
          text: groupingTexts.ungroupAll,
          value: "ungroupAll",
          onItemClick,
          icon: CONTEXT_MENU_UNGROUP_ALL_COLUMNS_ICON_NAME
        });
      }
    }
    if (groupItems.length) {
      items = items ?? [];
      const clearSortingItemIndex = items.findIndex(((item) => "clearSorting" === item.name)) + 1;
      items.splice(clearSortingItemIndex, 0, ...groupItems);
    }
    return items;
  }
  allowDragging(column) {
    const groupPanelOptions = this.option("groupPanel");
    return allowDragging(groupPanelOptions, column) || super.allowDragging(column);
  }
};
m_core_default.registerModule("grouping", {
  defaultOptions: () => ({
    grouping: {
      autoExpandAll: true,
      allowCollapsing: true,
      contextMenuEnabled: true,
      expandMode: "buttonClick",
      texts: {
        groupContinuesMessage: message_default.format("dxDataGrid-groupContinuesMessage"),
        groupContinuedMessage: message_default.format("dxDataGrid-groupContinuedMessage"),
        groupByThisColumn: message_default.format("dxDataGrid-groupHeaderText"),
        ungroup: message_default.format("dxDataGrid-ungroupHeaderText"),
        ungroupAll: message_default.format("dxDataGrid-ungroupAllText")
      }
    },
    groupPanel: {
      visible: false,
      emptyPanelText: message_default.format("dxDataGrid-groupPanelEmptyText"),
      allowColumnDragging: true
    }
  }),
  extenders: {
    controllers: {
      data: GroupingDataControllerExtender,
      columns: (Base) => class extends Base {
        _getExpandColumnOptions() {
          const options = super._getExpandColumnOptions.apply(this, arguments);
          options.cellTemplate = m_core_default.getExpandCellTemplate();
          return options;
        }
      },
      editing: (Base) => class extends Base {
        _isProcessedItem(item) {
          return isDefined(item.groupIndex) && isString(item.rowType) && 0 === item.rowType.indexOf("group");
        }
      }
    },
    views: {
      headerPanel: GroupingHeaderPanelExtender,
      rowsView: GroupingRowsViewExtender,
      columnHeadersView: columnHeadersViewExtender
    }
  }
});

// node_modules/devextreme/esm/__internal/grids/grid_core/master_detail/const.js
var CLASSES6 = {
  detailRow: "dx-master-detail-row",
  detailCell: "dx-master-detail-cell",
  detailContainer: "master-detail-container",
  cellFocusDisabledClass: "dx-cell-focus-disabled",
  rowLines: "dx-row-lines"
};

// node_modules/devextreme/esm/__internal/grids/grid_core/master_detail/utils.js
function isDetailRow(row) {
  const rowType = null === row || void 0 === row ? void 0 : row.rowType;
  return "detail" === rowType || "detailAdaptive" === rowType;
}

// node_modules/devextreme/esm/__internal/grids/grid_core/master_detail/m_master_detail.js
var columns3 = (Base) => class extends Base {
  _getExpandColumnsCore() {
    const expandColumns = super._getExpandColumnsCore();
    if (this.option("masterDetail.enabled")) {
      expandColumns.push({
        type: "detailExpand",
        cellTemplate: m_utils_default.getExpandCellTemplate()
      });
    }
    return expandColumns;
  }
};
var initMasterDetail = function(that) {
  that._expandedItems = [];
  that._isExpandAll = that.option("masterDetail.autoExpandAll");
};
var dataMasterDetailExtenderMixin = (Base) => class extends Base {
  init() {
    initMasterDetail(this);
    super.init();
  }
  expandAll(groupIndex) {
    const that = this;
    if (groupIndex < 0) {
      that._isExpandAll = true;
      that._expandedItems = [];
      that.updateItems();
    } else {
      super.expandAll.apply(that, arguments);
    }
  }
  collapseAll(groupIndex) {
    const that = this;
    if (groupIndex < 0) {
      that._isExpandAll = false;
      that._expandedItems = [];
      that.updateItems();
    } else {
      super.collapseAll.apply(that, arguments);
    }
  }
  isRowExpandedHack() {
    return super.isRowExpanded.apply(this, arguments);
  }
  isRowExpanded(key) {
    const that = this;
    const expandIndex = m_utils_default.getIndexByKey(key, that._expandedItems);
    if (Array.isArray(key)) {
      return super.isRowExpanded.apply(that, arguments);
    }
    return !!(that._isExpandAll ^ (expandIndex >= 0 && that._expandedItems[expandIndex].visible));
  }
  _getRowIndicesForExpand(key) {
    const rowIndex = this.getRowIndexByKey(key);
    return [rowIndex, rowIndex + 1];
  }
  _changeRowExpandCore(key) {
    const that = this;
    let result;
    if (Array.isArray(key)) {
      result = super._changeRowExpandCore.apply(that, arguments);
    } else {
      const expandIndex = m_utils_default.getIndexByKey(key, that._expandedItems);
      if (expandIndex >= 0) {
        const {
          visible
        } = that._expandedItems[expandIndex];
        that._expandedItems[expandIndex].visible = !visible;
      } else {
        that._expandedItems.push({
          key,
          visible: true
        });
      }
      that.updateItems({
        changeType: "update",
        rowIndices: that._getRowIndicesForExpand(key)
      });
      result = new Deferred().resolve();
    }
    return result;
  }
  _processDataItemHack() {
    return super._processDataItem.apply(this, arguments);
  }
  _processDataItem(data17, options) {
    const dataItem = super._processDataItem.apply(this, arguments);
    dataItem.isExpanded = this.isRowExpanded(dataItem.key);
    if (void 0 === options.detailColumnIndex) {
      options.detailColumnIndex = -1;
      each(options.visibleColumns, ((index, column) => {
        if ("expand" === column.command && !isDefined(column.groupIndex)) {
          options.detailColumnIndex = index;
          return false;
        }
        return;
      }));
    }
    if (options.detailColumnIndex >= 0) {
      dataItem.values[options.detailColumnIndex] = dataItem.isExpanded;
    }
    return dataItem;
  }
  _processItemsHack() {
    return super._processItems.apply(this, arguments);
  }
  _processItems(items, change) {
    const that = this;
    const {
      changeType
    } = change;
    const result = [];
    items = super._processItems.apply(that, arguments);
    if ("loadingAll" === changeType) {
      return items;
    }
    if ("refresh" === changeType) {
      that._expandedItems = grep(that._expandedItems, ((item) => item.visible));
    }
    each(items, ((index, item) => {
      result.push(item);
      const expandIndex = m_utils_default.getIndexByKey(item.key, that._expandedItems);
      if ("data" === item.rowType && (item.isExpanded || expandIndex >= 0) && !item.isNewRow) {
        result.push({
          visible: item.isExpanded,
          rowType: "detail",
          key: item.key,
          data: item.data,
          values: []
        });
      }
    }));
    return result;
  }
  optionChanged(args) {
    const that = this;
    let isEnabledChanged;
    let isAutoExpandAllChanged;
    if ("masterDetail" === args.name) {
      args.name = "dataSource";
      switch (args.fullName) {
        case "masterDetail": {
          const value2 = args.value || {};
          const previousValue = args.previousValue || {};
          isEnabledChanged = value2.enabled !== previousValue.enabled;
          isAutoExpandAllChanged = value2.autoExpandAll !== previousValue.autoExpandAll;
          break;
        }
        case "masterDetail.template":
          initMasterDetail(that);
          break;
        case "masterDetail.enabled":
          isEnabledChanged = true;
          break;
        case "masterDetail.autoExpandAll":
          isAutoExpandAllChanged = true;
      }
      if (isEnabledChanged || isAutoExpandAllChanged) {
        initMasterDetail(that);
      }
    }
    super.optionChanged(args);
  }
};
var resizing2 = (Base) => class extends Base {
  fireContentReadyAction() {
    super.fireContentReadyAction.apply(this, arguments);
    this._updateParentDataGrids(this.component.$element());
  }
  _updateParentDataGrids($element) {
    const $masterDetailRow = $element.closest(`.${CLASSES6.detailRow}`);
    if ($masterDetailRow.length) {
      when(this._updateMasterDataGrid($masterDetailRow, $element)).done((() => {
        this._updateParentDataGrids($masterDetailRow.parent());
      }));
    }
  }
  _updateMasterDataGrid($masterDetailRow, $detailElement) {
    const masterRowOptions = renderer_default($masterDetailRow).data("options");
    const masterDataGrid = renderer_default($masterDetailRow).closest(`.${this.getWidgetContainerClass()}`).parent().data("dxDataGrid");
    if (masterRowOptions && masterDataGrid) {
      return this._updateMasterDataGridCore(masterDataGrid, masterRowOptions);
    }
    return;
  }
  _updateMasterDataGridCore(masterDataGrid, masterRowOptions) {
    var _masterDataGrid$getVi, _masterDataGrid$getVi2;
    const d = Deferred();
    if (null !== (_masterDataGrid$getVi = masterDataGrid.getView("rowsView")) && void 0 !== _masterDataGrid$getVi && null !== (_masterDataGrid$getVi2 = _masterDataGrid$getVi.isFixedColumns) && void 0 !== _masterDataGrid$getVi2 && _masterDataGrid$getVi2.call(_masterDataGrid$getVi)) {
      this._updateFixedMasterDetailGrids(masterDataGrid, masterRowOptions.rowIndex, renderer_default(masterRowOptions.rowElement)).done(d.resolve);
    } else {
      if (true === masterDataGrid.option("scrolling.useNative")) {
        masterDataGrid.updateDimensions().done((() => d.resolve(true)));
        return;
      }
      const scrollable = masterDataGrid.getScrollable();
      if (scrollable) {
        null === scrollable || void 0 === scrollable || scrollable.update().done((() => d.resolve()));
      } else {
        d.resolve();
      }
    }
    return d.promise();
  }
  _updateFixedMasterDetailGrids(masterDataGrid, masterRowIndex, $detailElement) {
    const d = Deferred();
    const $rows = renderer_default(masterDataGrid.getRowElement(masterRowIndex));
    const $tables = renderer_default(masterDataGrid.getView("rowsView").getTableElements());
    const rowsNotEqual = 2 === (null === $rows || void 0 === $rows ? void 0 : $rows.length) && getHeight($rows.eq(0)) !== getHeight($rows.eq(1));
    const tablesNotEqual = 2 === (null === $tables || void 0 === $tables ? void 0 : $tables.length) && getHeight($tables.eq(0)) !== getHeight($tables.eq(1));
    if (rowsNotEqual || tablesNotEqual) {
      const detailElementWidth = getWidth($detailElement);
      masterDataGrid.updateDimensions().done((() => {
        const isDetailHorizontalScrollCanBeShown = this.option("columnAutoWidth") && true === masterDataGrid.option("scrolling.useNative");
        const isDetailGridWidthChanged = isDetailHorizontalScrollCanBeShown && detailElementWidth !== getWidth($detailElement);
        if (isDetailHorizontalScrollCanBeShown && isDetailGridWidthChanged) {
          this.updateDimensions().done((() => d.resolve(true)));
        } else {
          d.resolve(true);
        }
      }));
      return d.promise();
    }
    return Deferred().resolve();
  }
  _toggleBestFitMode(isBestFit) {
    super._toggleBestFitMode.apply(this, arguments);
    const hasMasterDetailTemplate = this.option("masterDetail.template");
    if (!hasMasterDetailTemplate) {
      return;
    }
    const $rowsTable = this._rowsView.getTableElement();
    if ($rowsTable) {
      const detailSelector = `.${this.addWidgetPrefix(CLASSES6.detailContainer)}, .${CLASSES6.detailCell}`;
      $rowsTable.find(detailSelector).css("maxWidth", isBestFit ? 0 : "");
    }
  }
};
var rowsView2 = (Base) => class extends Base {
  _getCellTemplate(options) {
    const that = this;
    const {
      column
    } = options;
    const editingController = this._editingController;
    const isEditRow2 = editingController && editingController.isEditRow(options.rowIndex);
    let template;
    if ("detail" === column.command && !isEditRow2) {
      template = that.option("masterDetail.template") || {
        allowRenderToDetachedContainer: false,
        render: that._getDefaultTemplate(column)
      };
    } else {
      template = super._getCellTemplate.apply(that, arguments);
    }
    return template;
  }
  _createRow(row) {
    const $row = super._createRow.apply(this, arguments);
    const isDetailRowResult = isDetailRow(row);
    if (isDetailRowResult) {
      const showRowLines = this.option("showRowLines");
      $row.addClass(CLASSES6.detailRow).toggleClass(CLASSES6.rowLines, showRowLines);
      if (isDefined(row.visible)) {
        $row.toggle(row.visible);
      }
    }
    return $row;
  }
  _renderCells($row, options) {
    const {
      row
    } = options;
    const isDetailRowResult = isDetailRow(row);
    if (isDetailRowResult) {
      if (this._needRenderCell(0, options.columnIndices)) {
        this._renderMasterDetailCell($row, row, options);
      }
    } else {
      super._renderCells.apply(this, arguments);
    }
  }
  _renderMasterDetailCell($row, row, options) {
    const visibleColumns = this._columnsController.getVisibleColumns();
    const $detailCell = this._renderCell($row, {
      value: null,
      row,
      rowIndex: row.rowIndex,
      column: {
        command: "detail"
      },
      columnIndex: 0,
      change: options.change
    });
    $detailCell.addClass(CLASSES6.cellFocusDisabledClass).addClass(CLASSES6.detailCell).attr("colSpan", visibleColumns.length);
    const isEditForm2 = row.isEditing;
    if (!isEditForm2) {
      $detailCell.attr("aria-roledescription", message_default.format("dxDataGrid-masterDetail"));
    }
    return $detailCell;
  }
};
var masterDetailModule = {
  defaultOptions: () => ({
    masterDetail: {
      enabled: false,
      autoExpandAll: false,
      template: null
    }
  }),
  extenders: {
    controllers: {
      columns: columns3,
      data: dataMasterDetailExtenderMixin,
      resizing: resizing2
    },
    views: {
      rowsView: rowsView2
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/master_detail.js
m_core_default.registerModule("masterDetail", masterDetailModule);

// node_modules/devextreme/esm/ui/select_box.js
var select_box_default = m_select_box_default;

// node_modules/devextreme/esm/ui/shared/ui.editor_factory_mixin.js
var {
  isWrapped
} = variable_wrapper_default;
var EDITOR_INLINE_BLOCK = "dx-editor-inline-block";
var getResultConfig = function(config, options) {
  return extend(config, {
    readOnly: options.readOnly,
    placeholder: options.placeholder,
    inputAttr: {
      id: options.id,
      "aria-labelledby": options["aria-labelledby"]
    },
    tabIndex: options.tabIndex
  }, options.editorOptions);
};
var checkEnterBug = function() {
  return browser_default.mozilla || devices_default.real().ios;
};
var getTextEditorConfig = function(options) {
  const data17 = {};
  const isEnterBug = checkEnterBug();
  const sharedData = options.sharedData || data17;
  return getResultConfig({
    placeholder: options.placeholder,
    width: options.width,
    value: options.value,
    onValueChanged: function(e) {
      const needDelayedUpdate = "filterRow" === options.parentType || "searchPanel" === options.parentType;
      const isInputOrKeyUpEvent = e.event && ("input" === e.event.type || "keyup" === e.event.type);
      const updateValue = function(e2, notFireEvent) {
        options && options.setValue(e2.value, notFireEvent);
      };
      clearTimeout(data17.valueChangeTimeout);
      if (isInputOrKeyUpEvent && needDelayedUpdate) {
        sharedData.valueChangeTimeout = data17.valueChangeTimeout = setTimeout((function() {
          updateValue(e, data17.valueChangeTimeout !== sharedData.valueChangeTimeout);
        }), isDefined(options.updateValueTimeout) ? options.updateValueTimeout : 0);
      } else {
        updateValue(e);
      }
    },
    onKeyDown: function(e) {
      if (isEnterBug && "enter" === normalizeKeyName(e.event)) {
        m_events_engine_default.trigger(renderer_default(e.component._input()), "change");
      }
    },
    valueChangeEvent: "change" + ("filterRow" === options.parentType ? " keyup input" : "")
  }, options);
};
var prepareDateBox = function(options) {
  options.editorName = "dxDateBox";
  options.editorOptions = getResultConfig({
    value: options.value,
    onValueChanged: function(args) {
      options.setValue(args.value);
    },
    onKeyDown: function(_ref) {
      let {
        component,
        event
      } = _ref;
      const useMaskBehavior = component.option("useMaskBehavior");
      if ((checkEnterBug() || useMaskBehavior) && "enter" === normalizeKeyName(event)) {
        component.blur();
        component.focus();
      }
    },
    displayFormat: options.format,
    type: options.dataType,
    dateSerializationFormat: null,
    width: "filterBuilder" === options.parentType ? void 0 : "auto"
  }, options);
};
var prepareTextBox = function(options) {
  const config = getTextEditorConfig(options);
  const isSearching = "searchPanel" === options.parentType;
  if (options.editorType && "dxTextBox" !== options.editorType) {
    config.value = options.value;
  } else {
    config.value = (value2 = options.value, isDefined(value2) ? value2.toString() : "");
  }
  var value2;
  config.valueChangeEvent += isSearching ? " keyup input search" : "";
  config.mode = config.mode || (isSearching ? "search" : "text");
  options.editorName = "dxTextBox";
  options.editorOptions = config;
};
var prepareNumberBox = function(options) {
  const config = getTextEditorConfig(options);
  config.value = isDefined(options.value) ? options.value : null;
  options.editorName = "dxNumberBox";
  options.editorOptions = config;
};
var prepareBooleanEditor = function(options) {
  if ("filterRow" === options.parentType || "filterBuilder" === options.parentType) {
    prepareLookupEditor(extend(options, {
      lookup: {
        displayExpr: function(data17) {
          if (true === data17) {
            return options.trueText || "true";
          } else if (false === data17) {
            return options.falseText || "false";
          }
        },
        dataSource: [true, false]
      }
    }));
  } else {
    prepareCheckBox(options);
  }
};
function watchLookupDataSource(options) {
  if (options.row && options.row.watch && "dataRow" === options.parentType) {
    const editorOptions = options.editorOptions || {};
    options.editorOptions = editorOptions;
    let selectBox;
    const onInitialized = editorOptions.onInitialized;
    editorOptions.onInitialized = function(e) {
      onInitialized && onInitialized.apply(this, arguments);
      selectBox = e.component;
      selectBox.on("disposing", stopWatch);
    };
    let dataSource;
    const stopWatch = options.row.watch((() => {
      dataSource = options.lookup.dataSource(options.row);
      return dataSource && dataSource.filter;
    }), (() => {
      selectBox.option("dataSource", dataSource);
    }), ((row) => {
      options.row = row;
    }));
  }
}
function prepareLookupEditor(options) {
  const lookup = options.lookup;
  let displayGetter;
  let dataSource;
  let postProcess;
  const isFilterRow = "filterRow" === options.parentType;
  if (lookup) {
    displayGetter = compileGetter(lookup.displayExpr);
    dataSource = lookup.dataSource;
    if (isFunction(dataSource) && !isWrapped(dataSource)) {
      dataSource = dataSource(options.row || {});
      watchLookupDataSource(options);
    }
    if (isObject(dataSource) || Array.isArray(dataSource)) {
      dataSource = normalizeDataSourceOptions(dataSource);
      if (isFilterRow) {
        postProcess = dataSource.postProcess;
        dataSource.postProcess = function(items) {
          if (0 === this.pageIndex()) {
            items = items.slice(0);
            items.unshift(null);
          }
          if (postProcess) {
            return postProcess.call(this, items);
          }
          return items;
        };
      }
    }
    const allowClearing = Boolean(lookup.allowClearing && !isFilterRow);
    options.editorName = options.editorType ?? "dxSelectBox";
    options.editorOptions = getResultConfig({
      searchEnabled: true,
      value: options.value,
      valueExpr: options.lookup.valueExpr,
      searchExpr: options.lookup.searchExpr || options.lookup.displayExpr,
      allowClearing,
      showClearButton: allowClearing,
      displayExpr: function(data17) {
        if (null === data17) {
          return options.showAllText;
        }
        return displayGetter(data17);
      },
      dataSource,
      onValueChanged: function(e) {
        const params = [e.value];
        !isFilterRow && params.push(e.component.option("text"));
        options.setValue.apply(this, params);
      }
    }, options);
  }
}
function prepareCheckBox(options) {
  options.editorName = "dxCheckBox";
  options.editorOptions = getResultConfig({
    elementAttr: {
      id: options.id
    },
    value: isDefined(options.value) ? options.value : void 0,
    hoverStateEnabled: !options.readOnly,
    focusStateEnabled: !options.readOnly,
    activeStateEnabled: false,
    onValueChanged: function(e) {
      options.setValue && options.setValue(e.value, e);
    }
  }, options);
}
var createEditorCore = function(that, options) {
  const $editorElement = renderer_default(options.editorElement);
  if (options.editorName && options.editorOptions && $editorElement[options.editorName]) {
    if ("dxCheckBox" === options.editorName || "dxSwitch" === options.editorName) {
      if (!options.isOnForm) {
        $editorElement.addClass(that.addWidgetPrefix("checkbox-size"));
        $editorElement.parent().addClass(EDITOR_INLINE_BLOCK);
      }
    }
    that._createComponent($editorElement, options.editorName, options.editorOptions);
    if ("dxDateBox" === options.editorName) {
      const dateBox = $editorElement.dxDateBox("instance");
      const defaultEnterKeyHandler = dateBox._supportedKeys().enter;
      dateBox.registerKeyHandler("enter", ((e) => {
        if (dateBox.option("opened")) {
          defaultEnterKeyHandler(e);
        }
        return true;
      }));
    }
    if ("dxTextArea" === options.editorName) {
      $editorElement.dxTextArea("instance").registerKeyHandler("enter", (function(event) {
        if ("enter" === normalizeKeyName(event) && !event.ctrlKey && !event.shiftKey) {
          event.stopPropagation();
        }
      }));
    }
  }
};
var prepareCustomEditor = (options) => {
  options.editorName = options.editorType;
  options.editorOptions = getResultConfig({
    value: options.value,
    onValueChanged: function(args) {
      options.setValue(args.value);
    }
  }, options);
};
var prepareEditor = (options) => {
  const prepareDefaultEditor = {
    dxDateBox: prepareDateBox,
    dxCheckBox: prepareCheckBox,
    dxNumberBox: prepareNumberBox,
    dxTextBox: prepareTextBox
  };
  if (options.lookup) {
    prepareLookupEditor(options);
  } else if (options.editorType) {
    (prepareDefaultEditor[options.editorType] ?? prepareCustomEditor)(options);
  } else {
    switch (options.dataType) {
      case "date":
      case "datetime":
        prepareDateBox(options);
        break;
      case "boolean":
        prepareBooleanEditor(options);
        break;
      case "number":
        prepareNumberBox(options);
        break;
      default:
        prepareTextBox(options);
    }
  }
};
var EditorFactoryMixin = (Base) => class extends Base {
  createEditor($container, options) {
    options.cancel = false;
    options.editorElement = getPublicElement($container);
    if (!isDefined(options.tabIndex)) {
      options.tabIndex = this.option("tabIndex");
    }
    prepareEditor(options);
    this.executeAction("onEditorPreparing", options);
    if (options.cancel) {
      return;
    }
    if ("dataRow" === options.parentType && !options.isOnForm && !isDefined(options.editorOptions.showValidationMark)) {
      options.editorOptions.showValidationMark = false;
    }
    createEditorCore(this, options);
    this.executeAction("onEditorPrepared", options);
  }
};
var ui_editor_factory_mixin_default = EditorFactoryMixin;

// node_modules/devextreme/esm/__internal/grids/grid_core/editor_factory/m_editor_factory.js
var EDITOR_INLINE_BLOCK2 = "dx-editor-inline-block";
var MODULE_NAMESPACE = "dxDataGridEditorFactory";
var UPDATE_FOCUS_EVENTS = addNamespace([CLICK_EVENT_NAME, "focusin"].join(" "), MODULE_NAMESPACE);
var DX_HIDDEN = "dx-hidden";
var ViewControllerWithMixin = ui_editor_factory_mixin_default(m_modules_default.ViewController);
var EditorFactory = class extends ViewControllerWithMixin {
  init() {
    this.createAction("onEditorPreparing", {
      excludeValidators: ["disabled", "readOnly"],
      category: "rendering"
    });
    this.createAction("onEditorPrepared", {
      excludeValidators: ["disabled", "readOnly"],
      category: "rendering"
    });
    this._columnsResizerController = this.getController("columnsResizer");
    this._editingController = this.getController("editing");
    this._keyboardNavigationController = this.getController("keyboardNavigation");
    this._columnsController = this.getController("columns");
    this._validatingController = this.getController("validating");
    this._columnHeadersView = this.getView("columnHeadersView");
    this._rowsView = this.getView("rowsView");
    this._updateFocusHandler = this._updateFocusHandler || this.createAction(this._updateFocus.bind(this));
    this._subscribedContainerRoot = this._getContainerRoot();
    m_events_engine_default.on(this._subscribedContainerRoot, UPDATE_FOCUS_EVENTS, this._updateFocusHandler);
    this._attachContainerEventHandlers();
  }
  dispose() {
    clearTimeout(this._focusTimeoutID);
    clearTimeout(this._updateFocusTimeoutID);
    m_events_engine_default.off(this._subscribedContainerRoot, UPDATE_FOCUS_EVENTS, this._updateFocusHandler);
  }
  _getFocusedElement($dataGridElement) {
    const rowSelector = this.option("focusedRowEnabled") ? "tr[tabindex]:focus" : "tr[tabindex]:not(.dx-data-row):focus";
    const focusedElementSelector = ["td[tabindex]:focus", `${rowSelector}`, "input:focus", "button:focus", "textarea:focus", "div[tabindex]:focus", ".dx-lookup-field:focus", ".dx-checkbox:focus", ".dx-switch:focus", ".dx-dropdownbutton .dx-buttongroup:focus", ".dx-adaptive-item-text:focus"].join(",");
    const $focusedElement = $dataGridElement.find(focusedElementSelector);
    return this.elementIsInsideGrid($focusedElement) && $focusedElement;
  }
  _getFocusCellSelector() {
    return ".dx-row > td";
  }
  _updateFocusCore() {
    const $dataGridElement = this.component && this.component.$element();
    if ($dataGridElement) {
      let $focus = this._getFocusedElement($dataGridElement);
      if ($focus && $focus.length) {
        let isHideBorder;
        if (!$focus.hasClass("dx-cell-focus-disabled") && !$focus.hasClass("dx-row")) {
          const $focusCell = $focus.closest(`${this._getFocusCellSelector()}, .dx-cell-focus-disabled`);
          if ($focusCell.get(0) !== $focus.get(0)) {
            isHideBorder = this._needHideBorder($focusCell);
            $focus = $focusCell;
          }
        }
        if ($focus.length && !$focus.hasClass("dx-cell-focus-disabled")) {
          this.focus($focus, isHideBorder);
          return;
        }
      }
    }
    this.loseFocus();
  }
  _needHideBorder($element) {
    const rowsViewElement = this._rowsView.element();
    const isRowsView = $element.closest(rowsViewElement).length > 0;
    const isEditing = this._editingController.isEditing();
    return $element.hasClass(EDITOR_INLINE_BLOCK2) || isRowsView && !isEditing;
  }
  _updateFocus(e) {
    const that = this;
    const isFocusOverlay = e && e.event && renderer_default(e.event.target).hasClass(that.addWidgetPrefix("focus-overlay"));
    that._isFocusOverlay = that._isFocusOverlay || isFocusOverlay;
    clearTimeout(that._updateFocusTimeoutID);
    that._updateFocusTimeoutID = setTimeout((() => {
      delete that._updateFocusTimeoutID;
      if (!that._isFocusOverlay) {
        that._updateFocusCore();
      }
      that._isFocusOverlay = false;
    }));
  }
  updateFocusOverlaySize($element, position) {
    $element.hide();
    const location = position_default.calculate($element, extend({
      collision: "fit"
    }, position));
    if (location.h.oversize > 0) {
      setOuterWidth($element, getOuterWidth($element) - location.h.oversize);
    }
    if (location.v.oversize > 0) {
      setOuterHeight($element, getOuterHeight($element) - location.v.oversize);
    }
    $element.show();
  }
  callbackNames() {
    return ["focused"];
  }
  getFocusOverlayContainer($focusedElement) {
    return $focusedElement.closest(`.${this.addWidgetPrefix("content")}`);
  }
  getFocusOverlaySize($element) {
    const elementRect = getBoundingRect($element.get(0));
    return {
      width: elementRect.right - elementRect.left + 1,
      height: elementRect.bottom - elementRect.top + 1
    };
  }
  updateFocusOverlay($element) {
    let isHideBorder = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;
    if (isHideBorder) {
      this._$focusOverlay.addClass(DX_HIDDEN);
    } else if ($element.length) {
      const align = browser_default.mozilla ? "right bottom" : "left top";
      const isFocusedCellInvalid = $element.hasClass(this.addWidgetPrefix("invalid"));
      const isFocusedCellModified = $element.hasClass("dx-cell-modified") && !isFocusedCellInvalid;
      const $content = this.getFocusOverlayContainer($element);
      const focusOverlaySize = this.getFocusOverlaySize($element);
      this._$focusOverlay.removeClass(DX_HIDDEN).toggleClass("dx-focused-cell-invalid", isFocusedCellInvalid).toggleClass("dx-focused-cell-modified", isFocusedCellModified).appendTo($content);
      setOuterHeight(this._$focusOverlay, focusOverlaySize.height);
      setOuterWidth(this._$focusOverlay, focusOverlaySize.width);
      const focusOverlayPosition = {
        precise: true,
        my: align,
        at: align,
        of: $element,
        boundary: $content.length && $content
      };
      this.updateFocusOverlaySize(this._$focusOverlay, focusOverlayPosition);
      position_default.setup(this._$focusOverlay, focusOverlayPosition);
      this._$focusOverlay.css("visibility", "visible");
    }
  }
  renderFocusOverlay($element, isHideBorder) {
    if (!m_utils_default.isElementInCurrentGrid(this, $element)) {
      return;
    }
    if (!this._$focusOverlay) {
      this._$focusOverlay = renderer_default("<div>").addClass(this.addWidgetPrefix("focus-overlay"));
    }
    this.updateFocusOverlay($element, isHideBorder);
  }
  focus($element, isHideBorder) {
    const that = this;
    if (void 0 === $element) {
      return that._$focusedElement;
    }
    if ($element) {
      if (!$element.is(that._$focusedElement)) {
        that._$focusedElement && that._$focusedElement.removeClass("dx-focused");
      }
      that._$focusedElement = $element;
      clearTimeout(that._focusTimeoutID);
      that._focusTimeoutID = setTimeout((() => {
        delete that._focusTimeoutID;
        that.renderFocusOverlay($element, isHideBorder);
        $element.addClass("dx-focused");
        that.focused.fire($element);
      }));
    }
  }
  refocus() {
    const $focus = this.focus();
    this.focus($focus);
  }
  resize() {
    const $focusedElement = this._$focusedElement;
    if ($focusedElement) {
      this.focus($focusedElement);
    }
  }
  loseFocus(skipValidator) {
    this._$focusedElement && this._$focusedElement.removeClass("dx-focused");
    this._$focusedElement = null;
    this._$focusOverlay && this._$focusOverlay.addClass(DX_HIDDEN);
  }
  _getContainerRoot() {
    var _this$component;
    const $container = null === (_this$component = this.component) || void 0 === _this$component ? void 0 : _this$component.$element();
    const root = dom_adapter_default.getRootNode(null === $container || void 0 === $container ? void 0 : $container.get(0));
    if (root.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !root.host) {
      return dom_adapter_default.getDocument();
    }
    return root;
  }
  _attachContainerEventHandlers() {
    const that = this;
    const $container = that.component && that.component.$element();
    if ($container) {
      m_events_engine_default.on($container, addNamespace("keydown", MODULE_NAMESPACE), ((e) => {
        if ("tab" === normalizeKeyName(e)) {
          that._updateFocusHandler(e);
        }
      }));
    }
  }
  getFocusOverlay() {
    return this._$focusOverlay;
  }
  hasOverlayElements() {
    var _this$_$focusOverlay;
    return !!(null !== (_this$_$focusOverlay = this._$focusOverlay) && void 0 !== _this$_$focusOverlay && _this$_$focusOverlay.length) && !this._$focusOverlay.hasClass(DX_HIDDEN);
  }
};
var editorFactoryModule = {
  defaultOptions: () => ({}),
  controllers: {
    editorFactory: EditorFactory
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/editor_factory.js
m_core_default.registerModule("editorFactory", editorFactoryModule);

// node_modules/devextreme/esm/__internal/ui/dialog.js
var window = getWindow();
var DEFAULT_BOUNDARY_OFFSET = {
  h: 10,
  v: 0
};
var DEFAULT_BUTTON_OPTIONS = {
  text: message_default.format("OK"),
  onClick: () => true
};
var getApplyButtonConfig = () => {
  if (isFluent(current())) {
    return {
      stylingMode: "contained",
      type: "default"
    };
  }
  return {};
};
var getCancelButtonConfig = () => {
  if (isFluent(current())) {
    return {
      stylingMode: "outlined",
      type: "default"
    };
  }
  return {};
};
var custom = (params) => {
  const {
    buttons,
    dragEnabled,
    message,
    messageHtml,
    popupOptions,
    showCloseButton,
    showTitle,
    title = "",
    width,
    position
  } = params ?? {};
  const isMessageDefined = isDefined(message);
  if (isMessageDefined) {
    ui_errors_default.log("W1013");
  }
  const isMessageHtmlDefined = isDefined(messageHtml);
  const messageMarkup = String(isMessageHtmlDefined ? messageHtml : message);
  const messageId = title ? null : new guid_default().toString();
  const deferred = Deferred();
  const $element = renderer_default("<div>").addClass("dx-dialog").appendTo(value());
  const $message = renderer_default("<div>").addClass("dx-dialog-message").html(messageMarkup).attr("id", messageId);
  let popupInstance = null;
  const hide = (value2) => {
    var _popupInstance3;
    deferred.resolve(value2);
    null === (_popupInstance3 = popupInstance) || void 0 === _popupInstance3 || _popupInstance3.hide();
  };
  const buttonOptions = buttons ?? [DEFAULT_BUTTON_OPTIONS];
  const toolbarItems = buttonOptions.map(((configuration2) => {
    const {
      onClick
    } = configuration2;
    const action = new action_default(onClick, {
      context: popupInstance
    });
    const buttonItem = {
      toolbar: "bottom",
      location: devices_default.current().android ? "after" : "center",
      widget: "dxButton",
      options: _extends({}, configuration2, {
        onClick: (e) => {
          const result = action.execute(e);
          hide(result);
        }
      })
    };
    return buttonItem;
  }));
  const popupPosition = position ?? {
    boundaryOffset: _extends({}, DEFAULT_BOUNDARY_OFFSET)
  };
  const configuration = {
    animation: {
      show: {
        type: "pop",
        duration: 400
      },
      hide: {
        type: "pop",
        duration: 400,
        to: {
          opacity: 0,
          scale: 0
        },
        from: {
          opacity: 1,
          scale: 1
        }
      }
    },
    container: $element,
    dragAndResizeArea: window,
    dragEnabled: ensureDefined(dragEnabled, true),
    height: "auto",
    ignoreChildEvents: false,
    onContentReady: (e) => {
      const component = e.component;
      component.$content().addClass("dx-dialog-content").append($message);
      if (messageId) {
        component.$overlayContent().attr("aria-labelledby", messageId);
      }
    },
    onHiding: () => {
      deferred.reject();
    },
    onShowing: (e) => {
      const component = e.component;
      const bottomToolbar = component.bottomToolbar();
      null === bottomToolbar || void 0 === bottomToolbar || bottomToolbar.addClass("dx-dialog-buttons").find(".dx-button").addClass("dx-dialog-button");
      m_dom_default.resetActiveElement();
    },
    onShown: (e) => {
      const component = e.component;
      const bottomToolbar = component.bottomToolbar();
      const $firstButton = null === bottomToolbar || void 0 === bottomToolbar ? void 0 : bottomToolbar.find(".dx-button").first();
      m_events_engine_default.trigger($firstButton, "focus");
    },
    position: popupPosition,
    rtlEnabled: config_default().rtlEnabled,
    showCloseButton: showCloseButton ?? false,
    showTitle: ensureDefined(showTitle, true),
    title,
    toolbarItems,
    visualContainer: window,
    width
  };
  const options = _extends({}, configuration, popupOptions, {
    onHidden: (e) => {
      var _popupOptions$onHidde;
      renderer_default(e.element).remove();
      null === popupOptions || void 0 === popupOptions || null === (_popupOptions$onHidde = popupOptions.onHidden) || void 0 === _popupOptions$onHidde || _popupOptions$onHidde.call(popupOptions, e);
    }
  });
  popupInstance = new m_popup_default($element, options);
  popupInstance.$wrapper().addClass("dx-dialog-wrapper").addClass("dx-dialog-root");
  const dialog = {
    show: () => {
      var _popupInstance2;
      if ("phone" === devices_default.real().deviceType) {
        var _popupInstance;
        const isPortrait = getHeight(window) > getWidth(window);
        const width2 = isPortrait ? "90%" : "60%";
        null === (_popupInstance = popupInstance) || void 0 === _popupInstance || _popupInstance.option({
          width: width2
        });
      }
      null === (_popupInstance2 = popupInstance) || void 0 === _popupInstance2 || _popupInstance2.show();
      return deferred.promise();
    },
    hide
  };
  return dialog;
};
var isCustomDialogOptions = (options) => isPlainObject(options);
var confirm = (messageHtml, title, showTitle) => {
  const titleValue = title ?? "";
  const options = isCustomDialogOptions(messageHtml) ? messageHtml : {
    title: titleValue,
    messageHtml,
    showTitle,
    buttons: [_extends({
      text: message_default.format("Yes"),
      onClick: () => true
    }, getApplyButtonConfig()), _extends({
      text: message_default.format("No"),
      onClick: () => false
    }, getCancelButtonConfig())],
    dragEnabled: showTitle
  };
  return custom(options).show();
};

// node_modules/devextreme/esm/__internal/grids/grid_core/editing/const.js
var EDITOR_CELL_CLASS = "dx-editor-cell";
var ROW_CLASS = "dx-row";
var CELL_MODIFIED_CLASS = "dx-cell-modified";
var ROW_SELECTED_CLASS = "dx-selection";
var EDIT_FORM_CLASS2 = "edit-form";
var DATA_EDIT_DATA_INSERT_TYPE = "insert";
var DATA_EDIT_DATA_REMOVE_TYPE = "remove";
var EDITING_POPUP_OPTION_NAME = "editing.popup";
var EDITING_FORM_OPTION_NAME = "editing.form";
var EDITING_EDITROWKEY_OPTION_NAME = "editing.editRowKey";
var EDITING_EDITCOLUMNNAME_OPTION_NAME = "editing.editColumnName";
var TARGET_COMPONENT_NAME = "targetComponent";
var EDITORS_INPUT_SELECTOR = "input:not([type='hidden'])";
var FOCUSABLE_ELEMENT_SELECTOR = `[tabindex]:not([disabled]), ${EDITORS_INPUT_SELECTOR}:not([disabled])`;
var EDIT_MODE_BATCH = "batch";
var EDIT_MODE_ROW = "row";
var EDIT_MODE_CELL = "cell";
var EDIT_MODE_FORM = "form";
var EDIT_MODE_POPUP = "popup";
var FIRST_NEW_ROW_POSITION = "first";
var LAST_NEW_ROW_POSITION = "last";
var PAGE_BOTTOM_NEW_ROW_POSITION = "pageBottom";
var PAGE_TOP_NEW_ROW_POSITION = "pageTop";
var VIEWPORT_BOTTOM_NEW_ROW_POSITION = "viewportBottom";
var VIEWPORT_TOP_NEW_ROW_POSITION = "viewportTop";
var EDIT_MODES = ["batch", "row", "cell", "form", "popup"];
var ROW_BASED_MODES = ["row", "form", "popup"];
var CELL_BASED_MODES = ["batch", "cell"];
var REQUIRED_EDITOR_LABELLEDBY_MODES = ["batch", "row", "cell"];
var MODES_WITH_DELAYED_FOCUS = ["row", "form"];
var READONLY_CLASS = "readonly";
var LINK_CLASS = "dx-link";
var LINK_ICON_CLASS = "dx-link-icon";
var ROW_SELECTED = "dx-selection";
var EDIT_BUTTON_CLASS = "dx-edit-button";
var COMMAND_EDIT_CLASS2 = "dx-command-edit";
var COMMAND_EDIT_WITH_ICONS_CLASS = "dx-command-edit-with-icons";
var INSERT_INDEX = "__DX_INSERT_INDEX__";
var ROW_INSERTED = "dx-row-inserted";
var ROW_MODIFIED = "dx-row-modified";
var CELL_MODIFIED = "dx-cell-modified";
var EDITING_NAMESPACE = "dxDataGridEditing";
var CELL_FOCUS_DISABLED_CLASS2 = "dx-cell-focus-disabled";
var DATA_EDIT_DATA_UPDATE_TYPE = "update";
var DEFAULT_START_EDIT_ACTION = "click";
var EDIT_LINK_CLASS = {
  save: "dx-link-save",
  cancel: "dx-link-cancel",
  edit: "dx-link-edit",
  undelete: "dx-link-undelete",
  delete: "dx-link-delete",
  add: "dx-link-add"
};
var EDIT_ICON_CLASS = {
  save: "save",
  cancel: "revert",
  edit: "edit",
  undelete: "revert",
  delete: "trash",
  add: "add"
};
var METHOD_NAMES = {
  edit: "editRow",
  delete: "deleteRow",
  undelete: "undeleteRow",
  save: "saveEditData",
  cancel: "cancelEditData",
  add: "addRowByRowIndex"
};
var ACTION_OPTION_NAMES = {
  add: "allowAdding",
  edit: "allowUpdating",
  delete: "allowDeleting"
};
var BUTTON_NAMES = ["edit", "save", "cancel", "delete", "undelete"];
var EDITING_CHANGES_OPTION_NAME = "editing.changes";
var FOCUS_OVERLAY_CLASS = "focus-overlay";
var ADD_ROW_BUTTON_CLASS = "addrow-button";
var DROPDOWN_EDITOR_OVERLAY_CLASS2 = "dx-dropdowneditor-overlay";
var DATA_ROW_CLASS2 = "dx-data-row";
var ROW_REMOVED = "dx-row-removed";
var FILTER_ROW_CLASS = "filter-row";
var EDIT_FORM_ITEM_CLASS2 = "edit-form-item";
var EDIT_POPUP_CLASS = "edit-popup";
var EDIT_POPUP_FORM_CLASS = "edit-popup-form";
var FOCUSABLE_ELEMENT_CLASS = "dx-scrollable-container";
var BUTTON_CLASS = "dx-button";
var FORM_BUTTONS_CONTAINER_CLASS = "form-buttons-container";
var EDIT_ROW = "dx-edit-row";

// node_modules/devextreme/esm/__internal/grids/grid_core/editing/m_editing_utils.js
var createFailureHandler = function(deferred) {
  return function(arg) {
    const error = arg instanceof Error ? arg : new Error(arg && String(arg) || "Unknown error");
    deferred.reject(error);
  };
};
var isEditingCell = function(isEditRow2, cellOptions) {
  return cellOptions.isEditing || isEditRow2 && cellOptions.column.allowEditing;
};
var isEditingOrShowEditorAlwaysDataCell = function(isEditRow2, cellOptions) {
  const isCommandCell = !!cellOptions.column.command;
  const isEditing = isEditingCell(isEditRow2, cellOptions);
  const isEditorCell2 = !isCommandCell && (isEditing || cellOptions.column.showEditorAlways);
  return "data" === cellOptions.rowType && isEditorCell2;
};
var getEditingTexts = (options) => {
  const editingTexts = options.component.option("editing.texts") || {};
  return {
    save: editingTexts.saveRowChanges,
    cancel: editingTexts.cancelRowChanges,
    edit: editingTexts.editRow,
    undelete: editingTexts.undeleteRow,
    delete: editingTexts.deleteRow,
    add: editingTexts.addRowToNode
  };
};
var generateNewRowTempKey = () => `_DX_KEY_${new guid_default()}`;
var isNewRowTempKey = (key) => "string" === typeof key && key.startsWith("_DX_KEY_") && 44 === key.length;
var getButtonIndex = (buttons, name) => {
  let result = -1;
  buttons.some(((button, index) => {
    if (getButtonName(button) === name) {
      result = index;
      return true;
    }
  }));
  return result;
};
function getButtonName(button) {
  return isObject(button) ? button.name : button;
}
function isEditable($element) {
  return $element && ($element.is("input") || $element.is("textarea"));
}
var getEditorType = (item) => {
  var _column$formItem;
  const {
    column
  } = item;
  return item.isCustomEditorType ? item.editorType : null === (_column$formItem = column.formItem) || void 0 === _column$formItem ? void 0 : _column$formItem.editorType;
};
var forEachFormItems = (items, callBack) => {
  items.forEach(((item) => {
    if (item.items || item.tabs) {
      forEachFormItems(item.items || item.tabs, callBack);
    } else {
      callBack(item);
    }
  }));
};

// node_modules/devextreme/esm/__internal/grids/grid_core/editing/m_editing.js
var EditingControllerImpl = class extends m_modules_default.ViewController {
  init() {
    this._columnsController = this.getController("columns");
    this._dataController = this.getController("data");
    this._adaptiveColumnsController = this.getController("adaptiveColumns");
    this._validatingController = this.getController("validating");
    this._editorFactoryController = this.getController("editorFactory");
    this._focusController = this.getController("focus");
    this._keyboardNavigationController = this.getController("keyboardNavigation");
    this._columnsResizerController = this.getController("columnsResizer");
    this._errorHandlingController = this.getController("errorHandling");
    this._rowsView = this.getView("rowsView");
    this._headerPanelView = this.getView("headerPanel");
    this._lastOperation = null;
    this._changes = [];
    if (this._deferreds) {
      this._deferreds.forEach(((d) => {
        d.reject("cancel");
      }));
    }
    this._deferreds = [];
    if (!this._dataChangedHandler) {
      this._dataChangedHandler = this._handleDataChanged.bind(this);
      this._dataController.changed.add(this._dataChangedHandler);
    }
    if (!this._saveEditorHandler) {
      this.createAction("onInitNewRow", {
        excludeValidators: ["disabled", "readOnly"]
      });
      this.createAction("onRowInserting", {
        excludeValidators: ["disabled", "readOnly"]
      });
      this.createAction("onRowInserted", {
        excludeValidators: ["disabled", "readOnly"]
      });
      this.createAction("onEditingStart", {
        excludeValidators: ["disabled", "readOnly"]
      });
      this.createAction("onRowUpdating", {
        excludeValidators: ["disabled", "readOnly"]
      });
      this.createAction("onRowUpdated", {
        excludeValidators: ["disabled", "readOnly"]
      });
      this.createAction("onRowRemoving", {
        excludeValidators: ["disabled", "readOnly"]
      });
      this.createAction("onRowRemoved", {
        excludeValidators: ["disabled", "readOnly"]
      });
      this.createAction("onSaved", {
        excludeValidators: ["disabled", "readOnly"]
      });
      this.createAction("onSaving", {
        excludeValidators: ["disabled", "readOnly"]
      });
      this.createAction("onEditCanceling", {
        excludeValidators: ["disabled", "readOnly"]
      });
      this.createAction("onEditCanceled", {
        excludeValidators: ["disabled", "readOnly"]
      });
    }
    this._updateEditColumn();
    this._updateEditButtons();
    if (!this._internalState) {
      this._internalState = /* @__PURE__ */ new Map();
    }
    this.component._optionsByReference[EDITING_EDITROWKEY_OPTION_NAME] = true;
    this.component._optionsByReference[EDITING_CHANGES_OPTION_NAME] = true;
  }
  getEditMode() {
    const editMode = this.option("editing.mode") ?? EDIT_MODE_ROW;
    if (EDIT_MODES.includes(editMode)) {
      return editMode;
    }
    return EDIT_MODE_ROW;
  }
  isCellBasedEditMode() {
    const editMode = this.getEditMode();
    return CELL_BASED_MODES.includes(editMode);
  }
  _getDefaultEditorTemplate() {
    return (container, options) => {
      const $editor = renderer_default("<div>").appendTo(container);
      const editorOptions = extend({}, options.column, {
        value: options.value,
        setValue: options.setValue,
        row: options.row,
        parentType: "dataRow",
        width: null,
        readOnly: !options.setValue,
        isOnForm: options.isOnForm,
        id: options.id
      });
      const needLabel = REQUIRED_EDITOR_LABELLEDBY_MODES.includes(this.getEditMode());
      if (needLabel) {
        editorOptions["aria-labelledby"] = options.column.headerId;
      }
      this._editorFactoryController.createEditor($editor, editorOptions);
    };
  }
  _getNewRowPosition() {
    const newRowPosition = this.option("editing.newRowPosition");
    const scrollingMode = this.option("scrolling.mode");
    if ("virtual" === scrollingMode) {
      switch (newRowPosition) {
        case PAGE_TOP_NEW_ROW_POSITION:
          return VIEWPORT_TOP_NEW_ROW_POSITION;
        case PAGE_BOTTOM_NEW_ROW_POSITION:
          return VIEWPORT_BOTTOM_NEW_ROW_POSITION;
        default:
          return newRowPosition;
      }
    }
    return newRowPosition;
  }
  getChanges() {
    return this.option(EDITING_CHANGES_OPTION_NAME);
  }
  getInsertRowCount() {
    const changes = this.option(EDITING_CHANGES_OPTION_NAME);
    return changes.filter(((change) => "insert" === change.type)).length;
  }
  resetChanges() {
    const changes = this.getChanges();
    const needReset = null === changes || void 0 === changes ? void 0 : changes.length;
    if (needReset) {
      this._silentOption(EDITING_CHANGES_OPTION_NAME, []);
      this._internalState.clear();
    }
  }
  _getInternalData(key) {
    return this._internalState.get(getKeyHash(key));
  }
  _addInternalData(params) {
    const internalData = this._getInternalData(params.key);
    if (internalData) {
      return extend(internalData, params);
    }
    this._internalState.set(getKeyHash(params.key), params);
    return params;
  }
  _getOldData(key) {
    var _this$_getInternalDat;
    return null === (_this$_getInternalDat = this._getInternalData(key)) || void 0 === _this$_getInternalDat ? void 0 : _this$_getInternalDat.oldData;
  }
  getUpdatedData(data17) {
    const key = this._dataController.keyOf(data17);
    const changes = this.getChanges();
    const editIndex = m_utils_default.getIndexByKey(key, changes);
    if (changes[editIndex]) {
      return createObjectWithChanges(data17, changes[editIndex].data);
    }
    return data17;
  }
  getInsertedData() {
    return this.getChanges().filter(((change) => change.data && change.type === DATA_EDIT_DATA_INSERT_TYPE)).map(((change) => change.data));
  }
  getRemovedData() {
    return this.getChanges().filter(((change) => this._getOldData(change.key) && change.type === DATA_EDIT_DATA_REMOVE_TYPE)).map(((change) => this._getOldData(change.key)));
  }
  _fireDataErrorOccurred(arg) {
    if ("cancel" === arg) {
      return;
    }
    const $popupContent = this.getPopupContent();
    this._dataController.dataErrorOccurred.fire(arg, $popupContent);
  }
  _needToCloseEditableCell($targetElement) {
  }
  _closeEditItem($targetElement) {
  }
  _handleDataChanged(args) {
  }
  _isDefaultButtonVisible(button, options) {
    let result = true;
    switch (button.name) {
      case "delete":
        result = this.allowDeleting(options);
        break;
      case "undelete":
        result = false;
    }
    return result;
  }
  isPopupEditMode() {
    const editMode = this.option("editing.mode");
    return editMode === EDIT_MODE_POPUP;
  }
  _isButtonVisible(button, options) {
    const {
      visible
    } = button;
    if (!isDefined(visible)) {
      return this._isDefaultButtonVisible(button, options);
    }
    return isFunction(visible) ? visible.call(button, {
      component: options.component,
      row: options.row,
      column: options.column
    }) : visible;
  }
  _isButtonDisabled(button, options) {
    const {
      disabled
    } = button;
    return isFunction(disabled) ? disabled.call(button, {
      component: options.component,
      row: options.row,
      column: options.column
    }) : !!disabled;
  }
  _getButtonConfig(button, options) {
    const config = isObject(button) ? button : {};
    const buttonName = getButtonName(button);
    const editingTexts = getEditingTexts(options);
    const methodName = METHOD_NAMES[buttonName];
    const editingOptions = this.option("editing");
    const actionName = ACTION_OPTION_NAMES[buttonName];
    const allowAction = actionName ? editingOptions[actionName] : true;
    return extend({
      name: buttonName,
      text: editingTexts[buttonName],
      cssClass: EDIT_LINK_CLASS[buttonName]
    }, {
      onClick: methodName && ((e) => {
        const {
          event
        } = e;
        event.stopPropagation();
        event.preventDefault();
        setTimeout((() => {
          options.row && allowAction && this[methodName] && this[methodName](options.row.rowIndex);
        }));
      })
    }, config);
  }
  _getEditingButtons(options) {
    let buttonIndex;
    const haveCustomButtons = !!options.column.buttons;
    let buttons = (options.column.buttons || []).slice();
    if (haveCustomButtons) {
      buttonIndex = getButtonIndex(buttons, "edit");
      if (buttonIndex >= 0) {
        if (getButtonIndex(buttons, "save") < 0) {
          buttons.splice(buttonIndex + 1, 0, "save");
        }
        if (getButtonIndex(buttons, "cancel") < 0) {
          buttons.splice(getButtonIndex(buttons, "save") + 1, 0, "cancel");
        }
      }
      buttonIndex = getButtonIndex(buttons, "delete");
      if (buttonIndex >= 0 && getButtonIndex(buttons, "undelete") < 0) {
        buttons.splice(buttonIndex + 1, 0, "undelete");
      }
    } else {
      buttons = BUTTON_NAMES.slice();
    }
    return buttons.map(((button) => this._getButtonConfig(button, options)));
  }
  _renderEditingButtons($container, buttons, options, change) {
    buttons.forEach(((button) => {
      if (this._isButtonVisible(button, options)) {
        this._createButton($container, button, options, change);
      }
    }));
  }
  _getEditCommandCellTemplate() {
    return (container, options, change) => {
      const $container = renderer_default(container);
      if ("data" === options.rowType) {
        const buttons = this._getEditingButtons(options);
        this._renderEditingButtons($container, buttons, options, change);
        if (options.watch) {
          const dispose = options.watch((() => buttons.map(((button) => ({
            visible: this._isButtonVisible(button, options),
            disabled: this._isButtonDisabled(button, options)
          })))), (() => {
            $container.empty();
            this._renderEditingButtons($container, buttons, options);
          }));
          m_events_engine_default.on($container, removeEvent, dispose);
        }
      } else {
        m_utils_default.setEmptyText($container);
      }
    };
  }
  isRowBasedEditMode() {
    const editMode = this.getEditMode();
    return ROW_BASED_MODES.includes(editMode);
  }
  getFirstEditableColumnIndex() {
    let columnIndex;
    const visibleColumns = this._columnsController.getVisibleColumns();
    each(visibleColumns, ((index, column) => {
      if (column.allowEditing) {
        columnIndex = index;
        return false;
      }
    }));
    return columnIndex;
  }
  getFirstEditableCellInRow(rowIndex) {
    var _this$_rowsView;
    const columnIndex = this.getFirstEditableColumnIndex();
    return null === (_this$_rowsView = this._rowsView) || void 0 === _this$_rowsView ? void 0 : _this$_rowsView._getCellElement(rowIndex || 0, columnIndex);
  }
  getFocusedCellInRow(rowIndex) {
    return this.getFirstEditableCellInRow(rowIndex);
  }
  getIndexByKey(key, items) {
    return m_utils_default.getIndexByKey(key, items);
  }
  hasChanges(rowIndex) {
    const changes = this.getChanges();
    let result = false;
    for (let i = 0; i < (null === changes || void 0 === changes ? void 0 : changes.length); i++) {
      if (changes[i].type && (!isDefined(rowIndex) || this._dataController.getRowIndexByKey(changes[i].key) === rowIndex)) {
        result = true;
        break;
      }
    }
    return result;
  }
  dispose() {
    super.dispose();
    clearTimeout(this._inputFocusTimeoutID);
    m_events_engine_default.off(dom_adapter_default.getDocument(), m_pointer_default.up, this._pointerUpEditorHandler);
    m_events_engine_default.off(dom_adapter_default.getDocument(), m_pointer_default.down, this._pointerDownEditorHandler);
    m_events_engine_default.off(dom_adapter_default.getDocument(), CLICK_EVENT_NAME, this._saveEditorHandler);
  }
  _silentOption(name, value2) {
    if ("editing.changes" === name) {
      this._changes = deepExtendArraySafe([], value2);
    }
    super._silentOption(name, value2);
  }
  optionChanged(args) {
    if ("editing" === args.name) {
      const {
        fullName
      } = args;
      if (fullName === EDITING_EDITROWKEY_OPTION_NAME) {
        this._handleEditRowKeyChange(args);
      } else if (fullName === EDITING_CHANGES_OPTION_NAME) {
        const isEqual = equalByValue(args.value, this._changes, {
          maxDepth: 4
        });
        if (!isEqual) {
          this._changes = deepExtendArraySafe([], args.value);
          this._handleChangesChange(args);
        }
      } else if (!args.handled) {
        this._columnsController.reinit();
        this.init();
        this.resetChanges();
        this._resetEditColumnName();
        this._resetEditRowKey();
      }
      args.handled = true;
    } else {
      super.optionChanged(args);
    }
  }
  _handleEditRowKeyChange(args) {
    const rowIndex = this._dataController.getRowIndexByKey(args.value);
    const oldRowIndexCorrection = this._getEditRowIndexCorrection();
    const oldRowIndex = this._dataController.getRowIndexByKey(args.previousValue) + oldRowIndexCorrection;
    if (isDefined(args.value)) {
      if (args.value !== args.previousValue) {
        this._editRowFromOptionChanged(rowIndex, oldRowIndex);
      }
    } else {
      this.cancelEditData();
    }
  }
  _handleChangesChange(args) {
    const dataController2 = this._dataController;
    const changes = args.value;
    if (!args.value.length && !args.previousValue.length) {
      return;
    }
    changes.forEach(((change) => {
      if ("insert" === change.type) {
        this._addInsertInfo(change);
      } else {
        var _dataController$items;
        const items = dataController2.getCachedStoreData() || (null === (_dataController$items = dataController2.items()) || void 0 === _dataController$items ? void 0 : _dataController$items.map(((item) => item.data)));
        const rowIndex = m_utils_default.getIndexByKey(change.key, items, dataController2.key());
        this._addInternalData({
          key: change.key,
          oldData: items[rowIndex]
        });
      }
    }));
    dataController2.updateItems({
      repaintChangesOnly: true,
      isLiveUpdate: false,
      isOptionChanged: true
    });
  }
  publicMethods() {
    return ["addRow", "deleteRow", "undeleteRow", "editRow", "saveEditData", "cancelEditData", "hasEditData"];
  }
  refresh() {
    if (!isDefined(this._pageIndex)) {
      return;
    }
    this._refreshCore.apply(this, arguments);
  }
  _refreshCore(params) {
  }
  isEditing() {
    const isEditRowKeyDefined = isDefined(this.option(EDITING_EDITROWKEY_OPTION_NAME));
    return isEditRowKeyDefined;
  }
  isEditRow(rowIndex) {
    return false;
  }
  _setEditRowKey(value2, silent) {
    if (silent) {
      this._silentOption(EDITING_EDITROWKEY_OPTION_NAME, value2);
    } else {
      this.option(EDITING_EDITROWKEY_OPTION_NAME, value2);
    }
    if (this._refocusEditCell) {
      this._refocusEditCell = false;
      this._focusEditingCell();
    }
  }
  getEditRowIndex() {
    return this._getVisibleEditRowIndex();
  }
  getEditFormRowIndex() {
    return -1;
  }
  isEditRowByIndex(rowIndex) {
    const key = this._dataController.getKeyByRowIndex(rowIndex);
    const isKeyEqual = isDefined(key) && equalByValue(this.option(EDITING_EDITROWKEY_OPTION_NAME), key);
    if (isKeyEqual) {
      return this._getVisibleEditRowIndex() === rowIndex;
    }
    return isKeyEqual;
  }
  isEditCell(visibleRowIndex, columnIndex) {
    return this.isEditRowByIndex(visibleRowIndex) && this._getVisibleEditColumnIndex() === columnIndex;
  }
  getPopupContent() {
  }
  _isProcessedItem(item) {
    return false;
  }
  _getInsertRowIndex(items, change, isProcessedItems) {
    let result = -1;
    const dataController2 = this._dataController;
    const key = this._getInsertAfterOrBeforeKey(change);
    if (!isDefined(key) && 0 === items.length) {
      result = 0;
    } else if (isDefined(key)) {
      items.some(((item, index) => {
        const isProcessedItem = isProcessedItems || this._isProcessedItem(item);
        if (isObject(item)) {
          if (isProcessedItem || isDefined(item[INSERT_INDEX])) {
            if (equalByValue(item.key, key)) {
              result = index;
            }
          } else if (equalByValue(dataController2.keyOf(item), key)) {
            result = index;
          }
        }
        if (result >= 0) {
          const nextItem = items[result + 1];
          if (nextItem && ("detail" === nextItem.rowType || "detailAdaptive" === nextItem.rowType) && isDefined(change.insertAfterKey)) {
            return;
          }
          if (isDefined(change.insertAfterKey)) {
            result += 1;
          }
          return true;
        }
      }));
    }
    return result;
  }
  _generateNewItem(key) {
    var _this$_getInternalDat2;
    const item = {
      key
    };
    const insertInfo = null === (_this$_getInternalDat2 = this._getInternalData(key)) || void 0 === _this$_getInternalDat2 ? void 0 : _this$_getInternalDat2.insertInfo;
    if (null !== insertInfo && void 0 !== insertInfo && insertInfo[INSERT_INDEX]) {
      item[INSERT_INDEX] = insertInfo[INSERT_INDEX];
    }
    return item;
  }
  _getLoadedRowIndex(items, change, isProcessedItems) {
    let loadedRowIndex = this._getInsertRowIndex(items, change, isProcessedItems);
    const dataController2 = this._dataController;
    if (loadedRowIndex < 0) {
      const newRowPosition = this._getNewRowPosition();
      const pageIndex = dataController2.pageIndex();
      const insertAfterOrBeforeKey = this._getInsertAfterOrBeforeKey(change);
      if (newRowPosition !== LAST_NEW_ROW_POSITION && 0 === pageIndex && !isDefined(insertAfterOrBeforeKey)) {
        loadedRowIndex = 0;
      } else if (newRowPosition === LAST_NEW_ROW_POSITION && dataController2.isLastPageLoaded()) {
        loadedRowIndex = items.length;
      }
    }
    return loadedRowIndex;
  }
  processItems(items, e) {
    const {
      changeType
    } = e;
    this.update(changeType);
    const changes = this.getChanges();
    changes.forEach(((change) => {
      var _this$_getInternalDat3;
      const isInsert = change.type === DATA_EDIT_DATA_INSERT_TYPE;
      if (!isInsert) {
        return;
      }
      let {
        key
      } = change;
      let insertInfo = null === (_this$_getInternalDat3 = this._getInternalData(key)) || void 0 === _this$_getInternalDat3 ? void 0 : _this$_getInternalDat3.insertInfo;
      if (!isDefined(key) || !isDefined(insertInfo)) {
        insertInfo = this._addInsertInfo(change);
        key = insertInfo.key;
      }
      const loadedRowIndex = this._getLoadedRowIndex(items, change);
      const item = this._generateNewItem(key);
      if (loadedRowIndex >= 0) {
        items.splice(loadedRowIndex, 0, item);
      }
    }));
    return items;
  }
  processDataItem(item, options, generateDataValues) {
    const columns7 = options.visibleColumns;
    const key = item.data[INSERT_INDEX] ? item.data.key : item.key;
    const changes = this.getChanges();
    const editIndex = m_utils_default.getIndexByKey(key, changes);
    item.isEditing = false;
    if (editIndex >= 0) {
      this._processDataItemCore(item, changes[editIndex], key, columns7, generateDataValues);
    }
  }
  _processDataItemCore(item, change, key, columns7, generateDataValues) {
    const {
      data: data17,
      type: type2
    } = change;
    switch (type2) {
      case DATA_EDIT_DATA_INSERT_TYPE:
        item.isNewRow = true;
        item.key = key;
        item.data = data17;
        break;
      case DATA_EDIT_DATA_UPDATE_TYPE:
        item.modified = true;
        item.oldData = item.data;
        item.data = createObjectWithChanges(item.data, data17);
        item.modifiedValues = generateDataValues(data17, columns7, true);
        break;
      case DATA_EDIT_DATA_REMOVE_TYPE:
        item.removed = true;
    }
  }
  _initNewRow(options) {
    this.executeAction("onInitNewRow", options);
    if (options.promise) {
      const deferred = new Deferred();
      when(fromPromise(options.promise)).done(deferred.resolve).fail(createFailureHandler(deferred)).fail(((arg) => this._fireDataErrorOccurred(arg)));
      return deferred;
    }
  }
  _createInsertInfo() {
    const insertInfo = {};
    insertInfo[INSERT_INDEX] = this._getInsertIndex();
    return insertInfo;
  }
  _addInsertInfo(change, parentKey) {
    var _this$_getInternalDat4;
    let insertInfo;
    change.key = this.getChangeKeyValue(change);
    const {
      key
    } = change;
    insertInfo = null === (_this$_getInternalDat4 = this._getInternalData(key)) || void 0 === _this$_getInternalDat4 ? void 0 : _this$_getInternalDat4.insertInfo;
    if (!isDefined(insertInfo)) {
      const insertAfterOrBeforeKey = this._getInsertAfterOrBeforeKey(change);
      insertInfo = this._createInsertInfo();
      if (!isDefined(insertAfterOrBeforeKey)) {
        this._setInsertAfterOrBeforeKey(change, parentKey);
      }
    }
    this._addInternalData({
      insertInfo,
      key
    });
    return {
      insertInfo,
      key
    };
  }
  getChangeKeyValue(change) {
    if (isDefined(change.key)) {
      return change.key;
    }
    const keyExpr = this._dataController.key();
    let keyValue;
    if (change.data && keyExpr && !Array.isArray(keyExpr)) {
      keyValue = change.data[keyExpr];
    }
    if (!isDefined(keyValue)) {
      keyValue = generateNewRowTempKey();
    }
    return keyValue;
  }
  _setInsertAfterOrBeforeKey(change, parentKey) {
    const rowsView18 = this.getView("rowsView");
    const dataController2 = this._dataController;
    const allItems = dataController2.items(true);
    const newRowPosition = this._getNewRowPosition();
    switch (newRowPosition) {
      case FIRST_NEW_ROW_POSITION:
      case LAST_NEW_ROW_POSITION:
        break;
      case PAGE_TOP_NEW_ROW_POSITION:
        if (allItems.length) {
          change.insertBeforeKey = allItems[0].key;
        }
        break;
      case PAGE_BOTTOM_NEW_ROW_POSITION:
        if (allItems.length) {
          change.insertAfterKey = allItems[allItems.length - 1].key;
        }
        break;
      default: {
        const isViewportBottom = newRowPosition === VIEWPORT_BOTTOM_NEW_ROW_POSITION;
        let visibleItemIndex = isViewportBottom ? null === rowsView18 || void 0 === rowsView18 ? void 0 : rowsView18.getBottomVisibleItemIndex() : null === rowsView18 || void 0 === rowsView18 ? void 0 : rowsView18.getTopVisibleItemIndex();
        const row = dataController2.getVisibleRows()[visibleItemIndex];
        if (row && (!row.isEditing && "detail" === row.rowType || "detailAdaptive" === row.rowType)) {
          visibleItemIndex++;
        }
        const insertKey = dataController2.getKeyByRowIndex(visibleItemIndex);
        if (isDefined(insertKey)) {
          change.insertBeforeKey = insertKey;
        }
      }
    }
  }
  _getInsertIndex() {
    let maxInsertIndex = 0;
    this.getChanges().forEach(((editItem) => {
      var _this$_getInternalDat5;
      const insertInfo = null === (_this$_getInternalDat5 = this._getInternalData(editItem.key)) || void 0 === _this$_getInternalDat5 ? void 0 : _this$_getInternalDat5.insertInfo;
      if (isDefined(insertInfo) && editItem.type === DATA_EDIT_DATA_INSERT_TYPE && insertInfo[INSERT_INDEX] > maxInsertIndex) {
        maxInsertIndex = insertInfo[INSERT_INDEX];
      }
    }));
    return maxInsertIndex + 1;
  }
  _getInsertAfterOrBeforeKey(insertChange) {
    return insertChange.insertAfterKey ?? insertChange.insertBeforeKey;
  }
  _getPageIndexToInsertRow() {
    const newRowPosition = this._getNewRowPosition();
    const dataController2 = this._dataController;
    const pageIndex = dataController2.pageIndex();
    const lastPageIndex = dataController2.pageCount() - 1;
    if (newRowPosition === FIRST_NEW_ROW_POSITION && 0 !== pageIndex) {
      return 0;
    }
    if (newRowPosition === LAST_NEW_ROW_POSITION && pageIndex !== lastPageIndex) {
      return lastPageIndex;
    }
    return -1;
  }
  addRow(parentKey) {
    const dataController2 = this._dataController;
    const store = dataController2.store();
    if (!store) {
      dataController2.fireError("E1052", this.component.NAME);
      return new Deferred().reject();
    }
    return this._addRow(parentKey);
  }
  _addRow(parentKey) {
    const dataController2 = this._dataController;
    const store = dataController2.store();
    const key = store && store.key();
    const param = {
      data: {}
    };
    const oldEditRowIndex = this._getVisibleEditRowIndex();
    const deferred = new Deferred();
    this.refresh({
      allowCancelEditing: true
    });
    if (!this._allowRowAdding()) {
      when(this._navigateToNewRow(oldEditRowIndex)).done(deferred.resolve).fail(deferred.reject);
      return deferred.promise();
    }
    if (!key) {
      param.data.__KEY__ = String(new guid_default());
    }
    when(this._initNewRow(param, parentKey)).done((() => {
      if (this._allowRowAdding()) {
        when(this._addRowCore(param.data, parentKey, oldEditRowIndex)).done(deferred.resolve).fail(deferred.reject);
      } else {
        deferred.reject("cancel");
      }
    })).fail(deferred.reject);
    return deferred.promise();
  }
  _allowRowAdding(params) {
    const insertIndex = this._getInsertIndex();
    if (insertIndex > 1) {
      return false;
    }
    return true;
  }
  _addRowCore(data17, parentKey, initialOldEditRowIndex) {
    const change = {
      data: data17,
      type: DATA_EDIT_DATA_INSERT_TYPE
    };
    const editRowIndex = this._getVisibleEditRowIndex();
    const insertInfo = this._addInsertInfo(change, parentKey);
    const {
      key
    } = insertInfo;
    this._setEditRowKey(key, true);
    this._addChange(change);
    return this._navigateToNewRow(initialOldEditRowIndex, change, editRowIndex);
  }
  _navigateToNewRow(oldEditRowIndex, change, editRowIndex) {
    const d = new Deferred();
    const dataController2 = this._dataController;
    editRowIndex = editRowIndex ?? -1;
    change = change ?? this.getChanges().filter(((c) => c.type === DATA_EDIT_DATA_INSERT_TYPE))[0];
    if (!change) {
      return d.reject("cancel").promise();
    }
    const pageIndexToInsertRow = this._getPageIndexToInsertRow();
    let rowIndex = this._getLoadedRowIndex(dataController2.items(), change, true);
    const navigateToRowByKey = (key) => {
      var _this$_focusControlle;
      when(null === (_this$_focusControlle = this._focusController) || void 0 === _this$_focusControlle ? void 0 : _this$_focusControlle.navigateToRow(key)).done((() => {
        rowIndex = dataController2.getRowIndexByKey(change.key);
        d.resolve();
      }));
    };
    const insertAfterOrBeforeKey = this._getInsertAfterOrBeforeKey(change);
    if (pageIndexToInsertRow >= 0) {
      dataController2.pageIndex(pageIndexToInsertRow).done((() => {
        navigateToRowByKey(change.key);
      })).fail(d.reject);
    } else if (rowIndex < 0 && isDefined(insertAfterOrBeforeKey)) {
      navigateToRowByKey(insertAfterOrBeforeKey);
    } else {
      dataController2.updateItems({
        changeType: "update",
        rowIndices: [oldEditRowIndex, editRowIndex, rowIndex]
      });
      rowIndex = dataController2.getRowIndexByKey(change.key);
      if (rowIndex < 0) {
        navigateToRowByKey(change.key);
      } else {
        d.resolve();
      }
    }
    d.done((() => {
      var _this$_rowsView2;
      null === (_this$_rowsView2 = this._rowsView) || void 0 === _this$_rowsView2 || _this$_rowsView2.waitAsyncTemplates(true).done((() => {
        this._showAddedRow(rowIndex);
        this._afterInsertRow(change.key);
      }));
    }));
    return d.promise();
  }
  _showAddedRow(rowIndex) {
    this._focusFirstEditableCellInRow(rowIndex);
  }
  _beforeFocusElementInRow(rowIndex) {
  }
  _focusFirstEditableCellInRow(rowIndex) {
    var _this$_keyboardNaviga;
    const dataController2 = this._dataController;
    const key = dataController2.getKeyByRowIndex(rowIndex);
    const $firstCell = this.getFirstEditableCellInRow(rowIndex);
    null === (_this$_keyboardNaviga = this._keyboardNavigationController) || void 0 === _this$_keyboardNaviga || _this$_keyboardNaviga.focus($firstCell);
    this.option("focusedRowKey", key);
    this._editCellInProgress = true;
    this._delayedInputFocus($firstCell, (() => {
      rowIndex = dataController2.getRowIndexByKey(key);
      this._editCellInProgress = false;
      this._beforeFocusElementInRow(rowIndex);
    }));
  }
  _isEditingStart(options) {
    this.executeAction("onEditingStart", options);
    return options.cancel;
  }
  _beforeUpdateItems(rowIndices, rowIndex) {
  }
  _getVisibleEditColumnIndex() {
    const editColumnName = this.option(EDITING_EDITCOLUMNNAME_OPTION_NAME);
    if (!isDefined(editColumnName)) {
      return -1;
    }
    return this._columnsController.getVisibleColumnIndex(editColumnName);
  }
  _setEditColumnNameByIndex(index, silent) {
    var _visibleColumns$index;
    const visibleColumns = this._columnsController.getVisibleColumns();
    this._setEditColumnName(null === (_visibleColumns$index = visibleColumns[index]) || void 0 === _visibleColumns$index ? void 0 : _visibleColumns$index.name, silent);
  }
  _setEditColumnName(name, silent) {
    if (silent) {
      this._silentOption(EDITING_EDITCOLUMNNAME_OPTION_NAME, name);
    } else {
      this.option(EDITING_EDITCOLUMNNAME_OPTION_NAME, name);
    }
  }
  _resetEditColumnName() {
    this._setEditColumnName(null, true);
  }
  _getEditColumn() {
    const editColumnName = this.option(EDITING_EDITCOLUMNNAME_OPTION_NAME);
    return this._getColumnByName(editColumnName);
  }
  _getColumnByName(name) {
    const visibleColumns = this._columnsController.getVisibleColumns();
    let editColumn;
    isDefined(name) && visibleColumns.some(((column) => {
      if (column.name === name) {
        editColumn = column;
        return true;
      }
    }));
    return editColumn;
  }
  _getVisibleEditRowIndex(columnName) {
    const dataController2 = this._dataController;
    const editRowKey = this.option(EDITING_EDITROWKEY_OPTION_NAME);
    const rowIndex = dataController2.getRowIndexByKey(editRowKey);
    if (-1 === rowIndex) {
      return rowIndex;
    }
    return rowIndex + this._getEditRowIndexCorrection(columnName);
  }
  _getEditRowIndexCorrection(columnName) {
    const editColumn = columnName ? this._getColumnByName(columnName) : this._getEditColumn();
    const isColumnHidden = "adaptiveHidden" === (null === editColumn || void 0 === editColumn ? void 0 : editColumn.visibleWidth);
    return isColumnHidden ? 1 : 0;
  }
  _resetEditRowKey() {
    this._refocusEditCell = false;
    this._setEditRowKey(null, true);
  }
  _resetEditIndices() {
    this._resetEditColumnName();
    this._resetEditRowKey();
  }
  editRow(rowIndex) {
    const dataController2 = this._dataController;
    const items = dataController2.items();
    const item = items[rowIndex];
    const params = {
      data: item && item.data,
      cancel: false
    };
    const oldRowIndex = this._getVisibleEditRowIndex();
    if (!item) {
      return;
    }
    if (rowIndex === oldRowIndex) {
      return true;
    }
    if (void 0 === item.key) {
      this._dataController.fireError("E1043");
      return;
    }
    if (!item.isNewRow) {
      params.key = item.key;
    }
    if (this._isEditingStart(params)) {
      return;
    }
    this.resetChanges();
    this.init();
    this._resetEditColumnName();
    this._pageIndex = dataController2.pageIndex();
    this._addInternalData({
      key: item.key,
      oldData: item.oldData ?? item.data
    });
    this._setEditRowKey(item.key);
  }
  _editRowFromOptionChanged(rowIndex, oldRowIndex) {
    const rowIndices = [oldRowIndex, rowIndex];
    this._beforeUpdateItems(rowIndices, rowIndex, oldRowIndex);
    this._editRowFromOptionChangedCore(rowIndices, rowIndex);
  }
  _editRowFromOptionChangedCore(rowIndices, rowIndex, preventRendering) {
    this._needFocusEditor = true;
    this._dataController.updateItems({
      changeType: "update",
      rowIndices,
      cancel: preventRendering
    });
  }
  _focusEditorIfNeed() {
  }
  _showEditPopup(rowIndex, repaintForm) {
  }
  _repaintEditPopup() {
  }
  _getEditPopupHiddenHandler() {
    return (e) => {
      if (this.isEditing()) {
        this.cancelEditData();
      }
    };
  }
  _getPopupEditFormTemplate(rowIndex) {
  }
  _getSaveButtonConfig() {
    const buttonConfig = {
      text: this.option("editing.texts.saveRowChanges"),
      onClick: this.saveEditData.bind(this)
    };
    if (isFluent(current())) {
      buttonConfig.stylingMode = "contained";
      buttonConfig.type = "default";
    }
    return buttonConfig;
  }
  _getCancelButtonConfig() {
    const buttonConfig = {
      text: this.option("editing.texts.cancelRowChanges"),
      onClick: this.cancelEditData.bind(this)
    };
    if (isFluent(current())) {
      buttonConfig.stylingMode = "outlined";
    }
    return buttonConfig;
  }
  _removeInternalData(key) {
    this._internalState.delete(getKeyHash(key));
  }
  _updateInsertAfterOrBeforeKeys(changes, index) {
    const removeChange = changes[index];
    changes.forEach(((change) => {
      if (change.type === DATA_EDIT_DATA_INSERT_TYPE) {
        const insertAfterOrBeforeKey = this._getInsertAfterOrBeforeKey(change);
        if (equalByValue(insertAfterOrBeforeKey, removeChange.key)) {
          change[isDefined(change.insertAfterKey) ? "insertAfterKey" : "insertBeforeKey"] = this._getInsertAfterOrBeforeKey(removeChange);
        }
      }
    }));
  }
  _removeChange(index) {
    if (index >= 0) {
      const changes = [...this.getChanges()];
      const {
        key
      } = changes[index];
      this._removeInternalData(key);
      this._updateInsertAfterOrBeforeKeys(changes, index);
      changes.splice(index, 1);
      this._silentOption(EDITING_CHANGES_OPTION_NAME, changes);
      if (equalByValue(this.option(EDITING_EDITROWKEY_OPTION_NAME), key)) {
        this._resetEditIndices();
      }
    }
  }
  executeOperation(deferred, func) {
    this._lastOperation && this._lastOperation.reject();
    this._lastOperation = deferred;
    this.waitForDeferredOperations().done((() => {
      if ("rejected" === deferred.state()) {
        return;
      }
      func();
      this._lastOperation = null;
    })).fail((() => {
      deferred.reject();
      this._lastOperation = null;
    }));
  }
  waitForDeferredOperations() {
    return when(...this._deferreds);
  }
  _processCanceledEditingCell() {
  }
  _repaintEditCell(column, oldColumn, oldEditRowIndex) {
    if (!column || !column.showEditorAlways || oldColumn && !oldColumn.showEditorAlways) {
      this._editCellInProgress = true;
      this._needFocusEditor = true;
      this._editorFactoryController.loseFocus();
      this._dataController.updateItems({
        changeType: "update",
        rowIndices: [oldEditRowIndex, this._getVisibleEditRowIndex()]
      });
    } else if (column !== oldColumn) {
      this._needFocusEditor = true;
      this._dataController.updateItems({
        changeType: "update",
        rowIndices: []
      });
    }
  }
  _delayedInputFocus($cell, beforeFocusCallback, callBeforeFocusCallbackAlways) {
    const inputFocus = () => {
      if (beforeFocusCallback) {
        beforeFocusCallback();
      }
      if ($cell) {
        const $focusableElement = $cell.find(FOCUSABLE_ELEMENT_SELECTOR).first();
        m_utils_default.focusAndSelectElement(this, $focusableElement);
      }
      this._beforeFocusCallback = null;
    };
    if (devices_default.real().ios || devices_default.real().android) {
      inputFocus();
    } else {
      if (this._beforeFocusCallback) {
        this._beforeFocusCallback();
      }
      clearTimeout(this._inputFocusTimeoutID);
      if (callBeforeFocusCallbackAlways) {
        this._beforeFocusCallback = beforeFocusCallback;
      }
      this._inputFocusTimeoutID = setTimeout(inputFocus);
    }
  }
  _focusEditingCell(beforeFocusCallback, $editCell, callBeforeFocusCallbackAlways) {
    const editColumnIndex = this._getVisibleEditColumnIndex();
    $editCell = $editCell || this._rowsView && this._rowsView._getCellElement(this._getVisibleEditRowIndex(), editColumnIndex);
    if ($editCell) {
      this._delayedInputFocus($editCell, beforeFocusCallback, callBeforeFocusCallbackAlways);
    }
  }
  deleteRow(rowIndex) {
    this._checkAndDeleteRow(rowIndex);
  }
  _checkAndDeleteRow(rowIndex) {
    const editingOptions = this.option("editing");
    const editingTexts = null === editingOptions || void 0 === editingOptions ? void 0 : editingOptions.texts;
    const confirmDelete = null === editingOptions || void 0 === editingOptions ? void 0 : editingOptions.confirmDelete;
    const confirmDeleteMessage = null === editingTexts || void 0 === editingTexts ? void 0 : editingTexts.confirmDeleteMessage;
    const item = this._dataController.items()[rowIndex];
    const allowDeleting = !this.isEditing() || item.isNewRow;
    if (item && allowDeleting) {
      if (!confirmDelete || !confirmDeleteMessage) {
        this._deleteRowCore(rowIndex);
      } else {
        const confirmDeleteTitle = editingTexts && editingTexts.confirmDeleteTitle;
        const showDialogTitle = isDefined(confirmDeleteTitle) && confirmDeleteTitle.length > 0;
        confirm(confirmDeleteMessage, confirmDeleteTitle, showDialogTitle).done(((confirmResult) => {
          if (confirmResult) {
            this._deleteRowCore(rowIndex);
          }
        }));
      }
    }
  }
  _deleteRowCore(rowIndex) {
    const dataController2 = this._dataController;
    const item = dataController2.items()[rowIndex];
    const key = item && item.key;
    const oldEditRowIndex = this._getVisibleEditRowIndex();
    this.refresh();
    const changes = this.getChanges();
    const editIndex = m_utils_default.getIndexByKey(key, changes);
    if (editIndex >= 0) {
      if (changes[editIndex].type === DATA_EDIT_DATA_INSERT_TYPE) {
        this._removeChange(editIndex);
      } else {
        this._addChange({
          key,
          type: DATA_EDIT_DATA_REMOVE_TYPE
        });
      }
    } else {
      this._addChange({
        key,
        oldData: item.data,
        type: DATA_EDIT_DATA_REMOVE_TYPE
      });
    }
    return this._afterDeleteRow(rowIndex, oldEditRowIndex);
  }
  _afterDeleteRow(rowIndex, oldEditRowIndex) {
    return this.saveEditData();
  }
  undeleteRow(rowIndex) {
    const dataController2 = this._dataController;
    const item = dataController2.items()[rowIndex];
    const oldEditRowIndex = this._getVisibleEditRowIndex();
    const key = item && item.key;
    const changes = this.getChanges();
    if (item) {
      const editIndex = m_utils_default.getIndexByKey(key, changes);
      if (editIndex >= 0) {
        const {
          data: data17
        } = changes[editIndex];
        if (isEmptyObject(data17)) {
          this._removeChange(editIndex);
        } else {
          this._addChange({
            key,
            type: DATA_EDIT_DATA_UPDATE_TYPE
          });
        }
        dataController2.updateItems({
          changeType: "update",
          rowIndices: [oldEditRowIndex, rowIndex]
        });
      }
    }
  }
  _fireOnSaving() {
    const onSavingParams = {
      cancel: false,
      promise: null,
      changes: [...this.getChanges()]
    };
    this.executeAction("onSaving", onSavingParams);
    const d = new Deferred();
    when(fromPromise(onSavingParams.promise)).done((() => {
      d.resolve(onSavingParams);
    })).fail(((arg) => {
      createFailureHandler(d);
      this._fireDataErrorOccurred(arg);
      d.resolve({
        cancel: true
      });
    }));
    return d;
  }
  _executeEditingAction(actionName, params, func) {
    if (this.component._disposed) {
      return null;
    }
    const deferred = new Deferred();
    this.executeAction(actionName, params);
    when(fromPromise(params.cancel)).done(((cancel) => {
      if (cancel) {
        setTimeout((() => {
          deferred.resolve("cancel");
        }));
      } else {
        func(params).done(deferred.resolve).fail(createFailureHandler(deferred));
      }
    })).fail(createFailureHandler(deferred));
    return deferred;
  }
  _processChanges(deferreds, results, dataChanges, changes) {
    const store = this._dataController.store();
    each(changes, ((index, change) => {
      const oldData = this._getOldData(change.key);
      const {
        data: data17,
        type: type2
      } = change;
      const changeCopy = _extends({}, change);
      let deferred;
      let params;
      if (this._beforeSaveEditData(change, index)) {
        return;
      }
      switch (type2) {
        case DATA_EDIT_DATA_REMOVE_TYPE:
          params = {
            data: oldData,
            key: change.key,
            cancel: false
          };
          deferred = this._executeEditingAction("onRowRemoving", params, (() => store.remove(change.key).done(((key) => {
            dataChanges.push({
              type: "remove",
              key
            });
          }))));
          break;
        case DATA_EDIT_DATA_INSERT_TYPE:
          params = {
            data: data17,
            cancel: false
          };
          deferred = this._executeEditingAction("onRowInserting", params, (() => store.insert(params.data).done(((data18, key) => {
            if (isDefined(key)) {
              changeCopy.key = key;
            }
            if (data18 && isObject(data18) && data18 !== params.data) {
              changeCopy.data = data18;
            }
            dataChanges.push({
              type: "insert",
              data: data18,
              index: 0
            });
          }))));
          break;
        case DATA_EDIT_DATA_UPDATE_TYPE:
          params = {
            newData: data17,
            oldData,
            key: change.key,
            cancel: false
          };
          deferred = this._executeEditingAction("onRowUpdating", params, (() => store.update(change.key, params.newData).done(((data18, key) => {
            if (data18 && isObject(data18) && data18 !== params.newData) {
              changeCopy.data = data18;
            }
            dataChanges.push({
              type: "update",
              key,
              data: data18
            });
          }))));
      }
      changes[index] = changeCopy;
      if (deferred) {
        const doneDeferred = new Deferred();
        deferred.always(((data18) => {
          results.push({
            key: change.key,
            result: data18
          });
        })).always(doneDeferred.resolve);
        deferreds.push(doneDeferred.promise());
      }
    }));
  }
  _processRemoveIfError(changes, editIndex) {
    const change = changes[editIndex];
    if ((null === change || void 0 === change ? void 0 : change.type) === DATA_EDIT_DATA_REMOVE_TYPE) {
      if (editIndex >= 0) {
        changes.splice(editIndex, 1);
      }
    }
    return true;
  }
  _processRemove(changes, editIndex, cancel) {
    const change = changes[editIndex];
    if (!cancel || !change || change.type === DATA_EDIT_DATA_REMOVE_TYPE) {
      return this._processRemoveCore(changes, editIndex, !cancel || !change);
    }
  }
  _processRemoveCore(changes, editIndex, processIfBatch) {
    if (editIndex >= 0) {
      changes.splice(editIndex, 1);
    }
    return true;
  }
  _processSaveEditDataResult(results) {
    let hasSavedData = false;
    const originalChanges = this.getChanges();
    const changes = [...originalChanges];
    const changesLength = changes.length;
    for (let i = 0; i < results.length; i++) {
      const arg = results[i].result;
      const cancel = "cancel" === arg;
      const editIndex = m_utils_default.getIndexByKey(results[i].key, changes);
      const change = changes[editIndex];
      const isError = arg && arg instanceof Error;
      if (isError) {
        if (change) {
          this._addInternalData({
            key: change.key,
            error: arg
          });
        }
        this._fireDataErrorOccurred(arg);
        if (this._processRemoveIfError(changes, editIndex)) {
          break;
        }
      } else if (this._processRemove(changes, editIndex, cancel)) {
        hasSavedData = !cancel;
        const removedChangeIndex = m_utils_default.getIndexByKey(results[i].key, originalChanges);
        this._updateInsertAfterOrBeforeKeys(originalChanges, removedChangeIndex);
      }
    }
    if (changes.length < changesLength) {
      this._silentOption(EDITING_CHANGES_OPTION_NAME, changes);
    }
    return hasSavedData;
  }
  _fireSaveEditDataEvents(changes) {
    each(changes, ((_, _ref) => {
      let {
        data: data17,
        key,
        type: type2
      } = _ref;
      const internalData = this._addInternalData({
        key
      });
      const params = {
        key,
        data: data17
      };
      if (internalData.error) {
        params.error = internalData.error;
      }
      switch (type2) {
        case DATA_EDIT_DATA_REMOVE_TYPE:
          this.executeAction("onRowRemoved", extend({}, params, {
            data: internalData.oldData
          }));
          break;
        case DATA_EDIT_DATA_INSERT_TYPE:
          this.executeAction("onRowInserted", params);
          break;
        case DATA_EDIT_DATA_UPDATE_TYPE:
          this.executeAction("onRowUpdated", params);
      }
    }));
    this.executeAction("onSaved", {
      changes
    });
  }
  saveEditData() {
    const deferred = new Deferred();
    this.waitForDeferredOperations().done((() => {
      if (this.isSaving()) {
        this._resolveAfterSave(deferred);
        return;
      }
      when(this._beforeSaveEditData()).done(((cancel) => {
        if (cancel) {
          this._resolveAfterSave(deferred, {
            cancel
          });
          return;
        }
        this._saving = true;
        this._saveEditDataInner().always((() => {
          this._saving = false;
          if (this._refocusEditCell) {
            this._focusEditingCell();
          }
        })).done(deferred.resolve).fail(deferred.reject);
      })).fail(deferred.reject);
    })).fail(deferred.reject);
    return deferred.promise();
  }
  _resolveAfterSave(deferred) {
    let {
      cancel,
      error
    } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    when(this._afterSaveEditData(cancel)).done((() => {
      deferred.resolve(error);
    })).fail(deferred.reject);
  }
  _saveEditDataInner() {
    const result = new Deferred();
    const results = [];
    const deferreds = [];
    const dataChanges = [];
    const dataSource = this._dataController.dataSource();
    when(this._fireOnSaving()).done(((_ref2) => {
      let {
        cancel,
        changes
      } = _ref2;
      if (cancel) {
        return result.resolve().promise();
      }
      this._processChanges(deferreds, results, dataChanges, changes);
      if (deferreds.length) {
        this._refocusEditCell = true;
        null === dataSource || void 0 === dataSource || dataSource.beginLoading();
        when(...deferreds).done((() => {
          if (this._processSaveEditDataResult(results)) {
            this._endSaving(dataChanges, changes, result);
          } else {
            null === dataSource || void 0 === dataSource || dataSource.endLoading();
            result.resolve();
          }
        })).fail(((error) => {
          null === dataSource || void 0 === dataSource || dataSource.endLoading();
          result.resolve(error);
        }));
        return result.always((() => {
          this._refocusEditCell = true;
        })).promise();
      }
      this._cancelSaving(result);
    })).fail(result.reject);
    return result.promise();
  }
  _beforeEndSaving(changes) {
    this._resetEditIndices();
  }
  _endSaving(dataChanges, changes, deferred) {
    const dataSource = this._dataController.dataSource();
    this._beforeEndSaving(changes);
    null === dataSource || void 0 === dataSource || dataSource.endLoading();
    this._refreshDataAfterSave(dataChanges, changes, deferred);
  }
  _cancelSaving(result) {
    this.executeAction("onSaved", {
      changes: []
    });
    this._resolveAfterSave(result);
  }
  _refreshDataAfterSave(dataChanges, changes, deferred) {
    const dataController2 = this._dataController;
    const refreshMode = this.option("editing.refreshMode");
    const isFullRefresh = "reshape" !== refreshMode && "repaint" !== refreshMode;
    if (!isFullRefresh) {
      dataController2.push(dataChanges);
    }
    when(dataController2.refresh({
      selection: isFullRefresh,
      reload: isFullRefresh,
      load: "reshape" === refreshMode,
      changesOnly: this.option("repaintChangesOnly")
    })).always((() => {
      this._fireSaveEditDataEvents(changes);
    })).done((() => {
      this._resolveAfterSave(deferred);
    })).fail(((error) => {
      this._resolveAfterSave(deferred, {
        error
      });
    }));
  }
  isSaving() {
    return this._saving;
  }
  _updateEditColumn() {
    const isEditColumnVisible = this._isEditColumnVisible();
    const useIcons = this.option("editing.useIcons");
    const cssClass = COMMAND_EDIT_CLASS2 + (useIcons ? ` ${COMMAND_EDIT_WITH_ICONS_CLASS}` : "");
    this._columnsController.addCommandColumn({
      type: "buttons",
      command: "edit",
      visible: isEditColumnVisible,
      cssClass,
      width: "auto",
      alignment: "center",
      cellTemplate: this._getEditCommandCellTemplate(),
      fixedPosition: "right"
    });
    this._columnsController.columnOption("command:edit", {
      visible: isEditColumnVisible,
      cssClass
    });
  }
  _isEditColumnVisible() {
    const editingOptions = this.option("editing");
    return editingOptions.allowDeleting;
  }
  _isEditButtonDisabled() {
    const hasChanges = this.hasChanges();
    const isEditRowDefined = isDefined(this.option("editing.editRowKey"));
    return !(isEditRowDefined || hasChanges);
  }
  _updateEditButtons() {
    const isButtonDisabled = this._isEditButtonDisabled();
    if (this._headerPanelView) {
      this._headerPanelView.setToolbarItemDisabled("saveButton", isButtonDisabled);
      this._headerPanelView.setToolbarItemDisabled("revertButton", isButtonDisabled);
    }
  }
  _applyModified($element, options) {
    $element && $element.addClass(CELL_MODIFIED);
  }
  _beforeCloseEditCellInBatchMode(rowIndices) {
  }
  cancelEditData() {
    const changes = this.getChanges();
    const params = {
      cancel: false,
      changes
    };
    this.executeAction("onEditCanceling", params);
    if (!params.cancel) {
      this._cancelEditDataCore();
      this.executeAction("onEditCanceled", {
        changes
      });
    }
  }
  _cancelEditDataCore() {
    const rowIndex = this._getVisibleEditRowIndex();
    this._beforeCancelEditData();
    this.init();
    this.resetChanges();
    this._resetEditColumnName();
    this._resetEditRowKey();
    this._afterCancelEditData(rowIndex);
  }
  _afterCancelEditData(rowIndex) {
    const dataController2 = this._dataController;
    dataController2.updateItems({
      repaintChangesOnly: this.option("repaintChangesOnly")
    });
  }
  _hideEditPopup() {
  }
  hasEditData() {
    return this.hasChanges();
  }
  update(changeType) {
    const dataController2 = this._dataController;
    if (dataController2 && this._pageIndex !== dataController2.pageIndex()) {
      if ("refresh" === changeType) {
        this.refresh({
          isPageChanged: true
        });
      }
      this._pageIndex = dataController2.pageIndex();
    }
    this._updateEditButtons();
  }
  _getRowIndicesForCascadeUpdating(row, skipCurrentRow) {
    return skipCurrentRow ? [] : [row.rowIndex];
  }
  addDeferred(deferred) {
    if (!this._deferreds.includes(deferred)) {
      this._deferreds.push(deferred);
      deferred.always((() => {
        const index = this._deferreds.indexOf(deferred);
        if (index >= 0) {
          this._deferreds.splice(index, 1);
        }
      }));
    }
  }
  _prepareChange(options, value2, text) {
    var _options$row;
    const newData = {};
    const oldData = null === (_options$row = options.row) || void 0 === _options$row ? void 0 : _options$row.data;
    const rowKey = options.key;
    const deferred = new Deferred();
    if (void 0 !== rowKey) {
      options.value = value2;
      const setCellValueResult = fromPromise(options.column.setCellValue(newData, value2, extend(true, {}, oldData), text));
      setCellValueResult.done((() => {
        deferred.resolve({
          data: newData,
          key: rowKey,
          oldData,
          type: DATA_EDIT_DATA_UPDATE_TYPE
        });
      })).fail(createFailureHandler(deferred)).fail(((arg) => this._fireDataErrorOccurred(arg)));
      if (isDefined(text) && options.column.displayValueMap) {
        options.column.displayValueMap[value2] = text;
      }
      this._updateRowValues(options);
      this.addDeferred(deferred);
    }
    return deferred;
  }
  _updateRowValues(options) {
    if (options.values) {
      const dataController2 = this._dataController;
      const rowIndex = dataController2.getRowIndexByKey(options.key);
      const row = dataController2.getVisibleRows()[rowIndex];
      if (row) {
        options.row.values = row.values;
        options.values = row.values;
      }
      options.values[options.columnIndex] = options.value;
    }
  }
  updateFieldValue(options, value2, text, forceUpdateRow) {
    const rowKey = options.key;
    const deferred = new Deferred();
    if (void 0 === rowKey) {
      this._dataController.fireError("E1043");
    }
    if (options.column.setCellValue) {
      this._prepareChange(options, value2, text).done(((params) => {
        when(this._applyChange(options, params, forceUpdateRow)).always((() => {
          deferred.resolve();
        }));
      }));
    } else {
      deferred.resolve();
    }
    return deferred.promise();
  }
  _focusPreviousEditingCellIfNeed(options) {
    if (this.hasEditData() && !this.isEditCell(options.rowIndex, options.columnIndex)) {
      this._focusEditingCell();
      this._updateEditRow(options.row, true);
      return true;
    }
  }
  _needUpdateRow(column) {
    const visibleColumns = this._columnsController.getVisibleColumns();
    if (!column) {
      column = this._getEditColumn();
    }
    const isCustomSetCellValue = column && column.setCellValue !== column.defaultSetCellValue;
    const isCustomCalculateCellValue = visibleColumns.some(((visibleColumn) => visibleColumn.calculateCellValue !== visibleColumn.defaultCalculateCellValue));
    return isCustomSetCellValue || isCustomCalculateCellValue;
  }
  _applyChange(options, params, forceUpdateRow) {
    const changeOptions = _extends({}, options, {
      forceUpdateRow
    });
    this._addChange(params, changeOptions);
    this._updateEditButtons();
    return this._applyChangeCore(options, changeOptions.forceUpdateRow);
  }
  _applyChangeCore(options, forceUpdateRow) {
    const isCustomSetCellValue = options.column.setCellValue !== options.column.defaultSetCellValue;
    const {
      row
    } = options;
    if (row) {
      if (forceUpdateRow || isCustomSetCellValue) {
        this._updateEditRow(row, forceUpdateRow, isCustomSetCellValue);
      } else if (row.update) {
        row.update();
      }
    }
  }
  _updateEditRowCore(row, skipCurrentRow, isCustomSetCellValue) {
    this._dataController.updateItems({
      changeType: "update",
      rowIndices: this._getRowIndicesForCascadeUpdating(row, skipCurrentRow)
    });
  }
  _updateEditRow(row, forceUpdateRow, isCustomSetCellValue) {
    if (forceUpdateRow) {
      this._updateRowImmediately(row, forceUpdateRow, isCustomSetCellValue);
    } else {
      this._updateRowWithDelay(row, isCustomSetCellValue);
    }
  }
  _updateRowImmediately(row, forceUpdateRow, isCustomSetCellValue) {
    this._updateEditRowCore(row, !forceUpdateRow, isCustomSetCellValue);
    this._validateEditFormAfterUpdate(row, isCustomSetCellValue);
    if (!forceUpdateRow) {
      this._focusEditingCell();
    }
  }
  _updateRowWithDelay(row, isCustomSetCellValue) {
    const deferred = new Deferred();
    this.addDeferred(deferred);
    setTimeout((() => {
      var _this$_editForm;
      const elementContainer = (null === (_this$_editForm = this._editForm) || void 0 === _this$_editForm ? void 0 : _this$_editForm.element()) || this.component.$element().get(0);
      const $focusedElement = renderer_default(dom_adapter_default.getActiveElement(elementContainer));
      const columnIndex = this._rowsView.getCellIndex($focusedElement, row.rowIndex);
      let focusedElement = $focusedElement.get(0);
      const selectionRange = m_utils_default.getSelectionRange(focusedElement);
      this._updateEditRowCore(row, false, isCustomSetCellValue);
      this._validateEditFormAfterUpdate(row, isCustomSetCellValue);
      if (columnIndex >= 0) {
        const $focusedItem = this._rowsView._getCellElement(row.rowIndex, columnIndex);
        this._delayedInputFocus($focusedItem, (() => {
          setTimeout((() => {
            var _this$component$$elem;
            focusedElement = dom_adapter_default.getActiveElement(null === (_this$component$$elem = this.component.$element()) || void 0 === _this$component$$elem ? void 0 : _this$component$$elem.get(0));
            if (selectionRange.selectionStart >= 0) {
              m_utils_default.setSelectionRange(focusedElement, selectionRange);
            }
          }));
        }));
      }
      deferred.resolve();
    }));
  }
  _validateEditFormAfterUpdate() {
  }
  _addChange(changeParams, options) {
    var _this$getChanges;
    const row = null === options || void 0 === options ? void 0 : options.row;
    const changes = [...this.getChanges()];
    let index = m_utils_default.getIndexByKey(changeParams.key, changes);
    if (index < 0) {
      index = changes.length;
      this._addInternalData({
        key: changeParams.key,
        oldData: changeParams.oldData
      });
      delete changeParams.oldData;
      changes.push(changeParams);
    }
    const change = _extends({}, changes[index]);
    if (change) {
      if (changeParams.data) {
        change.data = createObjectWithChanges(change.data, changeParams.data);
      }
      if ((!change.type || !changeParams.data) && changeParams.type) {
        change.type = changeParams.type;
      }
      if (row) {
        row.oldData = this._getOldData(row.key);
        row.data = createObjectWithChanges(row.data, changeParams.data);
      }
    }
    changes[index] = change;
    this._silentOption(EDITING_CHANGES_OPTION_NAME, changes);
    if (options && change !== (null === (_this$getChanges = this.getChanges()) || void 0 === _this$getChanges ? void 0 : _this$getChanges[index])) {
      options.forceUpdateRow = true;
    }
    return change;
  }
  _getFormEditItemTemplate(cellOptions, column) {
    return column.editCellTemplate || this._getDefaultEditorTemplate();
  }
  getColumnTemplate(options) {
    const {
      column
    } = options;
    const rowIndex = options.row && options.row.rowIndex;
    let template;
    const isRowMode = this.isRowBasedEditMode();
    const isRowEditing = this.isEditRow(rowIndex);
    const isCellEditing = this.isEditCell(rowIndex, options.columnIndex);
    let editingStartOptions;
    if ((column.showEditorAlways || column.setCellValue && (isRowEditing && column.allowEditing || isCellEditing)) && ("data" === options.rowType || "detailAdaptive" === options.rowType) && !column.command) {
      const allowUpdating = this.allowUpdating(options);
      if (((allowUpdating || isRowEditing) && column.allowEditing || isCellEditing) && (isRowEditing || !isRowMode)) {
        if (column.showEditorAlways && !isRowMode) {
          editingStartOptions = {
            cancel: false,
            key: options.row.isNewRow ? void 0 : options.row.key,
            data: options.row.data,
            column
          };
          this._isEditingStart(editingStartOptions);
        }
        if (!editingStartOptions || !editingStartOptions.cancel) {
          options.setValue = (value2, text) => {
            this.updateFieldValue(options, value2, text);
          };
        }
      }
      template = column.editCellTemplate || this._getDefaultEditorTemplate();
    } else if ("detail" === column.command && "detail" === options.rowType && isRowEditing) {
      template = null === this || void 0 === this ? void 0 : this.getEditFormTemplate(options);
    }
    return template;
  }
  _createButton($container, button, options, change) {
    let icon = EDIT_ICON_CLASS[button.name];
    const useIcons = this.option("editing.useIcons");
    const useLegacyColumnButtonTemplate = this.option("useLegacyColumnButtonTemplate");
    let $button = renderer_default("<a>").attr("href", "#").addClass(LINK_CLASS).addClass(button.cssClass);
    if (button.template && useLegacyColumnButtonTemplate) {
      this._rowsView.renderTemplate($container, button.template, options, true);
    } else {
      if (button.template) {
        $button = renderer_default("<span>").addClass(button.cssClass);
      } else if (useIcons && icon || button.icon) {
        icon = button.icon || icon;
        const iconType = getImageSourceType(icon);
        if ("image" === iconType || "svg" === iconType) {
          $button = getImageContainer(icon).addClass(button.cssClass);
        } else {
          $button.addClass(`dx-icon${"dxIcon" === iconType ? "-" : " "}${icon}`).attr("title", button.text);
        }
        $button.addClass(LINK_ICON_CLASS);
        $container.addClass(COMMAND_EDIT_WITH_ICONS_CLASS);
        const localizationName = this.getButtonLocalizationNames()[button.name];
        localizationName && $button.attr("aria-label", message_default.format(localizationName));
      } else {
        $button.text(button.text);
      }
      if (isDefined(button.hint)) {
        $button.attr("title", button.hint);
      }
      if (this._isButtonDisabled(button, options)) {
        $button.addClass("dx-state-disabled");
      } else if (!button.template || button.onClick) {
        m_events_engine_default.on($button, addNamespace("click", EDITING_NAMESPACE), this.createAction(((e) => {
          var _button$onClick;
          null === (_button$onClick = button.onClick) || void 0 === _button$onClick || _button$onClick.call(button, extend({}, e, {
            row: options.row,
            column: options.column
          }));
          e.event.preventDefault();
          e.event.stopPropagation();
        })));
      }
      $container.append($button);
      if (button.template) {
        options.renderAsync = false;
        this._rowsView.renderTemplate($button, button.template, options, true, change);
      }
    }
  }
  getButtonLocalizationNames() {
    return {
      edit: "dxDataGrid-editingEditRow",
      save: "dxDataGrid-editingSaveRowChanges",
      delete: "dxDataGrid-editingDeleteRow",
      undelete: "dxDataGrid-editingUndeleteRow",
      cancel: "dxDataGrid-editingCancelRowChanges"
    };
  }
  prepareButtonItem(headerPanel8, name, methodName, sortIndex) {
    const editingTexts = this.option("editing.texts") ?? {};
    const titleButtonTextByClassNames = {
      revert: editingTexts.cancelAllChanges,
      save: editingTexts.saveAllChanges,
      addRow: editingTexts.addRow
    };
    const className = {
      revert: "cancel",
      save: "save",
      addRow: "addrow"
    }[name];
    const hintText = titleButtonTextByClassNames[name];
    const isButtonDisabled = ("save" === className || "cancel" === className) && this._isEditButtonDisabled();
    return {
      widget: "dxButton",
      options: {
        onInitialized: (e) => {
          renderer_default(e.element).addClass(headerPanel8._getToolbarButtonClass(`${EDIT_BUTTON_CLASS} ${this.addWidgetPrefix(className)}-button`));
        },
        icon: `edit-button-${className}`,
        disabled: isButtonDisabled,
        onClick: () => {
          setTimeout((() => {
            this[methodName]();
          }));
        },
        text: hintText,
        hint: hintText
      },
      showText: "inMenu",
      name: `${name}Button`,
      location: "after",
      locateInMenu: "auto",
      sortIndex
    };
  }
  prepareEditButtons(headerPanel8) {
    const editingOptions = this.option("editing") ?? {};
    const buttonItems = [];
    if (editingOptions.allowAdding) {
      buttonItems.push(this.prepareButtonItem(headerPanel8, "addRow", "addRow", 20));
    }
    return buttonItems;
  }
  highlightDataCell($cell, params) {
    this.shouldHighlightCell(params) && $cell.addClass(CELL_MODIFIED);
  }
  _afterInsertRow(key) {
  }
  _beforeSaveEditData(change) {
    if (change && !isDefined(change.key) && isDefined(change.type)) {
      return true;
    }
  }
  _afterSaveEditData() {
  }
  _beforeCancelEditData() {
  }
  _allowEditAction(actionName, options) {
    let allowEditAction = this.option(`editing.${actionName}`);
    if (isFunction(allowEditAction)) {
      allowEditAction = allowEditAction({
        component: this.component,
        row: options.row
      });
    }
    return allowEditAction;
  }
  allowUpdating(options, eventName) {
    const startEditAction = this.option("editing.startEditAction") ?? DEFAULT_START_EDIT_ACTION;
    const needCallback = arguments.length > 1 ? startEditAction === eventName || "down" === eventName : true;
    return needCallback && this._allowEditAction("allowUpdating", options);
  }
  allowDeleting(options) {
    return this._allowEditAction("allowDeleting", options);
  }
  isCellModified(parameters) {
    var _parameters$row, _parameters$row2;
    const {
      columnIndex
    } = parameters;
    let modifiedValue = null === parameters || void 0 === parameters || null === (_parameters$row = parameters.row) || void 0 === _parameters$row || null === (_parameters$row = _parameters$row.modifiedValues) || void 0 === _parameters$row ? void 0 : _parameters$row[columnIndex];
    if (null !== parameters && void 0 !== parameters && null !== (_parameters$row2 = parameters.row) && void 0 !== _parameters$row2 && _parameters$row2.isNewRow) {
      modifiedValue = parameters.value;
    }
    return void 0 !== modifiedValue;
  }
  isNewRowInEditMode() {
    const visibleEditRowIndex = this._getVisibleEditRowIndex();
    const rows = this._dataController.items();
    return visibleEditRowIndex >= 0 ? rows[visibleEditRowIndex].isNewRow : false;
  }
  _isRowDeleteAllowed() {
  }
  _prepareEditCell(parameters) {
    return false;
  }
  shouldHighlightCell(parameters) {
    const cellModified = this.isCellModified(parameters);
    return cellModified && parameters.column.setCellValue && (this.getEditMode() !== EDIT_MODE_ROW || !parameters.row.isEditing);
  }
};
var dataControllerEditingExtenderMixin = (Base) => class extends Base {
  reload(full, repaintChangesOnly) {
    !repaintChangesOnly && this._editingController.refresh();
    return super.reload.apply(this, arguments);
  }
  repaintRows() {
    if (this._editingController.isSaving()) {
      return;
    }
    return super.repaintRows.apply(this, arguments);
  }
  _updateEditRow(items) {
    const editRowKey = this.option(EDITING_EDITROWKEY_OPTION_NAME);
    const editRowIndex = m_utils_default.getIndexByKey(editRowKey, items);
    const editItem = items[editRowIndex];
    if (editItem) {
      var _this$_updateEditItem;
      editItem.isEditing = true;
      null === (_this$_updateEditItem = this._updateEditItem) || void 0 === _this$_updateEditItem || _this$_updateEditItem.call(this, editItem);
    }
  }
  _updateItemsCore(change) {
    super._updateItemsCore(change);
    this._updateEditRow(this.items(true));
  }
  _applyChangeUpdate(change) {
    this._updateEditRow(change.items);
    super._applyChangeUpdate(change);
  }
  _applyChangesOnly(change) {
    this._updateEditRow(change.items);
    super._applyChangesOnly(change);
  }
  _processItems(items, change) {
    items = this._editingController.processItems(items, change);
    return super._processItems(items, change);
  }
  _processDataItem(dataItem, options) {
    this._editingController.processDataItem(dataItem, options, this.generateDataValues);
    return super._processDataItem(dataItem, options);
  }
  _processItem(item, options) {
    item = super._processItem(item, options);
    if (item.isNewRow) {
      options.dataIndex--;
      delete item.dataIndex;
    }
    return item;
  }
  _getChangedColumnIndices(oldItem, newItem, rowIndex, isLiveUpdate) {
    if (oldItem.isNewRow !== newItem.isNewRow || oldItem.removed !== newItem.removed) {
      return;
    }
    return super._getChangedColumnIndices.apply(this, arguments);
  }
  _isCellChanged(oldRow, newRow, visibleRowIndex, columnIndex, isLiveUpdate) {
    const cell = oldRow.cells && oldRow.cells[columnIndex];
    const isEditing = this._editingController && this._editingController.isEditCell(visibleRowIndex, columnIndex);
    if (isLiveUpdate && isEditing) {
      return false;
    }
    if (cell && cell.column && !cell.column.showEditorAlways && cell.isEditing !== isEditing) {
      return true;
    }
    return super._isCellChanged.apply(this, arguments);
  }
  needToRefreshOnDataSourceChange(args) {
    const isParasiteChange = Array.isArray(args.value) && args.value === args.previousValue && this._editingController.isSaving();
    return !isParasiteChange;
  }
  _handleDataSourceChange(args) {
    const result = super._handleDataSourceChange(args);
    const changes = this.option("editing.changes");
    const dataSource = args.value;
    if (Array.isArray(dataSource) && changes.length) {
      const dataSourceKeys = dataSource.map(((item) => this.keyOf(item)));
      const newChanges = changes.filter(((change) => "insert" === change.type || dataSourceKeys.some(((key) => equalByValue(change.key, key)))));
      if (newChanges.length !== changes.length) {
        this.option("editing.changes", newChanges);
      }
      const editRowKey = this.option("editing.editRowKey");
      const isEditNewItem = newChanges.some(((change) => "insert" === change.type && equalByValue(editRowKey, change.key)));
      if (!isEditNewItem && dataSourceKeys.every(((key) => !equalByValue(editRowKey, key)))) {
        this.option("editing.editRowKey", null);
      }
    }
    return result;
  }
};
var rowsView3 = (Base) => class extends Base {
  getCellIndex($cell, rowIndex) {
    if (!$cell.is("td") && rowIndex >= 0) {
      const $cellElements = this.getCellElements(rowIndex);
      let cellIndex = -1;
      each($cellElements, ((index, cellElement) => {
        if (renderer_default(cellElement).find($cell).length) {
          cellIndex = index;
        }
      }));
      return cellIndex;
    }
    return super.getCellIndex.apply(this, arguments);
  }
  publicMethods() {
    return super.publicMethods().concat(["cellValue"]);
  }
  _getCellTemplate(options) {
    const template = this._editingController.getColumnTemplate(options);
    return template || super._getCellTemplate(options);
  }
  _createRow(row) {
    const $row = super._createRow.apply(this, arguments);
    if (row) {
      const isRowRemoved = !!row.removed;
      const isRowInserted = !!row.isNewRow;
      const isRowModified = !!row.modified;
      isRowInserted && $row.addClass(ROW_INSERTED);
      isRowModified && $row.addClass(ROW_MODIFIED);
      if (isRowInserted || isRowRemoved) {
        $row.removeClass(ROW_SELECTED);
      }
    }
    return $row;
  }
  _getColumnIndexByElement($element) {
    let $tableElement = $element.closest("table");
    const $tableElements = this.getTableElements();
    while ($tableElement.length && !$tableElements.filter($tableElement).length) {
      $element = $tableElement.closest("td");
      $tableElement = $element.closest("table");
    }
    return this._getColumnIndexByElementCore($element);
  }
  _getColumnIndexByElementCore($element) {
    const $targetElement = $element.closest(`.${ROW_CLASS}> td:not(.dx-master-detail-cell)`);
    return this.getCellIndex($targetElement);
  }
  _editCellByClick(e, eventName) {
    const editingController = this._editingController;
    const $targetElement = renderer_default(e.event.target);
    const columnIndex = this._getColumnIndexByElement($targetElement);
    const row = this._dataController.items()[e.rowIndex];
    const allowUpdating = editingController.allowUpdating({
      row
    }, eventName) || row && row.isNewRow;
    const column = this._columnsController.getVisibleColumns()[columnIndex];
    const isEditedCell = editingController.isEditCell(e.rowIndex, columnIndex);
    const allowEditing = allowUpdating && column && (column.allowEditing || isEditedCell);
    const startEditAction = this.option("editing.startEditAction") || "click";
    const isShowEditorAlways = column && column.showEditorAlways;
    if (isEditedCell) {
      return true;
    }
    if ("down" === eventName) {
      if (devices_default.real().ios || devices_default.real().android) {
        m_dom_default.resetActiveElement();
      }
      return isShowEditorAlways && allowEditing && editingController.editCell(e.rowIndex, columnIndex);
    }
    if ("click" === eventName && "dblClick" === startEditAction && this._pointerDownTarget === $targetElement.get(0)) {
      const isError = false;
      const withoutSaveEditData = null === row || void 0 === row ? void 0 : row.isNewRow;
      editingController.closeEditCell(isError, withoutSaveEditData);
    }
    if (allowEditing && eventName === startEditAction) {
      return editingController.editCell(e.rowIndex, columnIndex) || editingController.isEditRow(e.rowIndex);
    }
  }
  _rowPointerDown(e) {
    this._pointerDownTarget = e.event.target;
    this._pointerDownTimeout = setTimeout((() => {
      this._editCellByClick(e, "down");
    }));
  }
  _rowClickTreeListHack(e) {
    super._rowClick.apply(this, arguments);
  }
  _rowClick(e) {
    const isEditForm2 = renderer_default(e.rowElement).hasClass(this.addWidgetPrefix(EDIT_FORM_CLASS2));
    e.event[TARGET_COMPONENT_NAME] = this.component;
    if (!this._editCellByClick(e, "click") && !isEditForm2) {
      super._rowClick.apply(this, arguments);
    }
  }
  _rowDblClickTreeListHack(e) {
    super._rowDblClick.apply(this, arguments);
  }
  _rowDblClick(e) {
    if (!this._editCellByClick(e, "dblClick")) {
      super._rowDblClick.apply(this, arguments);
    }
  }
  _cellPrepared($cell, parameters) {
    var _parameters$column;
    const editingController = this._editingController;
    const isCommandCell = !!parameters.column.command;
    const isEditableCell = parameters.setValue;
    const isEditRow2 = editingController.isEditRow(parameters.rowIndex);
    const isEditing = isEditingCell(isEditRow2, parameters);
    if (isEditingOrShowEditorAlwaysDataCell(isEditRow2, parameters)) {
      const {
        alignment
      } = parameters.column;
      $cell.toggleClass(this.addWidgetPrefix(READONLY_CLASS), !isEditableCell).toggleClass(CELL_FOCUS_DISABLED_CLASS2, !isEditableCell);
      if (alignment) {
        $cell.find(EDITORS_INPUT_SELECTOR).first().css("textAlign", alignment);
      }
    }
    if (isEditing) {
      this._editCellPrepared($cell);
    }
    const hasTemplate = !!(null !== (_parameters$column = parameters.column) && void 0 !== _parameters$column && _parameters$column.cellTemplate);
    if (parameters.column && !isCommandCell && (!hasTemplate || editingController.shouldHighlightCell(parameters))) {
      editingController.highlightDataCell($cell, parameters);
    }
    super._cellPrepared.apply(this, arguments);
  }
  _getCellOptions(options) {
    const cellOptions = super._getCellOptions(options);
    const {
      columnIndex,
      row
    } = options;
    cellOptions.isEditing = this._editingController.isEditCell(cellOptions.rowIndex, cellOptions.columnIndex);
    cellOptions.removed = row.removed;
    if (row.modified) {
      cellOptions.modified = void 0 !== row.modifiedValues[columnIndex];
    }
    return cellOptions;
  }
  _setCellAriaAttributes($cell, cellOptions, options) {
    super._setCellAriaAttributes($cell, cellOptions, options);
    if (cellOptions.removed) {
      this.setAria("roledescription", message_default.format("dxDataGrid-ariaDeletedCell"), $cell);
    }
    if (cellOptions.modified) {
      this.setAria("roledescription", message_default.format("dxDataGrid-ariaModifiedCell"), $cell);
    }
    const isEditableCell = cellOptions.column.allowEditing && !cellOptions.removed && !cellOptions.modified && "data" === cellOptions.rowType && cellOptions.column.calculateCellValue === cellOptions.column.defaultCalculateCellValue && this._editingController.isCellBasedEditMode();
    if (isEditableCell) {
      this.setAria("roledescription", message_default.format("dxDataGrid-ariaEditableCell"), $cell);
    }
  }
  _createCell(options) {
    const $cell = super._createCell(options);
    const isEditRow2 = this._editingController.isEditRow(options.rowIndex);
    isEditingOrShowEditorAlwaysDataCell(isEditRow2, options) && $cell.addClass(EDITOR_CELL_CLASS);
    return $cell;
  }
  cellValue(rowIndex, columnIdentifier, value2, text) {
    const cellOptions = this.getCellOptions(rowIndex, columnIdentifier);
    if (cellOptions) {
      if (void 0 === value2) {
        return cellOptions.value;
      }
      this._editingController.updateFieldValue(cellOptions, value2, text, true);
    }
  }
  dispose() {
    super.dispose.apply(this, arguments);
    clearTimeout(this._pointerDownTimeout);
  }
  _renderCore() {
    super._renderCore.apply(this, arguments);
    return this.waitAsyncTemplates(true).done((() => {
      this._editingController._focusEditorIfNeed();
    }));
  }
  _editCellPrepared() {
  }
  _formItemPrepared() {
  }
};
var headerPanel3 = (Base) => class extends Base {
  optionChanged(args) {
    const {
      fullName
    } = args;
    switch (args.name) {
      case "editing": {
        const excludedOptions = [EDITING_POPUP_OPTION_NAME, EDITING_CHANGES_OPTION_NAME, EDITING_EDITCOLUMNNAME_OPTION_NAME, EDITING_EDITROWKEY_OPTION_NAME];
        const shouldInvalidate = fullName && !excludedOptions.some(((optionName) => optionName === fullName));
        shouldInvalidate && this._invalidate();
        super.optionChanged(args);
        break;
      }
      case "useLegacyColumnButtonTemplate":
        args.handled = true;
        break;
      default:
        super.optionChanged(args);
    }
  }
  _getToolbarItems() {
    const items = super._getToolbarItems();
    const editButtonItems = this._editingController.prepareEditButtons(this);
    return editButtonItems.concat(items);
  }
};
var editingModule = {
  defaultOptions: () => ({
    editing: {
      mode: "row",
      refreshMode: "full",
      newRowPosition: VIEWPORT_TOP_NEW_ROW_POSITION,
      allowAdding: false,
      allowUpdating: false,
      allowDeleting: false,
      useIcons: false,
      selectTextOnEditStart: false,
      confirmDelete: true,
      texts: {
        editRow: message_default.format("dxDataGrid-editingEditRow"),
        saveAllChanges: message_default.format("dxDataGrid-editingSaveAllChanges"),
        saveRowChanges: message_default.format("dxDataGrid-editingSaveRowChanges"),
        cancelAllChanges: message_default.format("dxDataGrid-editingCancelAllChanges"),
        cancelRowChanges: message_default.format("dxDataGrid-editingCancelRowChanges"),
        addRow: message_default.format("dxDataGrid-editingAddRow"),
        deleteRow: message_default.format("dxDataGrid-editingDeleteRow"),
        undeleteRow: message_default.format("dxDataGrid-editingUndeleteRow"),
        confirmDeleteMessage: message_default.format("dxDataGrid-editingConfirmDeleteMessage"),
        confirmDeleteTitle: ""
      },
      form: {
        colCount: 2
      },
      popup: {},
      startEditAction: "click",
      editRowKey: null,
      editColumnName: null,
      changes: []
    },
    useLegacyColumnButtonTemplate: false
  }),
  controllers: {
    editing: EditingControllerImpl
  },
  extenders: {
    controllers: {
      data: dataControllerEditingExtenderMixin
    },
    views: {
      rowsView: rowsView3,
      headerPanel: headerPanel3
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/m_editing.js
var data4 = (Base) => class extends dataControllerEditingExtenderMixin(Base) {
  _changeRowExpandCore(key) {
    const editingController = this._editingController;
    if (Array.isArray(key)) {
      editingController && editingController.refresh();
    }
    return super._changeRowExpandCore.apply(this, arguments);
  }
};
m_core_default.registerModule("editing", _extends({}, editingModule, {
  extenders: _extends({}, editingModule.extenders, {
    controllers: _extends({}, editingModule.extenders.controllers, {
      data: data4
    })
  })
}));

// node_modules/devextreme/esm/__internal/grids/grid_core/editing/m_editing_row_based.js
var editingControllerExtender = (Base) => class extends Base {
  isRowEditMode() {
    return this.getEditMode() === EDIT_MODE_ROW;
  }
  _afterCancelEditData(rowIndex) {
    const dataController2 = this._dataController;
    if (this.isRowBasedEditMode() && rowIndex >= 0) {
      dataController2.updateItems({
        changeType: "update",
        rowIndices: [rowIndex, rowIndex + 1]
      });
    } else {
      super._afterCancelEditData(rowIndex);
    }
  }
  _isDefaultButtonVisible(button, options) {
    const isRowMode = this.isRowBasedEditMode();
    const isPopupEditMode = this.isPopupEditMode();
    const isEditRow2 = !isPopupEditMode && options.row && equalByValue(options.row.key, this.option(EDITING_EDITROWKEY_OPTION_NAME));
    if (isRowMode) {
      switch (button.name) {
        case "edit":
          return !isEditRow2 && this.allowUpdating(options);
        case "delete":
          return super._isDefaultButtonVisible(button, options) && !isEditRow2;
        case "save":
        case "cancel":
          return isEditRow2;
        default:
          return super._isDefaultButtonVisible(button, options);
      }
    }
    return super._isDefaultButtonVisible(button, options);
  }
  isEditRow(rowIndex) {
    return this.isRowBasedEditMode() && this.isEditRowByIndex(rowIndex);
  }
  _cancelSaving(result) {
    if (this.isRowBasedEditMode()) {
      if (!this.hasChanges()) {
        this._cancelEditDataCore();
      }
    }
    super._cancelSaving(result);
  }
  _refreshCore(params) {
    const {
      allowCancelEditing
    } = params ?? {};
    if (this.isRowBasedEditMode()) {
      const hasUpdateChanges = this.getChanges().filter(((it) => "update" === it.type)).length > 0;
      this.init();
      allowCancelEditing && hasUpdateChanges && this._cancelEditDataCore();
    }
    super._refreshCore(params);
  }
  _isEditColumnVisible() {
    const result = super._isEditColumnVisible();
    const editingOptions = this.option("editing");
    const isRowEditMode = this.isRowEditMode();
    const isVisibleInRowEditMode = editingOptions.allowUpdating || editingOptions.allowAdding;
    return result || isRowEditMode && isVisibleInRowEditMode;
  }
  _focusEditorIfNeed() {
    const editMode = this.getEditMode();
    if (this._needFocusEditor) {
      if (MODES_WITH_DELAYED_FOCUS.includes(editMode)) {
        const $editingCell = this.getFocusedCellInRow(this._getVisibleEditRowIndex());
        this._delayedInputFocus($editingCell, (() => {
          $editingCell && this.component.focus($editingCell);
        }));
      }
      this._needFocusEditor = false;
    }
  }
};
var data5 = (Base) => class extends Base {
  _getChangedColumnIndices(oldItem, newItem, rowIndex, isLiveUpdate) {
    if (this._editingController.isRowBasedEditMode() && oldItem.isEditing !== newItem.isEditing) {
      return;
    }
    return super._getChangedColumnIndices.apply(this, arguments);
  }
};
var rowsView4 = (Base) => class extends Base {
  _createRow(row) {
    const $row = super._createRow.apply(this, arguments);
    if (row) {
      const editingController = this._editingController;
      const isEditRow2 = editingController.isEditRow(row.rowIndex);
      if (isEditRow2) {
        $row.addClass(EDIT_ROW);
        $row.removeClass(ROW_SELECTED_CLASS);
        if ("detail" === row.rowType) {
          $row.addClass(this.addWidgetPrefix(EDIT_FORM_CLASS2));
        }
      }
    }
    return $row;
  }
  _update(change) {
    super._update(change);
    if ("updateSelection" === change.changeType) {
      this.getTableElements().children("tbody").children(`.${EDIT_ROW}`).removeClass(ROW_SELECTED_CLASS);
    }
  }
};
var editingRowBasedModule = {
  extenders: {
    controllers: {
      editing: editingControllerExtender,
      data: data5
    },
    views: {
      rowsView: rowsView4
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/editing_row_based.js
m_core_default.registerModule("editingRowBased", editingRowBasedModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/editing/m_editing_form_based.js
var editingControllerExtender2 = (Base) => class extends Base {
  init() {
    this._editForm = null;
    this._updateEditFormDeferred = null;
    super.init();
  }
  isEditRow(rowIndex) {
    return !this.isPopupEditMode() && super.isEditRow(rowIndex);
  }
  isFormOrPopupEditMode() {
    return this.isPopupEditMode() || this.isFormEditMode();
  }
  isFormEditMode() {
    const editMode = this.option("editing.mode");
    return editMode === EDIT_MODE_FORM;
  }
  getFirstEditableColumnIndex() {
    const firstFormItem = this._firstFormItem;
    if (this.isFormEditMode() && firstFormItem) {
      const editRowKey = this.option(EDITING_EDITROWKEY_OPTION_NAME);
      const editRowIndex = this._dataController.getRowIndexByKey(editRowKey);
      const $editFormElements = this._rowsView.getCellElements(editRowIndex);
      return this._rowsView._getEditFormEditorVisibleIndex($editFormElements, firstFormItem.column);
    }
    return super.getFirstEditableColumnIndex();
  }
  getEditFormRowIndex() {
    return this.isFormOrPopupEditMode() ? this._getVisibleEditRowIndex() : super.getEditFormRowIndex();
  }
  _isEditColumnVisible() {
    const result = super._isEditColumnVisible();
    const editingOptions = this.option("editing");
    return this.isFormOrPopupEditMode() ? editingOptions.allowUpdating || result : result;
  }
  _handleDataChanged(args) {
    if (this.isPopupEditMode()) {
      var _args$items, _args$changeTypes;
      const editRowKey = this.option("editing.editRowKey");
      const hasEditRow = null === args || void 0 === args || null === (_args$items = args.items) || void 0 === _args$items ? void 0 : _args$items.some(((item) => equalByValue(item.key, editRowKey)));
      const onlyInsertChanges = (null === (_args$changeTypes = args.changeTypes) || void 0 === _args$changeTypes ? void 0 : _args$changeTypes.length) && args.changeTypes.every(((item) => "insert" === item));
      if (("refresh" === args.changeType || hasEditRow && args.isOptionChanged) && !onlyInsertChanges) {
        this._repaintEditPopup();
      }
    }
    super._handleDataChanged(args);
  }
  getPopupContent() {
    var _this$_editPopup;
    const popupVisible = null === (_this$_editPopup = this._editPopup) || void 0 === _this$_editPopup ? void 0 : _this$_editPopup.option("visible");
    if (this.isPopupEditMode() && popupVisible) {
      return this._$popupContent;
    }
  }
  _showAddedRow(rowIndex) {
    if (this.isPopupEditMode()) {
      this._showEditPopup(rowIndex);
    } else {
      super._showAddedRow(rowIndex);
    }
  }
  _cancelEditDataCore() {
    super._cancelEditDataCore();
    if (this.isPopupEditMode()) {
      this._hideEditPopup();
    }
  }
  _updateEditRowCore(row, skipCurrentRow, isCustomSetCellValue) {
    const editForm = this._editForm;
    if (this.isPopupEditMode()) {
      if (this.option("repaintChangesOnly")) {
        var _row$update;
        null === (_row$update = row.update) || void 0 === _row$update || _row$update.call(row, row);
        this._rowsView.renderDelayedTemplates();
      } else if (editForm) {
        this._updateEditFormDeferred = new Deferred().done((() => editForm.repaint()));
        if (!this._updateLockCount) {
          this._updateEditFormDeferred.resolve();
        }
      }
    } else {
      super._updateEditRowCore(row, skipCurrentRow, isCustomSetCellValue);
    }
  }
  _showEditPopup(rowIndex, repaintForm) {
    const isMobileDevice = "desktop" !== devices_default.current().deviceType;
    const editPopupClass = this.addWidgetPrefix(EDIT_POPUP_CLASS);
    const popupOptions = extend({
      showTitle: false,
      fullScreen: isMobileDevice,
      wrapperAttr: {
        class: editPopupClass
      },
      toolbarItems: [{
        toolbar: "bottom",
        location: "after",
        widget: "dxButton",
        options: this._getSaveButtonConfig()
      }, {
        toolbar: "bottom",
        location: "after",
        widget: "dxButton",
        options: this._getCancelButtonConfig()
      }],
      contentTemplate: this._getPopupEditFormTemplate(rowIndex)
    }, this.option(EDITING_POPUP_OPTION_NAME));
    if (!this._editPopup) {
      const $popupContainer = renderer_default("<div>").appendTo(this.component.$element()).addClass(editPopupClass);
      this._editPopup = this._createComponent($popupContainer, ui_popup_default);
      this._editPopup.on("hiding", this._getEditPopupHiddenHandler());
      this._editPopup.on("shown", ((e) => {
        m_events_engine_default.trigger(e.component.$content().find(FOCUSABLE_ELEMENT_SELECTOR).not(`.${FOCUSABLE_ELEMENT_CLASS}`).first(), "focus");
        if (repaintForm) {
          var _this$_editForm;
          null === (_this$_editForm = this._editForm) || void 0 === _this$_editForm || _this$_editForm.repaint();
        }
      }));
    }
    this._editPopup.option(popupOptions);
    this._editPopup.show();
    super._showEditPopup(rowIndex, repaintForm);
  }
  _getPopupEditFormTemplate(rowIndex) {
    const row = this.component.getVisibleRows()[rowIndex];
    const templateOptions = {
      row,
      values: row.values,
      rowType: row.rowType,
      key: row.key,
      rowIndex
    };
    this._rowsView._addWatchMethod(templateOptions, row);
    return (container) => {
      const formTemplate = this.getEditFormTemplate();
      const scrollable = this._createComponent(renderer_default("<div>").appendTo(container), ui_scrollable_default);
      this._$popupContent = renderer_default(scrollable.content());
      formTemplate(this._$popupContent, templateOptions, {
        isPopupForm: true
      });
      this._rowsView.renderDelayedTemplates();
      renderer_default(container).parent().attr("aria-label", this.localize("dxDataGrid-ariaEditForm"));
    };
  }
  _repaintEditPopup() {
    const rowIndex = this._getVisibleEditRowIndex();
    if (rowIndex >= 0) {
      var _this$_editPopup2, _this$_editPopup3;
      const defaultAnimation = null === (_this$_editPopup2 = this._editPopup) || void 0 === _this$_editPopup2 ? void 0 : _this$_editPopup2.option("animation");
      null === (_this$_editPopup3 = this._editPopup) || void 0 === _this$_editPopup3 || _this$_editPopup3.option("animation", null);
      this._showEditPopup(rowIndex, true);
      if (void 0 !== defaultAnimation) {
        this._editPopup.option("animation", defaultAnimation);
      }
    }
  }
  _hideEditPopup() {
    var _this$_editPopup4;
    null === (_this$_editPopup4 = this._editPopup) || void 0 === _this$_editPopup4 || _this$_editPopup4.option("visible", false);
  }
  optionChanged(args) {
    if ("editing" === args.name && this.isFormOrPopupEditMode()) {
      const {
        fullName
      } = args;
      if (0 === fullName.indexOf(EDITING_FORM_OPTION_NAME)) {
        this._handleFormOptionChange(args);
        args.handled = true;
      } else if (0 === fullName.indexOf(EDITING_POPUP_OPTION_NAME)) {
        this._handlePopupOptionChange(args);
        args.handled = true;
      }
    }
    super.optionChanged(args);
  }
  _handleFormOptionChange(args) {
    var _this$_editPopup5;
    if (this.isFormEditMode()) {
      const editRowIndex = this._getVisibleEditRowIndex();
      if (editRowIndex >= 0) {
        this._dataController.updateItems({
          changeType: "update",
          rowIndices: [editRowIndex]
        });
      }
    } else if (null !== (_this$_editPopup5 = this._editPopup) && void 0 !== _this$_editPopup5 && _this$_editPopup5.option("visible") && 0 === args.fullName.indexOf(EDITING_FORM_OPTION_NAME)) {
      this._repaintEditPopup();
    }
  }
  _handlePopupOptionChange(args) {
    const editPopup = this._editPopup;
    if (editPopup) {
      const popupOptionName = args.fullName.slice(EDITING_POPUP_OPTION_NAME.length + 1);
      if (popupOptionName) {
        editPopup.option(popupOptionName, args.value);
      } else {
        editPopup.option(args.value);
      }
    }
  }
  renderFormEditorTemplate(detailCellOptions, item, formTemplateOptions, container, isReadOnly) {
    const that = this;
    const $container = renderer_default(container);
    const {
      column
    } = item;
    const editorType = getEditorType(item);
    const row = null === detailCellOptions || void 0 === detailCellOptions ? void 0 : detailCellOptions.row;
    const rowData = null === row || void 0 === row ? void 0 : row.data;
    const form = formTemplateOptions.component;
    const value2 = column.calculateCellValue(rowData);
    const displayValue = m_utils_default.getDisplayValue(column, value2, rowData, null === row || void 0 === row ? void 0 : row.rowType);
    const {
      label,
      labelMark,
      labelMode
    } = formTemplateOptions.editorOptions || {};
    const cellOptions = extend({}, detailCellOptions, {
      data: rowData,
      cellElement: null,
      isOnForm: true,
      item,
      id: form.getItemID(item.name || item.dataField),
      column: extend({}, column, {
        editorType,
        editorOptions: extend({
          label,
          labelMark,
          labelMode
        }, column.editorOptions, item.editorOptions)
      }),
      columnIndex: column.index,
      setValue: !isReadOnly && column.allowEditing && function(value3, text) {
        that.updateFieldValue(cellOptions, value3, text);
      }
    });
    cellOptions.value = value2;
    cellOptions.displayValue = displayValue;
    cellOptions.text = !column.command ? m_utils_default.formatValue(displayValue, column) : "";
    const template = this._getFormEditItemTemplate.bind(this)(cellOptions, column);
    this._rowsView.renderTemplate($container, template, cellOptions, !!isElementInDom($container)).done((() => {
      this._rowsView._updateCell($container, cellOptions);
    }));
    return cellOptions;
  }
  getFormEditorTemplate(cellOptions, item) {
    const column = this.component.columnOption(item.name || item.dataField);
    return (options, container) => {
      const $container = renderer_default(container);
      const {
        row
      } = cellOptions;
      if (null !== row && void 0 !== row && row.watch) {
        const dispose = row.watch((() => column.selector(row.data)), (() => {
          var _validator;
          let $editorElement = $container.find(".dx-widget").first();
          let validator = $editorElement.data("dxValidator");
          const validatorOptions = null === (_validator = validator) || void 0 === _validator ? void 0 : _validator.option();
          $container.contents().remove();
          cellOptions = this.renderFormEditorTemplate.bind(this)(cellOptions, item, options, $container);
          $editorElement = $container.find(".dx-widget").first();
          validator = $editorElement.data("dxValidator");
          if (validatorOptions && !validator) {
            $editorElement.dxValidator({
              validationRules: validatorOptions.validationRules,
              validationGroup: validatorOptions.validationGroup,
              dataGetter: validatorOptions.dataGetter
            });
          }
        }));
        m_events_engine_default.on($container, removeEvent, dispose);
      }
      cellOptions = this.renderFormEditorTemplate.bind(this)(cellOptions, item, options, $container);
    };
  }
  getEditFormOptions(detailOptions) {
    var _this$_getValidationG;
    const editFormOptions = null === (_this$_getValidationG = this._getValidationGroupsInForm) || void 0 === _this$_getValidationG ? void 0 : _this$_getValidationG.call(this, detailOptions);
    const userCustomizeItem = this.option("editing.form.customizeItem");
    const editFormItemClass = this.addWidgetPrefix(EDIT_FORM_ITEM_CLASS2);
    let items = this.option("editing.form.items");
    const isCustomEditorType = {};
    if (!items) {
      const columns7 = this._columnsController.getColumns();
      items = [];
      each(columns7, ((_, column) => {
        if (!column.isBand && !column.type) {
          items.push({
            column,
            name: column.name,
            dataField: column.dataField
          });
        }
      }));
    } else {
      forEachFormItems(items, ((item) => {
        const itemId = (null === item || void 0 === item ? void 0 : item.name) || (null === item || void 0 === item ? void 0 : item.dataField);
        if (itemId) {
          isCustomEditorType[itemId] = !!item.editorType;
        }
      }));
    }
    return extend({}, editFormOptions, {
      items,
      formID: `dx-${new guid_default()}`,
      customizeItem: (item) => {
        let column;
        const itemId = item.name || item.dataField;
        if (item.column || itemId) {
          column = item.column || this._columnsController.columnOption(item.name ? `name:${item.name}` : `dataField:${item.dataField}`);
        }
        if (column) {
          item.label = item.label || {};
          item.label.text = item.label.text || column.caption;
          if ("boolean" === column.dataType && void 0 === item.label.visible) {
            const labelMode = this.option("editing.form.labelMode");
            if ("floating" === labelMode || "static" === labelMode) {
              item.label.visible = true;
            }
          }
          item.template = item.template || this.getFormEditorTemplate(detailOptions, item);
          item.column = column;
          item.isCustomEditorType = isCustomEditorType[itemId];
          if (column.formItem) {
            extend(item, column.formItem);
          }
          if (void 0 === item.isRequired && column.validationRules) {
            item.isRequired = column.validationRules.some(((rule) => "required" === rule.type));
            item.validationRules = [];
          }
          const itemVisible = isDefined(item.visible) ? item.visible : true;
          if (!this._firstFormItem && itemVisible) {
            this._firstFormItem = item;
          }
        }
        null === userCustomizeItem || void 0 === userCustomizeItem || userCustomizeItem.call(this, item);
        item.cssClass = isString(item.cssClass) ? `${item.cssClass} ${editFormItemClass}` : editFormItemClass;
      }
    });
  }
  getEditFormTemplate() {
    return ($container, detailOptions, options) => {
      const editFormOptions = this.option(EDITING_FORM_OPTION_NAME);
      const baseEditFormOptions = this.getEditFormOptions(detailOptions);
      const $formContainer = renderer_default("<div>").appendTo($container);
      const isPopupForm = null === options || void 0 === options ? void 0 : options.isPopupForm;
      this._firstFormItem = void 0;
      if (isPopupForm) {
        $formContainer.addClass(this.addWidgetPrefix(EDIT_POPUP_FORM_CLASS));
      }
      this._editForm = this._createComponent($formContainer, form_default, extend({}, editFormOptions, baseEditFormOptions));
      if (!isPopupForm) {
        const $buttonsContainer = renderer_default("<div>").addClass(this.addWidgetPrefix(FORM_BUTTONS_CONTAINER_CLASS)).appendTo($container);
        this._createComponent(renderer_default("<div>").appendTo($buttonsContainer), button_default, this._getSaveButtonConfig());
        this._createComponent(renderer_default("<div>").appendTo($buttonsContainer), button_default, this._getCancelButtonConfig());
      }
      this._editForm.on("contentReady", (() => {
        var _this$_editPopup6;
        this._rowsView.renderDelayedTemplates();
        null === (_this$_editPopup6 = this._editPopup) || void 0 === _this$_editPopup6 || _this$_editPopup6.repaint();
      }));
    };
  }
  getEditForm() {
    return this._editForm;
  }
  _endUpdateCore() {
    var _this$_updateEditForm;
    null === (_this$_updateEditForm = this._updateEditFormDeferred) || void 0 === _this$_updateEditForm || _this$_updateEditForm.resolve();
  }
  _beforeEndSaving(changes) {
    super._beforeEndSaving(changes);
    if (this.isPopupEditMode()) {
      var _this$_editPopup7;
      null === (_this$_editPopup7 = this._editPopup) || void 0 === _this$_editPopup7 || _this$_editPopup7.hide();
    }
  }
  _processDataItemCore(item, change, key, columns7, generateDataValues) {
    const {
      type: type2
    } = change;
    if (this.isPopupEditMode() && type2 === DATA_EDIT_DATA_INSERT_TYPE) {
      item.visible = false;
    }
    super._processDataItemCore(item, change, key, columns7, generateDataValues);
  }
  _editRowFromOptionChangedCore(rowIndices, rowIndex) {
    const isPopupEditMode = this.isPopupEditMode();
    super._editRowFromOptionChangedCore(rowIndices, rowIndex, isPopupEditMode);
    if (isPopupEditMode) {
      this._showEditPopup(rowIndex);
    }
  }
};
var data6 = (Base) => class extends Base {
  _updateEditItem(item) {
    if (this._editingController.isFormEditMode()) {
      item.rowType = "detail";
    }
  }
  _getChangedColumnIndices(oldItem, newItem, visibleRowIndex, isLiveUpdate) {
    if (false === isLiveUpdate && newItem.isEditing && this._editingController.isFormEditMode()) {
      return;
    }
    return super._getChangedColumnIndices.apply(this, arguments);
  }
};
var rowsView5 = (Base) => class extends Base {
  _renderCellContent($cell, options) {
    if ("data" === options.rowType && this._editingController.isPopupEditMode() && false === options.row.visible) {
      return;
    }
    super._renderCellContent.apply(this, arguments);
  }
  getCellElements(rowIndex) {
    const $cellElements = super.getCellElements(rowIndex);
    const editingController = this._editingController;
    const editForm = editingController.getEditForm();
    const editFormRowIndex = editingController.getEditFormRowIndex();
    if (editFormRowIndex === rowIndex && $cellElements && editForm) {
      return editForm.$element().find(`.${this.addWidgetPrefix(EDIT_FORM_ITEM_CLASS2)}, .${BUTTON_CLASS}`);
    }
    return $cellElements;
  }
  _getVisibleColumnIndex($cells, rowIndex, columnIdentifier) {
    const editFormRowIndex = this._editingController.getEditFormRowIndex();
    if (editFormRowIndex === rowIndex && isString(columnIdentifier)) {
      const column = this._columnsController.columnOption(columnIdentifier);
      return this._getEditFormEditorVisibleIndex($cells, column);
    }
    return super._getVisibleColumnIndex.apply(this, arguments);
  }
  _getEditFormEditorVisibleIndex($cells, column) {
    let visibleIndex = -1;
    each($cells, ((index, cellElement) => {
      const item = renderer_default(cellElement).find(".dx-field-item-content").data("dx-form-item");
      if (null !== item && void 0 !== item && item.column && column && item.column.index === column.index) {
        visibleIndex = index;
        return false;
      }
    }));
    return visibleIndex;
  }
  _isFormItem(parameters) {
    const isDetailRow3 = "detail" === parameters.rowType || "detailAdaptive" === parameters.rowType;
    const isPopupEditing = "data" === parameters.rowType && this._editingController.isPopupEditMode();
    return (isDetailRow3 || isPopupEditing) && parameters.item;
  }
  _updateCell($cell, parameters) {
    if (this._isFormItem(parameters)) {
      this._formItemPrepared(parameters, $cell);
    } else {
      super._updateCell($cell, parameters);
    }
  }
  _updateContent() {
    const editingController = this._editingController;
    const oldEditForm = editingController.getEditForm();
    const validationGroup = null === oldEditForm || void 0 === oldEditForm ? void 0 : oldEditForm.option("validationGroup");
    const deferred = super._updateContent.apply(this, arguments);
    return deferred.done((() => {
      const newEditForm = editingController.getEditForm();
      if (validationGroup && newEditForm && newEditForm !== oldEditForm) {
        newEditForm.option("validationGroup", validationGroup);
      }
    }));
  }
};
var editingFormBasedModule = {
  extenders: {
    controllers: {
      editing: editingControllerExtender2,
      data: data6
    },
    views: {
      rowsView: rowsView5
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/editing_form_based.js
m_core_default.registerModule("editingFormBased", editingFormBasedModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/editing/m_editing_cell_based.js
var editingControllerExtender3 = (Base) => class extends Base {
  init() {
    const needCreateHandlers = !this._saveEditorHandler;
    super.init();
    if (needCreateHandlers) {
      let $pointerDownTarget;
      let isResizing;
      this._pointerUpEditorHandler = () => {
        var _this$_columnsResizer;
        isResizing = null === (_this$_columnsResizer = this._columnsResizerController) || void 0 === _this$_columnsResizer ? void 0 : _this$_columnsResizer.isResizing();
      };
      this._pointerDownEditorHandler = (e) => $pointerDownTarget = renderer_default(e.target);
      this._saveEditorHandler = this.createAction((function(e) {
        const {
          event
        } = e;
        const $target = renderer_default(event.target);
        const targetComponent = event[TARGET_COMPONENT_NAME];
        const {
          component
        } = this;
        if (isEditable($pointerDownTarget) && !$pointerDownTarget.is($target)) {
          return;
        }
        function checkEditorPopup($element) {
          if (!$element) {
            return false;
          }
          const $dropDownEditorOverlay = $element.closest(`.${DROPDOWN_EDITOR_OVERLAY_CLASS2}`);
          const $componentElement = component.$element();
          return $dropDownEditorOverlay.length > 0 && 0 === $componentElement.closest($dropDownEditorOverlay).length;
        }
        if (this.isCellOrBatchEditMode() && !this._editCellInProgress) {
          const isEditorPopup = checkEditorPopup($target) || checkEditorPopup(null === targetComponent || void 0 === targetComponent ? void 0 : targetComponent.$element());
          const isAnotherComponent = targetComponent && !targetComponent._disposed && targetComponent !== this.component;
          const isAddRowButton = !!$target.closest(`.${this.addWidgetPrefix(ADD_ROW_BUTTON_CLASS)}`).length;
          const isFocusOverlay = $target.hasClass(this.addWidgetPrefix(FOCUS_OVERLAY_CLASS));
          const isCellEditMode = this.isCellEditMode();
          if (!isResizing && !isEditorPopup && !isFocusOverlay && !(isAddRowButton && isCellEditMode && this.isEditing()) && (isElementInDom($target) || isAnotherComponent)) {
            this._closeEditItem.bind(this)($target);
          }
        }
      }));
      m_events_engine_default.on(dom_adapter_default.getDocument(), m_pointer_default.up, this._pointerUpEditorHandler);
      m_events_engine_default.on(dom_adapter_default.getDocument(), m_pointer_default.down, this._pointerDownEditorHandler);
      m_events_engine_default.on(dom_adapter_default.getDocument(), CLICK_EVENT_NAME, this._saveEditorHandler);
    }
  }
  isCellEditMode() {
    return this.option("editing.mode") === EDIT_MODE_CELL;
  }
  isBatchEditMode() {
    return this.option("editing.mode") === EDIT_MODE_BATCH;
  }
  isCellOrBatchEditMode() {
    return this.isCellEditMode() || this.isBatchEditMode();
  }
  _needToCloseEditableCell($targetElement) {
    const $element = this.component.$element();
    let result = this.isEditing();
    const isCurrentComponentElement = !$element || !!$targetElement.closest($element).length;
    if (isCurrentComponentElement) {
      const isDataRow2 = $targetElement.closest(`.${DATA_ROW_CLASS2}`).length;
      if (isDataRow2) {
        const $targetCell = $targetElement.closest(`.${ROW_CLASS}> td`);
        const rowIndex = this._rowsView.getRowIndex($targetCell.parent());
        const cellElements = this._rowsView.getCellElements(rowIndex);
        if (null !== cellElements && void 0 !== cellElements && cellElements.length) {
          var _visibleColumns$colum;
          const columnIndex = cellElements.index($targetCell);
          const visibleColumns = this._columnsController.getVisibleColumns();
          const allowEditing = null === (_visibleColumns$colum = visibleColumns[columnIndex]) || void 0 === _visibleColumns$colum ? void 0 : _visibleColumns$colum.allowEditing;
          const isEditingCell2 = this.isEditCell(rowIndex, columnIndex);
          result = result && !allowEditing && !isEditingCell2;
        }
      }
    }
    return result || super._needToCloseEditableCell($targetElement);
  }
  _closeEditItem($targetElement) {
    if (this._needToCloseEditableCell($targetElement)) {
      this.closeEditCell();
    }
  }
  _focusEditorIfNeed() {
    if (this._needFocusEditor && this.isCellOrBatchEditMode()) {
      var _this$_rowsView;
      const editColumnIndex = this._getVisibleEditColumnIndex();
      const $cell = null === (_this$_rowsView = this._rowsView) || void 0 === _this$_rowsView ? void 0 : _this$_rowsView._getCellElement(this._getVisibleEditRowIndex(), editColumnIndex);
      this._refocusEditCell = false;
      clearTimeout(this._inputFocusTimeoutID);
      if ($cell && !$cell.find(":focus").length) {
        this._focusEditingCell((() => {
          this._editCellInProgress = false;
        }), $cell, true);
      } else {
        this._editCellInProgress = false;
      }
      this._needFocusEditor = false;
    } else {
      super._focusEditorIfNeed();
    }
  }
  isEditing() {
    if (this.isCellOrBatchEditMode()) {
      const isEditRowKeyDefined = isDefined(this.option(EDITING_EDITROWKEY_OPTION_NAME));
      const isEditColumnNameDefined = isDefined(this.option(EDITING_EDITCOLUMNNAME_OPTION_NAME));
      return isEditRowKeyDefined && isEditColumnNameDefined;
    }
    return super.isEditing();
  }
  _handleEditColumnNameChange(args) {
    const oldRowIndex = this._getVisibleEditRowIndex(args.previousValue);
    if (this.isCellOrBatchEditMode() && -1 !== oldRowIndex && isDefined(args.value) && args.value !== args.previousValue) {
      const columnIndex = this._columnsController.getVisibleColumnIndex(args.value);
      const oldColumnIndex = this._columnsController.getVisibleColumnIndex(args.previousValue);
      this._editCellFromOptionChanged(columnIndex, oldColumnIndex, oldRowIndex);
    }
  }
  _addRow(parentKey) {
    if (this.isCellEditMode() && this.hasChanges()) {
      const deferred = new Deferred();
      this.saveEditData().done((() => {
        if (!this.hasChanges()) {
          this.addRow(parentKey).done(deferred.resolve).fail(deferred.reject);
        } else {
          deferred.reject("cancel");
        }
      }));
      return deferred.promise();
    }
    return super._addRow(parentKey);
  }
  editCell(rowIndex, columnIndex) {
    return this._editCell({
      rowIndex,
      columnIndex
    });
  }
  _editCell(options) {
    const d = new Deferred();
    let coreResult;
    this.executeOperation(d, (() => {
      coreResult = this._editCellCore(options);
      when(coreResult).done(d.resolve).fail(d.reject);
    }));
    return void 0 !== coreResult ? coreResult : d.promise();
  }
  _editCellCore(options) {
    const editCellOptions = this._getNormalizedEditCellOptions(options);
    const {
      columnIndex,
      rowIndex,
      column,
      item
    } = editCellOptions;
    if (void 0 === item.key) {
      this._dataController.fireError("E1043");
      return;
    }
    if (column && ("data" === item.rowType || "detailAdaptive" === item.rowType) && !item.removed && this.isCellOrBatchEditMode()) {
      if (this.isEditCell(rowIndex, columnIndex)) {
        return true;
      }
      return when(this._beforeEditCell(rowIndex, columnIndex, item)).done(((cancel) => {
        if (cancel) {
          return;
        }
        if (!this._prepareEditCell(editCellOptions)) {
          this._processCanceledEditingCell();
        }
      }));
    }
    return false;
  }
  _beforeEditCell(rowIndex, columnIndex, item) {
    if (this.isCellEditMode() && !item.isNewRow && this.hasChanges()) {
      const isSaving = new Deferred();
      this.saveEditData().always((() => {
        isSaving.resolve(this.hasChanges());
      }));
      this.addDeferred(isSaving);
      return isSaving;
    }
    return false;
  }
  publicMethods() {
    const publicMethods = super.publicMethods();
    return publicMethods.concat(["editCell", "closeEditCell"]);
  }
  _getNormalizedEditCellOptions(_ref) {
    let {
      oldColumnIndex,
      oldRowIndex,
      columnIndex,
      rowIndex
    } = _ref;
    const columnsController = this._columnsController;
    const visibleColumns = columnsController.getVisibleColumns();
    const items = this._dataController.items();
    const item = items[rowIndex];
    let oldColumn;
    if (isDefined(oldColumnIndex)) {
      oldColumn = visibleColumns[oldColumnIndex];
    } else {
      oldColumn = this._getEditColumn();
    }
    if (!isDefined(oldRowIndex)) {
      oldRowIndex = this._getVisibleEditRowIndex();
    }
    if (isString(columnIndex)) {
      columnIndex = columnsController.columnOption(columnIndex, "index");
      columnIndex = columnsController.getVisibleIndex(columnIndex);
    }
    const column = visibleColumns[columnIndex];
    return {
      oldColumn,
      columnIndex,
      oldRowIndex,
      rowIndex,
      column,
      item
    };
  }
  _prepareEditCell(_ref2) {
    let {
      item,
      column,
      oldColumn,
      columnIndex,
      oldRowIndex
    } = _ref2;
    const editingStartParams = {
      data: null === item || void 0 === item ? void 0 : item.data,
      cancel: false,
      column,
      key: !item.isNewRow ? item.key : void 0
    };
    if (this._isEditingStart(editingStartParams)) {
      return false;
    }
    this._pageIndex = this._dataController.pageIndex();
    this._setEditRowKey(item.key, true);
    this._setEditColumnNameByIndex(columnIndex, true);
    this._repaintEditCell(column, oldColumn, oldRowIndex);
    if (!column.showEditorAlways) {
      this._addInternalData({
        key: item.key,
        oldData: item.oldData ?? item.data
      });
    }
    return true;
  }
  closeEditCell(isError, withoutSaveEditData) {
    let result = when();
    const oldEditRowIndex = this._getVisibleEditRowIndex();
    if (this.isCellOrBatchEditMode()) {
      const deferred = new Deferred();
      result = new Deferred();
      this.executeOperation(deferred, (() => {
        this._closeEditCellCore(isError, oldEditRowIndex, withoutSaveEditData).always(result.resolve);
      }));
    }
    return result.promise();
  }
  _closeEditCellCore(isError, oldEditRowIndex, withoutSaveEditData) {
    const dataController2 = this._dataController;
    const deferred = new Deferred();
    const promise = deferred.promise();
    if (this.isCellEditMode() && this.hasChanges()) {
      if (!withoutSaveEditData) {
        this.saveEditData().done(((error) => {
          if (!this.hasChanges()) {
            this.closeEditCell(!!error).always(deferred.resolve);
            return;
          }
          deferred.resolve();
        }));
        return promise;
      }
    } else {
      this._resetEditRowKey();
      this._resetEditColumnName();
      if (oldEditRowIndex >= 0) {
        const rowIndices = [oldEditRowIndex];
        this._beforeCloseEditCellInBatchMode(rowIndices);
        if (!isError) {
          dataController2.updateItems({
            changeType: "update",
            rowIndices
          });
        }
      }
    }
    deferred.resolve();
    return promise;
  }
  _resetModifiedClassCells(changes) {
    if (this.isBatchEditMode()) {
      const columnsCount = this._columnsController.getVisibleColumns().length;
      changes.forEach(((_ref3) => {
        let {
          key
        } = _ref3;
        const rowIndex = this._dataController.getRowIndexByKey(key);
        for (let columnIndex = 0; columnIndex < columnsCount; columnIndex++) {
          const cellElement = this._rowsView._getCellElement(rowIndex, columnIndex);
          null === cellElement || void 0 === cellElement || cellElement.removeClass(CELL_MODIFIED_CLASS);
        }
      }));
    }
  }
  _prepareChange(options, value2, text) {
    const $cellElement = renderer_default(options.cellElement);
    if (this.isBatchEditMode() && void 0 !== options.key) {
      this._applyModified($cellElement, options);
    }
    return super._prepareChange(options, value2, text);
  }
  _cancelSaving(result) {
    const dataController2 = this._dataController;
    if (this.isCellOrBatchEditMode()) {
      if (this.isBatchEditMode()) {
        this._resetEditIndices();
      }
      dataController2.updateItems();
    }
    super._cancelSaving(result);
  }
  optionChanged(args) {
    const {
      fullName
    } = args;
    if ("editing" === args.name && fullName === EDITING_EDITCOLUMNNAME_OPTION_NAME) {
      this._handleEditColumnNameChange(args);
      args.handled = true;
    } else {
      super.optionChanged(args);
    }
  }
  _editCellFromOptionChanged(columnIndex, oldColumnIndex, oldRowIndex) {
    const columns7 = this._columnsController.getVisibleColumns();
    if (columnIndex > -1) {
      deferRender((() => {
        this._repaintEditCell(columns7[columnIndex], columns7[oldColumnIndex], oldRowIndex);
      }));
    }
  }
  _handleEditRowKeyChange(args) {
    if (this.isCellOrBatchEditMode()) {
      const columnIndex = this._getVisibleEditColumnIndex();
      const oldRowIndexCorrection = this._getEditRowIndexCorrection();
      const oldRowIndex = this._dataController.getRowIndexByKey(args.previousValue) + oldRowIndexCorrection;
      if (isDefined(args.value) && args.value !== args.previousValue) {
        var _this$_editCellFromOp;
        null === (_this$_editCellFromOp = this._editCellFromOptionChanged) || void 0 === _this$_editCellFromOp || _this$_editCellFromOp.call(this, columnIndex, columnIndex, oldRowIndex);
      }
    } else {
      super._handleEditRowKeyChange(args);
    }
  }
  deleteRow(rowIndex) {
    if (this.isCellEditMode() && this.isEditing()) {
      const {
        isNewRow
      } = this._dataController.items()[rowIndex];
      const rowKey = this._dataController.getKeyByRowIndex(rowIndex);
      this.closeEditCell(null, isNewRow).always((() => {
        rowIndex = this._dataController.getRowIndexByKey(rowKey);
        this._checkAndDeleteRow(rowIndex);
      }));
    } else {
      super.deleteRow(rowIndex);
    }
  }
  _checkAndDeleteRow(rowIndex) {
    if (this.isBatchEditMode()) {
      this._deleteRowCore(rowIndex);
    } else {
      super._checkAndDeleteRow(rowIndex);
    }
  }
  _refreshCore(params) {
    const {
      isPageChanged
    } = params ?? {};
    const needResetIndexes = this.isBatchEditMode() || isPageChanged && "virtual" !== this.option("scrolling.mode");
    if (this.isCellOrBatchEditMode()) {
      if (needResetIndexes) {
        this._resetEditColumnName();
        this._resetEditRowKey();
      }
    } else {
      super._refreshCore(params);
    }
  }
  _allowRowAdding(params) {
    if (this.isBatchEditMode()) {
      return true;
    }
    return super._allowRowAdding(params);
  }
  _afterDeleteRow(rowIndex, oldEditRowIndex) {
    const dataController2 = this._dataController;
    if (this.isBatchEditMode()) {
      dataController2.updateItems({
        changeType: "update",
        rowIndices: [oldEditRowIndex, rowIndex]
      });
      return new Deferred().resolve();
    }
    return super._afterDeleteRow(rowIndex, oldEditRowIndex);
  }
  _updateEditRow(row, forceUpdateRow, isCustomSetCellValue) {
    if (this.isCellOrBatchEditMode()) {
      this._updateRowImmediately(row, forceUpdateRow, isCustomSetCellValue);
    } else {
      super._updateEditRow(row, forceUpdateRow, isCustomSetCellValue);
    }
  }
  _isDefaultButtonVisible(button, options) {
    if (this.isCellOrBatchEditMode()) {
      const isBatchMode = this.isBatchEditMode();
      switch (button.name) {
        case "save":
        case "cancel":
        case "edit":
          return false;
        case "delete":
          return super._isDefaultButtonVisible(button, options) && (!isBatchMode || !options.row.removed);
        case "undelete":
          return isBatchMode && this.allowDeleting(options) && options.row.removed;
        default:
          return super._isDefaultButtonVisible(button, options);
      }
    }
    return super._isDefaultButtonVisible(button, options);
  }
  _isRowDeleteAllowed() {
    const callBaseResult = super._isRowDeleteAllowed();
    return callBaseResult || this.isBatchEditMode();
  }
  _beforeEndSaving(changes) {
    if (this.isCellEditMode()) {
      var _changes$;
      if ("update" !== (null === (_changes$ = changes[0]) || void 0 === _changes$ ? void 0 : _changes$.type)) {
        super._beforeEndSaving(changes);
      }
    } else {
      if (this.isBatchEditMode()) {
        this._resetModifiedClassCells(changes);
      }
      super._beforeEndSaving(changes);
    }
  }
  prepareEditButtons(headerPanel8) {
    const editingOptions = this.option("editing") ?? {};
    const buttonItems = super.prepareEditButtons(headerPanel8);
    const needEditingButtons = editingOptions.allowUpdating || editingOptions.allowAdding || editingOptions.allowDeleting;
    if (needEditingButtons && this.isBatchEditMode()) {
      buttonItems.push(this.prepareButtonItem(headerPanel8, "save", "saveEditData", 21));
      buttonItems.push(this.prepareButtonItem(headerPanel8, "revert", "cancelEditData", 22));
    }
    return buttonItems;
  }
  _saveEditDataInner() {
    var _deferred;
    const editRow = this._dataController.getVisibleRows()[this.getEditRowIndex()];
    const editColumn = this._getEditColumn();
    const showEditorAlways = null === editColumn || void 0 === editColumn ? void 0 : editColumn.showEditorAlways;
    const isUpdateInCellMode = this.isCellEditMode() && !(null !== editRow && void 0 !== editRow && editRow.isNewRow);
    let deferred;
    if (isUpdateInCellMode && showEditorAlways) {
      deferred = new Deferred();
      this.addDeferred(deferred);
    }
    return super._saveEditDataInner().always(null === (_deferred = deferred) || void 0 === _deferred ? void 0 : _deferred.resolve);
  }
  _applyChange(options, params, forceUpdateRow) {
    const isUpdateInCellMode = this.isCellEditMode() && options.row && !options.row.isNewRow;
    const {
      showEditorAlways
    } = options.column;
    const isCustomSetCellValue = options.column.setCellValue !== options.column.defaultSetCellValue;
    const focusPreviousEditingCell = showEditorAlways && !forceUpdateRow && isUpdateInCellMode && this.hasEditData() && !this.isEditCell(options.rowIndex, options.columnIndex);
    if (focusPreviousEditingCell) {
      this._focusEditingCell();
      this._updateEditRow(options.row, true, isCustomSetCellValue);
      return;
    }
    return super._applyChange(options, params, forceUpdateRow);
  }
  _applyChangeCore(options, forceUpdateRow) {
    const {
      showEditorAlways
    } = options.column;
    const isUpdateInCellMode = this.isCellEditMode() && options.row && !options.row.isNewRow;
    if (showEditorAlways && !forceUpdateRow) {
      if (isUpdateInCellMode) {
        this._setEditRowKey(options.row.key, true);
        this._setEditColumnNameByIndex(options.columnIndex, true);
        return this.saveEditData();
      }
      if (this.isBatchEditMode()) {
        forceUpdateRow = this._needUpdateRow(options.column);
        return super._applyChangeCore(options, forceUpdateRow);
      }
    }
    return super._applyChangeCore(options, forceUpdateRow);
  }
  _processDataItemCore(item, change, key, columns7, generateDataValues) {
    const {
      data: data17,
      type: type2
    } = change;
    if (this.isBatchEditMode() && type2 === DATA_EDIT_DATA_REMOVE_TYPE) {
      item.data = createObjectWithChanges(item.data, data17);
    }
    super._processDataItemCore(item, change, key, columns7, generateDataValues);
  }
  _processRemoveCore(changes, editIndex, processIfBatch) {
    if (this.isBatchEditMode() && !processIfBatch) {
      return;
    }
    return super._processRemoveCore(changes, editIndex, processIfBatch);
  }
  _processRemoveIfError(changes, editIndex) {
    if (this.isBatchEditMode()) {
      return;
    }
    return super._processRemoveIfError(changes, editIndex);
  }
  _beforeFocusElementInRow(rowIndex) {
    super._beforeFocusElementInRow(rowIndex);
    const editRowIndex = rowIndex >= 0 ? rowIndex : 0;
    const columnIndex = this.getFirstEditableColumnIndex();
    columnIndex >= 0 && this.editCell(editRowIndex, columnIndex);
  }
};
var rowsView6 = (Base) => class extends Base {
  _createTable() {
    const $table = super._createTable.apply(this, arguments);
    const editingController = this._editingController;
    if (editingController.isCellOrBatchEditMode() && this.option("editing.allowUpdating")) {
      m_events_engine_default.on($table, addNamespace(m_hold_default.name, "dxDataGridRowsView"), `td:not(.${EDITOR_CELL_CLASS})`, this.createAction((() => {
        if (editingController.isEditing()) {
          editingController.closeEditCell();
        }
      })));
    }
    return $table;
  }
  _createRow(row) {
    const $row = super._createRow.apply(this, arguments);
    if (row) {
      const editingController = this._editingController;
      const isRowRemoved = !!row.removed;
      if (editingController.isBatchEditMode()) {
        isRowRemoved && $row.addClass(ROW_REMOVED);
      }
    }
    return $row;
  }
};
var editingCellBasedModule = {
  extenders: {
    controllers: {
      editing: editingControllerExtender3
    },
    views: {
      rowsView: rowsView6
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/editing_cell_based.js
m_core_default.registerModule("editingCellBased", editingCellBasedModule);

// node_modules/devextreme/esm/ui/validator.js
var validator_default = m_validator_default;

// node_modules/devextreme/esm/__internal/grids/grid_core/validating/m_validating.js
var INSERT_INDEX2 = "__DX_INSERT_INDEX__";
var EDIT_MODE_ROW2 = "row";
var EDIT_MODE_BATCH2 = "batch";
var EDIT_MODE_CELL2 = "cell";
var FORM_BASED_MODES = ["popup", "form"];
var VALIDATION_STATUS = {
  valid: "valid",
  invalid: "invalid",
  pending: "pending"
};
var validationResultIsValid = function(result) {
  return isDefined(result) && "cancel" !== result;
};
var cellValueShouldBeValidated = function(value2, rowOptions) {
  return void 0 !== value2 || void 0 === value2 && rowOptions && !rowOptions.isNewRow;
};
var ValidatingController = class extends m_modules_default.Controller {
  constructor() {
    super(...arguments);
    this._isValidationInProgress = false;
    this._disableApplyValidationResults = false;
  }
  init() {
    this._editingController = this.getController("editing");
    this._editorFactoryController = this.getController("editorFactory");
    this._columnsController = this.getController("columns");
    this.createAction("onRowValidating");
    if (!this._validationState) {
      this.initValidationState();
    }
  }
  initValidationState() {
    this._validationState = [];
    this._validationStateCache = {};
  }
  _rowIsValidated(change) {
    const validationData = this._getValidationData(null === change || void 0 === change ? void 0 : change.key);
    return !!validationData && !!validationData.validated;
  }
  _getValidationData(key, create) {
    const keyHash = getKeyHash(key);
    const isObjectKeyHash = isObject(keyHash);
    let validationData;
    if (isObjectKeyHash) {
      validationData = this._validationState.filter(((data17) => equalByValue(data17.key, key)))[0];
    } else {
      validationData = this._validationStateCache[keyHash];
    }
    if (!validationData && create) {
      validationData = {
        key,
        isValid: true
      };
      this._validationState.push(validationData);
      if (!isObjectKeyHash) {
        this._validationStateCache[keyHash] = validationData;
      }
    }
    return validationData;
  }
  _getBrokenRules(validationData, validationResults) {
    let brokenRules;
    if (validationResults) {
      brokenRules = validationResults.brokenRules || validationResults.brokenRule && [validationResults.brokenRule];
    } else {
      brokenRules = validationData.brokenRules || [];
    }
    return brokenRules;
  }
  _rowValidating(validationData, validationResults) {
    const deferred = new Deferred();
    const change = this._editingController.getChangeByKey(null === validationData || void 0 === validationData ? void 0 : validationData.key);
    const brokenRules = this._getBrokenRules(validationData, validationResults);
    const isValid = validationResults ? validationResults.isValid : validationData.isValid;
    const parameters = {
      brokenRules,
      isValid,
      key: change.key,
      newData: change.data,
      oldData: this._editingController._getOldData(change.key),
      promise: null,
      errorText: this.getHiddenValidatorsErrorText(brokenRules)
    };
    this.executeAction("onRowValidating", parameters);
    when(fromPromise(parameters.promise)).always((() => {
      validationData.isValid = parameters.isValid;
      validationData.errorText = parameters.errorText;
      deferred.resolve(parameters);
    }));
    return deferred.promise();
  }
  getHiddenValidatorsErrorText(brokenRules) {
    const brokenRulesMessages = [];
    each(brokenRules, ((_, brokenRule) => {
      const {
        column
      } = brokenRule;
      const isGroupExpandColumn = column && void 0 !== column.groupIndex && !column.showWhenGrouped;
      const isVisibleColumn2 = column && column.visible;
      if (!brokenRule.validator.$element().parent().length && (!isVisibleColumn2 || isGroupExpandColumn)) {
        brokenRulesMessages.push(brokenRule.message);
      }
    }));
    return brokenRulesMessages.join(", ");
  }
  validate(isFull) {
    let isValid = true;
    const editingController = this._editingController;
    const deferred = new Deferred();
    const completeList = [];
    const editMode = editingController.getEditMode();
    isFull = isFull || editMode === EDIT_MODE_ROW2;
    if (this._isValidationInProgress) {
      return deferred.resolve(false).promise();
    }
    this._isValidationInProgress = true;
    if (isFull) {
      editingController.addDeferred(deferred);
      const changes = editingController.getChanges();
      each(changes, ((index, _ref) => {
        let {
          type: type2,
          key
        } = _ref;
        if ("remove" !== type2) {
          const validationData = this._getValidationData(key, true);
          const validationResult = this.validateGroup(validationData);
          completeList.push(validationResult);
          validationResult.done(((validationResult2) => {
            validationData.validated = true;
            isValid = isValid && validationResult2.isValid;
          }));
        }
      }));
    } else if (this._currentCellValidator) {
      const validationResult = this.validateGroup(this._currentCellValidator._findGroup());
      completeList.push(validationResult);
      validationResult.done(((validationResult2) => {
        isValid = validationResult2.isValid;
      }));
    }
    when(...completeList).done((() => {
      this._isValidationInProgress = false;
      deferred.resolve(isValid);
    }));
    return deferred.promise();
  }
  validateGroup(validationData) {
    var _validationResult;
    const result = new Deferred();
    const validateGroup = validationData && validation_engine_default.getGroupConfig(validationData);
    let validationResult;
    if (null !== validateGroup && void 0 !== validateGroup && validateGroup.validators.length) {
      this.resetRowValidationResults(validationData);
      validationResult = validation_engine_default.validateGroup(validationData);
    }
    when((null === (_validationResult = validationResult) || void 0 === _validationResult ? void 0 : _validationResult.complete) || validationResult).done(((validationResult2) => {
      when(this._rowValidating(validationData, validationResult2)).done(result.resolve);
    }));
    return result.promise();
  }
  isRowDataModified(change) {
    return !isEmptyObject(change.data);
  }
  updateValidationState(change) {
    const editMode = this._editingController.getEditMode();
    const {
      key
    } = change;
    const validationData = this._getValidationData(key, true);
    if (!FORM_BASED_MODES.includes(editMode)) {
      if ("insert" === change.type && !this.isRowDataModified(change)) {
        validationData.isValid = true;
        return;
      }
      this.setDisableApplyValidationResults(true);
      const groupConfig = validation_engine_default.getGroupConfig(validationData);
      if (groupConfig) {
        const validationResult = validation_engine_default.validateGroup(validationData);
        when(validationResult.complete || validationResult).done(((validationResult2) => {
          validationData.isValid = validationResult2.isValid;
          validationData.brokenRules = validationResult2.brokenRules;
        }));
      } else if (!validationData.brokenRules || !validationData.brokenRules.length) {
        validationData.isValid = true;
      }
      this.setDisableApplyValidationResults(false);
    } else {
      validationData.isValid = true;
    }
  }
  setValidator(validator) {
    this._currentCellValidator = validator;
  }
  renderCellPendingIndicator($container) {
    let $indicator = $container.find(".dx-pending-indicator");
    if (!$indicator.length) {
      const $indicatorContainer = $container;
      $indicator = renderer_default("<div>").appendTo($indicatorContainer).addClass("dx-pending-indicator");
      this._createComponent($indicator, load_indicator_default);
      $container.addClass("dx-validation-pending");
    }
  }
  disposeCellPendingIndicator($container) {
    const $indicator = $container.find(".dx-pending-indicator");
    if ($indicator.length) {
      const indicator = load_indicator_default.getInstance($indicator);
      if (indicator) {
        indicator.dispose();
        indicator.$element().remove();
      }
      $container.removeClass("dx-validation-pending");
    }
  }
  validationStatusChanged(result) {
    const {
      validator
    } = result;
    const validationGroup = validator.option("validationGroup");
    const {
      column
    } = validator.option("dataGetter")();
    this.updateCellValidationResult({
      rowKey: validationGroup.key,
      columnIndex: column.index,
      validationResult: result
    });
  }
  validatorInitialized(arg) {
    arg.component.on("validating", this.validationStatusChanged.bind(this));
    arg.component.on("validated", this.validationStatusChanged.bind(this));
  }
  validatorDisposing(arg) {
    const validator = arg.component;
    const validationGroup = validator.option("validationGroup");
    const {
      column
    } = validator.option("dataGetter")();
    const result = this.getCellValidationResult({
      rowKey: null === validationGroup || void 0 === validationGroup ? void 0 : validationGroup.key,
      columnIndex: column.index
    });
    if (validationResultIsValid(result) && result.status === VALIDATION_STATUS.pending) {
      this.cancelCellValidationResult({
        change: validationGroup,
        columnIndex: column.index
      });
    }
  }
  applyValidationResult($container, result) {
    const {
      validator
    } = result;
    const validationGroup = validator.option("validationGroup");
    const {
      column
    } = validator.option("dataGetter")();
    result.brokenRules && result.brokenRules.forEach(((rule) => {
      rule.columnIndex = column.index;
      rule.column = column;
    }));
    if ($container) {
      const validationResult = this.getCellValidationResult({
        rowKey: validationGroup.key,
        columnIndex: column.index
      });
      const requestIsDisabled = validationResultIsValid(validationResult) && validationResult.disabledPendingId === result.id;
      if (this._disableApplyValidationResults || requestIsDisabled) {
        return;
      }
      if (result.status === VALIDATION_STATUS.invalid) {
        const $focus = $container.find(":focus");
        if (!focused($focus)) {
          m_events_engine_default.trigger($focus, "focus");
          m_events_engine_default.trigger($focus, m_pointer_default.down);
        }
      }
      const editor = !column.editCellTemplate && this._editorFactoryController.getEditorInstance($container);
      if (result.status === VALIDATION_STATUS.pending) {
        if (editor) {
          editor.option("validationStatus", VALIDATION_STATUS.pending);
        } else {
          this.renderCellPendingIndicator($container);
        }
      } else if (editor) {
        editor.option("validationStatus", VALIDATION_STATUS.valid);
      } else {
        this.disposeCellPendingIndicator($container);
      }
      $container.toggleClass(this.addWidgetPrefix("invalid"), result.status === VALIDATION_STATUS.invalid);
    }
  }
  _syncInternalEditingData(parameters) {
    var _parameters$row;
    const editingController = this._editingController;
    const change = editingController.getChangeByKey(parameters.key);
    const oldDataFromState = editingController._getOldData(parameters.key);
    const oldData = null === (_parameters$row = parameters.row) || void 0 === _parameters$row ? void 0 : _parameters$row.oldData;
    if (change && oldData && !oldDataFromState) {
      editingController._addInternalData({
        key: parameters.key,
        oldData
      });
    }
  }
  createValidator(parameters, $container) {
    const editingController = this._editingController;
    const {
      column
    } = parameters;
    let {
      showEditorAlways
    } = column;
    if (isDefined(column.command) || !column.validationRules || !Array.isArray(column.validationRules) || !column.validationRules.length) {
      return;
    }
    const editIndex = editingController.getIndexByKey(parameters.key, editingController.getChanges());
    let needCreateValidator = editIndex > -1;
    if (!needCreateValidator) {
      if (!showEditorAlways) {
        var _this$_columnsControl;
        const visibleColumns = (null === (_this$_columnsControl = this._columnsController) || void 0 === _this$_columnsControl ? void 0 : _this$_columnsControl.getVisibleColumns()) || [];
        showEditorAlways = visibleColumns.some(((column2) => column2.showEditorAlways));
      }
      const isEditRow2 = equalByValue(this.option("editing.editRowKey"), parameters.key);
      const isCellOrBatchEditingAllowed = editingController.isCellOrBatchEditMode() && editingController.allowUpdating({
        row: parameters.row
      });
      needCreateValidator = isEditRow2 || isCellOrBatchEditingAllowed && showEditorAlways;
      if (isCellOrBatchEditingAllowed && showEditorAlways) {
        var _parameters$row2;
        editingController._addInternalData({
          key: parameters.key,
          oldData: (null === (_parameters$row2 = parameters.row) || void 0 === _parameters$row2 ? void 0 : _parameters$row2.oldData) ?? parameters.data
        });
      }
    }
    if (needCreateValidator) {
      if ($container && !$container.length) {
        ui_errors_default.log("E1050");
        return;
      }
      this._syncInternalEditingData(parameters);
      const validationData = this._getValidationData(parameters.key, true);
      const getValue = () => {
        const change = editingController.getChangeByKey(null === validationData || void 0 === validationData ? void 0 : validationData.key);
        const value2 = column.calculateCellValue((null === change || void 0 === change ? void 0 : change.data) || {});
        return void 0 !== value2 ? value2 : parameters.value;
      };
      const useDefaultValidator = $container && $container.hasClass("dx-widget");
      $container && $container.addClass(this.addWidgetPrefix("validator"));
      const validator = new validator_default($container || renderer_default("<div>"), {
        name: column.caption,
        validationRules: extend(true, [], column.validationRules),
        validationGroup: validationData,
        adapter: useDefaultValidator ? null : {
          getValue,
          applyValidationResults: (result) => {
            this.applyValidationResult($container, result);
          }
        },
        dataGetter() {
          const key = null === validationData || void 0 === validationData ? void 0 : validationData.key;
          const change = editingController.getChangeByKey(key);
          const oldData = editingController._getOldData(key);
          return {
            data: createObjectWithChanges(oldData, null === change || void 0 === change ? void 0 : change.data),
            column
          };
        },
        onInitialized: this.validatorInitialized.bind(this),
        onDisposing: this.validatorDisposing.bind(this)
      });
      if (useDefaultValidator) {
        const adapter = validator.option("adapter");
        if (adapter) {
          const originBypass = adapter.bypass;
          const defaultAdapterBypass = () => parameters.row.isNewRow && !this._isValidationInProgress && !editingController.isCellModified(parameters);
          adapter.getValue = getValue;
          adapter.validationRequestsCallbacks = [];
          adapter.bypass = () => originBypass.call(adapter) || defaultAdapterBypass();
        }
      }
      return validator;
    }
    return;
  }
  setDisableApplyValidationResults(flag) {
    this._disableApplyValidationResults = flag;
  }
  getDisableApplyValidationResults() {
    return this._disableApplyValidationResults;
  }
  isCurrentValidatorProcessing(_ref2) {
    let {
      rowKey,
      columnIndex
    } = _ref2;
    return this._currentCellValidator && equalByValue(this._currentCellValidator.option("validationGroup").key, rowKey) && this._currentCellValidator.option("dataGetter")().column.index === columnIndex;
  }
  validateCell(validator) {
    const cellParams = {
      rowKey: validator.option("validationGroup").key,
      columnIndex: validator.option("dataGetter")().column.index,
      validationResult: null
    };
    let validationResult = this.getCellValidationResult(cellParams);
    const stateRestored = validationResultIsValid(validationResult);
    const adapter = validator.option("adapter");
    if (!stateRestored) {
      validationResult = validator.validate();
    } else {
      const currentCellValue = adapter.getValue();
      if (!equalByValue(currentCellValue, validationResult.value)) {
        validationResult = validator.validate();
      }
    }
    const deferred = new Deferred();
    if (stateRestored && validationResult.status === VALIDATION_STATUS.pending) {
      this.updateCellValidationResult(cellParams);
      adapter.applyValidationResults(validationResult);
    }
    when(validationResult.complete || validationResult).done(((validationResult2) => {
      stateRestored && adapter.applyValidationResults(validationResult2);
      deferred.resolve(validationResult2);
    }));
    return deferred.promise();
  }
  updateCellValidationResult(_ref3) {
    let {
      rowKey,
      columnIndex,
      validationResult
    } = _ref3;
    const validationData = this._getValidationData(rowKey);
    if (!validationData) {
      return;
    }
    if (!validationData.validationResults) {
      validationData.validationResults = {};
    }
    let result;
    if (validationResult) {
      result = extend({}, validationResult);
      validationData.validationResults[columnIndex] = result;
      if (validationResult.status === VALIDATION_STATUS.pending) {
        if (this._editingController.getEditMode() === EDIT_MODE_CELL2) {
          result.deferred = new Deferred();
          result.complete.always((() => {
            result.deferred.resolve();
          }));
          this._editingController.addDeferred(result.deferred);
        }
        if (this._disableApplyValidationResults) {
          result.disabledPendingId = validationResult.id;
          return;
        }
      }
    } else {
      result = validationData.validationResults[columnIndex];
    }
    if (result && result.disabledPendingId) {
      delete result.disabledPendingId;
    }
  }
  getCellValidationResult(_ref4) {
    var _validationData$valid;
    let {
      rowKey,
      columnIndex
    } = _ref4;
    const validationData = this._getValidationData(rowKey, true);
    return null === validationData || void 0 === validationData || null === (_validationData$valid = validationData.validationResults) || void 0 === _validationData$valid ? void 0 : _validationData$valid[columnIndex];
  }
  removeCellValidationResult(_ref5) {
    let {
      change,
      columnIndex
    } = _ref5;
    const validationData = this._getValidationData(null === change || void 0 === change ? void 0 : change.key);
    if (validationData && validationData.validationResults) {
      this.cancelCellValidationResult({
        change,
        columnIndex
      });
      delete validationData.validationResults[columnIndex];
    }
  }
  cancelCellValidationResult(_ref6) {
    let {
      change,
      columnIndex
    } = _ref6;
    const validationData = this._getValidationData(change.key);
    if (change && validationData.validationResults) {
      const result = validationData.validationResults[columnIndex];
      if (result) {
        result.deferred && result.deferred.reject("cancel");
        validationData.validationResults[columnIndex] = "cancel";
      }
    }
  }
  resetRowValidationResults(validationData) {
    if (validationData) {
      validationData.validationResults && delete validationData.validationResults;
      delete validationData.validated;
    }
  }
  isInvalidCell(_ref7) {
    let {
      rowKey,
      columnIndex
    } = _ref7;
    const result = this.getCellValidationResult({
      rowKey,
      columnIndex
    });
    return validationResultIsValid(result) && result.status === VALIDATION_STATUS.invalid;
  }
  getCellValidator(_ref8) {
    let {
      rowKey,
      columnIndex
    } = _ref8;
    const validationData = this._getValidationData(rowKey);
    const groupConfig = validationData && validation_engine_default.getGroupConfig(validationData);
    const validators = groupConfig && groupConfig.validators;
    return validators && validators.filter(((v) => {
      const {
        column
      } = v.option("dataGetter")();
      return column ? column.index === columnIndex : false;
    }))[0];
  }
  setCellValidationStatus(cellOptions) {
    const validationResult = this.getCellValidationResult({
      rowKey: cellOptions.key,
      columnIndex: cellOptions.column.index
    });
    if (isDefined(validationResult)) {
      cellOptions.validationStatus = "cancel" !== validationResult ? validationResult.status : "cancel";
    } else {
      delete cellOptions.validationStatus;
    }
  }
};
var validatingEditingExtender = (Base) => class extends Base {
  processDataItemTreeListHack(item) {
    super.processDataItem.apply(this, arguments);
  }
  processItemsTreeListHack(items, e) {
    return super.processItems.apply(this, arguments);
  }
  _addChange(changeParams) {
    const change = super._addChange.apply(this, arguments);
    if (change && "remove" !== changeParams.type) {
      this._validatingController.updateValidationState(change);
    }
    return change;
  }
  _handleChangesChange(args) {
    super._handleChangesChange.apply(this, arguments);
    args.value.forEach(((change) => {
      if (void 0 === this._validatingController._getValidationData(change.key)) {
        this._validatingController.updateValidationState(change);
      }
    }));
  }
  _updateRowAndPageIndices() {
    const that = this;
    const startInsertIndex = that.getView("rowsView").getTopVisibleItemIndex();
    let rowIndex = startInsertIndex;
    each(that.getChanges(), ((_, _ref9) => {
      let {
        key,
        type: type2
      } = _ref9;
      const validationData = this._validatingController._getValidationData(key);
      if (validationData && !validationData.isValid && validationData.pageIndex !== that._pageIndex) {
        validationData.pageIndex = that._pageIndex;
        if ("insert" === type2) {
          validationData.rowIndex = startInsertIndex;
        } else {
          validationData.rowIndex = rowIndex;
        }
        rowIndex++;
      }
    }));
  }
  _getValidationGroupsInForm(detailOptions) {
    const validationData = this._validatingController._getValidationData(detailOptions.key, true);
    return {
      validationGroup: validationData
    };
  }
  _validateEditFormAfterUpdate(row, isCustomSetCellValue) {
    if (isCustomSetCellValue && this._editForm) {
      this._editForm.validate();
    }
    super._validateEditFormAfterUpdate.apply(this, arguments);
  }
  _prepareEditCell(parameters) {
    const {
      column,
      item
    } = parameters;
    const isNotCanceled = super._prepareEditCell(parameters);
    const key = !item.isNewRow ? item.key : void 0;
    if (isNotCanceled && column.showEditorAlways) {
      this._validatingController.updateValidationState({
        key
      });
    }
    return isNotCanceled;
  }
  processItems(items, changeType) {
    const changes = this.getChanges();
    const getIndexByChange = (change, items2) => {
      let index = -1;
      const isInsert = "insert" === change.type;
      const {
        key
      } = change;
      each(items2, ((i, item) => {
        if (equalByValue(key, isInsert ? item.key : this._dataController.keyOf(item))) {
          index = i;
          return false;
        }
        return;
      }));
      return index;
    };
    items = super.processItems(items, changeType);
    const itemsCount = items.length;
    if (this.getEditMode() === EDIT_MODE_BATCH2 && "prepend" !== changeType && "append" !== changeType) {
      changes.forEach(((change) => {
        const {
          key
        } = change;
        const validationData = this._validatingController._getValidationData(key);
        if (validationData && change.type && validationData.pageIndex === this._pageIndex && (null === change || void 0 === change ? void 0 : change.pageIndex) !== this._pageIndex) {
          !(function(change2, validationData2) {
            const data17 = {
              key: change2.key
            };
            const index = getIndexByChange(change2, items);
            if (index >= 0) {
              return;
            }
            validationData2.rowIndex = validationData2.rowIndex > itemsCount ? validationData2.rowIndex % itemsCount : validationData2.rowIndex;
            const {
              rowIndex
            } = validationData2;
            data17[INSERT_INDEX2] = 1;
            items.splice(rowIndex, 0, data17);
          })(change, validationData);
        }
      }));
    }
    return items;
  }
  processDataItem(item) {
    const isInserted = item.data[INSERT_INDEX2];
    const key = isInserted ? item.data.key : item.key;
    const editMode = this.getEditMode();
    if (editMode === EDIT_MODE_BATCH2 && isInserted && key) {
      const changes = this.getChanges();
      const editIndex = m_utils_default.getIndexByKey(key, changes);
      if (editIndex >= 0) {
        const change = changes[editIndex];
        if ("insert" !== change.type) {
          const oldData = this._getOldData(change.key);
          item.data = extend(true, {}, oldData, change.data);
          item.key = key;
        }
      }
    }
    super.processDataItem.apply(this, arguments);
  }
  _createInvisibleColumnValidators(changes) {
    const that = this;
    const columns7 = this._columnsController.getColumns();
    const invisibleColumns = this._columnsController.getInvisibleColumns().filter(((column) => !column.isBand));
    const groupColumns = this._columnsController.getGroupColumns().filter(((column) => !column.showWhenGrouped && -1 === invisibleColumns.indexOf(column)));
    const invisibleColumnValidators = [];
    const isCellVisible = (column, rowKey) => this._dataController.getRowIndexByKey(rowKey) >= 0 && invisibleColumns.indexOf(column) < 0;
    invisibleColumns.push(...groupColumns);
    if (!FORM_BASED_MODES.includes(this.getEditMode())) {
      each(columns7, ((_, column) => {
        changes.forEach(((change) => {
          let data17;
          if (isCellVisible(column, change.key)) {
            return;
          }
          if ("insert" === change.type) {
            data17 = change.data;
          } else if ("update" === change.type) {
            const oldData = that._getOldData(change.key);
            if (!isDefined(oldData)) {
              return;
            }
            data17 = createObjectWithChanges(oldData, change.data);
          }
          if (data17) {
            const validator = this._validatingController.createValidator({
              column,
              key: change.key,
              value: column.calculateCellValue(data17)
            });
            if (validator) {
              invisibleColumnValidators.push(validator);
            }
          }
        }));
      }));
    }
    return function() {
      invisibleColumnValidators.forEach(((validator) => {
        validator.dispose();
      }));
    };
  }
  _beforeSaveEditData(change, editIndex) {
    let result = super._beforeSaveEditData.apply(this, arguments);
    const validationData = this._validatingController._getValidationData(null === change || void 0 === change ? void 0 : change.key, true);
    if (change) {
      const isValid = "remove" === change.type || validationData.isValid;
      result = result || !isValid;
    } else {
      const disposeValidators = this._createInvisibleColumnValidators(this.getChanges());
      result = new Deferred();
      this.executeOperation(result, (() => {
        this._validatingController.validate(true).done(((isFullValid) => {
          disposeValidators();
          this._updateRowAndPageIndices();
          switch (this.getEditMode()) {
            case EDIT_MODE_CELL2:
              if (!isFullValid) {
                this._focusEditingCell();
              }
              break;
            case EDIT_MODE_BATCH2:
              if (!isFullValid) {
                this._resetEditRowKey();
                this._resetEditColumnName();
                this._dataController.updateItems();
              }
          }
          result.resolve(!isFullValid);
        }));
      }));
    }
    return result.promise ? result.promise() : result;
  }
  _beforeEditCell(rowIndex, columnIndex, item) {
    const result = super._beforeEditCell(rowIndex, columnIndex, item);
    if (this.getEditMode() === EDIT_MODE_CELL2) {
      const $cell = this._rowsView._getCellElement(rowIndex, columnIndex);
      const validator = $cell && $cell.data("dxValidator");
      const rowOptions = $cell && $cell.closest(".dx-row").data("options");
      const value2 = validator && validator.option("adapter").getValue();
      if (validator && cellValueShouldBeValidated(value2, rowOptions)) {
        const deferred = new Deferred();
        when(this._validatingController.validateCell(validator), result).done(((validationResult, result2) => {
          deferred.resolve(validationResult.status === VALIDATION_STATUS.valid && result2);
        }));
        return deferred.promise();
      }
      if (!validator) {
        return result;
      }
    }
    return false;
  }
  _afterSaveEditData(cancel) {
    let $firstErrorRow;
    const isCellEditMode = this.getEditMode() === EDIT_MODE_CELL2;
    each(this.getChanges(), ((_, change) => {
      const $errorRow = this._showErrorRow(change);
      $firstErrorRow = $firstErrorRow || $errorRow;
    }));
    if ($firstErrorRow) {
      const scrollable = this._rowsView.getScrollable();
      if (scrollable) {
        scrollable.update();
        scrollable.scrollToElement($firstErrorRow);
      }
    }
    if (cancel && isCellEditMode && this._needUpdateRow()) {
      const editRowIndex = this.getEditRowIndex();
      this._dataController.updateItems({
        changeType: "update",
        rowIndices: [editRowIndex]
      });
      this._focusEditingCell();
    } else if (!cancel) {
      let shouldResetValidationState = true;
      if (isCellEditMode) {
        const columns7 = this._columnsController.getColumns();
        const columnsWithValidatingEditors = columns7.filter(((col) => {
          var _col$validationRules;
          return col.showEditorAlways && (null === (_col$validationRules = col.validationRules) || void 0 === _col$validationRules ? void 0 : _col$validationRules.length) > 0;
        })).length > 0;
        shouldResetValidationState = !columnsWithValidatingEditors;
      }
      if (shouldResetValidationState) {
        this._validatingController.initValidationState();
      }
    }
  }
  _handleDataChanged(args) {
    const validationState = this._validatingController._validationState;
    if ("standard" === this.option("scrolling.mode")) {
      this.resetRowAndPageIndices();
    }
    if ("prepend" === args.changeType) {
      each(validationState, ((_, validationData) => {
        validationData.rowIndex += args.items.length;
      }));
    }
    super._handleDataChanged(args);
  }
  resetRowAndPageIndices() {
    const validationState = this._validatingController._validationState;
    each(validationState, ((_, validationData) => {
      if (validationData.pageIndex !== this._pageIndex) {
        delete validationData.pageIndex;
        delete validationData.rowIndex;
      }
    }));
  }
  _beforeCancelEditData() {
    this._validatingController.initValidationState();
    super._beforeCancelEditData();
  }
  _showErrorRow(change) {
    let $popupContent;
    const items = this._dataController.items();
    const rowIndex = this.getIndexByKey(change.key, items);
    const validationData = this._validatingController._getValidationData(change.key);
    if (!(null !== validationData && void 0 !== validationData && validationData.isValid) && null !== validationData && void 0 !== validationData && validationData.errorText && rowIndex >= 0) {
      $popupContent = this.getPopupContent();
      return this._errorHandlingController && this._errorHandlingController.renderErrorRow(null === validationData || void 0 === validationData ? void 0 : validationData.errorText, rowIndex, $popupContent);
    }
  }
  updateFieldValue(e) {
    const deferred = new Deferred();
    this._validatingController.removeCellValidationResult({
      change: this.getChangeByKey(e.key),
      columnIndex: e.column.index
    });
    super.updateFieldValue.apply(this, arguments).done((() => {
      const currentValidator = this._validatingController.getCellValidator({
        rowKey: e.key,
        columnIndex: e.column.index
      });
      when(currentValidator && this._validatingController.validateCell(currentValidator)).done(((validationResult) => {
        this._editorFactoryController.refocus();
        deferred.resolve(validationResult);
      }));
    }));
    return deferred.promise();
  }
  highlightDataCell($cell, parameters) {
    super.highlightDataCell.apply(this, arguments);
    this._validatingController.setCellValidationStatus(parameters);
    const isEditableCell = !!parameters.setValue;
    const cellModified = this.isCellModified(parameters);
    const isValidated = isDefined(parameters.validationStatus);
    const needValidation = cellModified && parameters.column.setCellValue || isEditableCell && !cellModified && !(parameters.row.isNewRow || !isValidated);
    if (needValidation) {
      const validator = $cell.data("dxValidator");
      if (validator) {
        when(this._validatingController.validateCell(validator)).done((() => {
          this._validatingController.setCellValidationStatus(parameters);
        }));
      }
    }
  }
  getChangeByKey(key) {
    const changes = this.getChanges();
    return changes[m_utils_default.getIndexByKey(key, changes)];
  }
  isCellModified(parameters) {
    const cellModified = super.isCellModified(parameters);
    const change = this.getChangeByKey(parameters.key);
    const isCellInvalid = !!parameters.row && this._validatingController.isInvalidCell({
      rowKey: parameters.key,
      columnIndex: parameters.column.index
    });
    return cellModified || this._validatingController._rowIsValidated(change) && isCellInvalid;
  }
};
var getWidthOfVisibleCells = function(that, element) {
  const rowIndex = renderer_default(element).closest("tr").index();
  const $cellElements = renderer_default(that._rowsView.getRowElement(rowIndex)).first().children().filter(":not(.dx-hidden-cell)");
  return that._rowsView._getWidths($cellElements).reduce(((w1, w2) => w1 + w2), 0);
};
var getBoundaryNonFixedColumnsInfo = function(fixedColumns) {
  let firstNonFixedColumnIndex;
  let lastNonFixedColumnIndex;
  fixedColumns.some(((column, index) => {
    if ("transparent" === column.command) {
      firstNonFixedColumnIndex = 0 === index ? -1 : index;
      lastNonFixedColumnIndex = index === fixedColumns.length - 1 ? -1 : index + column.colspan - 1;
      return true;
    }
    return;
  }));
  return {
    startColumnIndex: firstNonFixedColumnIndex,
    endColumnIndex: lastNonFixedColumnIndex
  };
};
var validatingEditorFactoryExtender = (Base) => class extends Base {
  _showRevertButton($container) {
    var _this$_revertTooltip, _$tooltipElement2;
    let $tooltipElement = null === (_this$_revertTooltip = this._revertTooltip) || void 0 === _this$_revertTooltip ? void 0 : _this$_revertTooltip.$element();
    if (!$container || !$container.length) {
      var _$tooltipElement;
      null === (_$tooltipElement = $tooltipElement) || void 0 === _$tooltipElement || _$tooltipElement.remove();
      this._revertTooltip = void 0;
      return;
    }
    if ($container.find($tooltipElement).length) {
      var _this$_revertTooltip2;
      null === (_this$_revertTooltip2 = this._revertTooltip) || void 0 === _this$_revertTooltip2 || _this$_revertTooltip2.repaint();
      return;
    }
    const $overlayContainer = this.getRevertButtonContainer($container);
    const revertTooltipClass = this.addWidgetPrefix("revert-tooltip");
    null === (_$tooltipElement2 = $tooltipElement) || void 0 === _$tooltipElement2 || _$tooltipElement2.remove();
    $tooltipElement = renderer_default("<div>").addClass(revertTooltipClass).appendTo($container);
    const tooltipOptions = {
      animation: null,
      visible: true,
      width: "auto",
      height: "auto",
      shading: false,
      container: $overlayContainer,
      propagateOutsideClick: true,
      hideOnOutsideClick: false,
      wrapperAttr: {
        class: revertTooltipClass
      },
      contentTemplate: () => {
        const $buttonElement = renderer_default("<div>").addClass("dx-revert-button");
        const buttonOptions = {
          icon: "revert",
          hint: this.option("editing.texts.validationCancelChanges"),
          elementAttr: {
            id: "dxRevertButton",
            "aria-label": message_default.format("dxDataGrid-ariaRevertButton")
          },
          onClick: () => {
            this._editingController.cancelEditData();
          }
        };
        return new button_default($buttonElement, buttonOptions).$element();
      },
      position: {
        my: "left top",
        at: "right top",
        offset: "1 0",
        collision: "flip",
        boundaryOffset: "0 0",
        boundary: this._rowsView.element(),
        of: $container
      },
      onPositioned: this.overlayPositionedHandler.bind(this)
    };
    this._revertTooltip = new ui_overlay_default($tooltipElement, tooltipOptions);
  }
  _hideFixedGroupCell($cell, overlayOptions) {
    var _this$_rowsView, _this$_rowsView$isFix;
    let $nextFixedRowElement;
    let $groupCellElement;
    const isFixedColumns = null === (_this$_rowsView = this._rowsView) || void 0 === _this$_rowsView || null === (_this$_rowsView$isFix = _this$_rowsView.isFixedColumns) || void 0 === _this$_rowsView$isFix ? void 0 : _this$_rowsView$isFix.call(_this$_rowsView);
    const isFormOrPopupEditMode = this._editingController.isFormOrPopupEditMode();
    if (isFixedColumns && !isFormOrPopupEditMode) {
      const nextRowOptions = $cell.closest(".dx-row").next().data("options");
      if (nextRowOptions && "group" === nextRowOptions.rowType) {
        $nextFixedRowElement = renderer_default(this._rowsView.getRowElement(nextRowOptions.rowIndex)).last();
        $groupCellElement = $nextFixedRowElement.find(".dx-group-cell");
        if ($groupCellElement.length && "hidden" !== $groupCellElement.get(0).style.visibility) {
          $groupCellElement.css("visibility", "hidden");
          overlayOptions.onDisposing = function() {
            $groupCellElement.css("visibility", "");
          };
        }
      }
    }
  }
  _showValidationMessage($cell, messages, alignment) {
    const editorPopup = $cell.find(".dx-dropdowneditor-overlay").data("dxPopup");
    const isOverlayVisible = editorPopup && editorPopup.option("visible");
    const myPosition = isOverlayVisible ? "top right" : `top ${alignment}`;
    const atPosition = isOverlayVisible ? "top left" : `bottom ${alignment}`;
    const $overlayContainer = this.getValidationMessageContainer($cell);
    let errorMessageText = "";
    messages && messages.forEach(((message) => {
      errorMessageText += (errorMessageText.length ? "<br/>" : "") + encodeHtml(message);
    }));
    const invalidMessageClass = this.addWidgetPrefix("invalid-message");
    this._rowsView.element().find(`.${invalidMessageClass}`).remove();
    const $overlayElement = renderer_default("<div>").addClass("dx-invalid-message").addClass("dx-invalid-message-always").addClass(invalidMessageClass).html(errorMessageText).appendTo($cell);
    const overlayOptions = {
      container: $overlayContainer,
      shading: false,
      width: "auto",
      height: "auto",
      visible: true,
      animation: false,
      propagateOutsideClick: true,
      hideOnOutsideClick: false,
      wrapperAttr: {
        id: "dxInvalidMessage",
        class: `dx-invalid-message dx-invalid-message-always ${invalidMessageClass}`
      },
      position: {
        collision: "flip",
        boundary: this._rowsView.element(),
        boundaryOffset: "0 0",
        offset: {
          x: 0,
          y: !isOverlayVisible && browser_default.mozilla ? -1 : 0
        },
        my: myPosition,
        at: atPosition,
        of: $cell
      },
      onPositioned: (e) => {
        this.overlayPositionedHandler(e, isOverlayVisible);
        this._shiftValidationMessageIfNeed(e.component.$content(), $cell);
      }
    };
    this._hideFixedGroupCell($cell, overlayOptions);
    new ui_overlay_default($overlayElement, overlayOptions);
  }
  getValidationMessages() {
    var _this$_rowsView$eleme;
    return null === (_this$_rowsView$eleme = this._rowsView.element()) || void 0 === _this$_rowsView$eleme ? void 0 : _this$_rowsView$eleme.find(this._getValidationMessagesSelector());
  }
  getRevertButton() {
    var _this$_revertTooltip3;
    return renderer_default(null === (_this$_revertTooltip3 = this._revertTooltip) || void 0 === _this$_revertTooltip3 ? void 0 : _this$_revertTooltip3.element());
  }
  _hideValidationMessage() {
    var _this$_rowsView$eleme2;
    const validationMessages = null === (_this$_rowsView$eleme2 = this._rowsView.element()) || void 0 === _this$_rowsView$eleme2 ? void 0 : _this$_rowsView$eleme2.find(this._getValidationMessagesSelector());
    null === validationMessages || void 0 === validationMessages || validationMessages.remove();
  }
  _normalizeValidationMessagePositionAndMaxWidth(options, isRevertButton, isOverlayVisible) {
    const fixedColumns = this._columnsController.getFixedColumns();
    if (!fixedColumns || !fixedColumns.length) {
      return;
    }
    let position;
    const visibleTableWidth = !isRevertButton && getWidthOfVisibleCells(this, options.element);
    const $overlayContentElement = options.component.$content();
    const validationMessageWidth = getOuterWidth($overlayContentElement, true);
    const needMaxWidth = !isRevertButton && validationMessageWidth > visibleTableWidth;
    const columnIndex = this._rowsView.getCellIndex(renderer_default(options.element).closest("td"));
    const boundaryNonFixedColumnsInfo = getBoundaryNonFixedColumnsInfo(fixedColumns);
    if (!isRevertButton && (columnIndex === boundaryNonFixedColumnsInfo.startColumnIndex || needMaxWidth)) {
      position = {
        collision: "none flip",
        my: "top left",
        at: isOverlayVisible ? "top right" : "bottom left"
      };
    } else if (columnIndex === boundaryNonFixedColumnsInfo.endColumnIndex) {
      position = {
        collision: "none flip",
        my: "top right",
        at: isRevertButton || isOverlayVisible ? "top left" : "bottom right"
      };
      if (isRevertButton) {
        position.offset = "-1 0";
      }
    }
    return position && {
      position,
      maxWidth: needMaxWidth ? visibleTableWidth - 2 : void 0
    };
  }
  _shiftValidationMessageIfNeed($content, $cell) {
    const $revertContent = this._revertTooltip && this._revertTooltip.$content();
    if (!$revertContent) {
      return;
    }
    const contentOffset = $content.offset();
    const revertContentOffset = $revertContent.offset();
    if (contentOffset.top === revertContentOffset.top && contentOffset.left + getWidth($content) > revertContentOffset.left) {
      const left = getWidth($revertContent) + 2;
      $content.css("left", revertContentOffset.left < $cell.offset().left ? -left : left);
    }
  }
  getOverlayBaseZIndex() {
    return ui_overlay_default.baseZIndex();
  }
  overlayPositionedHandler(e, isOverlayVisible) {
    if (!e.component.__skipPositionProcessing) {
      const isRevertButton = renderer_default(e.element).hasClass(this.addWidgetPrefix("revert-tooltip"));
      const needRepaint = !isRevertButton && this._rowsView.updateFreeSpaceRowHeight();
      const normalizedPosition = this._normalizeValidationMessagePositionAndMaxWidth(e, isRevertButton, isOverlayVisible);
      e.component.__skipPositionProcessing = !!(needRepaint || normalizedPosition);
      if (normalizedPosition) {
        e.component.option(normalizedPosition);
      } else if (needRepaint) {
        e.component.repaint();
      }
    }
  }
  _getRevertTooltipsSelector() {
    const revertTooltipClass = this.addWidgetPrefix("revert-tooltip");
    return `.dx-editor-cell .${revertTooltipClass}`;
  }
  _getValidationMessagesSelector() {
    const invalidMessageClass = this.addWidgetPrefix("invalid-message");
    return `.dx-editor-cell .${invalidMessageClass}, .dx-cell-modified .${invalidMessageClass}`;
  }
  loseFocus(skipValidator) {
    if (!skipValidator) {
      this._validatingController.setValidator(null);
    }
    super.loseFocus();
  }
  updateCellState($element, validationResult, isHideBorder) {
    var _change$data;
    const $focus = null === $element || void 0 === $element ? void 0 : $element.closest(this._getFocusCellSelector());
    const $cell = null !== $focus && void 0 !== $focus && $focus.is("td") ? $focus : null;
    const rowOptions = null === $focus || void 0 === $focus ? void 0 : $focus.closest(".dx-row").data("options");
    const change = rowOptions ? this._editingController.getChangeByKey(rowOptions.key) : null;
    const column = $cell && this._columnsController.getVisibleColumns()[$cell.index()];
    const isCellModified = void 0 !== (null === change || void 0 === change || null === (_change$data = change.data) || void 0 === _change$data ? void 0 : _change$data[null === column || void 0 === column ? void 0 : column.name]) && !this._editingController.isSaving();
    const validationDescriptionValues = [];
    if (this._editingController.getEditMode() === EDIT_MODE_CELL2) {
      if ((null === validationResult || void 0 === validationResult ? void 0 : validationResult.status) === VALIDATION_STATUS.invalid || isCellModified) {
        this._showRevertButton($focus);
        validationDescriptionValues.push("dxRevertButton");
      } else {
        this._revertTooltip && this._revertTooltip.$element().remove();
      }
    }
    const showValidationMessage = validationResult && validationResult.status === VALIDATION_STATUS.invalid;
    if (showValidationMessage && $cell && column && validationResult && validationResult.brokenRules) {
      const errorMessages = [];
      validationResult.brokenRules.forEach(((rule) => {
        if (rule.message) {
          errorMessages.push(rule.message);
        }
      }));
      if (errorMessages.length) {
        this._showValidationMessage($focus, errorMessages, column.alignment || "left");
        validationDescriptionValues.push("dxInvalidMessage");
      }
    }
    this._updateAriaValidationAttributes($focus, validationDescriptionValues);
    !isHideBorder && this._rowsView.element() && this._rowsView.updateFreeSpaceRowHeight();
  }
  _updateAriaValidationAttributes($focus, inputDescriptionValues) {
    if (0 === inputDescriptionValues.length) {
      return;
    }
    const editMode = this._editingController.getEditMode();
    const shouldSetValidationAriaAttributes = [EDIT_MODE_CELL2, EDIT_MODE_BATCH2, EDIT_MODE_ROW2].includes(editMode);
    if (shouldSetValidationAriaAttributes) {
      const $focusElement = this._getCurrentFocusElement($focus);
      $focusElement.attr("aria-labelledby", inputDescriptionValues.join(" "));
      $focusElement.attr("aria-invalid", true);
    }
  }
  _getCurrentFocusElement($focus) {
    if (this._editingController.isEditing()) {
      return $focus.find(EDITORS_INPUT_SELECTOR).first();
    }
    return $focus;
  }
  focus($element, isHideBorder) {
    if (!arguments.length) {
      return super.focus();
    }
    this._hideValidationMessage();
    if (null !== $element && void 0 !== $element && $element.hasClass("dx-row") || null !== $element && void 0 !== $element && $element.hasClass("dx-master-detail-cell")) {
      return super.focus($element, isHideBorder);
    }
    const $focus = null === $element || void 0 === $element ? void 0 : $element.closest(this._getFocusCellSelector());
    const validator = $focus && ($focus.data("dxValidator") || $element.find(`.${this.addWidgetPrefix("validator")}`).eq(0).data("dxValidator"));
    const rowOptions = $focus && $focus.closest(".dx-row").data("options");
    const change = rowOptions ? this._editingController.getChangeByKey(rowOptions.key) : null;
    let validationResult;
    if (validator) {
      this._validatingController.setValidator(validator);
      const value2 = validator.option("adapter").getValue();
      if (cellValueShouldBeValidated(value2, rowOptions) || this._validatingController._rowIsValidated(change)) {
        this._editingController.waitForDeferredOperations().done((() => {
          const isDetached = !this._rowsView.isElementInside($element);
          if (isDetached) {
            return;
          }
          when(this._validatingController.validateCell(validator)).done(((result) => {
            validationResult = result;
            const {
              column
            } = validationResult.validator.option("dataGetter")();
            if (change && column && !this._validatingController.isCurrentValidatorProcessing({
              rowKey: change.key,
              columnIndex: column.index
            })) {
              return;
            }
            if (!isFluent(current()) && validationResult.status === VALIDATION_STATUS.invalid) {
              isHideBorder = true;
            }
            this.updateCellState($element, validationResult, isHideBorder);
            super.focus.call(this, $element, isHideBorder);
          }));
        }));
        return super.focus($element, isHideBorder);
      }
    }
    this.updateCellState($element, validationResult, isHideBorder);
    return super.focus($element, isHideBorder);
  }
  getEditorInstance($container) {
    const $editor = $container.find(".dx-texteditor").eq(0);
    return m_utils_default.getWidgetInstance($editor);
  }
  getValidationMessageContainer($cell) {
    return $cell.closest(`.${this.addWidgetPrefix("content")}`);
  }
  getRevertButtonContainer($cell) {
    return $cell.closest(`.${this.addWidgetPrefix("content")}`).parent();
  }
  hasOverlayElements() {
    const $validationMessageElements = this.getValidationMessages();
    const $revertButtonElement = this.getRevertButton();
    return super.hasOverlayElements() || !!(null !== $validationMessageElements && void 0 !== $validationMessageElements && $validationMessageElements.length) || !!(null !== $revertButtonElement && void 0 !== $revertButtonElement && $revertButtonElement.length);
  }
};
var validatingDataControllerExtender = (Base) => class extends Base {
  _getValidationStatus(validationResult) {
    const validationStatus = validationResultIsValid(validationResult) ? validationResult.status : validationResult;
    return validationStatus || VALIDATION_STATUS.valid;
  }
  _isCellChanged(oldRow, newRow, visibleRowIndex, columnIndex, isLiveUpdate) {
    var _oldRow$cells, _cell$column$validati;
    const cell = null === (_oldRow$cells = oldRow.cells) || void 0 === _oldRow$cells ? void 0 : _oldRow$cells[columnIndex];
    const oldValidationStatus = this._getValidationStatus({
      status: null === cell || void 0 === cell ? void 0 : cell.validationStatus
    });
    const validationResult = this._validatingController.getCellValidationResult({
      rowKey: oldRow.key,
      columnIndex
    });
    const validationData = this._validatingController._getValidationData(oldRow.key);
    const newValidationStatus = this._getValidationStatus(validationResult);
    const rowIsModified = JSON.stringify(newRow.modifiedValues) !== JSON.stringify(oldRow.modifiedValues);
    const validationStatusChanged = oldValidationStatus !== newValidationStatus && rowIsModified;
    const cellIsMarkedAsInvalid = renderer_default(null === cell || void 0 === cell ? void 0 : cell.cellElement).hasClass(this.addWidgetPrefix("invalid"));
    const hasValidationRules = null === cell || void 0 === cell || null === (_cell$column$validati = cell.column.validationRules) || void 0 === _cell$column$validati ? void 0 : _cell$column$validati.length;
    const rowEditStateChanged = oldRow.isEditing !== newRow.isEditing && hasValidationRules;
    const cellValidationStateChanged = validationStatusChanged || validationData.isValid && cellIsMarkedAsInvalid;
    if (rowEditStateChanged || cellValidationStateChanged) {
      return true;
    }
    return super._isCellChanged.apply(this, arguments);
  }
};
var validatingRowsViewExtender = (Base) => class extends Base {
  updateFreeSpaceRowHeight($table) {
    const that = this;
    let $rowElements;
    let $freeSpaceRowElement;
    let $freeSpaceRowElements;
    const $element = that.element();
    const $tooltipContent = $element && $element.find(`.${that.addWidgetPrefix("invalid-message")} .dx-overlay-content`);
    super.updateFreeSpaceRowHeight($table);
    if ($tooltipContent && $tooltipContent.length) {
      $rowElements = that._getRowElements().filter(":visible");
      $freeSpaceRowElements = that._getFreeSpaceRowElements($table);
      $freeSpaceRowElement = $freeSpaceRowElements.first();
      const rowElementsHasFocusInside = $rowElements.find(":focus").length > 0;
      if ($freeSpaceRowElement && 1 === $rowElements.length && (!$freeSpaceRowElement.is(":visible") || getOuterHeight($tooltipContent) > getOuterHeight($freeSpaceRowElement)) && rowElementsHasFocusInside) {
        $freeSpaceRowElements.show();
        setHeight($freeSpaceRowElements, getOuterHeight($tooltipContent));
        return true;
      }
    }
    return;
  }
  _formItemPrepared(cellOptions, $container) {
    super._formItemPrepared.apply(this, arguments);
    deferUpdate((() => {
      const $editor = $container.find(".dx-widget").first();
      const isEditorDisposed = $editor.length && !$editor.children().length;
      if (!isEditorDisposed) {
        this._validatingController.createValidator(cellOptions, $editor);
      }
    }));
  }
  _cellPrepared($cell, parameters) {
    if (!this._editingController.isFormOrPopupEditMode()) {
      this._validatingController.createValidator(parameters, $cell);
    }
    super._cellPrepared.apply(this, arguments);
  }
  _restoreErrorRow(contentTable) {
    this._editingController && this._editingController.hasChanges() && this._getRowElements(contentTable).each(((_, item) => {
      const rowOptions = renderer_default(item).data("options");
      if (rowOptions) {
        const change = this._editingController.getChangeByKey(rowOptions.key);
        change && this._editingController._showErrorRow(change);
      }
    }));
  }
};
var validatingModule = {
  defaultOptions: () => ({
    editing: {
      texts: {
        validationCancelChanges: message_default.format("dxDataGrid-validationCancelChanges")
      }
    }
  }),
  controllers: {
    validating: ValidatingController
  },
  extenders: {
    controllers: {
      editing: validatingEditingExtender,
      editorFactory: validatingEditorFactoryExtender,
      data: validatingDataControllerExtender
    },
    views: {
      rowsView: validatingRowsViewExtender
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/validating.js
m_core_default.registerModule("validating", validatingModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/virtual_data_loader/m_virtual_data_loader.js
var LEGACY_SCROLLING_MODE2 = "scrolling.legacyMode";
var needTwoPagesLoading = (that) => that.option("scrolling.loadTwoPagesOnStart") || that._controller.isVirtual() || that._controller.getViewportItemIndex() > 0;
var getBeginPageIndex = (that) => that._cache.length ? that._cache[0].pageIndex : -1;
var getEndPageIndex = (that) => that._cache.length ? that._cache[that._cache.length - 1].pageIndex : -1;
var fireChanged = (that, changed, args) => {
  that._isChangedFiring = true;
  changed(args);
  that._isChangedFiring = false;
};
var processDelayChanged = (that, changed, args) => {
  if (that._isDelayChanged) {
    that._isDelayChanged = false;
    fireChanged(that, changed, args);
    return true;
  }
};
var getViewportPageCount = (that) => {
  const pageSize = that._dataOptions.pageSize();
  const preventPreload = that.option("scrolling.preventPreload");
  if (preventPreload) {
    return 0;
  }
  let realViewportSize = that._controller.viewportSize();
  if (that._controller.isVirtualMode() && that.option("scrolling.removeInvisiblePages")) {
    realViewportSize = 0;
    const viewportSize = that._controller.viewportSize() * that._controller.viewportItemSize();
    let offset = that._controller.getContentOffset();
    const position = that._controller.getViewportPosition();
    const virtualItemsCount = that._controller.virtualItemsCount();
    const totalItemsCount = that._dataOptions.totalItemsCount();
    for (let itemIndex = virtualItemsCount.begin; itemIndex < totalItemsCount; itemIndex++) {
      if (offset >= position + viewportSize) {
        break;
      }
      const itemSize = that._controller.getItemSizes()[itemIndex] || that._controller.viewportItemSize();
      offset += itemSize;
      if (offset >= position) {
        realViewportSize++;
      }
    }
  }
  return pageSize && realViewportSize > 0 ? Math.ceil(realViewportSize / pageSize) : 1;
};
var getPreloadPageCount = (that, previous) => {
  const preloadEnabled = that.option("scrolling.preloadEnabled");
  let pageCount = getViewportPageCount(that);
  const isAppendMode3 = that._controller.isAppendMode();
  if (pageCount) {
    if (previous) {
      pageCount = preloadEnabled ? 1 : 0;
    } else {
      if (preloadEnabled) {
        pageCount++;
      }
      if (isAppendMode3 || !needTwoPagesLoading(that)) {
        pageCount--;
      }
    }
  }
  return pageCount;
};
var getPageIndexForLoad = (that) => {
  let result = -1;
  const beginPageIndex = getBeginPageIndex(that);
  const dataOptions = that._dataOptions;
  if (beginPageIndex < 0) {
    result = that._pageIndex;
  } else if (!that._cache[that._pageIndex - beginPageIndex]) {
    result = that._pageIndex;
  } else if (beginPageIndex >= 0 && that._controller.viewportSize() >= 0) {
    if (beginPageIndex > 0) {
      const needToLoadPageBeforeLast = getEndPageIndex(that) + 1 === dataOptions.pageCount() && that._cache.length < getPreloadPageCount(that) + 1;
      const needToLoadPrevPage = needToLoadPageBeforeLast || that._pageIndex === beginPageIndex && getPreloadPageCount(that, true);
      if (needToLoadPrevPage) {
        result = beginPageIndex - 1;
      }
    }
    if (result < 0) {
      const needToLoadNextPage = beginPageIndex + that._cache.length <= that._pageIndex + getPreloadPageCount(that);
      if (needToLoadNextPage) {
        result = beginPageIndex + that._cache.length;
      }
    }
  }
  if (that._loadingPageIndexes[result]) {
    result = -1;
  }
  return result;
};
var loadCore = (that, pageIndex) => {
  const dataOptions = that._dataOptions;
  if (pageIndex === that.pageIndex() || !dataOptions.isLoading() && pageIndex < dataOptions.pageCount() || !dataOptions.hasKnownLastPage() && pageIndex === dataOptions.pageCount()) {
    dataOptions.pageIndex(pageIndex);
    that._loadingPageIndexes[pageIndex] = true;
    return when(dataOptions.load()).always((() => {
      that._loadingPageIndexes[pageIndex] = false;
    }));
  }
};
var processChanged = (that, changed, changeType, isDelayChanged, removeCacheItem) => {
  const dataOptions = that._dataOptions;
  const items = dataOptions.items().slice();
  let change = isObject(changeType) ? changeType : void 0;
  const isPrepend = "prepend" === changeType;
  const viewportItems = dataOptions.viewportItems();
  if (changeType && isString(changeType) && !that._isDelayChanged) {
    change = {
      changeType,
      items
    };
    if (removeCacheItem) {
      change.removeCount = removeCacheItem.itemsCount;
      if (change.removeCount && dataOptions.correctCount) {
        change.removeCount = dataOptions.correctCount(viewportItems, change.removeCount, isPrepend);
      }
    }
  }
  let removeItemCount = removeCacheItem ? removeCacheItem.itemsLength : 0;
  if (removeItemCount && dataOptions.correctCount) {
    removeItemCount = dataOptions.correctCount(viewportItems, removeItemCount, isPrepend);
  }
  if ("append" === changeType) {
    viewportItems.push.apply(viewportItems, items);
    if (removeCacheItem) {
      viewportItems.splice(0, removeItemCount);
    }
  } else if (isPrepend) {
    viewportItems.unshift.apply(viewportItems, items);
    if (removeCacheItem) {
      viewportItems.splice(-removeItemCount);
    }
  } else {
    that._dataOptions.viewportItems(items);
  }
  dataOptions.updateLoading();
  that._lastPageIndex = that.pageIndex();
  that._isDelayChanged = isDelayChanged;
  if (!isDelayChanged) {
    fireChanged(that, changed, change);
  }
};
var VirtualDataLoader = class {
  constructor(controller, dataOptions) {
    this._dataOptions = dataOptions;
    this._controller = controller;
    this._pageIndex = this._lastPageIndex = dataOptions.pageIndex();
    this._cache = [];
    this._loadingPageIndexes = {};
  }
  option() {
    return this._controller.option.apply(this._controller, arguments);
  }
  viewportItemIndexChanged(itemIndex) {
    const pageSize = this._dataOptions.pageSize();
    const pageCount = this._dataOptions.pageCount();
    const virtualMode = this._controller.isVirtualMode();
    const appendMode = this._controller.isAppendMode();
    const totalItemsCount = this._dataOptions.totalItemsCount();
    let newPageIndex;
    if (pageSize && (virtualMode || appendMode) && totalItemsCount >= 0) {
      const viewportSize = this._controller.viewportSize();
      if (viewportSize && itemIndex + viewportSize >= totalItemsCount && !this._controller.isVirtual()) {
        if (this._dataOptions.hasKnownLastPage()) {
          newPageIndex = pageCount - 1;
          const lastPageSize = totalItemsCount % pageSize;
          if (newPageIndex > 0 && lastPageSize > 0 && lastPageSize < viewportSize) {
            newPageIndex--;
          }
        } else {
          newPageIndex = pageCount;
        }
      } else {
        newPageIndex = Math.floor(itemIndex / pageSize);
        const maxPageIndex = pageCount - 1;
        newPageIndex = Math.max(newPageIndex, 0);
        newPageIndex = Math.min(newPageIndex, maxPageIndex);
      }
      this.pageIndex(newPageIndex);
      return this.load();
    }
  }
  pageIndex(pageIndex) {
    const isVirtualMode3 = this._controller.isVirtualMode();
    const isAppendMode3 = this._controller.isAppendMode();
    if (false !== this.option(LEGACY_SCROLLING_MODE2) && (isVirtualMode3 || isAppendMode3)) {
      if (void 0 !== pageIndex) {
        this._pageIndex = pageIndex;
      }
      return this._pageIndex;
    }
    return this._dataOptions.pageIndex(pageIndex);
  }
  beginPageIndex(defaultPageIndex) {
    let index = getBeginPageIndex(this);
    if (index < 0) {
      index = void 0 !== defaultPageIndex ? defaultPageIndex : this.pageIndex();
    }
    return index;
  }
  endPageIndex() {
    const endPageIndex = getEndPageIndex(this);
    return endPageIndex > 0 ? endPageIndex : this._lastPageIndex;
  }
  pageSize() {
    return this._dataOptions.pageSize();
  }
  load() {
    const dataOptions = this._dataOptions;
    let result;
    const isVirtualMode3 = this._controller.isVirtualMode();
    const isAppendMode3 = this._controller.isAppendMode();
    if (false !== this.option(LEGACY_SCROLLING_MODE2) && (isVirtualMode3 || isAppendMode3)) {
      const pageIndexForLoad = getPageIndexForLoad(this);
      if (pageIndexForLoad >= 0) {
        const loadResult = loadCore(this, pageIndexForLoad);
        if (loadResult) {
          result = new Deferred();
          loadResult.done((() => {
            const delayDeferred = this._delayDeferred;
            if (delayDeferred) {
              delayDeferred.done(result.resolve).fail(result.reject);
            } else {
              result.resolve();
            }
          })).fail(result.reject);
          dataOptions.updateLoading();
        }
      }
    } else {
      result = dataOptions.load();
    }
    if (!result && this._lastPageIndex !== this.pageIndex()) {
      this._dataOptions.onChanged({
        changeType: "pageIndex"
      });
    }
    return result || new Deferred().resolve();
  }
  loadIfNeed() {
    const isVirtualMode3 = this._controller.isVirtualMode();
    const isAppendMode3 = this._controller.isAppendMode();
    if ((isVirtualMode3 || isAppendMode3) && !this._dataOptions.isLoading() && (!this._isChangedFiring || this._controller.isVirtual())) {
      const position = this._controller.getViewportPosition();
      if (position > 0) {
        this._controller._setViewportPositionCore(position);
      } else {
        this.load();
      }
    }
  }
  handleDataChanged(callBase, e) {
    const dataOptions = this._dataOptions;
    let lastCacheLength = this._cache.length;
    let changeType;
    let removeInvisiblePages;
    const isVirtualMode3 = this._controller.isVirtualMode();
    const isAppendMode3 = this._controller.isAppendMode();
    if (e && e.changes) {
      fireChanged(this, callBase, e);
    } else if (false !== this.option(LEGACY_SCROLLING_MODE2) && (isVirtualMode3 || isAppendMode3)) {
      const beginPageIndex = getBeginPageIndex(this);
      if (beginPageIndex >= 0) {
        if (isVirtualMode3 && beginPageIndex + this._cache.length !== dataOptions.pageIndex() && beginPageIndex - 1 !== dataOptions.pageIndex()) {
          lastCacheLength = 0;
          this._cache = [];
        }
        if (isAppendMode3) {
          if (0 === dataOptions.pageIndex()) {
            this._cache = [];
          } else if (dataOptions.pageIndex() < getEndPageIndex(this)) {
            fireChanged(this, callBase, {
              changeType: "append",
              items: []
            });
            return;
          }
        }
      }
      const cacheItem = {
        pageIndex: dataOptions.pageIndex(),
        itemsLength: dataOptions.items(true).length,
        itemsCount: this.itemsCount(true)
      };
      if (this.option("scrolling.removeInvisiblePages") && isVirtualMode3) {
        removeInvisiblePages = this._cache.length > Math.max(getPreloadPageCount(this) + (this.option("scrolling.preloadEnabled") ? 1 : 0), 2);
      } else {
        processDelayChanged(this, callBase, {
          isDelayed: true
        });
      }
      let removeCacheItem;
      if (beginPageIndex === dataOptions.pageIndex() + 1) {
        if (removeInvisiblePages) {
          removeCacheItem = this._cache.pop();
        }
        changeType = "prepend";
        this._cache.unshift(cacheItem);
      } else {
        if (removeInvisiblePages) {
          removeCacheItem = this._cache.shift();
        }
        changeType = "append";
        this._cache.push(cacheItem);
      }
      const isDelayChanged = isVirtualMode3 && 0 === lastCacheLength && needTwoPagesLoading(this);
      processChanged(this, callBase, this._cache.length > 1 ? changeType : void 0, isDelayChanged, removeCacheItem);
      this._delayDeferred = this.load().done((() => {
        if (processDelayChanged(this, callBase)) {
          this.load();
        }
      }));
    } else {
      processChanged(this, callBase, e);
    }
  }
  getDelayDeferred() {
    return this._delayDeferred;
  }
  itemsCount(isBase) {
    let count = 0;
    const isVirtualMode3 = this._controller.isVirtualMode();
    if (!isBase && isVirtualMode3) {
      this._cache.forEach(((cacheItem) => {
        count += cacheItem.itemsCount;
      }));
    } else {
      count = this._dataOptions.itemsCount();
    }
    return count;
  }
  virtualItemsCount() {
    let pageIndex = getBeginPageIndex(this);
    if (pageIndex < 0) {
      pageIndex = this._dataOptions.pageIndex();
    }
    const beginItemsCount = pageIndex * this._dataOptions.pageSize();
    const itemsCount = this._cache.length * this._dataOptions.pageSize();
    const endItemsCount = Math.max(0, this._dataOptions.totalItemsCount() - itemsCount - beginItemsCount);
    return {
      begin: beginItemsCount,
      end: endItemsCount
    };
  }
  reset() {
    this._loadingPageIndexes = {};
    this._cache = [];
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/virtual_scrolling/m_virtual_scrolling_core.js
var LEGACY_SCROLLING_MODE3 = "scrolling.legacyMode";
var isVirtualMode = (that) => "virtual" === that.option("scrolling.mode") || that._isVirtual;
var isAppendMode = (that) => "infinite" === that.option("scrolling.mode") && !that._isVirtual;
function subscribeToExternalScrollers($element, scrollChangedHandler, $targetElement) {
  let $scrollElement;
  const scrollableArray = [];
  const scrollToArray = [];
  const disposeArray = [];
  $targetElement = $targetElement || $element;
  function getElementOffset(scrollable) {
    const $scrollableElement = scrollable.element ? scrollable.$element() : scrollable;
    const scrollableOffset = position_default.offset($scrollableElement);
    if (!scrollableOffset) {
      return $element.offset().top;
    }
    return scrollable.scrollTop() - (scrollableOffset.top - $element.offset().top);
  }
  const widgetScrollStrategy = {
    on(scrollable, eventName, handler) {
      scrollable.on("scroll", handler);
    },
    off(scrollable, eventName, handler) {
      scrollable.off("scroll", handler);
    }
  };
  function subscribeToScrollEvents($scrollElement2) {
    const isDocument = "#document" === $scrollElement2.get(0).nodeName;
    const isElement = $scrollElement2.get(0).nodeType === getWindow().Node.ELEMENT_NODE;
    let scrollable = $scrollElement2.data("dxScrollable");
    let eventsStrategy = widgetScrollStrategy;
    if (!scrollable) {
      scrollable = isDocument && renderer_default(getWindow()) || isElement && "auto" === $scrollElement2.css("overflowY") && $scrollElement2;
      eventsStrategy = m_events_engine_default;
      if (!scrollable) {
        return;
      }
    }
    const handler = /* @__PURE__ */ (function(scrollable2) {
      return function() {
        let scrollTop = scrollable2.scrollTop() - getElementOffset(scrollable2);
        scrollTop = scrollTop > 0 ? scrollTop : 0;
        scrollChangedHandler(scrollTop);
      };
    })(scrollable);
    eventsStrategy.on(scrollable, "scroll", handler);
    scrollToArray.push(((pos) => {
      const topOffset = getElementOffset(scrollable);
      const scrollMethod = scrollable.scrollTo ? "scrollTo" : "scrollTop";
      if (pos - topOffset >= 0) {
        scrollable[scrollMethod](pos + topOffset);
      }
    }));
    scrollableArray.push(scrollable);
    disposeArray.push((() => {
      eventsStrategy.off(scrollable, "scroll", handler);
    }));
  }
  const getScrollElementParent = ($element2) => renderer_default($element2.get(0).parentNode ?? $element2.get(0).host);
  for ($scrollElement = $targetElement.parent(); $scrollElement.length; $scrollElement = getScrollElementParent($scrollElement)) {
    subscribeToScrollEvents($scrollElement);
  }
  return {
    scrollTo(pos) {
      each(scrollToArray, ((_, scrollTo) => {
        scrollTo(pos);
      }));
    },
    dispose() {
      each(disposeArray, ((_, dispose) => {
        dispose();
      }));
    }
  };
}
var VirtualScrollController = class {
  constructor(component, dataOptions, isVirtual) {
    this._dataOptions = dataOptions;
    this.component = component;
    this._viewportSize = false === component.option(LEGACY_SCROLLING_MODE3) ? 15 : 0;
    this._viewportItemSize = 20;
    this._viewportItemIndex = 0;
    this._position = 0;
    this._isScrollingBack = false;
    this._contentSize = 0;
    this._itemSizes = {};
    this._sizeRatio = 1;
    this._isVirtual = isVirtual;
    this.positionChanged = callbacks_default();
    this._dataLoader = new VirtualDataLoader(this, this._dataOptions);
  }
  getItemSizes() {
    return this._itemSizes;
  }
  option(name, value2) {
    return this.component.option.apply(this.component, arguments);
  }
  isVirtual() {
    return this._isVirtual;
  }
  virtualItemsCount() {
    if (isVirtualMode(this)) {
      const dataOptions = this._dataOptions;
      const totalItemsCount = dataOptions.totalItemsCount();
      if (false === this.option(LEGACY_SCROLLING_MODE3) && -1 !== totalItemsCount) {
        const viewportParams = this.getViewportParams();
        const loadedOffset = dataOptions.loadedOffset();
        const loadedItemCount = dataOptions.loadedItemCount();
        const skip = Math.max(viewportParams.skip, loadedOffset);
        const take = Math.min(viewportParams.take, loadedItemCount);
        const endItemsCount = Math.max(totalItemsCount - (skip + take), 0);
        return {
          begin: skip,
          end: endItemsCount
        };
      }
      return this._dataLoader.virtualItemsCount.apply(this._dataLoader, arguments);
    }
    return;
  }
  getScrollingTimeout() {
    const renderAsync = this.option("scrolling.renderAsync");
    let scrollingTimeout = 0;
    if (!isDefined(renderAsync)) {
      scrollingTimeout = Math.min(this.option("scrolling.timeout") || 0, this._dataOptions.changingDuration());
      if (scrollingTimeout < this.option("scrolling.renderingThreshold")) {
        scrollingTimeout = this.option("scrolling.minTimeout") || 0;
      }
    } else if (renderAsync) {
      scrollingTimeout = this.option("scrolling.timeout") ?? 0;
    }
    return scrollingTimeout;
  }
  setViewportPosition(position) {
    const result = new Deferred();
    const scrollingTimeout = this.getScrollingTimeout();
    clearTimeout(this._scrollTimeoutID);
    if (scrollingTimeout > 0) {
      this._scrollTimeoutID = setTimeout((() => {
        this._setViewportPositionCore(position);
        result.resolve();
      }), scrollingTimeout);
    } else {
      this._setViewportPositionCore(position);
      result.resolve();
    }
    return result.promise();
  }
  getViewportPosition() {
    return this._position;
  }
  getItemIndexByPosition(position, viewportItemIndex, height) {
    position = position ?? this._position;
    const defaultItemSize = this.getItemSize();
    let offset = 0;
    let itemOffset = 0;
    const itemOffsetsWithSize = Object.keys(this._itemSizes).concat(-1);
    for (let i = 0; i < itemOffsetsWithSize.length && offset < position; i++) {
      const itemOffsetWithSize = parseInt(itemOffsetsWithSize[i]);
      let itemOffsetDiff = (position - offset) / defaultItemSize;
      if (itemOffsetWithSize < 0 || itemOffset + itemOffsetDiff < itemOffsetWithSize) {
        itemOffset += itemOffsetDiff;
        if (this._sizeRatio < 1 && isDefined(viewportItemIndex)) {
          itemOffset = viewportItemIndex + height / this._viewportItemSize;
        }
        break;
      } else {
        itemOffsetDiff = itemOffsetWithSize - itemOffset;
        offset += itemOffsetDiff * defaultItemSize;
        itemOffset += itemOffsetDiff;
      }
      const itemSize = this._itemSizes[itemOffsetWithSize];
      offset += itemSize;
      itemOffset += offset < position ? 1 : (position - offset + itemSize) / itemSize;
    }
    return Math.round(50 * itemOffset) / 50;
  }
  isScrollingBack() {
    return this._isScrollingBack;
  }
  _setViewportPositionCore(position) {
    const prevPosition = this._position || 0;
    this._position = position;
    if (prevPosition !== this._position) {
      this._isScrollingBack = this._position < prevPosition;
    }
    const itemIndex = this.getItemIndexByPosition();
    const result = this.setViewportItemIndex(itemIndex);
    this.positionChanged.fire();
    return result;
  }
  setContentItemSizes(sizes) {
    const virtualItemsCount = this.virtualItemsCount();
    this._contentSize = sizes.reduce(((a, b) => a + b), 0);
    if (virtualItemsCount) {
      sizes.forEach(((size, index) => {
        this._itemSizes[virtualItemsCount.begin + index] = size;
      }));
      const virtualContentSize = (virtualItemsCount.begin + virtualItemsCount.end + this.itemsCount()) * this._viewportItemSize;
      const contentHeightLimit = m_utils_default.getContentHeightLimit(browser_default);
      if (virtualContentSize > contentHeightLimit) {
        this._sizeRatio = contentHeightLimit / virtualContentSize;
      } else {
        this._sizeRatio = 1;
      }
    }
  }
  getItemSize() {
    return this._viewportItemSize * this._sizeRatio;
  }
  getItemOffset(itemIndex, isEnd) {
    const virtualItemsCount = this.virtualItemsCount();
    let itemCount = itemIndex;
    if (!virtualItemsCount) {
      return 0;
    }
    let offset = 0;
    const totalItemsCount = this._dataOptions.totalItemsCount();
    Object.keys(this._itemSizes).forEach(((currentItemIndex) => {
      if (!itemCount) {
        return;
      }
      if (isEnd ? currentItemIndex >= totalItemsCount - itemIndex : currentItemIndex < itemIndex) {
        offset += this._itemSizes[currentItemIndex];
        itemCount--;
      }
    }));
    return Math.floor(offset + itemCount * this._viewportItemSize * this._sizeRatio);
  }
  getContentOffset(type2) {
    const isEnd = "end" === type2;
    const virtualItemsCount = this.virtualItemsCount();
    if (!virtualItemsCount) {
      return 0;
    }
    return this.getItemOffset(isEnd ? virtualItemsCount.end : virtualItemsCount.begin, isEnd);
  }
  getVirtualContentSize() {
    const virtualItemsCount = this.virtualItemsCount();
    return virtualItemsCount ? this.getContentOffset("begin") + this.getContentOffset("end") + this._contentSize : 0;
  }
  getViewportItemIndex() {
    return this._viewportItemIndex;
  }
  setViewportItemIndex(itemIndex) {
    this._viewportItemIndex = itemIndex;
    if (false === this.option(LEGACY_SCROLLING_MODE3)) {
      return;
    }
    return this._dataLoader.viewportItemIndexChanged.apply(this._dataLoader, arguments);
  }
  viewportItemSize(size) {
    if (void 0 !== size) {
      this._viewportItemSize = size;
    }
    return this._viewportItemSize;
  }
  viewportSize(size) {
    if (void 0 !== size) {
      this._viewportSize = size;
    }
    return this._viewportSize;
  }
  viewportHeight(height, scrollTop) {
    const position = scrollTop ?? this._position;
    const begin = this.getItemIndexByPosition(position);
    const end = this.getItemIndexByPosition(position + height, begin, height);
    this.viewportSize(Math.ceil(end - begin));
    if (!isDefined(scrollTop) && this._viewportItemIndex !== begin) {
      this._setViewportPositionCore(position);
    }
  }
  reset(isRefresh) {
    this._dataLoader.reset();
    if (!isRefresh) {
      this._itemSizes = {};
    }
  }
  subscribeToWindowScrollEvents($element) {
    this._windowScroll = this._windowScroll || subscribeToExternalScrollers($element, ((scrollTop) => {
      if (this.viewportItemSize()) {
        this.setViewportPosition(scrollTop);
      }
    }));
  }
  dispose() {
    clearTimeout(this._scrollTimeoutID);
    this._windowScroll && this._windowScroll.dispose();
    this._windowScroll = null;
  }
  scrollTo(pos) {
    this._windowScroll && this._windowScroll.scrollTo(pos);
  }
  isVirtualMode() {
    return isVirtualMode(this);
  }
  isAppendMode() {
    return isAppendMode(this);
  }
  getViewportParams() {
    const virtualMode = "virtual" === this.option("scrolling.mode");
    const totalItemsCount = this._dataOptions.totalItemsCount();
    const hasKnownLastPage = this._dataOptions.hasKnownLastPage();
    const topIndex = hasKnownLastPage && this._viewportItemIndex > totalItemsCount ? totalItemsCount : this._viewportItemIndex;
    const bottomIndex = this._viewportSize + topIndex;
    const maxGap = this.option("scrolling.prerenderedRowChunkSize") || 1;
    const isScrollingBack = this.isScrollingBack();
    const minGap = this.option("scrolling.prerenderedRowCount") ?? 1;
    const topMinGap = isScrollingBack ? minGap : 0;
    const bottomMinGap = isScrollingBack ? 0 : minGap;
    const skip = Math.floor(Math.max(0, topIndex - topMinGap) / maxGap) * maxGap;
    let take = Math.ceil((bottomIndex + bottomMinGap - skip) / maxGap) * maxGap;
    if (virtualMode) {
      const remainedItems = Math.max(0, totalItemsCount - skip);
      take = Math.min(take, remainedItems);
    }
    return {
      skip,
      take
    };
  }
  itemsCount() {
    let result = 0;
    if (this.option(LEGACY_SCROLLING_MODE3)) {
      result = this._dataLoader.itemsCount.apply(this._dataLoader, arguments);
    } else {
      result = this._dataOptions.itemsCount();
    }
    return result;
  }
  pageIndex() {
    return this._dataLoader.pageIndex(...arguments);
  }
  beginPageIndex() {
    return this._dataLoader.beginPageIndex(...arguments);
  }
  endPageIndex() {
    return this._dataLoader.endPageIndex(...arguments);
  }
  pageSize() {
    return this._dataLoader.pageSize(...arguments);
  }
  load() {
    return this._dataLoader.load(...arguments);
  }
  loadIfNeed() {
    return this._dataLoader.loadIfNeed(...arguments);
  }
  handleDataChanged() {
    return this._dataLoader.handleDataChanged(...arguments);
  }
  getDelayDeferred() {
    return this._dataLoader.getDelayDeferred();
  }
};
var m_virtual_scrolling_core_default = {
  VirtualScrollController
};

// node_modules/devextreme/esm/__internal/grids/grid_core/virtual_scrolling/m_virtual_scrolling.js
var FREESPACE_CLASS = "dx-freespace-row";
var ROW_INSERTED2 = "dx-row-inserted";
var LEGACY_SCROLLING_MODE4 = "scrolling.legacyMode";
var PAGING_METHOD_NAMES = ["beginPageIndex", "endPageIndex", "pageIndex"];
var isVirtualMode2 = function(that) {
  return "virtual" === that.option("scrolling.mode");
};
var isAppendMode2 = function(that) {
  return "infinite" === that.option("scrolling.mode");
};
var isVirtualPaging = function(that) {
  return isVirtualMode2(that) || isAppendMode2(that);
};
var correctCount = function(items, count, fromEnd, isItemCountableFunc) {
  for (let i = 0; i < count + 1; i++) {
    const item = items[fromEnd ? items.length - 1 - i : i];
    if (item && !isItemCountableFunc(item, i === count, fromEnd)) {
      count++;
    }
  }
  return count;
};
var isItemCountableByDataSource = function(item, dataSource) {
  return "data" === item.rowType && !item.isNewRow || "group" === item.rowType && dataSource.isGroupItemCountable(item.data);
};
var updateItemIndices = function(items) {
  items.forEach(((item, index) => {
    item.rowIndex = index;
  }));
  return items;
};
var updateLoading = function(that) {
  const beginPageIndex = that._virtualScrollController.beginPageIndex(-1);
  if (isVirtualMode2(that)) {
    if (beginPageIndex < 0 || that.viewportSize() >= 0 && that.getViewportItemIndex() >= 0 && (beginPageIndex * that.pageSize() > that.getViewportItemIndex() || beginPageIndex * that.pageSize() + that.itemsCount() < that.getViewportItemIndex() + that.viewportSize()) && that._dataSource.isLoading()) {
      if (!that._isLoading) {
        that._isLoading = true;
        that.loadingChanged.fire(true);
      }
    } else if (that._isLoading) {
      that._isLoading = false;
      that.loadingChanged.fire(false);
    }
  }
};
var proxyDataSourceAdapterMethod = function(that, methodName, args) {
  if (false === that.option(LEGACY_SCROLLING_MODE4) && PAGING_METHOD_NAMES.includes(methodName)) {
    const dataSource = that._dataSource;
    return dataSource.pageIndex.apply(dataSource, args);
  }
  const virtualScrollController = that._virtualScrollController;
  return virtualScrollController[methodName].apply(virtualScrollController, args);
};
var removeEmptyRows = function($emptyRows, className) {
  const tBodies = $emptyRows.toArray().map(((row) => renderer_default(row).parent(`.${className}`).get(0))).filter(((row) => row));
  if (tBodies.length) {
    $emptyRows = renderer_default(tBodies);
  }
  const rowCount = className === FREESPACE_CLASS ? $emptyRows.length - 1 : $emptyRows.length;
  for (let i = 0; i < rowCount; i++) {
    $emptyRows.eq(i).remove();
  }
};
var dataSourceAdapterExtender2 = (Base) => class extends Base {
  init() {
    super.init.apply(this, arguments);
    this._items = [];
    this._totalCount = -1;
    this._isLoaded = true;
    this._loadPageCount = 1;
    this._virtualScrollController = new VirtualScrollController(this.component, this._getVirtualScrollDataOptions());
  }
  dispose() {
    this._virtualScrollController.dispose();
    super.dispose.apply(this, arguments);
  }
  _getVirtualScrollDataOptions() {
    const that = this;
    return {
      pageSize: () => that.pageSize(),
      totalItemsCount: () => that.totalItemsCount(),
      hasKnownLastPage: () => that.hasKnownLastPage(),
      pageIndex: (index) => that._dataSource.pageIndex(index),
      isLoading: () => that._dataSource.isLoading() && !that.isCustomLoading(),
      pageCount: () => that.pageCount(),
      load: () => that._dataSource.load(),
      updateLoading() {
        updateLoading(that);
      },
      itemsCount: () => that.itemsCount(true),
      items: () => that._dataSource.items(),
      viewportItems(items) {
        if (items) {
          that._items = items;
        }
        return that._items;
      },
      onChanged(e) {
        that.changed.fire(e);
      },
      changingDuration() {
        if (that.isLoading()) {
          return 300;
        }
        return that._renderTime || 0;
      }
    };
  }
  _handleLoadingChanged(isLoading) {
    if (false === this.option(LEGACY_SCROLLING_MODE4)) {
      super._handleLoadingChanged.apply(this, arguments);
      return;
    }
    if (!isVirtualMode2(this) || this._isLoadingAll) {
      this._isLoading = isLoading;
      super._handleLoadingChanged.apply(this, arguments);
    }
    if (isLoading) {
      this._startLoadTime = /* @__PURE__ */ new Date();
    } else {
      this._startLoadTime = void 0;
    }
  }
  _handleLoadError() {
    if (false !== this.option(LEGACY_SCROLLING_MODE4)) {
      this._isLoading = false;
      this.loadingChanged.fire(false);
    }
    super._handleLoadError.apply(this, arguments);
  }
  _handleDataChanged(e) {
    if (false === this.option(LEGACY_SCROLLING_MODE4)) {
      this._items = this._dataSource.items().slice();
      this._totalCount = this._dataSourceTotalCount(true);
      super._handleDataChanged.apply(this, arguments);
      return;
    }
    const callBase = super._handleDataChanged.bind(this);
    this._virtualScrollController.handleDataChanged(callBase, e);
  }
  _customizeRemoteOperations(options, operationTypes) {
    const newMode = false === this.option(LEGACY_SCROLLING_MODE4);
    let renderAsync = this.option("scrolling.renderAsync");
    if (!isDefined(renderAsync)) {
      renderAsync = this._renderTime >= this.option("scrolling.renderingThreshold");
    }
    if ((isVirtualMode2(this) || isAppendMode2(this) && newMode) && !operationTypes.reload && (operationTypes.skip || newMode) && !renderAsync) {
      options.delay = void 0;
    }
    super._customizeRemoteOperations.apply(this, arguments);
  }
  items() {
    return this._items;
  }
  _dataSourceTotalCount(isBase) {
    return false === this.option(LEGACY_SCROLLING_MODE4) && isVirtualMode2(this) && !isBase ? this._totalCount : super._dataSourceTotalCount();
  }
  itemsCount(isBase) {
    if (isBase || false === this.option(LEGACY_SCROLLING_MODE4)) {
      return super.itemsCount();
    }
    return this._virtualScrollController.itemsCount();
  }
  load(loadOptions) {
    if (false === this.option(LEGACY_SCROLLING_MODE4) || loadOptions) {
      return super.load(loadOptions);
    }
    return this._virtualScrollController.load();
  }
  isLoading() {
    return false === this.option(LEGACY_SCROLLING_MODE4) ? this._dataSource.isLoading() : this._isLoading;
  }
  isLoaded() {
    return this._dataSource.isLoaded() && this._isLoaded;
  }
  resetPagesCache(isLiveUpdate) {
    if (!isLiveUpdate) {
      this._virtualScrollController.reset(true);
    }
    super.resetPagesCache.apply(this, arguments);
  }
  _changeRowExpandCore() {
    const result = super._changeRowExpandCore.apply(this, arguments);
    if (false === this.option(LEGACY_SCROLLING_MODE4)) {
      return result;
    }
    this.resetPagesCache();
    updateLoading(this);
    return result;
  }
  reload() {
    this._dataSource.pageIndex(this.pageIndex());
    const virtualScrollController = this._virtualScrollController;
    if (false !== this.option(LEGACY_SCROLLING_MODE4) && virtualScrollController) {
      const d = new Deferred();
      super.reload.apply(this, arguments).done(((r) => {
        const delayDeferred = virtualScrollController.getDelayDeferred();
        if (delayDeferred) {
          delayDeferred.done(d.resolve).fail(d.reject);
        } else {
          d.resolve(r);
        }
      })).fail(d.reject);
      return d;
    }
    return super.reload.apply(this, arguments);
  }
  refresh(options, operationTypes) {
    if (false !== this.option(LEGACY_SCROLLING_MODE4)) {
      const {
        storeLoadOptions
      } = options;
      const dataSource = this._dataSource;
      if (operationTypes.reload) {
        this._virtualScrollController.reset();
        dataSource.items().length = 0;
        this._isLoaded = false;
        updateLoading(this);
        this._isLoaded = true;
        if (isAppendMode2(this)) {
          this.pageIndex(0);
          dataSource.pageIndex(0);
          storeLoadOptions.pageIndex = 0;
          options.pageIndex = 0;
          storeLoadOptions.skip = 0;
        } else {
          dataSource.pageIndex(this.pageIndex());
          if (dataSource.paginate()) {
            options.pageIndex = this.pageIndex();
            storeLoadOptions.skip = this.pageIndex() * this.pageSize();
          }
        }
      } else if (isAppendMode2(this) && storeLoadOptions.skip && this._totalCountCorrection < 0) {
        storeLoadOptions.skip += this._totalCountCorrection;
      }
    }
    return super.refresh.apply(this, arguments);
  }
  loadPageCount(count) {
    if (!isDefined(count)) {
      return this._loadPageCount;
    }
    this._loadPageCount = count;
  }
  _handleDataLoading(options) {
    const loadPageCount = this.loadPageCount();
    const pageSize = this.pageSize();
    const newMode = false === this.option(LEGACY_SCROLLING_MODE4);
    const {
      storeLoadOptions
    } = options;
    const takeIsDefined = isDefined(storeLoadOptions.take);
    options.loadPageCount = loadPageCount;
    if (!options.isCustomLoading && newMode && takeIsDefined && loadPageCount > 1 && pageSize > 0) {
      storeLoadOptions.take = loadPageCount * pageSize;
    }
    super._handleDataLoading.apply(this, arguments);
  }
  _loadPageSize() {
    return super._loadPageSize.apply(this, arguments) * this.loadPageCount();
  }
  beginPageIndex() {
    return proxyDataSourceAdapterMethod(this, "beginPageIndex", [...arguments]);
  }
  endPageIndex() {
    return proxyDataSourceAdapterMethod(this, "endPageIndex", [...arguments]);
  }
  pageIndex(pageIndex) {
    return proxyDataSourceAdapterMethod(this, "pageIndex", [...arguments]);
  }
  virtualItemsCount() {
    return proxyDataSourceAdapterMethod(this, "virtualItemsCount", [...arguments]);
  }
  getContentOffset() {
    return proxyDataSourceAdapterMethod(this, "getContentOffset", [...arguments]);
  }
  getVirtualContentSize() {
    return proxyDataSourceAdapterMethod(this, "getVirtualContentSize", [...arguments]);
  }
  setContentItemSizes() {
    return proxyDataSourceAdapterMethod(this, "setContentItemSizes", [...arguments]);
  }
  setViewportPosition() {
    return proxyDataSourceAdapterMethod(this, "setViewportPosition", [...arguments]);
  }
  getViewportItemIndex() {
    return proxyDataSourceAdapterMethod(this, "getViewportItemIndex", [...arguments]);
  }
  setViewportItemIndex(viewportItemIndex) {
    return proxyDataSourceAdapterMethod(this, "setViewportItemIndex", [...arguments]);
  }
  getItemIndexByPosition() {
    return proxyDataSourceAdapterMethod(this, "getItemIndexByPosition", [...arguments]);
  }
  viewportSize() {
    return proxyDataSourceAdapterMethod(this, "viewportSize", [...arguments]);
  }
  viewportItemSize() {
    return proxyDataSourceAdapterMethod(this, "viewportItemSize", [...arguments]);
  }
  getItemSize() {
    return proxyDataSourceAdapterMethod(this, "getItemSize", [...arguments]);
  }
  getItemSizes() {
    return proxyDataSourceAdapterMethod(this, "getItemSizes", [...arguments]);
  }
  loadIfNeed() {
    return proxyDataSourceAdapterMethod(this, "loadIfNeed", [...arguments]);
  }
};
var data7 = (Base) => class extends Base {
  dispose() {
    const rowsScrollController = this._rowsScrollController;
    rowsScrollController && rowsScrollController.dispose();
    super.dispose.apply(this, arguments);
  }
  _refreshDataSource() {
    const baseResult = super._refreshDataSource.apply(this, arguments) || new Deferred().resolve().promise();
    baseResult.done(this.initVirtualRows.bind(this));
    return baseResult;
  }
  _loadDataSource() {
    if (this._rowsScrollController && isVirtualPaging(this)) {
      var _this$_dataSource;
      const {
        loadPageCount
      } = isDefined(this._loadViewportParams) ? this.getLoadPageParams() : {
        loadPageCount: 0
      };
      loadPageCount >= 1 && (null === (_this$_dataSource = this._dataSource) || void 0 === _this$_dataSource ? void 0 : _this$_dataSource.loadPageCount(loadPageCount));
    }
    return super._loadDataSource.apply(this, arguments);
  }
  getRowPageSize() {
    const rowPageSize = this.option("scrolling.rowPageSize");
    const pageSize = this.pageSize();
    return pageSize && pageSize < rowPageSize ? pageSize : rowPageSize;
  }
  reload() {
    const rowsScrollController = this._rowsScrollController || this._dataSource;
    const itemIndex = null === rowsScrollController || void 0 === rowsScrollController ? void 0 : rowsScrollController.getItemIndexByPosition();
    const result = super.reload.apply(this, arguments);
    return null === result || void 0 === result ? void 0 : result.done((() => {
      if (isVirtualMode2(this) || m_utils_default.isVirtualRowRendering(this)) {
        const rowIndexOffset = this.getRowIndexOffset();
        const rowIndex = Math.floor(itemIndex) - rowIndexOffset;
        const {
          component
        } = this;
        const scrollable = component.getScrollable && component.getScrollable();
        const isSortingOperation = this.dataSource().operationTypes().sorting;
        if (scrollable && !isSortingOperation && rowIndex >= 0) {
          var _$rowElement$position;
          const rowElement = component.getRowElement(rowIndex);
          const $rowElement = (null === rowElement || void 0 === rowElement ? void 0 : rowElement[0]) && renderer_default(rowElement[0]);
          let top = null === $rowElement || void 0 === $rowElement || null === (_$rowElement$position = $rowElement.position()) || void 0 === _$rowElement$position ? void 0 : _$rowElement$position.top;
          const isChromeLatest = browser_default.chrome && Number(browser_default.version ?? 0) >= 91;
          const allowedTopOffset = browser_default.mozilla || isChromeLatest ? 1 : 0;
          if (top && top > allowedTopOffset) {
            top = Math.round(top + getOuterHeight($rowElement) * (itemIndex % 1));
            scrollable.scrollTo({
              y: top
            });
          }
        }
      }
    }));
  }
  initVirtualRows() {
    const virtualRowsRendering = m_utils_default.isVirtualRowRendering(this);
    this._allItems = null;
    this._loadViewportParams = null;
    if ("virtual" !== this.option("scrolling.mode") && !virtualRowsRendering || !virtualRowsRendering || false !== this.option(LEGACY_SCROLLING_MODE4) && !this.option("scrolling.rowPageSize")) {
      this._visibleItems = null;
      this._rowsScrollController = null;
      return;
    }
    const pageIndex = !isVirtualMode2(this) && this.pageIndex() >= this.pageCount() ? this.pageCount() - 1 : this.pageIndex();
    this._rowPageIndex = Math.ceil(pageIndex * this.pageSize() / this.getRowPageSize());
    this._visibleItems = false === this.option(LEGACY_SCROLLING_MODE4) ? null : [];
    this._viewportChanging = false;
    this._needUpdateViewportAfterLoading = false;
    if (!this._rowsScrollController) {
      this._rowsScrollController = new VirtualScrollController(this.component, this._getRowsScrollDataOptions(), true);
      this._rowsScrollController.positionChanged.add((() => {
        var _this$_dataSource2;
        if (false === this.option(LEGACY_SCROLLING_MODE4)) {
          this._viewportChanging = true;
          this.loadViewport();
          this._viewportChanging = false;
          return;
        }
        null === (_this$_dataSource2 = this._dataSource) || void 0 === _this$_dataSource2 || _this$_dataSource2.setViewportItemIndex(this._rowsScrollController.getViewportItemIndex());
      }));
    }
    if (false === this.option(LEGACY_SCROLLING_MODE4)) {
      this._updateLoadViewportParams();
    }
    if (this.isLoaded() && false !== this.option(LEGACY_SCROLLING_MODE4)) {
      this._rowsScrollController.load();
    }
  }
  isViewportChanging() {
    return this._viewportChanging;
  }
  _getRowsScrollDataOptions() {
    const that = this;
    const isItemCountable = function(item) {
      return isItemCountableByDataSource(item, that._dataSource);
    };
    return {
      pageSize: () => that.getRowPageSize(),
      loadedOffset() {
        var _that$_dataSource;
        return isVirtualMode2(that) && (null === (_that$_dataSource = that._dataSource) || void 0 === _that$_dataSource ? void 0 : _that$_dataSource.lastLoadOptions().skip) || 0;
      },
      loadedItemCount: () => that._itemCount,
      totalItemsCount() {
        if (isVirtualPaging(that)) {
          return that.totalItemsCount();
        }
        return false === that.option(LEGACY_SCROLLING_MODE4) ? that._itemCount : that._items.filter(isItemCountable).length;
      },
      hasKnownLastPage: () => false === that.option(LEGACY_SCROLLING_MODE4) ? that.hasKnownLastPage() : true,
      pageIndex(index) {
        if (void 0 !== index) {
          that._rowPageIndex = index;
        }
        return that._rowPageIndex;
      },
      isLoading: () => that.isLoading(),
      pageCount() {
        const pageCount = Math.ceil(this.totalItemsCount() / this.pageSize());
        return pageCount || 1;
      },
      load() {
        if (that._rowsScrollController.pageIndex() >= this.pageCount()) {
          that._rowPageIndex = this.pageCount() - 1;
          that._rowsScrollController.pageIndex(that._rowPageIndex);
        }
        if (!this.items().length && this.totalItemsCount()) {
          return;
        }
        that._rowsScrollController.handleDataChanged(((change) => {
          change = change || {};
          change.changeType = change.changeType || "refresh";
          change.items = change.items || that._visibleItems;
          that._visibleItems.forEach(((item, index) => {
            item.rowIndex = index;
          }));
          that._fireChanged(change);
        }));
      },
      updateLoading() {
      },
      itemsCount() {
        return this.items(true).length;
      },
      correctCount: (items, count, fromEnd) => correctCount(items, count, fromEnd, ((item, isNextAfterLast, fromEnd2) => {
        if (item.isNewRow) {
          return isNextAfterLast && !fromEnd2;
        }
        if (isNextAfterLast && fromEnd2) {
          return !item.isNewRow;
        }
        return isItemCountable(item);
      })),
      items(countableOnly) {
        let result = that._items;
        if (that.option(LEGACY_SCROLLING_MODE4)) {
          const dataSource = that.dataSource();
          const virtualItemsCount = null === dataSource || void 0 === dataSource ? void 0 : dataSource.virtualItemsCount();
          const begin = virtualItemsCount ? virtualItemsCount.begin : 0;
          const rowPageSize = that.getRowPageSize();
          let skip = that._rowPageIndex * rowPageSize - begin;
          let take = rowPageSize;
          if (skip < 0) {
            return [];
          }
          if (skip) {
            skip = this.correctCount(result, skip);
            result = result.slice(skip);
          }
          if (take) {
            take = this.correctCount(result, take);
            result = result.slice(0, take);
          }
        }
        return countableOnly ? result.filter(isItemCountable) : result;
      },
      viewportItems(items) {
        if (items && false !== that.option(LEGACY_SCROLLING_MODE4)) {
          that._visibleItems = items;
        }
        return that._visibleItems;
      },
      onChanged() {
      },
      changingDuration() {
        const dataSource = that.dataSource();
        if (null !== dataSource && void 0 !== dataSource && dataSource.isLoading() && false !== that.option(LEGACY_SCROLLING_MODE4)) {
          return 300;
        }
        return (null === dataSource || void 0 === dataSource ? void 0 : dataSource._renderTime) || 0;
      }
    };
  }
  _updateItemsCore(change) {
    const delta = this.getRowIndexDelta();
    super._updateItemsCore.apply(this, arguments);
    if (false === this.option(LEGACY_SCROLLING_MODE4) && m_utils_default.isVirtualRowRendering(this)) {
      if ("update" === change.changeType && 0 === change.rowIndices.length && change.cancelEmptyChanges) {
        change.cancel = true;
      }
      return;
    }
    const rowsScrollController = this._rowsScrollController;
    if (rowsScrollController) {
      const visibleItems = this._visibleItems;
      const isRefresh = "refresh" === change.changeType || change.isLiveUpdate;
      if ("append" === change.changeType && change.items && !change.items.length) {
        return;
      }
      if (isRefresh || "append" === change.changeType || "prepend" === change.changeType) {
        change.cancel = true;
        isRefresh && rowsScrollController.reset(true);
        rowsScrollController.load();
      } else {
        if ("update" === change.changeType) {
          change.rowIndices.forEach(((rowIndex, index) => {
            const changeType = change.changeTypes[index];
            const newItem = change.items[index];
            if ("update" === changeType) {
              visibleItems[rowIndex] = newItem;
            } else if ("insert" === changeType) {
              visibleItems.splice(rowIndex, 0, newItem);
            } else if ("remove" === changeType) {
              visibleItems.splice(rowIndex, 1);
            }
          }));
        } else {
          visibleItems.forEach(((item, index) => {
            visibleItems[index] = this._items[index + delta] || visibleItems[index];
          }));
          change.items = visibleItems;
        }
        updateItemIndices(visibleItems);
      }
    }
  }
  _updateLoadViewportParams() {
    const viewportParams = this._rowsScrollController.getViewportParams();
    const pageSize = this.pageSize();
    if (viewportParams && !isVirtualPaging(this) && pageSize > 0) {
      const pageOffset = this.pageIndex() * pageSize;
      viewportParams.skip += pageOffset;
    }
    this._loadViewportParams = viewportParams;
  }
  _processItems() {
    const resultItems = super._processItems.apply(this, arguments);
    if (false === this.option(LEGACY_SCROLLING_MODE4)) {
      const dataSource = this._dataSource;
      let currentIndex = (null === dataSource || void 0 === dataSource ? void 0 : dataSource.lastLoadOptions().skip) ?? 0;
      let prevCountable;
      let prevRowType;
      let isPrevRowNew;
      let wasCountableItem = false;
      let newRows = [];
      resultItems.forEach(((item) => {
        const {
          rowType
        } = item;
        const itemCountable = isItemCountableByDataSource(item, dataSource);
        const isNextGroupItem = "group" === rowType && (prevCountable || itemCountable || "group" !== prevRowType && currentIndex > 0);
        const isNextDataItem = "data" === rowType && itemCountable && (prevCountable || "group" !== prevRowType);
        if (!item.isNewRow && isDefined(prevCountable)) {
          const isPrevNewRowFirst = isPrevRowNew && !wasCountableItem;
          if ((isNextGroupItem || isNextDataItem) && !isPrevNewRowFirst) {
            currentIndex++;
          }
        }
        if (isNextGroupItem || isNextDataItem) {
          wasCountableItem = true;
        }
        if (item.isNewRow) {
          newRows.push(item);
        } else {
          newRows.forEach(((it) => {
            it.loadIndex = currentIndex;
          }));
          newRows = [];
        }
        item.loadIndex = currentIndex;
        prevCountable = itemCountable;
        prevRowType = rowType;
        isPrevRowNew = item.isNewRow;
      }));
      newRows.forEach(((it) => {
        it.loadIndex = currentIndex;
      }));
    }
    return resultItems;
  }
  _afterProcessItems(items) {
    this._itemCount = items.filter(((item) => isItemCountableByDataSource(item, this._dataSource))).length;
    if (isDefined(this._loadViewportParams)) {
      this._updateLoadViewportParams();
      let result = items;
      this._allItems = items;
      if (items.length) {
        const {
          skipForCurrentPage
        } = this.getLoadPageParams(true);
        const skip = items[0].loadIndex + skipForCurrentPage;
        const {
          take
        } = this._loadViewportParams;
        result = items.filter(((it) => {
          const isNewRowInEmptyData = it.isNewRow && it.loadIndex === skip && 0 === take;
          const isLoadIndexGreaterStart = it.loadIndex >= skip;
          const isLoadIndexLessEnd = it.loadIndex < skip + take || isNewRowInEmptyData;
          return isLoadIndexGreaterStart && isLoadIndexLessEnd;
        }));
      }
      return result;
    }
    return super._afterProcessItems.apply(this, arguments);
  }
  _applyChange(change) {
    const that = this;
    const {
      items
    } = change;
    const {
      changeType
    } = change;
    let {
      removeCount
    } = change;
    if (removeCount) {
      const fromEnd = "prepend" === changeType;
      removeCount = correctCount(that._items, removeCount, fromEnd, ((item, isNextAfterLast) => "data" === item.rowType && !item.isNewRow || "group" === item.rowType && (that._dataSource.isGroupItemCountable(item.data) || isNextAfterLast)));
      change.removeCount = removeCount;
    }
    switch (changeType) {
      case "prepend":
        that._items.unshift.apply(that._items, items);
        if (removeCount) {
          that._items.splice(-removeCount);
        }
        break;
      case "append":
        that._items.push.apply(that._items, items);
        if (removeCount) {
          that._items.splice(0, removeCount);
        }
        break;
      default:
        super._applyChange(change);
    }
  }
  items(allItems) {
    return allItems ? this._allItems || this._items : this._visibleItems || this._items;
  }
  getRowIndexDelta() {
    let delta = 0;
    if (this.option(LEGACY_SCROLLING_MODE4)) {
      const visibleItems = this._visibleItems;
      if (null !== visibleItems && void 0 !== visibleItems && visibleItems[0]) {
        delta = this._items.indexOf(visibleItems[0]);
      }
    }
    return delta < 0 ? 0 : delta;
  }
  getRowIndexOffset(byLoadedRows, needGroupOffset) {
    let offset = 0;
    const dataSource = this.dataSource();
    const rowsScrollController = this._rowsScrollController;
    const newMode = false === this.option(LEGACY_SCROLLING_MODE4);
    const virtualPaging = isVirtualPaging(this);
    if (rowsScrollController && !byLoadedRows) {
      if (newMode && isDefined(this._loadViewportParams)) {
        const {
          skipForCurrentPage,
          pageIndex
        } = this.getLoadPageParams(true);
        const items = this.items(true);
        offset = virtualPaging ? pageIndex * this.pageSize() : 0;
        if (items.length) {
          const firstLoadIndex = items[0].loadIndex;
          offset += items.filter(((item) => item.loadIndex < firstLoadIndex + skipForCurrentPage)).length;
        }
      } else {
        offset = rowsScrollController.beginPageIndex() * rowsScrollController.pageSize();
      }
    } else if (virtualPaging && newMode && dataSource) {
      var _lastLoadOptions$skip;
      const lastLoadOptions = dataSource.lastLoadOptions();
      if (needGroupOffset && null !== (_lastLoadOptions$skip = lastLoadOptions.skips) && void 0 !== _lastLoadOptions$skip && _lastLoadOptions$skip.length) {
        offset = lastLoadOptions.skips.reduce(((res, skip) => res + skip), 0);
      } else {
        offset = lastLoadOptions.skip ?? 0;
      }
    } else if (isVirtualMode2(this) && dataSource) {
      offset = dataSource.beginPageIndex() * dataSource.pageSize();
    }
    return offset;
  }
  getDataIndex() {
    if (false === this.option(LEGACY_SCROLLING_MODE4)) {
      return this.getRowIndexOffset(true, true);
    }
    return super.getDataIndex.apply(this, arguments);
  }
  viewportSize() {
    const rowsScrollController = this._rowsScrollController;
    const dataSource = this._dataSource;
    const result = null === rowsScrollController || void 0 === rowsScrollController ? void 0 : rowsScrollController.viewportSize.apply(rowsScrollController, arguments);
    if (false === this.option(LEGACY_SCROLLING_MODE4)) {
      return result;
    }
    return null === dataSource || void 0 === dataSource ? void 0 : dataSource.viewportSize.apply(dataSource, arguments);
  }
  viewportHeight(height, scrollTop) {
    var _this$_rowsScrollCont;
    null === (_this$_rowsScrollCont = this._rowsScrollController) || void 0 === _this$_rowsScrollCont || _this$_rowsScrollCont.viewportHeight(height, scrollTop);
  }
  viewportItemSize() {
    const rowsScrollController = this._rowsScrollController;
    const dataSource = this._dataSource;
    const result = null === rowsScrollController || void 0 === rowsScrollController ? void 0 : rowsScrollController.viewportItemSize.apply(rowsScrollController, arguments);
    if (false === this.option(LEGACY_SCROLLING_MODE4)) {
      return result;
    }
    return null === dataSource || void 0 === dataSource ? void 0 : dataSource.viewportItemSize.apply(dataSource, arguments);
  }
  setViewportPosition() {
    const rowsScrollController = this._rowsScrollController;
    const dataSource = this._dataSource;
    this._isPaging = false;
    if (rowsScrollController) {
      rowsScrollController.setViewportPosition.apply(rowsScrollController, arguments);
    } else {
      null === dataSource || void 0 === dataSource || dataSource.setViewportPosition.apply(dataSource, arguments);
    }
  }
  setContentItemSizes(sizes) {
    const rowsScrollController = this._rowsScrollController;
    const dataSource = this._dataSource;
    const result = null === rowsScrollController || void 0 === rowsScrollController ? void 0 : rowsScrollController.setContentItemSizes(sizes);
    if (false === this.option(LEGACY_SCROLLING_MODE4)) {
      return result;
    }
    return null === dataSource || void 0 === dataSource ? void 0 : dataSource.setContentItemSizes(sizes);
  }
  getPreloadedRowCount() {
    const preloadCount = this.option("scrolling.preloadedRowCount");
    const preloadEnabled = this.option("scrolling.preloadEnabled");
    if (isDefined(preloadCount)) {
      return preloadCount;
    }
    const viewportSize = this.viewportSize();
    return preloadEnabled ? 2 * viewportSize : viewportSize;
  }
  getLoadPageParams(byLoadedPage) {
    var _this$_dataSource3, _this$_dataSource4;
    const pageSize = this.pageSize();
    const viewportParams = this._loadViewportParams;
    const lastLoadOptions = null === (_this$_dataSource3 = this._dataSource) || void 0 === _this$_dataSource3 ? void 0 : _this$_dataSource3.lastLoadOptions();
    const loadedPageIndex = (null === lastLoadOptions || void 0 === lastLoadOptions ? void 0 : lastLoadOptions.pageIndex) || 0;
    const loadedTake = (null === lastLoadOptions || void 0 === lastLoadOptions ? void 0 : lastLoadOptions.take) || 0;
    const isScrollingBack = this._rowsScrollController.isScrollingBack();
    const topPreloadCount = isScrollingBack ? this.getPreloadedRowCount() : 0;
    const bottomPreloadCount = isScrollingBack ? 0 : this.getPreloadedRowCount();
    const totalCountCorrection = (null === (_this$_dataSource4 = this._dataSource) || void 0 === _this$_dataSource4 ? void 0 : _this$_dataSource4.totalCountCorrection()) || 0;
    const skipWithPreload = Math.max(0, viewportParams.skip - topPreloadCount);
    const pageIndex = byLoadedPage ? loadedPageIndex : Math.floor(pageSize ? skipWithPreload / pageSize : 0);
    const pageOffset = pageIndex * pageSize;
    const skipForCurrentPage = viewportParams.skip - pageOffset;
    const loadingTake = viewportParams.take + skipForCurrentPage + bottomPreloadCount - totalCountCorrection;
    const take = byLoadedPage ? loadedTake : loadingTake;
    const loadPageCount = Math.ceil(pageSize ? take / pageSize : 0);
    return {
      pageIndex,
      loadPageCount: Math.max(1, loadPageCount),
      skipForCurrentPage: Math.max(0, skipForCurrentPage)
    };
  }
  _updateVisiblePageIndex(currentPageIndex) {
    if (!this._rowsScrollController) {
      return;
    }
    if (isDefined(currentPageIndex)) {
      this._silentOption("paging.pageIndex", currentPageIndex);
      this.pageChanged.fire();
      return;
    }
    const viewPortItemIndex = this._rowsScrollController.getViewportItemIndex();
    const newPageIndex = Math.floor(viewPortItemIndex / this.pageSize());
    if (this.pageIndex() !== newPageIndex) {
      this._silentOption("paging.pageIndex", newPageIndex);
      this.updateItems({
        changeType: "pageIndex"
      });
    }
  }
  _getChangedLoadParams() {
    const loadedPageParams = this.getLoadPageParams(true);
    const {
      pageIndex,
      loadPageCount
    } = this.getLoadPageParams();
    const pageIndexIsValid = this._pageIndexIsValid(pageIndex);
    let result = null;
    if (!this._isLoading && pageIndexIsValid && (pageIndex !== loadedPageParams.pageIndex || loadPageCount !== loadedPageParams.loadPageCount)) {
      result = {
        pageIndex,
        loadPageCount
      };
    }
    return result;
  }
  _pageIndexIsValid(pageIndex) {
    let result = true;
    if (isAppendMode2(this) && this.hasKnownLastPage() || isVirtualMode2(this)) {
      result = pageIndex * this.pageSize() < this.totalItemsCount();
    }
    return result;
  }
  _loadItems(checkLoading, viewportIsFilled) {
    const virtualPaging = isVirtualPaging(this);
    const dataSourceAdapter = this._dataSource;
    const changedParams = this._getChangedLoadParams();
    const currentLoadPageCount = (null === dataSourceAdapter || void 0 === dataSourceAdapter ? void 0 : dataSourceAdapter.loadPageCount()) ?? 0;
    const lastRequiredItemCount = this.pageSize() * currentLoadPageCount;
    const currentPageIndex = (null === dataSourceAdapter || void 0 === dataSourceAdapter ? void 0 : dataSourceAdapter.pageIndex()) ?? 0;
    const pageIndexNotChanged = (null === changedParams || void 0 === changedParams ? void 0 : changedParams.pageIndex) === currentPageIndex;
    const allLoadedInAppendMode = isAppendMode2(this) && this.totalItemsCount() < lastRequiredItemCount;
    const isRepaintMode = "repaint" === this.option("editing.refreshMode");
    const pageIndexIncreased = (null === changedParams || void 0 === changedParams ? void 0 : changedParams.pageIndex) > currentPageIndex;
    let result = false;
    if (!dataSourceAdapter || virtualPaging && checkLoading && (isRepaintMode && viewportIsFilled || pageIndexIncreased || pageIndexNotChanged && allLoadedInAppendMode)) {
      return result;
    }
    if (virtualPaging && this._isLoading) {
      this._needUpdateViewportAfterLoading = true;
    }
    if (virtualPaging && changedParams) {
      result = true;
      dataSourceAdapter.pageIndex(changedParams.pageIndex);
      dataSourceAdapter.loadPageCount(changedParams.loadPageCount);
      this._repaintChangesOnly = true;
      this._needUpdateDimensions = true;
      const viewportChanging = this._viewportChanging;
      this.load().always((() => {
        this._repaintChangesOnly = void 0;
        this._needUpdateDimensions = void 0;
      })).done((() => {
        const isLastPage = this.pageCount() > 0 && this.pageIndex() === this.pageCount() - 1;
        (viewportChanging || isLastPage) && this._updateVisiblePageIndex();
        if (this._needUpdateViewportAfterLoading) {
          this._needUpdateViewportAfterLoading = false;
          this.loadViewport({
            checkLoadedParamsOnly: true
          });
        }
      }));
    }
    return result;
  }
  loadViewport(params) {
    const {
      checkLoadedParamsOnly,
      checkLoading,
      viewportIsNotFilled
    } = params ?? {};
    const virtualPaging = isVirtualPaging(this);
    if (virtualPaging || m_utils_default.isVirtualRowRendering(this)) {
      var _this$_dataSource5;
      this._updateLoadViewportParams();
      const loadingItemsStarted = this._loadItems(checkLoading, !viewportIsNotFilled);
      const isCustomLoading = null === (_this$_dataSource5 = this._dataSource) || void 0 === _this$_dataSource5 ? void 0 : _this$_dataSource5.isCustomLoading();
      const isLoading = checkLoading && !isCustomLoading && this._isLoading;
      const needToUpdateItems = !(loadingItemsStarted || isLoading || checkLoadedParamsOnly);
      if (needToUpdateItems) {
        var _this$_editingControl;
        const noPendingChangesInEditing = !(null !== (_this$_editingControl = this._editingController) && void 0 !== _this$_editingControl && null !== (_this$_editingControl = _this$_editingControl.getChanges()) && void 0 !== _this$_editingControl && _this$_editingControl.length);
        this.updateItems({
          repaintChangesOnly: true,
          needUpdateDimensions: true,
          useProcessedItemsCache: noPendingChangesInEditing,
          cancelEmptyChanges: true
        });
      }
    }
  }
  updateViewport() {
    var _this$_loadViewportPa;
    const viewportSize = this.viewportSize();
    const itemCount = this.items().length;
    const viewportIsNotFilled = viewportSize > itemCount;
    const currentTake = (null === (_this$_loadViewportPa = this._loadViewportParams) || void 0 === _this$_loadViewportPa ? void 0 : _this$_loadViewportPa.take) ?? 0;
    const rowsScrollController = this._rowsScrollController;
    const newTake = null === rowsScrollController || void 0 === rowsScrollController ? void 0 : rowsScrollController.getViewportParams().take;
    (viewportIsNotFilled || currentTake < newTake) && !this._isPaging && itemCount && this.loadViewport({
      checkLoading: true,
      viewportIsNotFilled
    });
  }
  loadIfNeed() {
    if (false === this.option(LEGACY_SCROLLING_MODE4)) {
      return;
    }
    const rowsScrollController = this._rowsScrollController;
    rowsScrollController && rowsScrollController.loadIfNeed();
    const dataSource = this._dataSource;
    return null === dataSource || void 0 === dataSource ? void 0 : dataSource.loadIfNeed();
  }
  getItemSize() {
    const rowsScrollController = this._rowsScrollController;
    if (rowsScrollController) {
      return rowsScrollController.getItemSize.apply(rowsScrollController, arguments);
    }
    const dataSource = this._dataSource;
    return null === dataSource || void 0 === dataSource ? void 0 : dataSource.getItemSize.apply(dataSource, arguments);
  }
  getItemSizes() {
    const rowsScrollController = this._rowsScrollController;
    if (rowsScrollController) {
      return rowsScrollController.getItemSizes.apply(rowsScrollController, arguments);
    }
    const dataSource = this._dataSource;
    return null === dataSource || void 0 === dataSource ? void 0 : dataSource.getItemSizes.apply(dataSource, arguments);
  }
  getContentOffset() {
    const rowsScrollController = this._rowsScrollController;
    if (rowsScrollController) {
      return rowsScrollController.getContentOffset.apply(rowsScrollController, arguments);
    }
    const dataSource = this._dataSource;
    return null === dataSource || void 0 === dataSource ? void 0 : dataSource.getContentOffset.apply(dataSource, arguments);
  }
  refresh(options) {
    const dataSource = this._dataSource;
    if (dataSource && null !== options && void 0 !== options && options.load && isAppendMode2(this)) {
      dataSource.resetCurrentTotalCount();
    }
    return super.refresh.apply(this, arguments);
  }
  topItemIndex() {
    var _this$_loadViewportPa2;
    return null === (_this$_loadViewportPa2 = this._loadViewportParams) || void 0 === _this$_loadViewportPa2 ? void 0 : _this$_loadViewportPa2.skip;
  }
  bottomItemIndex() {
    const viewportParams = this._loadViewportParams;
    return viewportParams && viewportParams.skip + viewportParams.take;
  }
  virtualItemsCount() {
    const rowsScrollController = this._rowsScrollController;
    if (rowsScrollController) {
      return rowsScrollController.virtualItemsCount.apply(rowsScrollController, arguments);
    }
    const dataSource = this._dataSource;
    return null === dataSource || void 0 === dataSource ? void 0 : dataSource.virtualItemsCount.apply(dataSource, arguments);
  }
  pageIndex(pageIndex) {
    const virtualPaging = isVirtualPaging(this);
    const rowsScrollController = this._rowsScrollController;
    if (false === this.option(LEGACY_SCROLLING_MODE4) && virtualPaging && rowsScrollController) {
      if (void 0 === pageIndex) {
        return this.option("paging.pageIndex") ?? 0;
      }
    }
    return super.pageIndex.apply(this, arguments);
  }
  _fireChanged(e) {
    super._fireChanged.apply(this, arguments);
    const {
      operationTypes
    } = e;
    if (false === this.option(LEGACY_SCROLLING_MODE4) && isVirtualPaging(this) && operationTypes) {
      const {
        fullReload,
        pageIndex
      } = operationTypes;
      if (e.isDataChanged && !fullReload && pageIndex) {
        this._updateVisiblePageIndex(this._dataSource.pageIndex());
      }
    }
  }
  _getPagingOptionValue(optionName) {
    let result = super._getPagingOptionValue.apply(this, arguments);
    if (false === this.option(LEGACY_SCROLLING_MODE4) && isVirtualPaging(this)) {
      result = this[optionName]();
    }
    return result;
  }
  isEmpty() {
    return false === this.option(LEGACY_SCROLLING_MODE4) ? !this.items(true).length : super.isEmpty.apply(this, arguments);
  }
  isLastPageLoaded() {
    let result = false;
    if (false === this.option(LEGACY_SCROLLING_MODE4) && isVirtualPaging(this)) {
      const {
        pageIndex,
        loadPageCount
      } = this.getLoadPageParams(true);
      const pageCount = this.pageCount();
      result = pageIndex + loadPageCount >= pageCount;
    } else {
      result = super.isLastPageLoaded.apply(this, arguments);
    }
    return result;
  }
  reset() {
    this._itemCount = 0;
    this._allItems = null;
    super.reset.apply(this, arguments);
  }
  _applyFilter() {
    var _this$_dataSource6;
    null === (_this$_dataSource6 = this._dataSource) || void 0 === _this$_dataSource6 || _this$_dataSource6.loadPageCount(1);
    return super._applyFilter.apply(this, arguments);
  }
  getVirtualContentSize() {
    var _this$_dataSource7;
    return null === (_this$_dataSource7 = this._dataSource) || void 0 === _this$_dataSource7 ? void 0 : _this$_dataSource7.getVirtualContentSize.apply(this._dataSource, arguments);
  }
  setViewportItemIndex() {
    var _this$_dataSource8;
    return null === (_this$_dataSource8 = this._dataSource) || void 0 === _this$_dataSource8 ? void 0 : _this$_dataSource8.setViewportItemIndex.apply(this._dataSource, arguments);
  }
};
var resizing3 = (Base) => class extends Base {
  dispose() {
    super.dispose.apply(this, arguments);
    clearTimeout(this._resizeTimeout);
  }
  _updateMasterDataGridCore(masterDataGrid) {
    return when(super._updateMasterDataGridCore.apply(this, arguments)).done(((masterDataGridUpdated) => {
      const isNewVirtualMode = isVirtualMode2(masterDataGrid) && false === masterDataGrid.option(LEGACY_SCROLLING_MODE4);
      if (!masterDataGridUpdated && isNewVirtualMode) {
        const scrollable = masterDataGrid.getScrollable();
        if (scrollable) {
          masterDataGrid.updateDimensions();
        }
      }
    }));
  }
  hasResizeTimeout() {
    return isDefined(this._resizeTimeout);
  }
  resetLastResizeTime() {
    this._lastTime = void 0;
  }
  resize() {
    let result;
    if (isVirtualMode2(this) || m_utils_default.isVirtualRowRendering(this)) {
      clearTimeout(this._resizeTimeout);
      this._resizeTimeout = null;
      const diff = /* @__PURE__ */ new Date() - this._lastTime;
      const updateTimeout = this.option("scrolling.updateTimeout");
      if (this._lastTime && diff < updateTimeout) {
        result = new Deferred();
        this._resizeTimeout = setTimeout((() => {
          this._resizeTimeout = null;
          super.resize.apply(this).done(result.resolve).fail(result.reject);
          this._lastTime = /* @__PURE__ */ new Date();
        }), updateTimeout);
        this._lastTime = /* @__PURE__ */ new Date();
      } else {
        result = super.resize.apply(this);
        if (this._dataController.isLoaded()) {
          this._lastTime = /* @__PURE__ */ new Date();
        }
      }
    } else {
      result = super.resize.apply(this);
    }
    return result;
  }
};
var rowsView7 = (Base) => class extends Base {
  init() {
    var _this$_dataController;
    super.init();
    this._dataController.pageChanged.add(((pageIndex) => {
      const scrollTop = this._scrollTop;
      this.scrollToPage(pageIndex ?? this._dataController.pageIndex());
      if (false === this.option(LEGACY_SCROLLING_MODE4) && this._scrollTop === scrollTop) {
        this._dataController.updateViewport();
      }
    }));
    this._dataController.dataSourceChanged.add((() => {
      !this._scrollTop && this._scrollToCurrentPageOnResize();
    }));
    null === (_this$_dataController = this._dataController.stateLoaded) || void 0 === _this$_dataController || _this$_dataController.add((() => {
      this._scrollToCurrentPageOnResize();
    }));
    this._scrollToCurrentPageOnResize();
  }
  dispose() {
    clearTimeout(this._scrollTimeoutID);
    super.dispose();
  }
  _scrollToCurrentPageOnResize() {
    if (this._dataController.pageIndex() > 0) {
      const resizeHandler = () => {
        this.resizeCompleted.remove(resizeHandler);
        this.scrollToPage(this._dataController.pageIndex());
      };
      this.resizeCompleted.add(resizeHandler);
    }
  }
  scrollToPage(pageIndex) {
    const pageSize = this._dataController ? this._dataController.pageSize() : 0;
    let scrollPosition;
    if (isVirtualMode2(this) || isAppendMode2(this)) {
      const itemSize = this._dataController.getItemSize();
      const itemSizes = this._dataController.getItemSizes();
      const itemIndex = pageIndex * pageSize;
      scrollPosition = itemIndex * itemSize;
      for (const index in itemSizes) {
        if (parseInt(index) < itemIndex) {
          scrollPosition += itemSizes[index] - itemSize;
        }
      }
    } else {
      scrollPosition = 0;
    }
    this.scrollTo({
      y: scrollPosition,
      x: this._scrollLeft
    });
  }
  renderDelayedTemplates() {
    this.waitAsyncTemplates().done((() => {
      this._updateContentPosition(true);
    }));
    super.renderDelayedTemplates.apply(this, arguments);
  }
  _renderCore(e) {
    const startRenderTime = /* @__PURE__ */ new Date();
    const deferred = super._renderCore.apply(this, arguments);
    const dataSource = this._dataController._dataSource;
    if (dataSource && e) {
      const itemCount = e.items ? e.items.length : 20;
      const viewportSize = this._dataController.viewportSize() || 20;
      if (m_utils_default.isVirtualRowRendering(this) && itemCount > 0 && false !== this.option(LEGACY_SCROLLING_MODE4)) {
        dataSource._renderTime = (/* @__PURE__ */ new Date() - startRenderTime) * viewportSize / itemCount;
      } else {
        dataSource._renderTime = /* @__PURE__ */ new Date() - startRenderTime;
      }
    }
    return deferred;
  }
  _getRowElements(tableElement) {
    const $rows = super._getRowElements(tableElement);
    return null === $rows || void 0 === $rows ? void 0 : $rows.not(".dx-virtual-row");
  }
  _removeRowsElements(contentTable, removeCount, changeType) {
    let rowElements = this._getRowElements(contentTable).toArray();
    if ("append" === changeType) {
      rowElements = rowElements.slice(0, removeCount);
    } else {
      rowElements = rowElements.slice(-removeCount);
    }
    rowElements.map(((rowElement) => {
      const $rowElement = renderer_default(rowElement);
      this._errorHandlingController && this._errorHandlingController.removeErrorRow($rowElement.next());
      $rowElement.remove();
    }));
  }
  _updateContent(tableElement, change) {
    let $freeSpaceRowElements;
    const contentElement = this._findContentElement();
    const changeType = null === change || void 0 === change ? void 0 : change.changeType;
    const d = Deferred();
    const contentTable = contentElement.children().first();
    if ("append" === changeType || "prepend" === changeType) {
      this.waitAsyncTemplates().done((() => {
        const $tBodies = this._getBodies(tableElement);
        if (1 === $tBodies.length) {
          this._getBodies(contentTable)["append" === changeType ? "append" : "prepend"]($tBodies.children());
        } else {
          $tBodies["append" === changeType ? "appendTo" : "prependTo"](contentTable);
        }
        tableElement.remove();
        $freeSpaceRowElements = this._getFreeSpaceRowElements(contentTable);
        removeEmptyRows($freeSpaceRowElements, FREESPACE_CLASS);
        if (change.removeCount) {
          this._removeRowsElements(contentTable, change.removeCount, changeType);
        }
        this._restoreErrorRow(contentTable);
        d.resolve();
      })).fail(d.reject);
    } else {
      super._updateContent.apply(this, arguments).done((() => {
        if ("update" === changeType) {
          this._restoreErrorRow(contentTable);
        }
        d.resolve();
      })).fail(d.reject);
    }
    return d.promise().done((() => {
      this._updateBottomLoading();
    }));
  }
  _addVirtualRow($table, isFixed, location, position) {
    if (!position) {
      return;
    }
    let $virtualRow = this._createEmptyRow("dx-virtual-row", isFixed, position);
    $virtualRow = this._wrapRowIfNeed($table, $virtualRow);
    this._appendEmptyRow($table, $virtualRow, location);
  }
  _updateContentItemSizes() {
    const rowHeights = this._getRowHeights();
    const correctedRowHeights = this._correctRowHeights(rowHeights);
    this._dataController.setContentItemSizes(correctedRowHeights);
  }
  _updateViewportSize(viewportHeight, scrollTop) {
    if (!isDefined(viewportHeight)) {
      viewportHeight = this._hasHeight ? getOuterHeight(this.element()) : getOuterHeight(getWindow());
    }
    this._dataController.viewportHeight(viewportHeight, scrollTop);
  }
  _getRowHeights() {
    var _this$_editingControl2, _this$_editingControl3;
    const isPopupEditMode = null === (_this$_editingControl2 = this._editingController) || void 0 === _this$_editingControl2 || null === (_this$_editingControl3 = _this$_editingControl2.isPopupEditMode) || void 0 === _this$_editingControl3 ? void 0 : _this$_editingControl3.call(_this$_editingControl2);
    let rowElements = this._getRowElements(this._tableElement).toArray();
    if (isPopupEditMode) {
      rowElements = rowElements.filter(((row) => !renderer_default(row).hasClass(ROW_INSERTED2)));
    }
    return rowElements.map(((row) => getBoundingRect(row).height));
  }
  _correctRowHeights(rowHeights) {
    const dataController2 = this._dataController;
    const dataSource = dataController2._dataSource;
    const correctedRowHeights = [];
    const visibleRows = dataController2.getVisibleRows();
    let itemSize = 0;
    let firstCountableItem = true;
    let lastLoadIndex = -1;
    for (let i = 0; i < rowHeights.length; i++) {
      const currentItem = visibleRows[i];
      if (!isDefined(currentItem)) {
        continue;
      }
      if (false === this.option(LEGACY_SCROLLING_MODE4)) {
        if (lastLoadIndex >= 0 && lastLoadIndex !== currentItem.loadIndex) {
          correctedRowHeights.push(itemSize);
          itemSize = 0;
        }
        lastLoadIndex = currentItem.loadIndex;
      } else if (isItemCountableByDataSource(currentItem, dataSource)) {
        if (firstCountableItem) {
          firstCountableItem = false;
        } else {
          correctedRowHeights.push(itemSize);
          itemSize = 0;
        }
      }
      itemSize += rowHeights[i];
    }
    itemSize > 0 && correctedRowHeights.push(itemSize);
    return correctedRowHeights;
  }
  _updateContentPosition(isRender) {
    const rowHeight = this._rowHeight || 20;
    this._dataController.viewportItemSize(rowHeight);
    if (isVirtualMode2(this) || m_utils_default.isVirtualRowRendering(this)) {
      const isEmptyRows = this._dataController.isEmpty();
      if (isEmptyRows) {
        return;
      }
      if (!isRender) {
        this._updateContentItemSizes();
      }
      const top = this._dataController.getContentOffset("begin");
      const bottom = this._dataController.getContentOffset("end");
      const $tables = this.getTableElements();
      const $virtualRows = $tables.children("tbody").children(".dx-virtual-row");
      removeEmptyRows($virtualRows, "dx-virtual-row");
      $tables.each(((index, element) => {
        const isFixed = index > 0;
        const prevFixed = this._isFixedTableRendering;
        this._isFixedTableRendering = isFixed;
        this._addVirtualRow(renderer_default(element), isFixed, "top", top);
        this._addVirtualRow(renderer_default(element), isFixed, "bottom", bottom);
        this._isFixedTableRendering = prevFixed;
      }));
    }
  }
  _isTableLinesDisplaysCorrect(table) {
    const hasColumnLines = table.find(".dx-column-lines").length > 0;
    return hasColumnLines === this.option("showColumnLines");
  }
  _isColumnElementsEqual($columns, $virtualColumns) {
    let result = $columns.length === $virtualColumns.length;
    if (result) {
      each($columns, ((index, element) => {
        if (element.style.width !== $virtualColumns[index].style.width) {
          result = false;
          return result;
        }
        return;
      }));
    }
    return result;
  }
  _getCellClasses(column) {
    const classes = [];
    const {
      cssClass
    } = column;
    const isExpandColumn = "expand" === column.command;
    cssClass && classes.push(cssClass);
    isExpandColumn && classes.push(this.addWidgetPrefix("group-space"));
    return classes;
  }
  _findBottomLoadPanel($contentElement) {
    const $element = $contentElement || this.element();
    const $bottomLoadPanel = null === $element || void 0 === $element ? void 0 : $element.find(`.${this.addWidgetPrefix("bottom-load-panel")}`);
    if (null !== $bottomLoadPanel && void 0 !== $bottomLoadPanel && $bottomLoadPanel.length) {
      return $bottomLoadPanel;
    }
  }
  _updateBottomLoading() {
    const that = this;
    const virtualMode = isVirtualMode2(this);
    const appendMode = isAppendMode2(this);
    const showBottomLoading = !that._dataController.hasKnownLastPage() && that._dataController.isLoaded() && (virtualMode || appendMode);
    const $contentElement = that._findContentElement();
    const bottomLoadPanelElement = that._findBottomLoadPanel($contentElement);
    if (showBottomLoading) {
      if (!bottomLoadPanelElement) {
        renderer_default("<div>").addClass(that.addWidgetPrefix("bottom-load-panel")).append(that._createComponent(renderer_default("<div>"), load_indicator_default, {
          elementAttr: {
            role: null,
            "aria-label": null
          }
        }).$element()).appendTo($contentElement);
      }
    } else if (bottomLoadPanelElement) {
      bottomLoadPanelElement.remove();
    }
  }
  _handleScroll(e) {
    const legacyScrollingMode = true === this.option(LEGACY_SCROLLING_MODE4);
    const zeroTopPosition = 0 === e.scrollOffset.top;
    const isScrollTopChanged = this._scrollTop !== e.scrollOffset.top;
    const hasScrolled = isScrollTopChanged || e.forceUpdateScrollPosition;
    const isValidScrollTarget = this._hasHeight || !legacyScrollingMode && zeroTopPosition;
    if (hasScrolled && isValidScrollTarget && this._rowHeight) {
      this._scrollTop = e.scrollOffset.top;
      const isVirtualRowRendering = isVirtualMode2(this) || "standard" !== this.option("scrolling.rowRenderingMode");
      if (isVirtualRowRendering && false === this.option(LEGACY_SCROLLING_MODE4)) {
        this._updateContentItemSizes();
        this._updateViewportSize(null, this._scrollTop);
      }
      this._dataController.setViewportPosition(e.scrollOffset.top);
    }
    super._handleScroll.apply(this, arguments);
  }
  _needUpdateRowHeight(itemsCount) {
    return super._needUpdateRowHeight.apply(this, arguments) || itemsCount > 0 && isAppendMode2(this) && !m_utils_default.isVirtualRowRendering(this);
  }
  _updateRowHeight() {
    super._updateRowHeight.apply(this, arguments);
    if (this._rowHeight) {
      this._updateContentPosition();
      const viewportHeight = this._hasHeight ? getOuterHeight(this.element()) : getOuterHeight(getWindow());
      if (false === this.option(LEGACY_SCROLLING_MODE4)) {
        this._updateViewportSize(viewportHeight);
        this._dataController.updateViewport();
      } else {
        this._dataController.viewportSize(Math.ceil(viewportHeight / this._rowHeight));
      }
    }
  }
  updateFreeSpaceRowHeight() {
    const result = super.updateFreeSpaceRowHeight.apply(this, arguments);
    if (result) {
      this._updateContentPosition();
    }
    return result;
  }
  setLoading(isLoading, messageText) {
    const dataController2 = this._dataController;
    const hasBottomLoadPanel = dataController2.pageIndex() > 0 && dataController2.isLoaded() && !!this._findBottomLoadPanel();
    if (false === this.option(LEGACY_SCROLLING_MODE4) && isLoading && dataController2.isViewportChanging()) {
      return;
    }
    if (hasBottomLoadPanel) {
      isLoading = false;
    }
    super.setLoading.call(this, isLoading, messageText);
  }
  isGridDragging() {
    return this.component.option("isDragging");
  }
  throwHeightWarningIfNeed() {
    const isGridDragging = this.isGridDragging();
    if (void 0 === this._hasHeight || isGridDragging) {
      return;
    }
    const needToThrow = !this._hasHeight && isVirtualPaging(this);
    if (needToThrow && !this._heightWarningIsThrown) {
      this._heightWarningIsThrown = true;
      ui_errors_default.log("W1025");
    }
  }
  _resizeCore() {
    const that = this;
    const $element = that.element();
    super._resizeCore();
    this.throwHeightWarningIfNeed();
    if (that.component.$element() && !that._windowScroll && isElementInDom($element)) {
      that._windowScroll = subscribeToExternalScrollers($element, ((scrollPos) => {
        if (!that._hasHeight && that._rowHeight) {
          that._dataController.setViewportPosition(scrollPos);
        }
      }), that.component.$element());
      that.on("disposing", (() => {
        that._windowScroll.dispose();
      }));
    }
    if (false !== this.option(LEGACY_SCROLLING_MODE4)) {
      that.loadIfNeed();
    }
  }
  loadIfNeed() {
    var _this$_dataController2, _this$_dataController3;
    null === (_this$_dataController2 = this._dataController) || void 0 === _this$_dataController2 || null === (_this$_dataController3 = _this$_dataController2.loadIfNeed) || void 0 === _this$_dataController3 || _this$_dataController3.call(_this$_dataController2);
  }
  _restoreErrorRow(contentTable) {
    if (false === this.option(LEGACY_SCROLLING_MODE4)) {
      var _this$_errorHandlingC;
      null === (_this$_errorHandlingC = this._errorHandlingController) || void 0 === _this$_errorHandlingC || _this$_errorHandlingC.removeErrorRow();
    }
    super._restoreErrorRow.apply(this, arguments);
  }
};
var virtualScrollingModule = {
  defaultOptions: () => ({
    scrolling: {
      timeout: 300,
      updateTimeout: 300,
      minTimeout: 0,
      renderingThreshold: 100,
      removeInvisiblePages: true,
      rowPageSize: 5,
      prerenderedRowChunkSize: 1,
      mode: "standard",
      preloadEnabled: false,
      rowRenderingMode: "standard",
      loadTwoPagesOnStart: false,
      legacyMode: false,
      prerenderedRowCount: 1
    }
  }),
  extenders: {
    controllers: {
      data: data7,
      resizing: resizing3
    },
    views: {
      rowsView: rowsView7
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/virtual_scrolling.js
m_core_default.registerModule("virtualScrolling", virtualScrollingModule);
m_data_source_adapter_default.extend(dataSourceAdapterExtender2);

// node_modules/devextreme/esm/__internal/ui/overlay/utils.js
var getElementMaxHeightByWindow = ($element, startLocation) => {
  const offset = $element.offset();
  if (void 0 === offset) {
    return;
  }
  const $window = renderer_default(getWindow());
  const {
    top: elementOffset
  } = offset;
  let actualOffset = 0;
  const windowScrollTop = $window.scrollTop();
  const windowHeight = getInnerHeight($window);
  if (isNumeric(startLocation)) {
    if (startLocation < elementOffset) {
      return elementOffset - startLocation;
    }
    actualOffset = windowHeight - startLocation + windowScrollTop;
  } else {
    const offsetTop = elementOffset - windowScrollTop;
    const offsetBottom = windowHeight - offsetTop - getOuterHeight($element);
    actualOffset = Math.max(offsetTop, offsetBottom);
  }
  return 0.9 * actualOffset;
};

// node_modules/devextreme/esm/__internal/ui/menu/submenu.js
var Submenu = class extends context_menu_default {
  _getMaxUsableSpace(offsetTop, windowHeight, anchorHeight) {
    return Math.max(offsetTop, windowHeight - offsetTop - anchorHeight);
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      orientation: "horizontal",
      tabIndex: null,
      onHoverStart: noop
    });
  }
  _initDataAdapter() {
    const {
      _dataAdapter
    } = this.option();
    this._dataAdapter = _dataAdapter;
    if (!this._dataAdapter) {
      super._initDataAdapter();
    }
  }
  _renderContentImpl() {
    this._renderContextMenuOverlay();
    super._renderContentImpl();
    const {
      _parentKey
    } = this.option();
    const node = this._dataAdapter.getNodeByKey(_parentKey);
    if (node) {
      this._renderItems(this._getChildNodes(node));
    }
    this._renderDelimiter();
  }
  _renderDelimiter() {
    this.$contentDelimiter = renderer_default("<div>").appendTo(this._itemContainer()).addClass("dx-context-menu-content-delimiter");
  }
  _getOverlayOptions() {
    return extend(true, super._getOverlayOptions(), {
      onPositioned: this._overlayPositionedActionHandler.bind(this),
      position: {
        precise: true
      }
    });
  }
  _overlayPositionedActionHandler(arg) {
    this._showDelimiter(arg);
  }
  _hoverEndHandler(e) {
    super._hoverEndHandler(e);
    this._toggleFocusClass(false, e.currentTarget);
  }
  _isMenuHorizontal() {
    const {
      orientation
    } = this.option();
    return "horizontal" === orientation;
  }
  _hoverStartHandler(e) {
    const {
      onHoverStart
    } = this.option();
    null === onHoverStart || void 0 === onHoverStart || onHoverStart(e);
    super._hoverStartHandler(e);
  }
  _drawSubmenu($rootItem) {
    var _this$_actions$onShow, _this$_actions, _this$_actions$onShow2, _this$_actions2;
    null === (_this$_actions$onShow = (_this$_actions = this._actions).onShowing) || void 0 === _this$_actions$onShow || _this$_actions$onShow.call(_this$_actions, {
      rootItem: getPublicElement($rootItem),
      submenu: this
    });
    super._drawSubmenu($rootItem);
    null === (_this$_actions$onShow2 = (_this$_actions2 = this._actions).onShown) || void 0 === _this$_actions$onShow2 || _this$_actions$onShow2.call(_this$_actions2, {
      rootItem: getPublicElement($rootItem),
      submenu: this
    });
  }
  _hideSubmenu($rootItem) {
    var _this$_actions$onHidi, _this$_actions3, _this$_actions$onHidd, _this$_actions4;
    null === (_this$_actions$onHidi = (_this$_actions3 = this._actions).onHiding) || void 0 === _this$_actions$onHidi || _this$_actions$onHidi.call(_this$_actions3, {
      cancel: true,
      rootItem: getPublicElement($rootItem),
      submenu: this
    });
    super._hideSubmenu($rootItem);
    null === (_this$_actions$onHidd = (_this$_actions4 = this._actions).onHidden) || void 0 === _this$_actions$onHidd || _this$_actions$onHidd.call(_this$_actions4, {
      rootItem: getPublicElement($rootItem),
      submenu: this
    });
  }
  _getDelimiterWidth($rootItem, $submenu) {
    if (this._isMenuHorizontal()) {
      const rootWidth = getWidth($rootItem);
      const submenuWidth = getWidth($submenu);
      return rootWidth < submenuWidth ? rootWidth : submenuWidth;
    }
    return 3;
  }
  _getDelimiterHeight($rootItem, $submenu) {
    if (this._isMenuHorizontal()) {
      return 3;
    }
    const rootHeight = getHeight($rootItem);
    const submenuHeight = getHeight($submenu);
    return rootHeight < submenuHeight ? rootHeight : submenuHeight;
  }
  _showDelimiter(arg) {
    if (!this.$contentDelimiter) {
      return;
    }
    const {
      position: positionOption
    } = this.option();
    const $submenu = this._itemContainer().children(".dx-submenu").eq(0);
    const $rootItem = renderer_default(null === positionOption || void 0 === positionOption ? void 0 : positionOption.of).find(".dx-context-menu-container-border");
    const position = {
      of: $submenu,
      precise: true
    };
    const containerOffset = arg.position;
    const vLocation = containerOffset.v.location;
    const hLocation = containerOffset.h.location;
    const rootOffset = $rootItem.offset();
    const offsetLeft = Math.round((null === rootOffset || void 0 === rootOffset ? void 0 : rootOffset.left) ?? 0);
    const offsetTop = Math.round((null === rootOffset || void 0 === rootOffset ? void 0 : rootOffset.top) ?? 0);
    this.$contentDelimiter.css("display", "block");
    setWidth(this.$contentDelimiter, this._getDelimiterWidth($rootItem, $submenu));
    setHeight(this.$contentDelimiter, this._getDelimiterHeight($rootItem, $submenu));
    if (this._isMenuHorizontal()) {
      if (vLocation > offsetTop) {
        if (Math.round(hLocation) === offsetLeft) {
          position.offset = "0 -2.5";
          position.at = "left top";
          position.my = "left top";
        } else {
          position.offset = "0 -2.5";
          position.at = "right top";
          position.my = "right top";
        }
      } else {
        setHeight(this.$contentDelimiter, 5);
        if (Math.round(hLocation) === offsetLeft) {
          position.offset = "0 5";
          position.at = "left bottom";
          position.my = "left bottom";
        } else {
          position.offset = "0 5";
          position.at = "right bottom";
          position.my = "right bottom";
        }
      }
    } else if (hLocation > offsetLeft) {
      if (Math.round(vLocation) === offsetTop) {
        position.offset = "-2.5 0";
        position.at = "left top";
        position.my = "left top";
      } else {
        position.offset = "-2.5 0";
        position.at = "left bottom";
        position.my = "left bottom";
      }
    } else if (Math.round(vLocation) === offsetTop) {
      position.offset = "2.5 0";
      position.at = "right top";
      position.my = "right top";
    } else {
      position.offset = "2.5 0";
      position.at = "right bottom";
      position.my = "right bottom";
    }
    position_default.setup(this.$contentDelimiter, position);
  }
  _getContextMenuPosition() {
    const {
      position
    } = this.option();
    return position;
  }
  isOverlayVisible() {
    var _this$_overlay;
    const {
      visible
    } = (null === (_this$_overlay = this._overlay) || void 0 === _this$_overlay ? void 0 : _this$_overlay.option()) ?? {};
    return visible;
  }
  getOverlayContent() {
    var _this$_overlay2;
    return null === (_this$_overlay2 = this._overlay) || void 0 === _this$_overlay2 ? void 0 : _this$_overlay2.$content();
  }
};
var submenu_default = Submenu;

// node_modules/devextreme/esm/__internal/ui/menu/menu.js
var DX_MENU_ITEM_CLASS = "dx-menu-item";
var DX_ADAPTIVE_MODE_CLASS = "dx-menu-adaptive-mode";
var DX_ADAPTIVE_MODE_OVERLAY_WRAPPER_CLASS = `${DX_ADAPTIVE_MODE_CLASS}-overlay-wrapper`;
var DEFAULT_DELAY = {
  show: 50,
  hide: 300
};
var ACTIONS = ["onSubmenuShowing", "onSubmenuShown", "onSubmenuHiding", "onSubmenuHidden", "onItemContextMenu", "onItemClick", "onSelectionChanged", "onItemRendered"];
var Menu = class extends menu_base_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      orientation: "horizontal",
      submenuDirection: "auto",
      showFirstSubmenuMode: {
        name: "onClick",
        delay: {
          show: 50,
          hide: 300
        }
      },
      hideSubmenuOnMouseLeave: false,
      onSubmenuShowing: null,
      onSubmenuShown: null,
      onSubmenuHiding: null,
      onSubmenuHidden: null,
      adaptivityEnabled: false
    });
  }
  _setOptionsByReference() {
    super._setOptionsByReference();
    extend(this._optionsByReference, {
      animation: true,
      selectedItem: true
    });
  }
  _itemElements() {
    const rootMenuElements = super._itemElements();
    const submenuElements = this._submenuItemElements();
    return rootMenuElements.add(submenuElements);
  }
  _submenuItemElements() {
    const currentSubmenu = this._submenus.length && this._submenus[0];
    if (currentSubmenu && currentSubmenu.itemsContainer()) {
      var _currentSubmenu$items;
      return (null === (_currentSubmenu$items = currentSubmenu.itemsContainer()) || void 0 === _currentSubmenu$items ? void 0 : _currentSubmenu$items.find(".dx-menu-item")) ?? renderer_default();
    }
    return renderer_default();
  }
  _focusTarget() {
    return this.$element();
  }
  _isMenuHorizontal() {
    const {
      orientation
    } = this.option();
    return "horizontal" === orientation;
  }
  _moveFocus(location) {
    const $items = this._getAvailableItems();
    const isMenuHorizontal = this._isMenuHorizontal();
    const $activeItem = this._getActiveItem(true);
    let $argument;
    let operation;
    switch (location) {
      case "up":
        operation = isMenuHorizontal ? "showSubmenu" : this._getItemsNavigationOperation("prevItem");
        $argument = isMenuHorizontal ? $activeItem : $items;
        break;
      case "down":
        operation = isMenuHorizontal ? "showSubmenu" : this._getItemsNavigationOperation("nextItem");
        $argument = isMenuHorizontal ? $activeItem : $items;
        break;
      case "right":
        operation = isMenuHorizontal ? this._getItemsNavigationOperation("nextItem") : "showSubmenu";
        $argument = isMenuHorizontal ? $items : $activeItem;
        break;
      case "left":
        operation = isMenuHorizontal ? this._getItemsNavigationOperation("prevItem") : "showSubmenu";
        $argument = isMenuHorizontal ? $items : $activeItem;
        break;
      default:
        return super._moveFocus(location);
    }
    const navigationAction = this._getKeyboardNavigationAction(operation, $argument);
    const $newTarget = navigationAction();
    if ($newTarget && 0 !== $newTarget.length) {
      this.option("focusedElement", getPublicElement($newTarget));
    }
  }
  _getItemsNavigationOperation(operation) {
    const {
      rtlEnabled
    } = this.option();
    if (rtlEnabled) {
      return "prevItem" === operation ? "nextItem" : "prevItem";
    }
    return operation;
  }
  _getKeyboardNavigationAction(operation, argument) {
    let action = noop;
    switch (operation) {
      case "showSubmenu":
        if (!argument.hasClass("dx-state-disabled")) {
          action = this._showSubmenu.bind(this, argument);
        }
        break;
      case "nextItem":
        action = this._nextItem.bind(this, argument);
        break;
      case "prevItem":
        action = this._prevItem.bind(this, argument);
    }
    return action;
  }
  _clean() {
    super._clean();
    const {
      templatesRenderAsynchronously
    } = this.option();
    if (templatesRenderAsynchronously) {
      clearTimeout(this._resizeEventTimer);
    }
  }
  _visibilityChanged(visible) {
    if (visible) {
      if (!this._menuItemsWidth) {
        this._updateItemsWidthCache();
      }
      this._dimensionChanged();
    }
  }
  _isAdaptivityEnabled() {
    const {
      adaptivityEnabled,
      orientation
    } = this.option();
    return !!adaptivityEnabled && "horizontal" === orientation;
  }
  _updateItemsWidthCache() {
    const $menuItems = this.$element().find("ul").first().children("li").children(".dx-menu-item");
    this._menuItemsWidth = this._getSummaryItemsSize("width", $menuItems, true);
  }
  _dimensionChanged() {
    if (!this._isAdaptivityEnabled()) {
      return;
    }
    const containerWidth = getOuterWidth(this.$element());
    this._toggleAdaptiveMode(this._menuItemsWidth > containerWidth);
  }
  _init() {
    super._init();
    this._submenus = [];
  }
  _initActions() {
    this._actions = {};
    each(ACTIONS, ((_index, action) => {
      this._actions[action] = this._createActionByOption(action);
    }));
  }
  _initMarkup() {
    this._visibleSubmenu = null;
    this.$element().addClass("dx-menu");
    super._initMarkup();
    this._addCustomCssClass(this.$element());
    this.setAria("role", "menubar");
  }
  _setAriaRole(state) {
    const role = this._isAdaptivityEnabled() && state ? void 0 : "menubar";
    this.setAria({
      role
    });
  }
  _render() {
    super._render();
    this._initAdaptivity();
  }
  _isTargetOutOfComponent(relatedTarget) {
    const isInsideRootMenu = 0 !== renderer_default(relatedTarget).closest(".dx-menu").length;
    const isInsideContextMenu = 0 !== renderer_default(relatedTarget).closest(".dx-context-menu").length;
    return !(isInsideRootMenu || isInsideContextMenu);
  }
  _focusOutHandler(e) {
    const {
      relatedTarget
    } = e;
    if (relatedTarget) {
      const isTargetOutside = this._isTargetOutOfComponent(relatedTarget);
      if (isTargetOutside) {
        this._hideVisibleSubmenu();
      }
    }
    super._focusOutHandler(e);
  }
  _renderHamburgerButton() {
    this._hamburger = new button_default(renderer_default("<div>").addClass("dx-menu-hamburger-button"), {
      icon: "menu",
      activeStateEnabled: false,
      onClick: () => {
        this._toggleTreeView();
      }
    });
    return this._hamburger.$element();
  }
  _toggleTreeView(visible) {
    var _this$_overlay, _this$_overlay2;
    const isTreeViewVisible = visible ?? !(null !== (_this$_overlay = this._overlay) && void 0 !== _this$_overlay && null !== (_this$_overlay = _this$_overlay.option()) && void 0 !== _this$_overlay && _this$_overlay.visible);
    null === (_this$_overlay2 = this._overlay) || void 0 === _this$_overlay2 || _this$_overlay2.option("visible", isTreeViewVisible);
    if (isTreeViewVisible) {
      var _this$_treeView;
      null === (_this$_treeView = this._treeView) || void 0 === _this$_treeView || _this$_treeView.focus();
    }
    this._toggleHamburgerActiveState(isTreeViewVisible);
  }
  _toggleHamburgerActiveState(isActive) {
    var _this$_hamburger;
    null === (_this$_hamburger = this._hamburger) || void 0 === _this$_hamburger || _this$_hamburger.$element().toggleClass("dx-state-active", isActive);
  }
  _toggleAdaptiveMode(isAdaptive) {
    const $menuItemsContainer = this.$element().find(".dx-menu-horizontal");
    const $adaptiveElements = this.$element().find(`.${DX_ADAPTIVE_MODE_CLASS}`);
    if (isAdaptive) {
      this._hideVisibleSubmenu();
    } else {
      var _this$_treeView2;
      null === (_this$_treeView2 = this._treeView) || void 0 === _this$_treeView2 || _this$_treeView2.collapseAll();
      if (this._overlay) {
        this._toggleTreeView(isAdaptive);
      }
    }
    this._setAriaRole(isAdaptive);
    $menuItemsContainer.toggle(!isAdaptive);
    $adaptiveElements.toggle(isAdaptive);
  }
  _removeAdaptivity() {
    if (!this._$adaptiveContainer) {
      return;
    }
    this._toggleAdaptiveMode(false);
    this._$adaptiveContainer.remove();
    this._$adaptiveContainer = null;
    this._treeView = null;
    this._hamburger = null;
    this._overlay = null;
  }
  _treeviewItemClickHandler(e) {
    var _e$node;
    this._actions.onItemClick(e);
    if (!(null !== (_e$node = e.node) && void 0 !== _e$node && null !== (_e$node = _e$node.children) && void 0 !== _e$node && _e$node.length)) {
      this._toggleTreeView(false);
    }
  }
  _getAdaptiveOverlayOptions() {
    var _this$_hamburger2;
    const {
      rtlEnabled
    } = this.option();
    const position = rtlEnabled ? "right" : "left";
    return {
      _ignoreFunctionValueDeprecation: true,
      maxHeight: () => getElementMaxHeightByWindow(this.$element()),
      deferRendering: false,
      shading: false,
      animation: false,
      hideOnParentScroll: true,
      onHidden: () => {
        this._toggleHamburgerActiveState(false);
      },
      height: "auto",
      hideOnOutsideClick: (e) => !renderer_default(e.target).closest(".dx-menu-hamburger-button").length,
      position: {
        collision: "flipfit",
        at: `bottom ${position}`,
        my: `top ${position}`,
        of: null === (_this$_hamburger2 = this._hamburger) || void 0 === _this$_hamburger2 ? void 0 : _this$_hamburger2.$element()
      }
    };
  }
  _getTreeViewOptions() {
    const menuOptions = {};
    each(["rtlEnabled", "width", "accessKey", "activeStateEnabled", "animation", "dataSource", "disabled", "displayExpr", "displayExpr", "focusStateEnabled", "hint", "hoverStateEnabled", "itemsExpr", "items", "itemTemplate", "selectedExpr", "selectionMode", "tabIndex", "visible"], ((_index, option) => {
      menuOptions[option] = this.option(option);
    }));
    each(["onItemContextMenu", "onSelectionChanged", "onItemRendered"], ((_index, actionName) => {
      menuOptions[actionName] = (e) => {
        this._actions[actionName](e);
      };
    }));
    const {
      animation,
      selectByClick
    } = this.option();
    return _extends({}, menuOptions, {
      dataSource: this.getDataSource(),
      animationEnabled: !!animation,
      onItemClick: this._treeviewItemClickHandler.bind(this),
      onItemExpanded: (e) => {
        var _this$_overlay3, _this$_actions$onSubm, _this$_actions;
        null === (_this$_overlay3 = this._overlay) || void 0 === _this$_overlay3 || _this$_overlay3.repaint();
        null === (_this$_actions$onSubm = (_this$_actions = this._actions).onSubmenuShown) || void 0 === _this$_actions$onSubm || _this$_actions$onSubm.call(_this$_actions, e);
      },
      onItemCollapsed: (e) => {
        var _this$_overlay4, _this$_actions$onSubm2, _this$_actions2;
        null === (_this$_overlay4 = this._overlay) || void 0 === _this$_overlay4 || _this$_overlay4.repaint();
        null === (_this$_actions$onSubm2 = (_this$_actions2 = this._actions).onSubmenuHidden) || void 0 === _this$_actions$onSubm2 || _this$_actions$onSubm2.call(_this$_actions2, e);
      },
      selectNodesRecursive: false,
      selectByClick,
      expandEvent: "click",
      _supportItemUrl: true
    });
  }
  _initAdaptivity() {
    if (!this._isAdaptivityEnabled()) {
      return;
    }
    const {
      cssClass
    } = this.option();
    const $hamburger = this._renderHamburgerButton();
    this._treeView = this._createComponent(renderer_default("<div>"), tree_view_default, this._getTreeViewOptions());
    this._overlay = this._createComponent(renderer_default("<div>"), ui_overlay_default, this._getAdaptiveOverlayOptions());
    this._overlay.$content().append(this._treeView.$element()).addClass(DX_ADAPTIVE_MODE_CLASS).addClass(cssClass);
    this._overlay.$wrapper().addClass(DX_ADAPTIVE_MODE_OVERLAY_WRAPPER_CLASS);
    this._$adaptiveContainer = renderer_default("<div>").addClass(DX_ADAPTIVE_MODE_CLASS);
    this._$adaptiveContainer.append($hamburger);
    this._$adaptiveContainer.append(this._overlay.$element());
    this.$element().append(this._$adaptiveContainer);
    this._updateItemsWidthCache();
    this._dimensionChanged();
  }
  _getDelay(delayType) {
    const {
      showFirstSubmenuMode
    } = this.option();
    const delay = isObject(showFirstSubmenuMode) ? showFirstSubmenuMode.delay : void 0;
    if (!isDefined(delay)) {
      return DEFAULT_DELAY[delayType];
    }
    return isObject(delay) ? delay[delayType] ?? DEFAULT_DELAY[delayType] : delay;
  }
  _keyboardHandler(e) {
    return super._keyboardHandler(e, !!this._visibleSubmenu);
  }
  _renderContainer() {
    const $wrapper = renderer_default("<div>");
    $wrapper.appendTo(this.$element()).addClass(this._isMenuHorizontal() ? "dx-menu-horizontal" : "dx-menu-vertical");
    return super._renderContainer($wrapper);
  }
  _renderSubmenuItems(node, $itemFrame) {
    const submenu = this._createSubmenu(node, $itemFrame);
    this._submenus.push(submenu);
    this._renderBorderElement($itemFrame);
    return submenu;
  }
  _getKeyboardListeners() {
    return super._getKeyboardListeners().concat(this._visibleSubmenu);
  }
  _createSubmenu(node, $rootItem) {
    const $submenuContainer = renderer_default("<div>").addClass("dx-context-menu").appendTo($rootItem);
    const items = this._getChildNodes(node);
    const subMenu = this._createComponent($submenuContainer, submenu_default, _extends({}, this._getSubmenuOptions(), {
      _dataAdapter: this._dataAdapter,
      _parentKey: node.internalFields.key,
      items,
      onHoverStart: this._clearTimeouts.bind(this),
      position: this.getSubmenuPosition($rootItem)
    }));
    this._attachSubmenuHandlers($rootItem, subMenu);
    return subMenu;
  }
  _getSubmenuOptions() {
    const $submenuTarget = renderer_default("<div>");
    const isMenuHorizontal = this._isMenuHorizontal();
    const {
      itemTemplate,
      orientation,
      selectionMode,
      cssClass,
      selectByClick,
      hoverStateEnabled,
      activeStateEnabled,
      focusStateEnabled,
      animation,
      showSubmenuMode,
      displayExpr,
      disabledExpr,
      selectedExpr,
      itemsExpr
    } = this.option();
    return {
      itemTemplate,
      target: $submenuTarget,
      orientation,
      selectionMode,
      cssClass,
      selectByClick,
      hoverStateEnabled,
      activeStateEnabled,
      focusStateEnabled,
      animation,
      showSubmenuMode,
      displayExpr,
      disabledExpr,
      selectedExpr,
      itemsExpr,
      onFocusedItemChanged: (e) => {
        const {
          visible,
          focusedElement
        } = e.component.option();
        if (!visible) {
          return;
        }
        this.option("focusedElement", focusedElement);
      },
      onSelectionChanged: this._nestedItemOnSelectionChangedHandler.bind(this),
      onItemClick: this._nestedItemOnItemClickHandler.bind(this),
      onItemRendered: this._nestedItemOnItemRenderedHandler.bind(this),
      onLeftFirstItem: isMenuHorizontal ? null : this._moveMainMenuFocus.bind(this, "prevItem"),
      onLeftLastItem: isMenuHorizontal ? null : this._moveMainMenuFocus.bind(this, "nextItem"),
      onCloseRootSubmenu: this._moveMainMenuFocus.bind(this, isMenuHorizontal ? "prevItem" : null),
      onExpandLastSubmenu: isMenuHorizontal ? this._moveMainMenuFocus.bind(this, "nextItem") : null
    };
  }
  _getShowFirstSubmenuMode() {
    if (!this._isDesktopDevice()) {
      return "onClick";
    }
    const {
      showFirstSubmenuMode: optionValue
    } = this.option();
    return isObject(optionValue) ? optionValue.name : optionValue;
  }
  _moveMainMenuFocus(direction) {
    const $items = this._getAvailableItems();
    const itemCount = $items.length;
    const $currentItem = $items.filter(".dx-menu-item-expanded").eq(0);
    let itemIndex = $items.index($currentItem);
    this._hideSubmenu(this._visibleSubmenu);
    itemIndex += "prevItem" === direction ? -1 : 1;
    if (itemIndex >= itemCount) {
      itemIndex = 0;
    } else if (itemIndex < 0) {
      itemIndex = itemCount - 1;
    }
    const $newItem = $items.eq(itemIndex);
    this.option("focusedElement", getPublicElement($newItem));
  }
  _nestedItemOnSelectionChangedHandler(args) {
    const selectedItem = args.addedItems.length && args.addedItems[0];
    const submenu = submenu_default.getInstance(args.element);
    const {
      onSelectionChanged
    } = this._actions;
    null === onSelectionChanged || void 0 === onSelectionChanged || onSelectionChanged(args);
    if (selectedItem) {
      this._clearSelectionInSubmenus(submenu);
    }
    this._clearRootSelection();
    this._setOptionWithoutOptionChange("selectedItem", selectedItem);
  }
  _clearSelectionInSubmenus(targetSubmenu) {
    const cleanAllSubmenus = !arguments.length;
    each(this._submenus, ((_index, submenu) => {
      const $submenu = submenu._itemContainer();
      const isOtherItem = !$submenu.is(null === targetSubmenu || void 0 === targetSubmenu ? void 0 : targetSubmenu._itemContainer());
      const $selectedItem = $submenu.find(`.${this._selectedItemClass()}`);
      if (isOtherItem && $selectedItem.length || cleanAllSubmenus) {
        $selectedItem.removeClass(this._selectedItemClass());
        const selectedItemData = this._getItemData($selectedItem);
        if (selectedItemData) {
          selectedItemData.selected = false;
        }
        submenu._clearSelectedItems();
      }
    }));
  }
  _clearRootSelection() {
    const $prevSelectedItem = this.$element().find(".dx-menu-items-container").first().children().children().filter(`.${this._selectedItemClass()}`);
    if ($prevSelectedItem.length) {
      const prevSelectedItemData = this._getItemData($prevSelectedItem);
      prevSelectedItemData.selected = false;
      $prevSelectedItem.removeClass(this._selectedItemClass());
    }
  }
  _nestedItemOnItemClickHandler(e) {
    var _this$_actions$onItem, _this$_actions3;
    null === (_this$_actions$onItem = (_this$_actions3 = this._actions).onItemClick) || void 0 === _this$_actions$onItem || _this$_actions$onItem.call(_this$_actions3, e);
  }
  _nestedItemOnItemRenderedHandler(e) {
    var _this$_actions$onItem2, _this$_actions4;
    null === (_this$_actions$onItem2 = (_this$_actions4 = this._actions).onItemRendered) || void 0 === _this$_actions$onItem2 || _this$_actions$onItem2.call(_this$_actions4, e);
  }
  _attachSubmenuHandlers($menuAnchorItem, submenu) {
    const $submenuOverlayContent = submenu.getOverlayContent();
    const submenus = null === $submenuOverlayContent || void 0 === $submenuOverlayContent ? void 0 : $submenuOverlayContent.find(".dx-submenu");
    const submenuMouseLeaveName = addNamespace(HOVEREND, `${this.NAME}_submenu`);
    submenu.option({
      onShowing: this._submenuOnShowingHandler.bind(this, $menuAnchorItem, submenu),
      onShown: this._submenuOnShownHandler.bind(this, $menuAnchorItem, submenu),
      onHiding: this._submenuOnHidingHandler.bind(this, $menuAnchorItem, submenu),
      onHidden: this._submenuOnHiddenHandler.bind(this, $menuAnchorItem, submenu)
    });
    each(submenus, ((_index, subMenu) => {
      m_events_engine_default.off(subMenu, submenuMouseLeaveName);
      m_events_engine_default.on(subMenu, submenuMouseLeaveName, null, this._submenuMouseLeaveHandler.bind(this, $menuAnchorItem));
    }));
  }
  _submenuOnShowingHandler($menuAnchorItem, submenu, _ref) {
    var _this$_actions$onSubm3, _this$_actions5;
    let {
      rootItem
    } = _ref;
    const $border = $menuAnchorItem.children(".dx-context-menu-container-border");
    const params = this._getVisibilityChangeEventParams(rootItem, submenu, $menuAnchorItem);
    null === (_this$_actions$onSubm3 = (_this$_actions5 = this._actions).onSubmenuShowing) || void 0 === _this$_actions$onSubm3 || _this$_actions$onSubm3.call(_this$_actions5, params);
    $border.show();
    $menuAnchorItem.addClass("dx-menu-item-expanded");
  }
  _submenuOnShownHandler($menuAnchorItem, submenu, _ref2) {
    var _this$_actions$onSubm4, _this$_actions6;
    let {
      rootItem
    } = _ref2;
    const params = this._getVisibilityChangeEventParams(rootItem, submenu, $menuAnchorItem);
    null === (_this$_actions$onSubm4 = (_this$_actions6 = this._actions).onSubmenuShown) || void 0 === _this$_actions$onSubm4 || _this$_actions$onSubm4.call(_this$_actions6, params);
  }
  _submenuOnHidingHandler($menuAnchorItem, submenu, eventArgs) {
    var _this$_actions$onSubm5, _this$_actions7;
    const $border = $menuAnchorItem.children(".dx-context-menu-container-border");
    const params = this._getVisibilityChangeEventParams(eventArgs.rootItem, submenu, $menuAnchorItem, true);
    eventArgs.itemData = params.itemData;
    eventArgs.rootItem = params.rootItem;
    eventArgs.submenuContainer = params.submenuContainer;
    eventArgs.submenu = params.submenu;
    null === (_this$_actions$onSubm5 = (_this$_actions7 = this._actions).onSubmenuHiding) || void 0 === _this$_actions$onSubm5 || _this$_actions$onSubm5.call(_this$_actions7, eventArgs);
    const {
      focusedElement
    } = this.option();
    const {
      focusedElement: submenuFocusedElement
    } = submenu.option();
    const isVisibleSubmenuHiding = this._visibleSubmenu === submenu;
    const isFocusedElementHiding = focusedElement === submenuFocusedElement;
    if (isVisibleSubmenuHiding && isFocusedElementHiding) {
      this.option("focusedElement", getPublicElement($menuAnchorItem));
    }
    if (!eventArgs.cancel) {
      if (isVisibleSubmenuHiding) {
        this._visibleSubmenu = null;
      }
      $border.hide();
      $menuAnchorItem.removeClass("dx-menu-item-expanded");
    }
  }
  _submenuOnHiddenHandler($menuAnchorItem, submenu, _ref3) {
    var _this$_actions$onSubm6, _this$_actions8;
    let {
      rootItem
    } = _ref3;
    const params = this._getVisibilityChangeEventParams(rootItem, submenu, $menuAnchorItem, true);
    null === (_this$_actions$onSubm6 = (_this$_actions8 = this._actions).onSubmenuHidden) || void 0 === _this$_actions$onSubm6 || _this$_actions$onSubm6.call(_this$_actions8, params);
  }
  _getVisibilityChangeEventParams(submenuItem, submenu, $menuAnchorItem, isHide) {
    let itemData;
    let $submenuContainer;
    if (submenuItem) {
      const anchor = isHide ? renderer_default(submenuItem).closest(".dx-menu-item")[0] : submenuItem;
      itemData = this._getItemData(anchor);
      $submenuContainer = renderer_default(anchor).find(".dx-submenu").first();
    } else {
      var _submenu$_overlay;
      const $overlayContent = renderer_default(null === (_submenu$_overlay = submenu._overlay) || void 0 === _submenu$_overlay ? void 0 : _submenu$_overlay.content());
      itemData = this._getItemData($menuAnchorItem);
      $submenuContainer = $overlayContent.find(".dx-submenu").first();
    }
    return {
      itemData,
      rootItem: getPublicElement($menuAnchorItem),
      submenuContainer: getPublicElement($submenuContainer),
      submenu
    };
  }
  _submenuMouseLeaveHandler($rootItem, eventArgs) {
    var _submenu$getOverlayCo;
    const target = renderer_default(eventArgs.relatedTarget).parents(".dx-context-menu")[0];
    const submenu = this._getSubmenuByRootElement($rootItem);
    const contextMenu2 = null === submenu || void 0 === submenu || null === (_submenu$getOverlayCo = submenu.getOverlayContent()) || void 0 === _submenu$getOverlayCo ? void 0 : _submenu$getOverlayCo[0];
    const {
      hideSubmenuOnMouseLeave
    } = this.option();
    if (hideSubmenuOnMouseLeave && target !== contextMenu2) {
      this._clearTimeouts();
      setTimeout(this._hideSubmenuAfterTimeout.bind(this), this._getDelay("hide"));
    }
  }
  _hideSubmenuAfterTimeout() {
    var _this$_visibleSubmenu, _this$_visibleSubmenu2;
    if (!this._visibleSubmenu) {
      return;
    }
    const isRootItemHovered = renderer_default(this._visibleSubmenu.$element().context).hasClass("dx-state-hover");
    const isSubmenuItemHovered = null === (_this$_visibleSubmenu = this._visibleSubmenu.getOverlayContent()) || void 0 === _this$_visibleSubmenu ? void 0 : _this$_visibleSubmenu.find(".dx-state-hover").length;
    const hoveredElementFromSubMenu = null === (_this$_visibleSubmenu2 = this._visibleSubmenu.getOverlayContent()) || void 0 === _this$_visibleSubmenu2 ? void 0 : _this$_visibleSubmenu2.get(0).querySelector(":hover");
    if (!hoveredElementFromSubMenu && !isSubmenuItemHovered && !isRootItemHovered) {
      this._visibleSubmenu.hide();
    }
  }
  _getSubmenuByRootElement($rootItem) {
    if (!$rootItem) {
      return;
    }
    const $submenu = $rootItem.children(".dx-context-menu");
    if (!$submenu.length) {
      return;
    }
    return submenu_default.getInstance($submenu);
  }
  getSubmenuPosition($rootItem) {
    const {
      submenuDirection: submenuDirectionOption,
      rtlEnabled
    } = this.option();
    const isHorizontalMenu = this._isMenuHorizontal();
    const submenuDirection = null === submenuDirectionOption || void 0 === submenuDirectionOption ? void 0 : submenuDirectionOption.toLowerCase();
    const submenuPosition = {
      collision: "flip",
      of: $rootItem,
      precise: true
    };
    switch (submenuDirection) {
      case "leftortop":
        submenuPosition.at = "left top";
        submenuPosition.my = isHorizontalMenu ? "left bottom" : "right top";
        break;
      case "rightorbottom":
        submenuPosition.at = isHorizontalMenu ? "left bottom" : "right top";
        submenuPosition.my = "left top";
        break;
      default:
        if (isHorizontalMenu) {
          submenuPosition.at = rtlEnabled ? "right bottom" : "left bottom";
          submenuPosition.my = rtlEnabled ? "right top" : "left top";
        } else {
          submenuPosition.at = rtlEnabled ? "left top" : "right top";
          submenuPosition.my = rtlEnabled ? "right top" : "left top";
        }
    }
    return submenuPosition;
  }
  _renderBorderElement($item) {
    renderer_default("<div>").appendTo($item).addClass("dx-context-menu-container-border").hide();
  }
  _itemPointerHandler(e) {
    const $target = renderer_default(e.target);
    const $closestItem = $target.closest(this._itemElements());
    if ($closestItem.hasClass("dx-menu-item-has-submenu")) {
      this.option("focusedElement", null);
      return;
    }
    super._itemPointerHandler(e);
  }
  _hoverStartHandler(e) {
    const mouseMoveEventName = addNamespace(m_pointer_default.move, this.NAME);
    const $item = this._getItemElementByEventArgs(e);
    if (!$item || this._isItemDisabled($item)) {
      return;
    }
    const node = this._dataAdapter.getNodeByItem(this._getItemData($item));
    const isSelectionActive = isDefined(e.buttons) && 1 === e.buttons || !isDefined(e.buttons) && 1 === e.which;
    m_events_engine_default.off($item, mouseMoveEventName);
    if (!this._hasChildren(node)) {
      this._showSubmenuTimer = setTimeout(this._hideSubmenuAfterTimeout.bind(this), this._getDelay("hide"));
      return;
    }
    if ("onHover" === this._getShowFirstSubmenuMode() && !isSelectionActive) {
      const submenu = this._getSubmenuByElement($item);
      this._clearTimeouts();
      if (!(null !== submenu && void 0 !== submenu && submenu.isOverlayVisible())) {
        m_events_engine_default.on($item, mouseMoveEventName, this._itemMouseMoveHandler.bind(this));
        this._showSubmenuTimer = this._getDelay("hide");
      }
    }
  }
  _hoverEndHandler(eventArg) {
    const $item = this._getItemElementByEventArgs(eventArg);
    const relatedTarget = renderer_default(eventArg.relatedTarget);
    super._hoverEndHandler(eventArg);
    this._clearTimeouts();
    if (!$item || this._isItemDisabled($item)) {
      return;
    }
    if (relatedTarget.hasClass("dx-context-menu-content-delimiter")) {
      return;
    }
    const {
      hideSubmenuOnMouseLeave
    } = this.option();
    if (hideSubmenuOnMouseLeave && !relatedTarget.hasClass("dx-menu-items-container")) {
      this._hideSubmenuTimer = setTimeout((() => {
        this._hideSubmenuAfterTimeout();
      }), this._getDelay("hide"));
    }
  }
  _hideVisibleSubmenu() {
    if (!this._visibleSubmenu) {
      return false;
    }
    this._hideSubmenu(this._visibleSubmenu);
    return true;
  }
  _showSubmenu($itemElement) {
    const submenu = this._getSubmenuByElement($itemElement);
    if (this._visibleSubmenu !== submenu) {
      this._hideVisibleSubmenu();
    }
    if (submenu) {
      this._clearTimeouts();
      this.focus();
      submenu.show();
      const {
        focusedElement
      } = submenu.option();
      this.option("focusedElement", focusedElement);
    }
    this._visibleSubmenu = submenu;
    this._hoveredRootItem = $itemElement;
  }
  _hideSubmenu(submenu) {
    if (submenu) {
      submenu.hide();
    }
    if (this._visibleSubmenu === submenu) {
      this._visibleSubmenu = null;
    }
    this._hoveredRootItem = null;
  }
  _itemMouseMoveHandler(e) {
    var _e$pointers;
    if (null !== (_e$pointers = e.pointers) && void 0 !== _e$pointers && _e$pointers.length) {
      return;
    }
    const $item = renderer_default(e.currentTarget);
    if (!isDefined(this._showSubmenuTimer)) {
      return;
    }
    this._clearTimeouts();
    this._showSubmenuTimer = setTimeout((() => {
      const submenu = this._getSubmenuByElement($item);
      if (submenu && !submenu.isOverlayVisible()) {
        this._showSubmenu($item);
      }
    }), this._getDelay("show"));
  }
  _clearTimeouts() {
    clearTimeout(this._hideSubmenuTimer);
    clearTimeout(this._showSubmenuTimer);
  }
  _getSubmenuByElement($itemElement, itemData) {
    const submenu = this._getSubmenuByRootElement($itemElement);
    if (submenu) {
      return submenu;
    }
    const node = this._dataAdapter.getNodeByItem(itemData ?? this._getItemData($itemElement));
    if (node && this._hasChildren(node)) {
      return this._renderSubmenuItems(node, $itemElement);
    }
    return;
  }
  _updateSubmenuVisibilityOnClick(actionArgs) {
    var _actionArgs$args;
    const args = null === (_actionArgs$args = actionArgs.args) || void 0 === _actionArgs$args ? void 0 : _actionArgs$args[0];
    if (!args || this._disabledGetter(args.itemData)) {
      return;
    }
    const $itemElement = renderer_default(args.itemElement);
    const currentSubmenu = this._getSubmenuByElement($itemElement, args.itemData);
    this._updateSelectedItemOnClick(actionArgs);
    if (this._visibleSubmenu) {
      if (this._visibleSubmenu === currentSubmenu) {
        const {
          showFirstSubmenuMode
        } = this.option();
        if ("onClick" === showFirstSubmenuMode) {
          this._hideSubmenu(this._visibleSubmenu);
        }
        return;
      }
      this._hideSubmenu(this._visibleSubmenu);
    }
    if (!currentSubmenu) {
      return;
    }
    if (!currentSubmenu.isOverlayVisible()) {
      this._showSubmenu($itemElement);
    }
  }
  _optionChanged(args) {
    if (ACTIONS.includes(args.name)) {
      this._initActions();
      return;
    }
    switch (args.name) {
      case "orientation":
      case "submenuDirection":
        this._invalidate();
        break;
      case "showFirstSubmenuMode":
      case "hideSubmenuOnMouseLeave":
        break;
      case "showSubmenuMode":
        this._changeSubmenusOption(args);
        break;
      case "adaptivityEnabled":
        if (args.value) {
          this._initAdaptivity();
        } else {
          this._removeAdaptivity();
        }
        break;
      case "width":
        if (this._isAdaptivityEnabled()) {
          var _this$_treeView3, _this$_overlay5;
          null === (_this$_treeView3 = this._treeView) || void 0 === _this$_treeView3 || _this$_treeView3.option(args.name, args.value);
          null === (_this$_overlay5 = this._overlay) || void 0 === _this$_overlay5 || _this$_overlay5.option(args.name, args.value);
        }
        super._optionChanged(args);
        this._dimensionChanged();
        break;
      case "animation":
        if (this._isAdaptivityEnabled()) {
          var _this$_treeView4;
          null === (_this$_treeView4 = this._treeView) || void 0 === _this$_treeView4 || _this$_treeView4.option("animationEnabled", !!args.value);
        }
        super._optionChanged(args);
        break;
      default:
        if (this._isAdaptivityEnabled() && (args.name === args.fullName || "items" === args.name)) {
          var _this$_treeView5;
          null === (_this$_treeView5 = this._treeView) || void 0 === _this$_treeView5 || _this$_treeView5.option(args.fullName, args.value);
        }
        super._optionChanged(args);
    }
  }
  _changeSubmenusOption(_ref4) {
    let {
      name,
      value: value2
    } = _ref4;
    each(this._submenus, ((_index, submenu) => {
      submenu.option(name, value2);
    }));
  }
  selectItem(itemElement) {
    this._hideSubmenu(this._visibleSubmenu);
    super.selectItem(itemElement);
  }
  unselectItem(itemElement) {
    this._hideSubmenu(this._visibleSubmenu);
    super.unselectItem(itemElement);
  }
};
component_registrator_default("dxMenu", Menu);
var menu_default = Menu;

// node_modules/devextreme/esm/ui/menu.js
var menu_default2 = menu_default;

// node_modules/devextreme/esm/__internal/grids/grid_core/filter/m_filter_row.js
var OPERATION_ICONS = {
  "=": "filter-operation-equals",
  "<>": "filter-operation-not-equals",
  "<": "filter-operation-less",
  "<=": "filter-operation-less-equal",
  ">": "filter-operation-greater",
  ">=": "filter-operation-greater-equal",
  default: "filter-operation-default",
  notcontains: "filter-operation-not-contains",
  contains: "filter-operation-contains",
  startswith: "filter-operation-starts-with",
  endswith: "filter-operation-ends-with",
  between: "filter-operation-between"
};
var OPERATION_DESCRIPTORS = {
  "=": "equal",
  "<>": "notEqual",
  "<": "lessThan",
  "<=": "lessThanOrEqual",
  ">": "greaterThan",
  ">=": "greaterThanOrEqual",
  startswith: "startsWith",
  contains: "contains",
  notcontains: "notContains",
  endswith: "endsWith",
  between: "between"
};
var FILTER_MENU = "dx-filter-menu";
var EDITORS_INPUT_SELECTOR2 = "input:not([type='hidden'])";
var BETWEEN_OPERATION_DATA_TYPES = ["date", "datetime", "number"];
function isOnClickApplyFilterMode(that) {
  return "onClick" === that.option("filterRow.applyFilter");
}
var getEditorInstance = function($editorContainer) {
  const $editor = null === $editorContainer || void 0 === $editorContainer ? void 0 : $editorContainer.children();
  const componentNames = null === $editor || void 0 === $editor ? void 0 : $editor.data("dxComponents");
  const editor = (null === componentNames || void 0 === componentNames ? void 0 : componentNames.length) && $editor.data(componentNames[0]);
  if (editor instanceof editor_default) {
    return editor;
  }
  return null;
};
var getRangeTextByFilterValue = function(that, column) {
  let result = "";
  let rangeEnd = "";
  const filterValue = getColumnFilterValue(that, column);
  const formatOptions = m_utils_default.getFormatOptionsByColumn(column, "filterRow");
  if (Array.isArray(filterValue)) {
    result = m_utils_default.formatValue(filterValue[0], formatOptions);
    rangeEnd = m_utils_default.formatValue(filterValue[1], formatOptions);
    if ("" !== rangeEnd) {
      result += ` - ${rangeEnd}`;
    }
  } else if (isDefined(filterValue)) {
    result = m_utils_default.formatValue(filterValue, formatOptions);
  }
  return result;
};
function getColumnFilterValue(that, column) {
  if (column) {
    return isOnClickApplyFilterMode(that) && void 0 !== column.bufferedFilterValue ? column.bufferedFilterValue : column.filterValue;
  }
}
var getColumnSelectedFilterOperation = function(that, column) {
  if (column) {
    return isOnClickApplyFilterMode(that) && void 0 !== column.bufferedSelectedFilterOperation ? column.bufferedSelectedFilterOperation : column.selectedFilterOperation;
  }
};
var isValidFilterValue = function(filterValue, column) {
  if (column && BETWEEN_OPERATION_DATA_TYPES.includes(column.dataType) && Array.isArray(filterValue)) {
    return false;
  }
  return void 0 !== filterValue;
};
var getFilterValue2 = function(that, columnIndex, $editorContainer) {
  const column = that._columnsController.columnOption(columnIndex);
  const filterValue = getColumnFilterValue(that, column);
  const isFilterRange = $editorContainer.closest(`.${that.addWidgetPrefix("filter-range-overlay")}`).length;
  const isRangeStart = $editorContainer.hasClass(that.addWidgetPrefix("filter-range-start"));
  if (filterValue && Array.isArray(filterValue) && "between" === getColumnSelectedFilterOperation(that, column)) {
    if (isRangeStart) {
      return filterValue[0];
    }
    return filterValue[1];
  }
  return !isFilterRange && isValidFilterValue(filterValue, column) ? filterValue : null;
};
var normalizeFilterValue = function(that, filterValue, column, $editorContainer) {
  if ("between" === getColumnSelectedFilterOperation(that, column)) {
    const columnFilterValue = getColumnFilterValue(that, column);
    if ($editorContainer.hasClass(that.addWidgetPrefix("filter-range-start"))) {
      return [filterValue, Array.isArray(columnFilterValue) ? columnFilterValue[1] : void 0];
    }
    return [Array.isArray(columnFilterValue) ? columnFilterValue[0] : columnFilterValue, filterValue];
  }
  return filterValue;
};
var updateFilterValue = function(that, options) {
  const value2 = "" === options.value ? null : options.value;
  const $editorContainer = options.container;
  const column = that._columnsController.columnOption(options.column.index);
  const filterValue = getFilterValue2(that, column.index, $editorContainer);
  if (!isDefined(filterValue) && !isDefined(value2)) {
    return;
  }
  that._applyFilterViewController.setHighLight($editorContainer, filterValue !== value2);
  const columnOptionName = isOnClickApplyFilterMode(that) ? "bufferedFilterValue" : "filterValue";
  const normalizedValue = normalizeFilterValue(that, value2, column, $editorContainer);
  const isBetween = "between" === getColumnSelectedFilterOperation(that, column);
  const notFireEvent = options.notFireEvent || isBetween && Array.isArray(normalizedValue) && normalizedValue.includes(void 0);
  that._columnsController.columnOption(column.index, columnOptionName, normalizedValue, notFireEvent);
};
var columnHeadersView3 = (Base) => class extends Base {
  init() {
    super.init();
    this._applyFilterViewController = this.getController("applyFilter");
  }
  optionChanged(args) {
    switch (args.name) {
      case "filterRow":
      case "showColumnLines":
        this._invalidate(true, true);
        args.handled = true;
        break;
      case "syncLookupFilterValues":
        if (args.value) {
          this.updateLookupDataSource();
        } else {
          this.render();
        }
        args.handled = true;
        break;
      default:
        super.optionChanged(args);
    }
  }
  _updateEditorValue(column, $editorContainer) {
    const editor = getEditorInstance($editorContainer);
    editor && editor.option("value", getFilterValue2(this, column.index, $editorContainer));
  }
  _columnOptionChanged(e) {
    const that = this;
    const {
      optionNames
    } = e;
    let $cell;
    let $editorContainer;
    let $editorRangeElements;
    let $menu;
    if (m_utils_default.checkChanges(optionNames, ["filterValue", "bufferedFilterValue", "selectedFilterOperation", "bufferedSelectedFilterOperation", "filterValues", "filterType"]) && void 0 !== e.columnIndex) {
      const visibleIndex = that._columnsController.getVisibleIndex(e.columnIndex);
      const column = that._columnsController.columnOption(e.columnIndex);
      $cell = that._getCellElement(that.element().find(`.${that.addWidgetPrefix("filter-row")}`).index(), visibleIndex) ?? renderer_default();
      $editorContainer = $cell.find(".dx-editor-container").first();
      if (optionNames.filterValue || optionNames.bufferedFilterValue) {
        that._updateEditorValue(column, $editorContainer);
        const overlayInstance = $cell.find(`.${that.addWidgetPrefix("filter-range-overlay")}`).data("dxOverlay");
        if (overlayInstance) {
          $editorRangeElements = overlayInstance.$content().find(".dx-editor-container");
          that._updateEditorValue(column, $editorRangeElements.first());
          that._updateEditorValue(column, $editorRangeElements.last());
        }
        if (!(null !== overlayInstance && void 0 !== overlayInstance && overlayInstance.option("visible"))) {
          that._updateFilterRangeContent($cell, getRangeTextByFilterValue(that, column));
        }
      }
      if (optionNames.selectedFilterOperation || optionNames.bufferedSelectedFilterOperation) {
        if (visibleIndex >= 0 && column) {
          $menu = $cell.find(".dx-menu");
          if ($menu.length) {
            that._updateFilterOperationChooser($menu, column, $editorContainer);
            if ("between" === getColumnSelectedFilterOperation(that, column)) {
              that._renderFilterRangeContent($cell, column);
            } else if ($editorContainer.find(".dx-filter-range-content").length) {
              that._renderEditor($editorContainer, that._getEditorOptions($editorContainer, column));
              that._hideFilterRange();
            }
          }
        }
      }
      return;
    }
    super._columnOptionChanged(e);
  }
  _renderCore() {
    this._filterRangeOverlayInstance = null;
    return super._renderCore.apply(this, arguments);
  }
  _resizeCore() {
    var _this$_filterRangeOve;
    super._resizeCore.apply(this, arguments);
    null === (_this$_filterRangeOve = this._filterRangeOverlayInstance) || void 0 === _this$_filterRangeOve || _this$_filterRangeOve.repaint();
  }
  isFilterRowVisible() {
    return this._isElementVisible(this.option("filterRow"));
  }
  isVisible() {
    return super.isVisible() || this.isFilterRowVisible();
  }
  _initFilterRangeOverlay($cell, column) {
    const that = this;
    const sharedData = {};
    const $editorContainer = $cell.find(".dx-editor-container");
    const filterRangeOverlayClass = that.addWidgetPrefix("filter-range-overlay");
    const $overlay = renderer_default("<div>").addClass(filterRangeOverlayClass).appendTo($cell);
    return that._createComponent($overlay, ui_overlay_default, {
      height: "auto",
      shading: false,
      showTitle: false,
      focusStateEnabled: false,
      hideOnOutsideClick: true,
      hideOnParentScroll: true,
      _hideOnParentScrollTarget: $overlay,
      wrapperAttr: {
        class: filterRangeOverlayClass
      },
      animation: false,
      position: {
        my: "top",
        at: "top",
        of: $editorContainer.length && $editorContainer || $cell,
        offset: "0 -1"
      },
      contentTemplate(contentElement) {
        let editorOptions;
        let $editor = renderer_default("<div>").addClass(`dx-editor-container ${that.addWidgetPrefix("filter-range-start")}`).appendTo(contentElement);
        column = that._columnsController.columnOption(column.index);
        editorOptions = that._getEditorOptions($editor, column);
        editorOptions.sharedData = sharedData;
        that._renderEditor($editor, editorOptions);
        m_events_engine_default.on($editor.find(EDITORS_INPUT_SELECTOR2), "keydown", ((e) => {
          let $prevElement = $cell.find("[tabindex]").not(e.target).first();
          if ("tab" === normalizeKeyName(e) && e.shiftKey) {
            e.preventDefault();
            that._hideFilterRange();
            if (!$prevElement.length) {
              $prevElement = $cell.prev().find("[tabindex]").last();
            }
            m_events_engine_default.trigger($prevElement, "focus");
          }
        }));
        $editor = renderer_default("<div>").addClass(`dx-editor-container ${that.addWidgetPrefix("filter-range-end")}`).appendTo(contentElement);
        editorOptions = that._getEditorOptions($editor, column);
        editorOptions.sharedData = sharedData;
        that._renderEditor($editor, editorOptions);
        m_events_engine_default.on($editor.find(EDITORS_INPUT_SELECTOR2), "keydown", ((e) => {
          if ("tab" === normalizeKeyName(e) && !e.shiftKey) {
            e.preventDefault();
            that._hideFilterRange();
            m_events_engine_default.trigger($cell.next().find("[tabindex]").first(), "focus");
          }
        }));
        return renderer_default(contentElement).addClass(that.getWidgetContainerClass());
      },
      onShown(e) {
        const $editor = e.component.$content().find(".dx-editor-container").first();
        m_events_engine_default.trigger($editor.find(EDITORS_INPUT_SELECTOR2), "focus");
      },
      onHidden() {
        column = that._columnsController.columnOption(column.index);
        $cell.find(".dx-menu").parent().addClass("dx-editor-with-menu");
        if ("between" === getColumnSelectedFilterOperation(that, column)) {
          that._updateFilterRangeContent($cell, getRangeTextByFilterValue(that, column));
          that.component.updateDimensions();
        }
      }
    });
  }
  _updateFilterRangeOverlay(options) {
    const overlayInstance = this._filterRangeOverlayInstance;
    null === overlayInstance || void 0 === overlayInstance || overlayInstance.option(options);
  }
  _showFilterRange($cell, column) {
    const that = this;
    const $overlay = $cell.children(`.${that.addWidgetPrefix("filter-range-overlay")}`);
    let overlayInstance = $overlay.length && $overlay.data("dxOverlay");
    if (!overlayInstance && column) {
      overlayInstance = that._initFilterRangeOverlay($cell, column);
    }
    if (!overlayInstance.option("visible")) {
      var _that$_filterRangeOve, _that$_filterRangeOve2;
      null === (_that$_filterRangeOve = that._filterRangeOverlayInstance) || void 0 === _that$_filterRangeOve || _that$_filterRangeOve.hide();
      that._filterRangeOverlayInstance = overlayInstance;
      that._updateFilterRangeOverlay({
        width: getOuterWidth($cell, true) + 1
      });
      null === (_that$_filterRangeOve2 = that._filterRangeOverlayInstance) || void 0 === _that$_filterRangeOve2 || _that$_filterRangeOve2.show();
    }
  }
  _hideFilterRange() {
    const overlayInstance = this._filterRangeOverlayInstance;
    null === overlayInstance || void 0 === overlayInstance || overlayInstance.hide();
  }
  getFilterRangeOverlayInstance() {
    return this._filterRangeOverlayInstance;
  }
  _createRow(row) {
    const $row = super._createRow(row);
    if ("filter" === row.rowType) {
      $row.addClass(this.addWidgetPrefix("filter-row"));
      if (!this.option("useLegacyKeyboardNavigation")) {
        m_events_engine_default.on($row, "keydown", ((event) => selectView("filterRow", this, event)));
      }
    }
    return $row;
  }
  _getRows() {
    const result = super._getRows();
    if (this.isFilterRowVisible()) {
      result.push({
        rowType: "filter"
      });
    }
    return result;
  }
  _renderFilterCell(cell, options) {
    var _column$filterOperati;
    const that = this;
    const {
      column
    } = options;
    const $cell = renderer_default(cell);
    if (that.component.option("showColumnHeaders")) {
      that.setAria("describedby", column.headerId, $cell);
    }
    that.setAria("label", message_default.format("dxDataGrid-ariaFilterCell"), $cell);
    $cell.addClass("dx-editor-cell");
    const $container = renderer_default("<div>").appendTo($cell);
    const $editorContainer = renderer_default("<div>").addClass("dx-editor-container").appendTo($container);
    if ("between" === getColumnSelectedFilterOperation(that, column)) {
      that._renderFilterRangeContent($cell, column);
    } else {
      const editorOptions = that._getEditorOptions($editorContainer, column);
      that._renderEditor($editorContainer, editorOptions);
    }
    const {
      alignment
    } = column;
    if (alignment && "center" !== alignment) {
      $cell.find(EDITORS_INPUT_SELECTOR2).first().css("textAlign", column.alignment);
    }
    if (null !== (_column$filterOperati = column.filterOperations) && void 0 !== _column$filterOperati && _column$filterOperati.length) {
      that._renderFilterOperationChooser($container, column, $editorContainer);
    }
  }
  _renderCellContent($cell, options) {
    const that = this;
    const {
      column
    } = options;
    if ("filter" === options.rowType) {
      if (column.command) {
        $cell.html("&nbsp;");
      } else if (column.allowFiltering) {
        that.renderTemplate($cell, that._renderFilterCell.bind(that), options).done((() => {
          that._updateCell($cell, options);
        }));
        return;
      }
    }
    super._renderCellContent.apply(this, arguments);
  }
  _getEditorOptions($editorContainer, column) {
    const that = this;
    const accessibilityOptions = {
      editorOptions: {
        inputAttr: that._getFilterInputAccessibilityAttributes(column)
      }
    };
    const result = extend(accessibilityOptions, column, {
      value: getFilterValue2(that, column.index, $editorContainer),
      parentType: "filterRow",
      showAllText: that.option("filterRow.showAllText"),
      updateValueTimeout: "onClick" === that.option("filterRow.applyFilter") ? 0 : 700,
      width: null,
      setValue(value2, notFireEvent) {
        updateFilterValue(that, {
          column,
          value: value2,
          container: $editorContainer,
          notFireEvent
        });
      }
    });
    if ("between" === getColumnSelectedFilterOperation(that, column)) {
      if ($editorContainer.hasClass(that.addWidgetPrefix("filter-range-start"))) {
        result.placeholder = that.option("filterRow.betweenStartText");
      } else {
        result.placeholder = that.option("filterRow.betweenEndText");
      }
    }
    return result;
  }
  _getFilterInputAccessibilityAttributes(column) {
    const columnAriaLabel = message_default.format("dxDataGrid-ariaFilterCell");
    if (this.component.option("showColumnHeaders")) {
      return {
        "aria-label": columnAriaLabel,
        "aria-describedby": column.headerId
      };
    }
    return {
      "aria-label": columnAriaLabel
    };
  }
  _renderEditor($editorContainer, options) {
    $editorContainer.empty();
    const $element = renderer_default("<div>").appendTo($editorContainer);
    const dataSource = this._dataController.dataSource();
    if (options.lookup && this.option("syncLookupFilterValues")) {
      this._applyFilterViewController.setCurrentColumnForFiltering(options);
      const filter = this._dataController.getCombinedFilter();
      this._applyFilterViewController.setCurrentColumnForFiltering(null);
      const lookupDataSource = m_utils_default.getWrappedLookupDataSource(options, dataSource, filter);
      const lookupOptions = _extends({}, options, {
        lookup: _extends({}, options.lookup, {
          dataSource: lookupDataSource
        })
      });
      return this._editorFactoryController.createEditor($element, lookupOptions);
    }
    return this._editorFactoryController.createEditor($element, options);
  }
  _renderFilterRangeContent($cell, column) {
    const that = this;
    const $editorContainer = $cell.find(".dx-editor-container").first();
    $editorContainer.empty();
    const $filterRangeContent = renderer_default("<div>").addClass("dx-filter-range-content").attr("tabindex", this.option("tabIndex"));
    m_events_engine_default.on($filterRangeContent, "focusin", (() => {
      that._showFilterRange($cell, column);
    }));
    $filterRangeContent.appendTo($editorContainer);
    that._updateFilterRangeContent($cell, getRangeTextByFilterValue(that, column));
  }
  _updateFilterRangeContent($cell, value2) {
    const $filterRangeContent = $cell.find(".dx-filter-range-content");
    if ($filterRangeContent.length) {
      if ("" === value2) {
        $filterRangeContent.html("&nbsp;");
      } else {
        $filterRangeContent.text(value2);
      }
    }
  }
  _updateFilterOperationChooser($menu, column, $editorContainer) {
    var _column$filterOperati2;
    const that = this;
    let isCellWasFocused;
    const restoreFocus3 = function() {
      const menu = menu_default2.getInstance($menu);
      menu && menu.option("focusedElement", null);
      isCellWasFocused && that._focusEditor($editorContainer);
    };
    const editorFactoryController = this._editorFactoryController;
    const ariaSearchBox = message_default.format("dxDataGrid-ariaSearchBox");
    that._createComponent($menu, menu_default2, {
      integrationOptions: {},
      activeStateEnabled: false,
      selectionMode: "single",
      cssClass: `${that.getWidgetContainerClass()} dx-cell-focus-disabled ${FILTER_MENU}`,
      showFirstSubmenuMode: "onHover",
      hideSubmenuOnMouseLeave: true,
      items: [{
        name: getColumnSelectedFilterOperation(that, column) || ariaSearchBox,
        disabled: !(null !== (_column$filterOperati2 = column.filterOperations) && void 0 !== _column$filterOperati2 && _column$filterOperati2.length),
        icon: OPERATION_ICONS[getColumnSelectedFilterOperation(that, column) || "default"],
        selectable: false,
        items: that._getFilterOperationMenuItems(column)
      }],
      onItemRendered: (_ref) => {
        let {
          itemElement,
          itemData
        } = _ref;
        if (null !== itemData && void 0 !== itemData && itemData.items && null !== itemData && void 0 !== itemData && itemData.name) {
          const labelText = that._getOperationDescriptionFromDescriptor(itemData.name) || ariaSearchBox;
          this.setAria("label", labelText, renderer_default(itemElement));
        }
      },
      onItemClick(properties) {
        var _properties$itemData;
        const selectedFilterOperation = properties.itemData.name;
        const columnSelectedFilterOperation = getColumnSelectedFilterOperation(that, column);
        let notFocusEditor = false;
        const isOnClickMode = isOnClickApplyFilterMode(that);
        const options = {};
        if (properties.itemData.items || selectedFilterOperation && selectedFilterOperation === columnSelectedFilterOperation) {
          return;
        }
        if (selectedFilterOperation) {
          options[isOnClickMode ? "bufferedSelectedFilterOperation" : "selectedFilterOperation"] = selectedFilterOperation;
          if ("between" === selectedFilterOperation || "between" === columnSelectedFilterOperation) {
            notFocusEditor = "between" === selectedFilterOperation;
            options[isOnClickMode ? "bufferedFilterValue" : "filterValue"] = null;
          }
        } else {
          options[isOnClickMode ? "bufferedFilterValue" : "filterValue"] = null;
          options[isOnClickMode ? "bufferedSelectedFilterOperation" : "selectedFilterOperation"] = column.defaultSelectedFilterOperation || null;
        }
        const isResetFilterOperation = !(null !== (_properties$itemData = properties.itemData) && void 0 !== _properties$itemData && _properties$itemData.name);
        const isNotFireEvent = isResetFilterOperation ? false : void 0;
        that._columnsController.columnOption(column.index, options, void 0, isNotFireEvent);
        that._applyFilterViewController.setHighLight($editorContainer, true);
        if (!selectedFilterOperation) {
          const editor = getEditorInstance($editorContainer);
          if (editor && "dxDateBox" === editor.NAME && !editor.option("isValid")) {
            editor.clear();
            editor.option("isValid", true);
          }
        }
        if (!notFocusEditor) {
          that._focusEditor($editorContainer);
        } else {
          that._showFilterRange($editorContainer.closest(".dx-editor-cell"), column);
        }
      },
      onSubmenuShowing() {
        isCellWasFocused = that._isEditorFocused($editorContainer);
        editorFactoryController.loseFocus();
      },
      onSubmenuHiding() {
        m_events_engine_default.trigger($menu, "blur");
        restoreFocus3();
      },
      onContentReady(e) {
        m_events_engine_default.on($menu, "blur", (() => {
          const menu = e.component;
          menu._hideSubmenuAfterTimeout();
          restoreFocus3();
        }));
      },
      rtlEnabled: that.option("rtlEnabled")
    });
  }
  _isEditorFocused($container) {
    return $container.hasClass("dx-focused") || $container.parents(".dx-focused").length;
  }
  _focusEditor($container) {
    this._editorFactoryController.focus($container);
    m_events_engine_default.trigger($container.find(EDITORS_INPUT_SELECTOR2), "focus");
  }
  _renderFilterOperationChooser($container, column, $editorContainer) {
    const that = this;
    let $menu;
    if (that.option("filterRow.showOperationChooser")) {
      $container.addClass("dx-editor-with-menu");
      $menu = renderer_default("<div>").prependTo($container);
      that._updateFilterOperationChooser($menu, column, $editorContainer);
    }
  }
  _getFilterOperationMenuItems(column) {
    var _column$filterOperati3;
    const that = this;
    let result = [{}];
    const filterRowOptions = that.option("filterRow");
    if (null !== (_column$filterOperati3 = column.filterOperations) && void 0 !== _column$filterOperati3 && _column$filterOperati3.length) {
      const availableFilterOperations = column.filterOperations.filter(((value2) => isDefined(OPERATION_DESCRIPTORS[value2])));
      result = map(availableFilterOperations, ((value2) => ({
        name: value2,
        selected: (getColumnSelectedFilterOperation(that, column) || column.defaultFilterOperation) === value2,
        text: that._getOperationDescriptionFromDescriptor(value2),
        icon: OPERATION_ICONS[value2]
      })));
      result.push({
        name: null,
        text: null === filterRowOptions || void 0 === filterRowOptions ? void 0 : filterRowOptions.resetOperationText,
        icon: OPERATION_ICONS.default
      });
    }
    return result;
  }
  _getOperationDescriptionFromDescriptor(value2) {
    const filterRowOptions = this.option("filterRow");
    const operationDescriptions = (null === filterRowOptions || void 0 === filterRowOptions ? void 0 : filterRowOptions.operationDescriptions) || {};
    const descriptionName = OPERATION_DESCRIPTORS[value2];
    return operationDescriptions[descriptionName];
  }
  _handleDataChanged(e) {
    var _this$_dataController, _this$_dataController2, _dataSource$lastLoadO, _e$operationTypes, _e$operationTypes2;
    const dataSource = null === (_this$_dataController = this._dataController) || void 0 === _this$_dataController || null === (_this$_dataController2 = _this$_dataController.dataSource) || void 0 === _this$_dataController2 ? void 0 : _this$_dataController2.call(_this$_dataController);
    const lastLoadOptions = null === dataSource || void 0 === dataSource || null === (_dataSource$lastLoadO = dataSource.lastLoadOptions) || void 0 === _dataSource$lastLoadO ? void 0 : _dataSource$lastLoadO.call(dataSource);
    super._handleDataChanged.apply(this, arguments);
    if (null !== (_e$operationTypes = e.operationTypes) && void 0 !== _e$operationTypes && _e$operationTypes.filtering || null !== (_e$operationTypes2 = e.operationTypes) && void 0 !== _e$operationTypes2 && _e$operationTypes2.fullReload) {
      var _e$operationTypes3;
      this.updateLookupDataSource((null === (_e$operationTypes3 = e.operationTypes) || void 0 === _e$operationTypes3 ? void 0 : _e$operationTypes3.filtering) || (null === lastLoadOptions || void 0 === lastLoadOptions ? void 0 : lastLoadOptions.filter));
    }
  }
  updateLookupDataSource(filterChanged) {
    if (!this.option("syncLookupFilterValues")) {
      return;
    }
    if (!this.element()) {
      return;
    }
    const columns7 = this._columnsController.getVisibleColumns();
    const dataSource = this._dataController.dataSource();
    const applyFilterViewController = this._applyFilterViewController;
    const rowIndex = this.element().find(`.${this.addWidgetPrefix("filter-row")}`).index();
    if (-1 === rowIndex) {
      return;
    }
    columns7.forEach(((column, index) => {
      if (!column.lookup || column.calculateCellValue !== column.defaultCalculateCellValue) {
        return;
      }
      const $cell = this._getCellElement(rowIndex, index);
      const editor = getEditorInstance(null === $cell || void 0 === $cell ? void 0 : $cell.find(".dx-editor-container"));
      if (editor) {
        applyFilterViewController.setCurrentColumnForFiltering(column);
        const filter = this._dataController.getCombinedFilter() || null;
        applyFilterViewController.setCurrentColumnForFiltering(null);
        const editorDataSource = editor.option("dataSource");
        const shouldUpdateFilter = !filterChanged || !equalByValue(editorDataSource.__dataGridSourceFilter || null, filter);
        if (shouldUpdateFilter) {
          const lookupDataSource = m_utils_default.getWrappedLookupDataSource(column, dataSource, filter);
          editor.option("dataSource", lookupDataSource);
        }
      }
    }));
  }
  getColumnElements(index, bandColumnIndex) {
    var _rows$index;
    const rows = this._getRows();
    if ("filter" === (null === rows || void 0 === rows || null === (_rows$index = rows[index]) || void 0 === _rows$index ? void 0 : _rows$index.rowType) && arguments.length < 2) {
      return this.getCellElements(index);
    }
    return super.getColumnElements(index, bandColumnIndex);
  }
  isFilterRowCell($cell) {
    return !!$cell.closest(`.${this.addWidgetPrefix("filter-row")}`).length;
  }
};
var data8 = (Base) => class extends Base {
  skipCalculateColumnFilters() {
    return false;
  }
  _calculateAdditionalFilter() {
    if (this.skipCalculateColumnFilters()) {
      return super._calculateAdditionalFilter();
    }
    const filters = [super._calculateAdditionalFilter()];
    const columns7 = this._columnsController.getVisibleColumns(null, true);
    const applyFilterController = this._applyFilterController;
    each(columns7, (function() {
      var _applyFilterControlle;
      const shouldSkip = (null === (_applyFilterControlle = applyFilterController.getCurrentColumnForFiltering()) || void 0 === _applyFilterControlle ? void 0 : _applyFilterControlle.index) === this.index;
      if (this.allowFiltering && this.calculateFilterExpression && isDefined(this.filterValue) && !shouldSkip) {
        const filter = this.createFilterExpression(this.filterValue, this.selectedFilterOperation || this.defaultFilterOperation, "filterRow");
        filters.push(filter);
      }
    }));
    return m_utils_default.combineFilters(filters);
  }
};
var ApplyFilterViewController = class extends m_modules_default.ViewController {
  init() {
    this._columnsController = this.getController("columns");
  }
  _getHeaderPanel() {
    if (!this._headerPanel) {
      this._headerPanel = this.getView("headerPanel");
    }
    return this._headerPanel;
  }
  setHighLight($element, value2) {
    if (isOnClickApplyFilterMode(this)) {
      (null === $element || void 0 === $element ? void 0 : $element.toggleClass("dx-highlight-outline", value2)) && $element.closest(".dx-editor-cell").toggleClass("dx-filter-modified", value2);
      this._getHeaderPanel().enableApplyButton(value2);
    }
  }
  applyFilter() {
    const columns7 = this._columnsController.getColumns();
    this._columnsController.beginUpdate();
    for (let i = 0; i < columns7.length; i++) {
      const column = columns7[i];
      if (void 0 !== column.bufferedFilterValue) {
        this._columnsController.columnOption(i, "filterValue", column.bufferedFilterValue);
        column.bufferedFilterValue = void 0;
      }
      if (void 0 !== column.bufferedSelectedFilterOperation) {
        this._columnsController.columnOption(i, "selectedFilterOperation", column.bufferedSelectedFilterOperation);
        column.bufferedSelectedFilterOperation = void 0;
      }
    }
    this._columnsController.endUpdate();
    this.removeHighLights();
  }
  removeHighLights() {
    if (isOnClickApplyFilterMode(this)) {
      const columnHeadersViewElement = this.getView("columnHeadersView").element();
      columnHeadersViewElement.find(`.${this.addWidgetPrefix("filter-row")} .dx-highlight-outline`).removeClass("dx-highlight-outline");
      columnHeadersViewElement.find(`.${this.addWidgetPrefix("filter-row")} .dx-filter-modified`).removeClass("dx-filter-modified");
      this._getHeaderPanel().enableApplyButton(false);
    }
  }
  setCurrentColumnForFiltering(column) {
    this._currentColumn = column;
  }
  getCurrentColumnForFiltering() {
    return this._currentColumn;
  }
};
var columnsResizer = (Base) => class extends Base {
  _startResizing() {
    const that = this;
    super._startResizing.apply(that, arguments);
    if (that.isResizing()) {
      const overlayInstance = that._columnHeadersView.getFilterRangeOverlayInstance();
      if (overlayInstance) {
        const cellIndex = overlayInstance.$element().closest("td").index();
        if (cellIndex === that._targetPoint.columnIndex || cellIndex === that._targetPoint.columnIndex + 1) {
          overlayInstance.$content().hide();
        }
      }
    }
  }
  _endResizing() {
    const that = this;
    let $cell;
    if (that.isResizing()) {
      const overlayInstance = that._columnHeadersView.getFilterRangeOverlayInstance();
      if (overlayInstance) {
        $cell = overlayInstance.$element().closest("td");
        that._columnHeadersView._updateFilterRangeOverlay({
          width: getOuterWidth($cell, true) + 1
        });
        overlayInstance.$content().show();
      }
    }
    super._endResizing.apply(that, arguments);
  }
};
var editing = (Base) => class extends Base {
  updateFieldValue(options) {
    if (options.column.lookup) {
      this._needUpdateLookupDataSource = true;
    }
    return super.updateFieldValue.apply(this, arguments);
  }
  _afterSaveEditData(cancel) {
    if (this._needUpdateLookupDataSource && !cancel) {
      var _this$getView;
      null === (_this$getView = this.getView("columnHeadersView")) || void 0 === _this$getView || _this$getView.updateLookupDataSource();
    }
    this._needUpdateLookupDataSource = false;
    return super._afterSaveEditData.apply(this, arguments);
  }
  _afterCancelEditData() {
    this._needUpdateLookupDataSource = false;
    return super._afterCancelEditData.apply(this, arguments);
  }
};
var headerPanel4 = (Base) => class extends Base {
  init() {
    super.init();
    this._dataController = this.getController("data");
    this._applyFilterViewController = this.getController("applyFilter");
  }
  optionChanged(args) {
    if ("filterRow" === args.name) {
      this._invalidate();
      args.handled = true;
    } else {
      super.optionChanged(args);
    }
  }
  _getToolbarItems() {
    const items = super._getToolbarItems();
    const filterItem = this._prepareFilterItem();
    return filterItem.concat(items);
  }
  _prepareFilterItem() {
    const that = this;
    const filterItem = [];
    if (that._isShowApplyFilterButton()) {
      const hintText = that.option("filterRow.applyFilterText");
      const columns7 = that._columnsController.getColumns();
      const disabled = !columns7.filter(((column) => void 0 !== column.bufferedFilterValue)).length;
      const onInitialized = function(e) {
        renderer_default(e.element).addClass(that._getToolbarButtonClass("dx-apply-button"));
      };
      const onClickHandler = function() {
        that._applyFilterViewController.applyFilter();
      };
      const toolbarItem = {
        widget: "dxButton",
        options: {
          icon: "apply-filter",
          disabled,
          onClick: onClickHandler,
          hint: hintText,
          text: hintText,
          onInitialized
        },
        showText: "inMenu",
        name: "applyFilterButton",
        location: "after",
        locateInMenu: "auto",
        sortIndex: 10
      };
      filterItem.push(toolbarItem);
    }
    return filterItem;
  }
  _isShowApplyFilterButton() {
    const filterRowOptions = this.option("filterRow");
    return !!(null !== filterRowOptions && void 0 !== filterRowOptions && filterRowOptions.visible) && "onClick" === filterRowOptions.applyFilter;
  }
  enableApplyButton(value2) {
    this.setToolbarItemDisabled("applyFilterButton", !value2);
  }
};
var filterRowModule = {
  defaultOptions: () => ({
    syncLookupFilterValues: true,
    filterRow: {
      visible: false,
      showOperationChooser: true,
      showAllText: message_default.format("dxDataGrid-filterRowShowAllText"),
      resetOperationText: message_default.format("dxDataGrid-filterRowResetOperationText"),
      applyFilter: "auto",
      applyFilterText: message_default.format("dxDataGrid-applyFilterText"),
      operationDescriptions: {
        equal: message_default.format("dxDataGrid-filterRowOperationEquals"),
        notEqual: message_default.format("dxDataGrid-filterRowOperationNotEquals"),
        lessThan: message_default.format("dxDataGrid-filterRowOperationLess"),
        lessThanOrEqual: message_default.format("dxDataGrid-filterRowOperationLessOrEquals"),
        greaterThan: message_default.format("dxDataGrid-filterRowOperationGreater"),
        greaterThanOrEqual: message_default.format("dxDataGrid-filterRowOperationGreaterOrEquals"),
        startsWith: message_default.format("dxDataGrid-filterRowOperationStartsWith"),
        contains: message_default.format("dxDataGrid-filterRowOperationContains"),
        notContains: message_default.format("dxDataGrid-filterRowOperationNotContains"),
        endsWith: message_default.format("dxDataGrid-filterRowOperationEndsWith"),
        between: message_default.format("dxDataGrid-filterRowOperationBetween"),
        isBlank: message_default.format("dxFilterBuilder-filterOperationIsBlank"),
        isNotBlank: message_default.format("dxFilterBuilder-filterOperationIsNotBlank")
      },
      betweenStartText: message_default.format("dxDataGrid-filterRowOperationBetweenStartText"),
      betweenEndText: message_default.format("dxDataGrid-filterRowOperationBetweenEndText")
    }
  }),
  controllers: {
    applyFilter: ApplyFilterViewController
  },
  extenders: {
    controllers: {
      data: data8,
      columnsResizer,
      editing
    },
    views: {
      columnHeadersView: columnHeadersView3,
      headerPanel: headerPanel4
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/filter_row.js
m_core_default.registerModule("filterRow", filterRowModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/header_filter/m_header_filter_core.js
var HANDLER_DECORATED_KEY = Symbol("HANDLER_DECORATED_KEY");
function resetChildrenItemSelection(items) {
  items = items || [];
  for (let i = 0; i < items.length; i++) {
    items[i].selected = false;
    resetChildrenItemSelection(items[i].items);
  }
}
function getSelectAllCheckBox(listComponent) {
  const selector = "dxTreeView" === listComponent.NAME ? ".dx-treeview-select-all-item" : ".dx-list-select-all-checkbox";
  return listComponent.$element().find(selector).dxCheckBox("instance");
}
function getListSelectAllValueChangedHandler(selectAllCheckBox, listComponent) {
  const originalHandler = selectAllCheckBox.option("onValueChanged");
  if (null !== originalHandler && void 0 !== originalHandler && originalHandler[HANDLER_DECORATED_KEY]) {
    return originalHandler;
  }
  const handler = (originalEvent) => {
    const {
      event,
      value: value2
    } = originalEvent;
    const isEventFromUI = !!event;
    null === event || void 0 === event || event.stopPropagation();
    switch (true) {
      case (isEventFromUI && true === value2):
        listComponent.selectAll();
        return;
      case (isEventFromUI && false === value2):
        listComponent.unselectAll();
        return;
      default:
        null === originalHandler || void 0 === originalHandler || originalHandler(originalEvent);
    }
  };
  handler[HANDLER_DECORATED_KEY] = true;
  return handler;
}
function decorateListSelectAllValueChanged(listComponent) {
  const selectAllCheckBox = getSelectAllCheckBox(listComponent);
  if (!selectAllCheckBox) {
    return;
  }
  const handler = getListSelectAllValueChangedHandler(selectAllCheckBox, listComponent);
  selectAllCheckBox.option("onValueChanged", handler);
}
function updateListSelectAllState(listComponent, filterValues) {
  if (listComponent.option("searchValue")) {
    return;
  }
  const selectAllCheckBox = getSelectAllCheckBox(listComponent);
  if (selectAllCheckBox && null !== filterValues && void 0 !== filterValues && filterValues.length) {
    selectAllCheckBox.option("value", void 0);
  }
}
function updateHeaderFilterItemSelectionState(item, filterValuesMatch, isExcludeFilter) {
  if (filterValuesMatch ^ isExcludeFilter) {
    item.selected = true;
    if (isExcludeFilter && item.items) {
      for (let j = 0; j < item.items.length; j++) {
        if (!item.items[j].selected) {
          item.selected = void 0;
          break;
        }
      }
    }
  } else if (isExcludeFilter || item.selected) {
    item.selected = false;
    resetChildrenItemSelection(item.items);
  }
}
var HeaderFilterView = class extends m_modules_default.View {
  getPopupContainer() {
    return this._popupContainer;
  }
  getListComponent() {
    return this._listComponent;
  }
  applyHeaderFilter(options) {
    const list = this.getListComponent();
    const searchValue = list.option("searchValue");
    const selectAllCheckBox = getSelectAllCheckBox(list);
    const isAllSelected = !searchValue && !options.isFilterBuilder && (null === selectAllCheckBox || void 0 === selectAllCheckBox ? void 0 : selectAllCheckBox.option("value"));
    const filterValues = [];
    const fillSelectedItemKeys = function(filterValues2, items, isExclude) {
      each(items, ((_, item) => {
        if (void 0 !== item.selected && !!item.selected ^ isExclude) {
          const node = list._getNode(item);
          const hasChildren = list._hasChildren(node);
          const hasChildrenWithSelection = hasChildren && item.items && item.items.some(((item2) => item2.selected));
          if (!searchValue || !hasChildrenWithSelection) {
            filterValues2.push(item.value);
            return;
          }
        }
        if (item.items && item.items.length) {
          fillSelectedItemKeys(filterValues2, item.items, isExclude);
        }
      }));
    };
    if (!isAllSelected) {
      if ("tree" === options.type) {
        if (options.filterType) {
          options.filterType = "include";
        }
        fillSelectedItemKeys(filterValues, list.option("items"), false);
        options.filterValues = filterValues;
      }
    } else {
      if ("tree" === options.type) {
        options.filterType = "exclude";
      }
      if (Array.isArray(options.filterValues)) {
        options.filterValues = [];
      }
    }
    if (options.filterValues && !options.filterValues.length) {
      options.filterValues = null;
    }
    options.apply();
    this.hideHeaderFilterMenu();
  }
  showHeaderFilterMenu($columnElement, options) {
    const that = this;
    if (options) {
      that._initializePopupContainer(options);
      const popupContainer = that.getPopupContainer();
      that.hideHeaderFilterMenu();
      that.updatePopup($columnElement, options);
      popupContainer.show();
    }
  }
  hideHeaderFilterMenu() {
    const headerFilterMenu = this.getPopupContainer();
    headerFilterMenu && headerFilterMenu.hide();
  }
  updatePopup($element, options) {
    const that = this;
    const showColumnLines = this.option("showColumnLines");
    const alignment = "right" === options.alignment ^ !showColumnLines ? "left" : "right";
    that._popupContainer.setAria({
      role: "dialog",
      label: message_default.format("dxDataGrid-headerFilterLabel")
    });
    if (that._popupContainer) {
      that._cleanPopupContent();
      that._popupContainer.option("position", {
        my: `${alignment} top`,
        at: `${alignment} bottom`,
        of: $element,
        collision: "fit fit"
      });
    }
  }
  _getSearchExpr(options, headerFilterOptions) {
    const {
      lookup
    } = options;
    const {
      useDefaultSearchExpr
    } = options;
    const headerFilterDataSource = headerFilterOptions.dataSource;
    const filterSearchExpr = headerFilterOptions.search.searchExpr;
    if (filterSearchExpr) {
      return filterSearchExpr;
    }
    if (useDefaultSearchExpr || isDefined(headerFilterDataSource) && !isFunction(headerFilterDataSource)) {
      return "text";
    }
    if (lookup) {
      return lookup.displayExpr || "this";
    }
    if (options.dataSource) {
      const {
        group
      } = options.dataSource;
      if (Array.isArray(group) && group.length > 0) {
        return group[0].selector;
      }
      if (isFunction(group) && !options.remoteFiltering) {
        return group;
      }
    }
    return options.dataField || options.selector;
  }
  _cleanPopupContent() {
    this._popupContainer && this._popupContainer.$content().empty();
  }
  _initializePopupContainer(options) {
    const that = this;
    const $element = that.element();
    const headerFilterOptions = this._normalizeHeaderFilterOptions(options);
    const {
      hidePopupCallback
    } = options;
    const {
      height,
      width
    } = headerFilterOptions;
    const dxPopupOptions = {
      width,
      height,
      visible: false,
      shading: false,
      showTitle: false,
      showCloseButton: false,
      hideOnParentScroll: false,
      dragEnabled: false,
      hideOnOutsideClick: true,
      wrapperAttr: {
        class: "dx-header-filter-menu"
      },
      focusStateEnabled: false,
      toolbarItems: [{
        toolbar: "bottom",
        location: "after",
        widget: "dxButton",
        options: {
          text: headerFilterOptions.texts.ok,
          onClick() {
            that.applyHeaderFilter(options);
          }
        }
      }, {
        toolbar: "bottom",
        location: "after",
        widget: "dxButton",
        options: {
          text: headerFilterOptions.texts.cancel,
          onClick() {
            that.hideHeaderFilterMenu();
            null === hidePopupCallback || void 0 === hidePopupCallback || hidePopupCallback();
          }
        }
      }],
      resizeEnabled: true,
      onShowing(e) {
        e.component.$content().parent().addClass("dx-dropdowneditor-overlay");
        that._initializeListContainer(options, headerFilterOptions);
        options.onShowing && options.onShowing(e);
      },
      onShown() {
        that.getListComponent().focus();
      },
      onHidden: options.onHidden,
      onInitialized(e) {
        const {
          component
        } = e;
        component.option("animation", component._getDefaultOptions().animation);
      },
      _loopFocus: true
    };
    if (!isDefined(that._popupContainer)) {
      that._popupContainer = that._createComponent($element, ui_popup_default, dxPopupOptions);
    } else {
      that._popupContainer.option(dxPopupOptions);
    }
  }
  _initializeListContainer(options, headerFilterOptions) {
    const that = this;
    const $content = that._popupContainer.$content();
    const needShowSelectAllCheckbox = !options.isFilterBuilder && headerFilterOptions.allowSelectAll;
    const widgetOptions = {
      searchEnabled: headerFilterOptions.search.enabled,
      searchTimeout: headerFilterOptions.search.timeout,
      searchEditorOptions: headerFilterOptions.search.editorOptions,
      searchMode: headerFilterOptions.search.mode || "",
      dataSource: options.dataSource,
      onContentReady() {
        that.renderCompleted.fire();
      },
      itemTemplate(data17, _, element) {
        const $element = renderer_default(element);
        if (false !== options.encodeHtml) {
          return $element.text(data17.text);
        }
        return $element.html(data17.text);
      }
    };
    const shouldChangeSelectAllCheckBoxVisibility = () => needShowSelectAllCheckbox && false !== that.option("headerFilter.hideSelectAllOnSearch");
    const onTreeViewOptionChanged = (event) => {
      switch (true) {
        case ("searchValue" === event.fullName && shouldChangeSelectAllCheckBoxVisibility()):
          event.component.option("showCheckBoxesMode", event.value ? "normal" : "selectAll");
          break;
        case "showCheckBoxesMode" === event.fullName:
          Promise.resolve().then((() => {
            event.component.getSearchBoxController().focus();
          })).catch((() => {
          }));
      }
    };
    const onListOptionChanged = (event) => {
      if ("searchValue" === event.fullName && shouldChangeSelectAllCheckBoxVisibility()) {
        event.component.option("selectionMode", event.value ? "multiple" : "all");
      }
    };
    if ("tree" === options.type) {
      that._listComponent = that._createComponent(renderer_default("<div>").appendTo($content), tree_view_search_default, extend(widgetOptions, {
        showCheckBoxesMode: needShowSelectAllCheckbox ? "selectAll" : "normal",
        onOptionChanged: onTreeViewOptionChanged,
        keyExpr: "id"
      }));
    } else {
      that._listComponent = that._createComponent(renderer_default("<div>").appendTo($content), list_edit_search_default, extend(widgetOptions, {
        searchExpr: that._getSearchExpr(options, headerFilterOptions),
        pageLoadMode: "scrollBottom",
        showSelectionControls: true,
        selectionMode: needShowSelectAllCheckbox ? "all" : "multiple",
        onOptionChanged: onListOptionChanged,
        onSelectionChanged(event) {
          const {
            component: listComponent
          } = event;
          const items = listComponent.option("items");
          const selectedItems = listComponent.option("selectedItems");
          if (!listComponent._selectedItemsUpdating && !listComponent.option("searchValue") && !options.isFilterBuilder) {
            const filterValues = options.filterValues || [];
            const isExclude = "exclude" === options.filterType;
            if (0 === selectedItems.length && items.length && (filterValues.length <= 1 || isExclude && filterValues.length === items.length - 1)) {
              options.filterType = "include";
              options.filterValues = [];
            } else if (selectedItems.length === items.length) {
              options.filterType = "exclude";
              options.filterValues = [];
            }
          }
          each(items, ((index, item) => {
            const selected = m_utils_default.getIndexByKey(item, selectedItems, null) >= 0;
            const oldSelected = !!item.selected;
            if (oldSelected !== selected) {
              item.selected = selected;
              options.filterValues = options.filterValues || [];
              const filterValueIndex = m_utils_default.getIndexByKey(item.value, options.filterValues, null);
              if (filterValueIndex >= 0) {
                options.filterValues.splice(filterValueIndex, 1);
              }
              const isExcludeFilterType = "exclude" === options.filterType;
              if (selected ^ isExcludeFilterType) {
                options.filterValues.push(item.value);
              }
            }
          }));
          updateListSelectAllState(listComponent, options.filterValues);
        },
        onContentReady(e) {
          const {
            component: listComponent
          } = e;
          const items = listComponent.option("items");
          const selectedItems = [];
          each(items, (function() {
            if (this.selected) {
              selectedItems.push(this);
            }
          }));
          listComponent._selectedItemsUpdating = true;
          listComponent.option("selectedItems", selectedItems);
          listComponent._selectedItemsUpdating = false;
          decorateListSelectAllValueChanged(listComponent);
          updateListSelectAllState(listComponent, options.filterValues);
        }
      }));
    }
  }
  _normalizeHeaderFilterOptions(options) {
    const generalHeaderFilter = this.option("headerFilter") || {};
    const specificHeaderFilter = options.headerFilter || {};
    const generalDeprecated = {
      search: {
        enabled: generalHeaderFilter.allowSearch,
        timeout: generalHeaderFilter.searchTimeout
      }
    };
    const specificDeprecated = {
      search: {
        enabled: specificHeaderFilter.allowSearch,
        mode: specificHeaderFilter.searchMode,
        timeout: specificHeaderFilter.searchTimeout
      }
    };
    return extend(true, {}, generalHeaderFilter, generalDeprecated, specificHeaderFilter, specificDeprecated);
  }
  _renderCore() {
    this.element().addClass("dx-header-filter-menu");
  }
};
var allowHeaderFiltering = function(column) {
  return isDefined(column.allowHeaderFiltering) ? column.allowHeaderFiltering : column.allowFiltering;
};
var headerFilterMixin = (Base) => class extends Base {
  optionChanged(args) {
    if ("headerFilter" === args.name) {
      const requireReady = "columnHeadersView" === this.name;
      this._invalidate(requireReady, requireReady);
      args.handled = true;
    } else {
      super.optionChanged(args);
    }
  }
  _applyColumnState(options) {
    let $headerFilterIndicator;
    const {
      rootElement
    } = options;
    const {
      column
    } = options;
    if ("headerFilter" === options.name) {
      rootElement.find(".dx-header-filter").remove();
      if (allowHeaderFiltering(column)) {
        $headerFilterIndicator = super._applyColumnState(options).toggleClass("dx-header-filter-empty", this._isHeaderFilterEmpty(column));
        if (!this.option("useLegacyKeyboardNavigation")) {
          $headerFilterIndicator.attr("tabindex", this.option("tabindex") || 0);
        }
        const indicatorLabel = message_default.format("dxDataGrid-headerFilterIndicatorLabel", column.caption);
        $headerFilterIndicator.attr("aria-label", indicatorLabel);
        $headerFilterIndicator.attr("aria-haspopup", "dialog");
        $headerFilterIndicator.attr("role", "button");
      }
      return $headerFilterIndicator;
    }
    return super._applyColumnState(options);
  }
  _isHeaderFilterEmpty(column) {
    return !column.filterValues || !column.filterValues.length;
  }
  _getIndicatorClassName(name) {
    if ("headerFilter" === name) {
      return "dx-header-filter";
    }
    return super._getIndicatorClassName(name);
  }
  _renderIndicator(options) {
    const $container = options.container;
    const $indicator = options.indicator;
    if ("headerFilter" === options.name) {
      const rtlEnabled = this.option("rtlEnabled");
      if ($container.children().length && (!rtlEnabled && "right" === options.columnAlignment || rtlEnabled && "left" === options.columnAlignment)) {
        $container.prepend($indicator);
        return;
      }
    }
    super._renderIndicator(options);
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/header_filter/m_header_filter.js
var DATE_INTERVAL_FORMATS = {
  month: (value2) => date_default2.getMonthNames()[value2 - 1],
  quarter: (value2) => date_default2.format(new Date(2e3, 3 * value2 - 1), "quarter")
};
function ungroupUTCDates(items, dateParts, dates) {
  dateParts = dateParts || [];
  dates = dates || [];
  items.forEach(((item) => {
    if (isDefined(item.key)) {
      const isMonthPart = 1 === dateParts.length;
      dateParts.push(isMonthPart ? item.key - 1 : item.key);
      if (item.items) {
        ungroupUTCDates(item.items, dateParts, dates);
      } else {
        const date = new Date(Date.UTC.apply(Date, dateParts));
        dates.push(date);
      }
      dateParts.pop();
    } else {
      dates.push(null);
    }
  }));
  return dates;
}
function convertDataFromUTCToLocal(data17, column) {
  const dates = ungroupUTCDates(data17);
  const query = m_query_default(dates);
  const group = m_utils_default.getHeaderFilterGroupParameters(_extends({}, column, {
    calculateCellValue: (date) => date
  }));
  return m_store_helper_default.queryByOptions(query, {
    group
  }).toArray();
}
function isUTCFormat(format2) {
  return "Z" === (null === format2 || void 0 === format2 ? void 0 : format2.slice(-1)) || "'Z'" === (null === format2 || void 0 === format2 ? void 0 : format2.slice(-3));
}
var getFormatOptions = function(value2, column, currentLevel) {
  const groupInterval = filtering_default.getGroupInterval(column);
  const result = m_utils_default.getFormatOptionsByColumn(column, "headerFilter");
  if (groupInterval) {
    result.groupInterval = groupInterval[currentLevel];
    if (m_utils_default.isDateType(column.dataType)) {
      result.format = DATE_INTERVAL_FORMATS[groupInterval[currentLevel]];
    } else if ("number" === column.dataType) {
      result.getDisplayFormat = function() {
        const formatOptions = {
          format: column.format,
          target: "headerFilter"
        };
        const firstValueText = m_utils_default.formatValue(value2, formatOptions);
        const secondValue = value2 + groupInterval[currentLevel];
        const secondValueText = m_utils_default.formatValue(secondValue, formatOptions);
        return firstValueText && secondValueText ? `${firstValueText} - ${secondValueText}` : "";
      };
    }
  }
  return result;
};
var HeaderFilterController = class extends m_modules_default.ViewController {
  init() {
    this._columnsController = this.getController("columns");
    this._dataController = this.getController("data");
    this._headerFilterView = this.getView("headerFilterView");
  }
  _updateSelectedState(items, column) {
    let i = items.length;
    const isExclude = "exclude" === column.filterType;
    while (i--) {
      const item = items[i];
      if ("items" in items[i]) {
        this._updateSelectedState(items[i].items, column);
      }
      updateHeaderFilterItemSelectionState(item, m_utils_default.getIndexByKey(items[i].value, column.filterValues, null) > -1, isExclude);
    }
  }
  _normalizeGroupItem(item, currentLevel, options) {
    let value2;
    let displayValue;
    const {
      path
    } = options;
    const {
      valueSelector
    } = options;
    const {
      displaySelector
    } = options;
    const {
      column
    } = options;
    if (valueSelector && displaySelector) {
      value2 = valueSelector(item);
      displayValue = displaySelector(item);
    } else {
      value2 = item.key;
      displayValue = value2;
    }
    if (!isObject(item)) {
      item = {};
    } else {
      item = extend({}, item);
    }
    path.push(value2);
    if (1 === path.length) {
      item.value = path[0];
    } else {
      item.value = path.join("/");
    }
    item.text = this.getHeaderItemText(displayValue, column, currentLevel, options.headerFilterOptions);
    return item;
  }
  getHeaderItemText(displayValue, column, currentLevel, headerFilterOptions) {
    let text = m_utils_default.formatValue(displayValue, getFormatOptions(displayValue, column, currentLevel));
    if (!text) {
      text = headerFilterOptions.texts.emptyValue;
    }
    return text;
  }
  _processGroupItems(groupItems, currentLevel, path, options) {
    const that = this;
    let displaySelector;
    let valueSelector;
    const {
      column
    } = options;
    const {
      lookup
    } = column;
    const {
      level
    } = options;
    path = path || [];
    currentLevel = currentLevel || 0;
    if (lookup) {
      displaySelector = compileGetter(lookup.displayExpr);
      valueSelector = compileGetter(lookup.valueExpr);
    }
    for (let i = 0; i < groupItems.length; i++) {
      groupItems[i] = that._normalizeGroupItem(groupItems[i], currentLevel, {
        column: options.column,
        headerFilterOptions: options.headerFilterOptions,
        displaySelector,
        valueSelector,
        path
      });
      if ("items" in groupItems[i]) {
        if (currentLevel === level || !isDefined(groupItems[i].value)) {
          delete groupItems[i].items;
        } else {
          that._processGroupItems(groupItems[i].items, currentLevel + 1, path, options);
        }
      }
      path.pop();
    }
  }
  getDataSource(column) {
    var _column$headerFilter;
    const dataSource = this._dataController.dataSource();
    const remoteGrouping = null === dataSource || void 0 === dataSource ? void 0 : dataSource.remoteOperations().grouping;
    const group = m_utils_default.getHeaderFilterGroupParameters(column, remoteGrouping);
    const headerFilterDataSource = null === (_column$headerFilter = column.headerFilter) || void 0 === _column$headerFilter ? void 0 : _column$headerFilter.dataSource;
    const headerFilterOptions = this.option("headerFilter");
    let isLookup = false;
    const options = {
      component: this.component
    };
    if (!dataSource) {
      return;
    }
    if (isDefined(headerFilterDataSource) && !isFunction(headerFilterDataSource)) {
      options.dataSource = normalizeDataSourceOptions(headerFilterDataSource);
    } else if (column.lookup) {
      isLookup = true;
      if (this.option("syncLookupFilterValues")) {
        this._currentColumn = column;
        const filter = this._dataController.getCombinedFilter();
        this._currentColumn = null;
        options.dataSource = m_utils_default.getWrappedLookupDataSource(column, dataSource, filter);
      } else {
        options.dataSource = m_utils_default.normalizeLookupDataSource(column.lookup);
      }
    } else {
      const cutoffLevel = Array.isArray(group) ? group.length - 1 : 0;
      this._currentColumn = column;
      const filter = this._dataController.getCombinedFilter();
      this._currentColumn = null;
      options.dataSource = {
        filter,
        group,
        useDefaultSearch: true,
        load: (options2) => {
          const d = new Deferred();
          options2.dataField = column.dataField || column.name;
          dataSource.load(options2).done(((data17) => {
            const convertUTCDates = remoteGrouping && isUTCFormat(column.serializationFormat) && cutoffLevel > 3;
            if (convertUTCDates) {
              data17 = convertDataFromUTCToLocal(data17, column);
            }
            that._processGroupItems(data17, null, null, {
              level: cutoffLevel,
              column,
              headerFilterOptions
            });
            d.resolve(data17);
          })).fail(d.reject);
          return d;
        }
      };
    }
    if (isFunction(headerFilterDataSource)) {
      headerFilterDataSource.call(column, options);
    }
    const origPostProcess = options.dataSource.postProcess;
    const that = this;
    options.dataSource.postProcess = function(data17) {
      let items = data17;
      if (isLookup) {
        items = items.filter(((item) => null !== item[column.lookup.valueExpr]));
        if (0 === this.pageIndex() && !this.searchValue()) {
          items = items.slice(0);
          items.unshift(null);
        }
        that._processGroupItems(items, null, null, {
          level: 0,
          column,
          headerFilterOptions
        });
      }
      items = origPostProcess && origPostProcess.call(this, items) || items;
      that._updateSelectedState(items, column);
      return items;
    };
    return options.dataSource;
  }
  getCurrentColumn() {
    return this._currentColumn;
  }
  showHeaderFilterMenu(columnIndex, isGroupPanel) {
    const columnsController = this._columnsController;
    const column = extend(true, {}, this._columnsController.getColumns()[columnIndex]);
    if (column) {
      const visibleIndex = columnsController.getVisibleIndex(columnIndex);
      const view = isGroupPanel ? this.getView("headerPanel") : this.getView("columnHeadersView");
      const $columnElement = view.getColumnElements().eq(isGroupPanel ? column.groupIndex : visibleIndex);
      this.showHeaderFilterMenuBase({
        columnElement: $columnElement,
        column,
        applyFilter: true,
        apply() {
          columnsController.columnOption(columnIndex, {
            filterValues: this.filterValues,
            filterType: this.filterType
          });
        }
      });
    }
  }
  showHeaderFilterMenuBase(options) {
    const that = this;
    const {
      column
    } = options;
    if (column) {
      const groupInterval = filtering_default.getGroupInterval(column);
      const dataSource = that._dataController.dataSource();
      const remoteFiltering = dataSource && dataSource.remoteOperations().filtering;
      const previousOnHidden = options.onHidden;
      extend(options, column, {
        type: groupInterval && groupInterval.length > 1 ? "tree" : "list",
        remoteFiltering,
        onShowing: (e) => {
          const dxResizableInstance = e.component.$overlayContent().dxResizable("instance");
          dxResizableInstance && dxResizableInstance.option("onResizeEnd", ((e2) => {
            let headerFilterByColumn = this._columnsController.columnOption(options.dataField, "headerFilter");
            headerFilterByColumn = headerFilterByColumn || {};
            headerFilterByColumn.width = e2.width;
            headerFilterByColumn.height = e2.height;
            this._columnsController.columnOption(options.dataField, "headerFilter", headerFilterByColumn, true);
          }));
        },
        onHidden: () => {
          null === previousOnHidden || void 0 === previousOnHidden || previousOnHidden();
          restoreFocus(this);
        }
      });
      options.dataSource = that.getDataSource(options);
      if (options.isFilterBuilder) {
        options.dataSource.filter = null;
        options.alignment = "right";
      }
      that._headerFilterView.showHeaderFilterMenu(options.columnElement, options);
    }
  }
  hideHeaderFilterMenu() {
    this._headerFilterView.hideHeaderFilterMenu();
  }
};
var columnHeadersView4 = (Base) => class extends headerFilterMixin(Base) {
  _renderCellContent($cell, options) {
    const that = this;
    let $headerFilterIndicator;
    const {
      column
    } = options;
    if (!column.command && allowHeaderFiltering(column) && that.option("headerFilter.visible") && "header" === options.rowType) {
      $headerFilterIndicator = that._applyColumnState({
        name: "headerFilter",
        rootElement: $cell,
        column,
        showColumnLines: that.option("showColumnLines")
      });
      $headerFilterIndicator && that._subscribeToIndicatorEvent($headerFilterIndicator, column, "headerFilter");
    }
    super._renderCellContent.apply(this, arguments);
  }
  _subscribeToIndicatorEvent($indicator, column, indicatorName) {
    if ("headerFilter" === indicatorName) {
      m_events_engine_default.on($indicator, CLICK_EVENT_NAME, this.createAction(((e) => {
        e.event.stopPropagation();
        saveFocusedElementInfo($indicator, this);
        this._headerFilterController.showHeaderFilterMenu(column.index, false);
      })));
    }
  }
  _updateIndicator($cell, column, indicatorName) {
    const $indicator = super._updateIndicator($cell, column, indicatorName);
    $indicator && this._subscribeToIndicatorEvent($indicator, column, indicatorName);
  }
  _updateHeaderFilterIndicators() {
    if (this.option("headerFilter.visible")) {
      this._updateIndicators("headerFilter");
    }
  }
  _needUpdateFilterIndicators() {
    return true;
  }
  _columnOptionChanged(e) {
    const {
      optionNames
    } = e;
    const isFilterRowAndHeaderFilterValuesChanged = m_utils_default.checkChanges(optionNames, ["filterValues", "filterValue"]);
    const isHeaderFilterValuesAndTypeChanged = m_utils_default.checkChanges(optionNames, ["filterValues", "filterType"]);
    const shouldUpdateFilterIndicators = (isFilterRowAndHeaderFilterValuesChanged || isHeaderFilterValuesAndTypeChanged) && this._needUpdateFilterIndicators();
    if (shouldUpdateFilterIndicators) {
      this._updateHeaderFilterIndicators();
    }
    if (!isHeaderFilterValuesAndTypeChanged) {
      super._columnOptionChanged(e);
    }
  }
};
var headerPanel5 = (Base) => class extends headerFilterMixin(Base) {
  _createGroupPanelItem($rootElement, groupColumn) {
    const that = this;
    const $item = super._createGroupPanelItem.apply(that, arguments);
    let $headerFilterIndicator;
    if (!groupColumn.command && allowHeaderFiltering(groupColumn) && that.option("headerFilter.visible")) {
      $headerFilterIndicator = that._applyColumnState({
        name: "headerFilter",
        rootElement: $item,
        column: {
          alignment: getDefaultAlignment(that.option("rtlEnabled")),
          filterValues: groupColumn.filterValues,
          allowHeaderFiltering: true,
          caption: groupColumn.caption
        },
        showColumnLines: true
      });
      $headerFilterIndicator && m_events_engine_default.on($headerFilterIndicator, CLICK_EVENT_NAME, that.createAction(((e) => {
        const {
          event
        } = e;
        event.stopPropagation();
        this._headerFilterController.showHeaderFilterMenu(groupColumn.index, true);
      })));
    }
    return $item;
  }
};
var data9 = (Base) => class extends Base {
  skipCalculateColumnFilters() {
    return false;
  }
  _calculateAdditionalFilter() {
    if (this.skipCalculateColumnFilters()) {
      return super._calculateAdditionalFilter();
    }
    const filters = [super._calculateAdditionalFilter()];
    const columns7 = this._columnsController.getVisibleColumns(null, true);
    const headerFilterController = this._headerFilterController;
    const currentColumn = headerFilterController.getCurrentColumn();
    each(columns7, ((_, column) => {
      let filter;
      if (currentColumn && currentColumn.index === column.index) {
        return;
      }
      if (allowHeaderFiltering(column) && column.calculateFilterExpression && Array.isArray(column.filterValues) && column.filterValues.length) {
        let filterValues = [];
        each(column.filterValues, ((_2, filterValue) => {
          if (Array.isArray(filterValue)) {
            filter = filterValue;
          } else {
            if (column.deserializeValue && !m_utils_default.isDateType(column.dataType) && "number" !== column.dataType) {
              filterValue = column.deserializeValue(filterValue);
            }
            filter = column.createFilterExpression(filterValue, "=", "headerFilter");
          }
          if (filter) {
            filter.columnIndex = column.index;
          }
          filterValues.push(filter);
        }));
        filterValues = m_utils_default.combineFilters(filterValues, "or");
        filters.push("exclude" === column.filterType ? ["!", filterValues] : filterValues);
      }
    }));
    return m_utils_default.combineFilters(filters);
  }
};
var headerFilterModule = {
  defaultOptions: () => ({
    syncLookupFilterValues: true,
    headerFilter: {
      visible: false,
      width: 252,
      height: 325,
      allowSelectAll: true,
      search: {
        enabled: false,
        timeout: 500,
        mode: "contains",
        editorOptions: {}
      },
      texts: {
        emptyValue: message_default.format("dxDataGrid-headerFilterEmptyValue"),
        ok: message_default.format("dxDataGrid-headerFilterOK"),
        cancel: message_default.format("dxDataGrid-headerFilterCancel")
      }
    }
  }),
  controllers: {
    headerFilter: HeaderFilterController
  },
  views: {
    headerFilterView: HeaderFilterView
  },
  extenders: {
    controllers: {
      data: data9
    },
    views: {
      columnHeadersView: columnHeadersView4,
      headerPanel: headerPanel5
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/header_filter.js
m_core_default.registerModule("headerFilter", headerFilterModule);

// node_modules/devextreme/esm/__internal/filter_builder/m_between.js
function editorTemplate(conditionInfo, container) {
  const $editorStart = renderer_default("<div>").addClass("dx-filterbuilder-range-start");
  const $editorEnd = renderer_default("<div>").addClass("dx-filterbuilder-range-end");
  let values = conditionInfo.value || [];
  const getStartValue = function(values2) {
    return values2 && values2.length > 0 ? values2[0] : null;
  };
  const getEndValue = function(values2) {
    return values2 && 2 === values2.length ? values2[1] : null;
  };
  container.append($editorStart);
  container.append(renderer_default("<span>").addClass("dx-filterbuilder-range-separator").text("–"));
  container.append($editorEnd);
  container.addClass("dx-filterbuilder-range");
  this._editorFactory.createEditor.call(this, $editorStart, extend({}, conditionInfo.field, conditionInfo, {
    value: getStartValue(values),
    parentType: "filterBuilder",
    setValue(value2) {
      values = [value2, getEndValue(values)];
      conditionInfo.setValue(values);
    }
  }));
  this._editorFactory.createEditor.call(this, $editorEnd, extend({}, conditionInfo.field, conditionInfo, {
    value: getEndValue(values),
    parentType: "filterBuilder",
    setValue(value2) {
      values = [getStartValue(values), value2];
      conditionInfo.setValue(values);
    }
  }));
}
function getConfig(caption, context) {
  return {
    name: "between",
    caption,
    icon: "range",
    valueSeparator: "–",
    dataTypes: ["number", "date", "datetime"],
    editorTemplate: editorTemplate.bind(context),
    notForLookup: true
  };
}

// node_modules/devextreme/esm/__internal/filter_builder/m_filter_operations_dictionary.js
var OPERATION_ICONS2 = {
  "=": "equal",
  "<>": "notequal",
  "<": "less",
  "<=": "lessorequal",
  ">": "greater",
  ">=": "greaterorequal",
  notcontains: "doesnotcontain",
  contains: "contains",
  startswith: "startswith",
  endswith: "endswith",
  isblank: "isblank",
  isnotblank: "isnotblank"
};
var OPERATION_NAME = {
  "=": "equal",
  "<>": "notEqual",
  "<": "lessThan",
  "<=": "lessThanOrEqual",
  ">": "greaterThan",
  ">=": "greaterThanOrEqual",
  startswith: "startsWith",
  contains: "contains",
  notcontains: "notContains",
  endswith: "endsWith",
  isblank: "isBlank",
  isnotblank: "isNotBlank",
  between: "between"
};
var m_filter_operations_dictionary_default = {
  getIconByFilterOperation: (filterOperation) => OPERATION_ICONS2[filterOperation],
  getNameByFilterOperation: (filterOperation) => OPERATION_NAME[filterOperation]
};

// node_modules/devextreme/esm/__internal/filter_builder/m_utils.js
var DATATYPE_OPERATIONS2 = {
  number: ["=", "<>", "<", ">", "<=", ">=", "isblank", "isnotblank"],
  string: ["contains", "notcontains", "startswith", "endswith", "=", "<>", "isblank", "isnotblank"],
  date: ["=", "<>", "<", ">", "<=", ">=", "isblank", "isnotblank"],
  datetime: ["=", "<>", "<", ">", "<=", ">=", "isblank", "isnotblank"],
  boolean: ["=", "<>", "isblank", "isnotblank"],
  object: ["isblank", "isnotblank"]
};
var DEFAULT_FORMAT = {
  date: "shortDate",
  datetime: "shortDateShortTime"
};
var LOOKUP_OPERATIONS = ["=", "<>", "isblank", "isnotblank"];
var AVAILABLE_FIELD_PROPERTIES = ["caption", "customizeText", "dataField", "dataType", "editorTemplate", "falseText", "editorOptions", "filterOperations", "format", "lookup", "trueText", "calculateFilterExpression", "name"];
function getFormattedValueText(field, value2) {
  const fieldFormat = field.format || DEFAULT_FORMAT[field.dataType];
  if (isBoolean(value2)) {
    const trueText = field.trueText || message_default.format("dxDataGrid-trueText");
    const falseText = field.falseText || message_default.format("dxDataGrid-falseText");
    return value2 ? trueText : falseText;
  }
  if ("date" === field.dataType || "datetime" === field.dataType) {
    return format_helper_default.format(new Date(value2), fieldFormat);
  }
  return format_helper_default.format(value2, fieldFormat);
}
function isNegationGroup(group) {
  return group && group.length > 1 && "!" === group[0] && !isCondition(group);
}
function getGroupCriteria(group) {
  return isNegationGroup(group) ? group[1] : group;
}
function setGroupCriteria(group, criteria) {
  if (isNegationGroup(group)) {
    group[1] = criteria;
  } else {
    group = criteria;
  }
  return group;
}
function convertGroupToNewStructure(group, value2) {
  if ((function(value3) {
    return -1 !== value3.indexOf("!");
  })(value2)) {
    if (!isNegationGroup(group)) {
      !(function(group2) {
        const criteria = group2.slice(0);
        group2.length = 0;
        group2.push("!", criteria);
      })(group);
    }
  } else if (isNegationGroup(group)) {
    !(function(group2) {
      const criteria = getGroupCriteria(group2);
      group2.length = 0;
      [].push.apply(group2, criteria);
    })(group);
  }
}
function setGroupValue(group, value2) {
  convertGroupToNewStructure(group, value2);
  const criteria = getGroupCriteria(group);
  let i;
  value2 = (function(value3) {
    return -1 === value3.indexOf("!") ? value3 : value3.substring(1);
  })(value2);
  !(function(criteria2, value3) {
    for (i = 0; i < criteria2.length; i++) {
      if (!Array.isArray(criteria2[i])) {
        criteria2[i] = value3;
      }
    }
  })(criteria, value2);
  return group;
}
function getGroupMenuItem(group, availableGroups) {
  const groupValue = getGroupValue(group);
  return availableGroups.filter(((item) => item.value === groupValue))[0];
}
function getCriteriaOperation(criteria) {
  if (isCondition(criteria)) {
    return "and";
  }
  let value2 = "";
  for (let i = 0; i < criteria.length; i++) {
    const item = criteria[i];
    if (!Array.isArray(item)) {
      if (value2 && value2 !== item) {
        throw errors.Error("E4019");
      }
      if ("!" !== item) {
        value2 = item;
      }
    }
  }
  return value2;
}
function getGroupValue(group) {
  const criteria = getGroupCriteria(group);
  let value2 = getCriteriaOperation(criteria);
  if (!value2) {
    value2 = "and";
  }
  if (criteria !== group) {
    value2 = `!${value2}`;
  }
  return value2;
}
function getDefaultFilterOperations(field) {
  return field.lookup && LOOKUP_OPERATIONS || DATATYPE_OPERATIONS2[field.dataType || "string"];
}
function containItems(entity) {
  return Array.isArray(entity) && entity.length;
}
function getFilterOperations(field) {
  const result = containItems(field.filterOperations) ? field.filterOperations : getDefaultFilterOperations(field);
  return extend([], result);
}
function getCaptionByOperation(operation, filterOperationDescriptions) {
  const operationName = m_filter_operations_dictionary_default.getNameByFilterOperation(operation);
  return filterOperationDescriptions && filterOperationDescriptions[operationName] ? filterOperationDescriptions[operationName] : operationName;
}
function getOperationFromAvailable(operation, availableOperations) {
  for (let i = 0; i < availableOperations.length; i++) {
    if (availableOperations[i].value === operation) {
      return availableOperations[i];
    }
  }
  throw new ui_errors_default.Error("E1048", operation);
}
function getCustomOperation(customOperations, name) {
  const filteredOperations = customOperations.filter(((item) => item.name === name));
  return filteredOperations.length ? filteredOperations[0] : null;
}
function getAvailableOperations(field, filterOperationDescriptions, customOperations) {
  const filterOperations = getFilterOperations(field);
  const isLookupField = !!field.lookup;
  customOperations.forEach(((customOperation) => {
    if (!field.filterOperations && -1 === filterOperations.indexOf(customOperation.name)) {
      const dataTypes = customOperation && customOperation.dataTypes;
      const isOperationForbidden = isLookupField ? !!customOperation.notForLookup : false;
      if (!isOperationForbidden && dataTypes && dataTypes.indexOf(field.dataType || "string") >= 0) {
        filterOperations.push(customOperation.name);
      }
    }
  }));
  return filterOperations.map(((operation) => {
    const customOperation = getCustomOperation(customOperations, operation);
    if (customOperation) {
      return {
        icon: customOperation.icon || "icon-none",
        text: customOperation.caption || captionize(customOperation.name),
        value: customOperation.name,
        isCustom: true
      };
    }
    return {
      icon: m_filter_operations_dictionary_default.getIconByFilterOperation(operation) || "icon-none",
      text: getCaptionByOperation(operation, filterOperationDescriptions),
      value: operation
    };
  }));
}
function getDefaultOperation(field) {
  return field.defaultFilterOperation || getFilterOperations(field)[0];
}
function createCondition(field, customOperations) {
  const condition = [field.dataField, "", ""];
  const filterOperation = getDefaultOperation(field);
  updateConditionByOperation(condition, filterOperation, customOperations);
  return condition;
}
function removeItem(group, item) {
  const criteria = getGroupCriteria(group);
  const index = criteria.indexOf(item);
  criteria.splice(index, 1);
  if (1 !== criteria.length) {
    criteria.splice(index, 1);
  }
  return group;
}
function createEmptyGroup(value2) {
  const isNegation = isNegationGroupOperation(value2);
  const groupOperation = isNegation ? getGroupOperationFromNegationOperation(value2) : value2;
  return isNegation ? ["!", [groupOperation]] : [groupOperation];
}
function addItem(item, group) {
  const criteria = getGroupCriteria(group);
  const groupValue = getGroupValue(criteria);
  1 === criteria.length ? criteria.unshift(item) : criteria.push(item, groupValue);
  return group;
}
function getField(dataField, fields) {
  for (let i = 0; i < fields.length; i++) {
    if (fields[i].name === dataField) {
      return fields[i];
    }
    if (fields[i].dataField.toLowerCase() === dataField.toLowerCase()) {
      return fields[i];
    }
  }
  const extendedFields = getItems(fields, true).filter(((item) => item.dataField.toLowerCase() === dataField.toLowerCase()));
  if (extendedFields.length > 0) {
    return extendedFields[0];
  }
  throw new ui_errors_default.Error("E1047", dataField);
}
function isGroup(criteria) {
  if (!Array.isArray(criteria)) {
    return false;
  }
  return criteria.length < 2 || Array.isArray(criteria[0]) || Array.isArray(criteria[1]);
}
function isCondition(criteria) {
  if (!Array.isArray(criteria)) {
    return false;
  }
  return criteria.length > 1 && !Array.isArray(criteria[0]) && !Array.isArray(criteria[1]);
}
function convertToInnerGroup(group, customOperations, defaultGroupOperation) {
  defaultGroupOperation = defaultGroupOperation || "and";
  const groupOperation = getCriteriaOperation(group).toLowerCase() || defaultGroupOperation;
  let innerGroup = [];
  for (let i = 0; i < group.length; i++) {
    if (isGroup(group[i])) {
      innerGroup.push(convertToInnerStructure(group[i], customOperations, defaultGroupOperation));
      innerGroup = appendGroupOperationToGroup(innerGroup, groupOperation);
    } else if (isCondition(group[i])) {
      innerGroup.push(convertToInnerCondition(group[i], customOperations));
      innerGroup = appendGroupOperationToGroup(innerGroup, groupOperation);
    }
  }
  if (0 === innerGroup.length) {
    innerGroup = appendGroupOperationToGroup(innerGroup, groupOperation);
  }
  return innerGroup;
}
function conditionHasCustomOperation(condition, customOperations) {
  const customOperation = getCustomOperation(customOperations, condition[1]);
  return customOperation && customOperation.name === condition[1];
}
function convertToInnerCondition(condition, customOperations) {
  if (conditionHasCustomOperation(condition, customOperations)) {
    return condition;
  }
  if (condition.length < 3) {
    condition[2] = condition[1];
    condition[1] = "=";
  }
  return condition;
}
function isNegationGroupOperation(operation) {
  return -1 !== operation.indexOf("not");
}
function getGroupOperationFromNegationOperation(operation) {
  return operation.substring(3).toLowerCase();
}
function appendGroupOperationToCriteria(criteria, groupOperation) {
  const isNegation = isNegationGroupOperation(groupOperation);
  groupOperation = isNegation ? getGroupOperationFromNegationOperation(groupOperation) : groupOperation;
  return isNegation ? ["!", criteria, groupOperation] : [criteria, groupOperation];
}
function appendGroupOperationToGroup(group, groupOperation) {
  const isNegation = isNegationGroupOperation(groupOperation);
  groupOperation = isNegation ? getGroupOperationFromNegationOperation(groupOperation) : groupOperation;
  group.push(groupOperation);
  let result = group;
  if (isNegation) {
    result = ["!", result];
  }
  return result;
}
function convertToInnerStructure(value2, customOperations, defaultGroupOperation) {
  defaultGroupOperation = defaultGroupOperation || "and";
  if (!value2) {
    return createEmptyGroup(defaultGroupOperation);
  }
  value2 = extend(true, [], value2);
  if (isCondition(value2)) {
    return appendGroupOperationToCriteria(convertToInnerCondition(value2, customOperations), defaultGroupOperation);
  }
  if (isNegationGroup(value2)) {
    return ["!", isCondition(value2[1]) ? appendGroupOperationToCriteria(convertToInnerCondition(value2[1], customOperations), defaultGroupOperation) : isNegationGroup(value2[1]) ? appendGroupOperationToCriteria(convertToInnerStructure(value2[1], customOperations), defaultGroupOperation) : convertToInnerGroup(value2[1], customOperations, defaultGroupOperation)];
  }
  return convertToInnerGroup(value2, customOperations, defaultGroupOperation);
}
function getNormalizedFields(fields) {
  return fields.reduce(((result, field) => {
    if (isDefined(field.dataField)) {
      const normalizedField = {};
      for (const key in field) {
        if (field[key] && AVAILABLE_FIELD_PROPERTIES.includes(key)) {
          normalizedField[key] = field[key];
        }
      }
      normalizedField.defaultCalculateFilterExpression = filtering_default.defaultCalculateFilterExpression;
      if (!isDefined(normalizedField.dataType)) {
        normalizedField.dataType = "string";
      }
      if (!isDefined(normalizedField.trueText)) {
        normalizedField.trueText = message_default.format("dxDataGrid-trueText");
      }
      if (!isDefined(normalizedField.falseText)) {
        normalizedField.falseText = message_default.format("dxDataGrid-falseText");
      }
      result.push(normalizedField);
    }
    return result;
  }), []);
}
function getConditionFilterExpression(condition, fields, customOperations, target) {
  const field = getField(condition[0], fields);
  const filterExpression = convertToInnerCondition(condition, customOperations);
  const customOperation = customOperations.length && getCustomOperation(customOperations, filterExpression[1]);
  if (customOperation && customOperation.calculateFilterExpression) {
    return customOperation.calculateFilterExpression.apply(customOperation, [filterExpression[2], field, fields]);
  }
  if (field.createFilterExpression) {
    return field.createFilterExpression.apply(field, [filterExpression[2], filterExpression[1], target]);
  }
  if (field.calculateFilterExpression) {
    return field.calculateFilterExpression.apply(field, [filterExpression[2], filterExpression[1], target]);
  }
  return field.defaultCalculateFilterExpression.apply(field, [filterExpression[2], filterExpression[1], target]);
}
function getFilterExpression(value2, fields, customOperations, target) {
  if (!isDefined(value2)) {
    return null;
  }
  if (isNegationGroup(value2)) {
    const filterExpression2 = getFilterExpression(value2[1], fields, customOperations, target);
    return ["!", filterExpression2];
  }
  const criteria = getGroupCriteria(value2);
  if (isCondition(criteria)) {
    return getConditionFilterExpression(criteria, fields, customOperations, target) || null;
  }
  let result = [];
  let filterExpression;
  const groupValue = getGroupValue(criteria);
  for (let i = 0; i < criteria.length; i++) {
    if (isGroup(criteria[i])) {
      filterExpression = getFilterExpression(criteria[i], fields, customOperations, target);
      if (filterExpression) {
        i && result.push(groupValue);
        result.push(filterExpression);
      }
    } else if (isCondition(criteria[i])) {
      filterExpression = getConditionFilterExpression(criteria[i], fields, customOperations, target);
      if (filterExpression) {
        result.length && result.push(groupValue);
        result.push(filterExpression);
      }
    }
  }
  if (1 === result.length) {
    result = result[0];
  }
  return result.length ? result : null;
}
function getNormalizedFilter(group) {
  const criteria = getGroupCriteria(group);
  let i;
  if (0 === criteria.length) {
    return null;
  }
  const itemsForRemove = [];
  for (i = 0; i < criteria.length; i++) {
    if (isGroup(criteria[i])) {
      const normalizedGroupValue = getNormalizedFilter(criteria[i]);
      if (normalizedGroupValue) {
        criteria[i] = normalizedGroupValue;
      } else {
        itemsForRemove.push(criteria[i]);
      }
    } else if (isCondition(criteria[i])) {
      if (!isValidCondition(criteria[i])) {
        itemsForRemove.push(criteria[i]);
      }
    }
  }
  for (i = 0; i < itemsForRemove.length; i++) {
    removeItem(criteria, itemsForRemove[i]);
  }
  if (1 === criteria.length) {
    return null;
  }
  criteria.splice(criteria.length - 1, 1);
  if (1 === criteria.length) {
    group = setGroupCriteria(group, criteria[0]);
  }
  if (0 === group.length) {
    return null;
  }
  return group;
}
function getCurrentLookupValueText(field, value2, handler) {
  if ("" === value2) {
    handler("");
    return;
  }
  const {
    lookup
  } = field;
  if (lookup.items) {
    handler(lookup.calculateCellValue(value2) || "");
  } else {
    const lookupDataSource = isFunction(lookup.dataSource) ? lookup.dataSource({}) : lookup.dataSource;
    const dataSource = new DataSource(lookupDataSource);
    dataSource.loadSingle(lookup.valueExpr, value2).done(((result) => {
      let valueText = "";
      if (result) {
        valueText = lookup.displayExpr ? compileGetter(lookup.displayExpr)(result) : result;
      }
      if (field.customizeText) {
        valueText = field.customizeText({
          value: value2,
          valueText
        });
      }
      handler(valueText);
    })).fail((() => {
      handler("");
    }));
  }
}
function getPrimitiveValueText(field, value2, customOperation, target, options) {
  let valueText = getFormattedValueText(field, value2);
  if (field.customizeText) {
    valueText = field.customizeText.call(field, {
      value: value2,
      valueText,
      target
    });
  }
  if (customOperation && customOperation.customizeText) {
    valueText = customOperation.customizeText.call(customOperation, {
      value: value2,
      valueText,
      field,
      target
    }, options);
  }
  return valueText;
}
function getArrayValueText(field, value2, customOperation, target) {
  const options = {
    values: value2
  };
  return value2.map(((v) => getPrimitiveValueText(field, v, customOperation, target, options)));
}
function checkDefaultValue(value2) {
  return "" === value2 || null === value2;
}
function getCurrentValueText(field, value2, customOperation) {
  let target = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "filterBuilder";
  if (checkDefaultValue(value2)) {
    return "";
  }
  if (Array.isArray(value2)) {
    const result = new Deferred();
    when.apply(this, getArrayValueText(field, value2, customOperation, target)).done((function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      const text = args.some(((item) => !checkDefaultValue(item))) ? args.map(((item) => !checkDefaultValue(item) ? item : "?")) : "";
      result.resolve(text);
    }));
    return result;
  }
  return getPrimitiveValueText(field, value2, customOperation, target);
}
function itemExists(plainItems, parentId) {
  return plainItems.some(((item) => item.dataField === parentId));
}
function pushItemAndCheckParent(originalItems, plainItems, item) {
  const {
    dataField
  } = item;
  if (hasParent(dataField)) {
    item.parentId = getParentIdFromItemDataField(dataField);
    if (!itemExists(plainItems, item.parentId) && !itemExists(originalItems, item.parentId)) {
      pushItemAndCheckParent(originalItems, plainItems, {
        id: item.parentId,
        dataType: "object",
        dataField: item.parentId,
        caption: generateCaptionByDataField(item.parentId, true),
        filterOperations: ["isblank", "isnotblank"],
        defaultCalculateFilterExpression: filtering_default.defaultCalculateFilterExpression
      });
    }
  }
  plainItems.push(item);
}
function generateCaptionByDataField(dataField, allowHierarchicalFields) {
  let caption = "";
  if (allowHierarchicalFields) {
    dataField = dataField.substring(dataField.lastIndexOf(".") + 1);
  } else if (hasParent(dataField)) {
    dataField.split(".").forEach(((field, index, arr) => {
      caption += captionize(field);
      if (index !== arr.length - 1) {
        caption += ".";
      }
    }));
    return caption;
  }
  return captionize(dataField);
}
function getItems(fields, allowHierarchicalFields) {
  const items = [];
  for (let i = 0; i < fields.length; i++) {
    const item = extend(true, {
      caption: generateCaptionByDataField(fields[i].dataField, allowHierarchicalFields)
    }, fields[i]);
    item.id = item.name || item.dataField;
    if (allowHierarchicalFields) {
      pushItemAndCheckParent(fields, items, item);
    } else {
      items.push(item);
    }
  }
  return items;
}
function hasParent(dataField) {
  return -1 !== dataField.lastIndexOf(".");
}
function getParentIdFromItemDataField(dataField) {
  return dataField.substring(0, dataField.lastIndexOf("."));
}
function getCaptionWithParents(item, plainItems) {
  if (hasParent(item.dataField)) {
    const parentId = getParentIdFromItemDataField(item.dataField);
    for (let i = 0; i < plainItems.length; i++) {
      if (plainItems[i].dataField === parentId) {
        return `${getCaptionWithParents(plainItems[i], plainItems)}.${item.caption}`;
      }
    }
  }
  return item.caption;
}
function updateConditionByOperation(condition, operation, customOperations) {
  let customOperation = getCustomOperation(customOperations, operation);
  if (customOperation) {
    if (false === customOperation.hasValue) {
      condition[1] = operation;
      condition.length = 2;
    } else {
      condition[1] = operation;
      condition[2] = "";
    }
    return condition;
  }
  if ("isblank" === operation) {
    condition[1] = "=";
    condition[2] = null;
  } else if ("isnotblank" === operation) {
    condition[1] = "<>";
    condition[2] = null;
  } else {
    customOperation = getCustomOperation(customOperations, condition[1]);
    if (customOperation || 2 === condition.length || null === condition[2]) {
      condition[2] = "";
    }
    condition[1] = operation;
  }
  return condition;
}
function getOperationValue(condition) {
  let caption;
  if (null === condition[2]) {
    if ("=" === condition[1]) {
      caption = "isblank";
    } else {
      caption = "isnotblank";
    }
  } else {
    caption = condition[1];
  }
  return caption;
}
function isValidCondition(condition) {
  return "" !== condition[2];
}
function getMergedOperations(customOperations, betweenCaption, context) {
  const result = extend(true, [], customOperations);
  let betweenIndex = -1;
  result.some(((customOperation, index) => {
    if ("between" === customOperation.name) {
      betweenIndex = index;
      return true;
    }
    return;
  }));
  if (-1 !== betweenIndex) {
    result[betweenIndex] = extend(getConfig(betweenCaption, context), result[betweenIndex]);
  } else {
    result.unshift(getConfig(betweenCaption, context));
  }
  return result;
}
function isMatchedCondition(filter, addedFilterDataField) {
  return filter[0] === addedFilterDataField;
}
function removeFieldConditionsFromFilter(filter, dataField) {
  if (!filter || 0 === filter.length) {
    return null;
  }
  if (isCondition(filter)) {
    const hasMatchedCondition = isMatchedCondition(filter, dataField);
    return !hasMatchedCondition ? filter : null;
  }
  return syncConditionIntoGroup(filter, [dataField], false);
}
function syncConditionIntoGroup(filter, addedFilter, canPush) {
  const result = [];
  const isNegation = isNegationGroup(filter);
  filter.forEach(((item) => {
    if (isCondition(item)) {
      if (isMatchedCondition(item, addedFilter[0])) {
        if (canPush) {
          result.push(addedFilter);
          canPush = false;
        } else {
          result.splice(result.length - 1, 1);
        }
      } else {
        result.push(item);
      }
    } else {
      (result.length || isGroup(item)) && result.push(item);
    }
  }));
  if (0 === result.length) {
    return null;
  }
  if (canPush) {
    result.push("and");
    result.push(addedFilter);
  }
  if (isNegation) {
    return ["!", 1 === result.length ? result[0] : result];
  }
  return 1 === result.length ? result[0] : result;
}
function syncFilters(filter, addedFilter) {
  if (null === filter || 0 === filter.length) {
    return addedFilter;
  }
  if (isCondition(filter)) {
    if (isMatchedCondition(filter, addedFilter[0])) {
      return addedFilter;
    }
    return [filter, "and", addedFilter];
  }
  const groupValue = getGroupValue(filter);
  if ("and" !== groupValue) {
    return [addedFilter, "and", filter];
  }
  return syncConditionIntoGroup(filter, addedFilter, true);
}
function getMatchedConditions(filter, dataField) {
  if (null === filter || 0 === filter.length) {
    return [];
  }
  if (isCondition(filter)) {
    if (isMatchedCondition(filter, dataField)) {
      return [filter];
    }
    return [];
  }
  const groupValue = getGroupValue(filter);
  if ("and" !== groupValue) {
    return [];
  }
  const result = filter.filter(((item) => isCondition(item) && isMatchedCondition(item, dataField)));
  return result;
}
function filterHasField(filter, dataField) {
  if (null === filter || 0 === filter.length) {
    return false;
  }
  if (isCondition(filter)) {
    return filter[0] === dataField;
  }
  return filter.some(((item) => (isCondition(item) || isGroup(item)) && filterHasField(item, dataField)));
}
var renderValueText = function($container, value2, customOperation) {
  if (Array.isArray(value2)) {
    const lastItemIndex = value2.length - 1;
    $container.empty();
    value2.forEach(((t, i) => {
      renderer_default("<span>").addClass("dx-filterbuilder-text-part").text(t).appendTo($container);
      if (i !== lastItemIndex) {
        renderer_default("<span>").addClass("dx-filterbuilder-text-separator").text(customOperation && customOperation.valueSeparator ? customOperation.valueSeparator : "|").addClass("dx-filterbuilder-text-separator-empty").appendTo($container);
      }
    }));
  } else if (value2) {
    $container.text(value2);
  } else {
    $container.text(message_default.format("dxFilterBuilder-enterValueText"));
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/filter/m_filter_custom_operations.js
function baseOperation(grid) {
  const getFullText = function(itemText, parentText) {
    return parentText ? `${parentText}/${itemText}` : itemText;
  };
  const getSelectedItemsTexts = function(items, parentText) {
    let result = [];
    items.forEach(((item) => {
      if (item.items) {
        const selectedItemsTexts = getSelectedItemsTexts(item.items, getFullText(item.text, parentText));
        result = result.concat(selectedItemsTexts);
      }
      item.selected && result.push(getFullText(item.text, parentText));
    }));
    return result;
  };
  const headerFilterController = grid && grid.getController("headerFilter");
  return {
    dataTypes: ["string", "date", "datetime", "number", "boolean", "object"],
    calculateFilterExpression: function(filterValue, field, fields) {
      const result = [];
      const lastIndex = filterValue.length - 1;
      filterValue && filterValue.forEach(((value2, index) => {
        if (isCondition(value2) || isGroup(value2)) {
          const filterExpression = getFilterExpression(value2, fields, [], "headerFilter");
          result.push(filterExpression);
        } else {
          const filterExpression = getFilterExpression([field.dataField, "=", value2], fields, [], "headerFilter");
          result.push(filterExpression);
        }
        index !== lastIndex && result.push("or");
      }));
      if (1 === result.length) {
        return result[0];
      }
      return result;
    },
    editorTemplate(conditionInfo, container) {
      const div = renderer_default("<div>").addClass("dx-filterbuilder-item-value-text").appendTo(container);
      const column = extend(true, {}, grid.columnOption(conditionInfo.field.dataField));
      renderValueText(div, conditionInfo.text && conditionInfo.text.split("|"));
      column.filterType = "include";
      column.filterValues = conditionInfo.value ? conditionInfo.value.slice() : [];
      headerFilterController.showHeaderFilterMenuBase({
        columnElement: div,
        column,
        apply() {
          value2 = this.filterValues, void conditionInfo.setValue(value2);
          var value2;
          headerFilterController.hideHeaderFilterMenu();
          conditionInfo.closeEditor();
        },
        onHidden() {
          conditionInfo.closeEditor();
        },
        isFilterBuilder: true
      });
      return container;
    },
    customizeText: function(fieldInfo, options) {
      options = options || {};
      const {
        value: value2
      } = fieldInfo;
      let column = grid.columnOption(fieldInfo.field.dataField);
      const headerFilter = column && column.headerFilter;
      const lookup = column && column.lookup;
      const values = options.values || [value2];
      if (headerFilter && headerFilter.dataSource || lookup && lookup.dataSource) {
        const result = new Deferred();
        const itemsDeferred = options.items || new Deferred();
        if (!options.items) {
          column = extend({}, column, {
            filterType: "include",
            filterValues: values
          });
          const dataSourceOptions = headerFilterController.getDataSource(column);
          dataSourceOptions.paginate = false;
          const dataSource = new DataSource(dataSourceOptions);
          const key = dataSource.store().key();
          if (key) {
            const {
              values: values2
            } = options;
            if (values2 && values2.length > 1) {
              const filter = values2.reduce(((result2, value3) => {
                if (result2.length) {
                  result2.push("or");
                }
                result2.push([key, "=", value3]);
                return result2;
              }), []);
              dataSource.filter(filter);
            } else {
              dataSource.filter([key, "=", fieldInfo.value]);
            }
          } else if (fieldInfo.field.calculateDisplayValue) {
            ui_errors_default.log("W1017");
          }
          options.items = itemsDeferred;
          dataSource.load().done(itemsDeferred.resolve);
        }
        itemsDeferred.done(((items) => {
          const index = values.indexOf(fieldInfo.value);
          result.resolve(getSelectedItemsTexts(items, null)[index]);
        }));
        return result;
      }
      const text = headerFilterController.getHeaderItemText(value2, column, 0, grid.option("headerFilter"));
      return text;
    }
  };
}
function anyOf(grid) {
  return extend(baseOperation(grid), {
    name: "anyof",
    icon: "selectall",
    caption: message_default.format("dxFilterBuilder-filterOperationAnyOf")
  });
}
function noneOf(grid) {
  const baseOp = baseOperation(grid);
  return extend({}, baseOp, {
    calculateFilterExpression(filterValue, field, fields) {
      const baseFilter = baseOp.calculateFilterExpression(filterValue, field, fields);
      if (!baseFilter || 0 === baseFilter.length) {
        return null;
      }
      return "!" === baseFilter[0] ? baseFilter : ["!", baseFilter];
    },
    name: "noneof",
    icon: "unselectall",
    caption: message_default.format("dxFilterBuilder-filterOperationNoneOf")
  });
}

// node_modules/devextreme/esm/__internal/grids/grid_core/filter/m_filter_sync.js
var FILTER_ROW_OPERATIONS = ["=", "<>", "<", "<=", ">", ">=", "notcontains", "contains", "startswith", "endswith", "between"];
function getColumnIdentifier(column) {
  return column.name || column.dataField;
}
function checkForErrors(columns7) {
  columns7.forEach(((column) => {
    const identifier = getColumnIdentifier(column);
    if (!isDefined(identifier) && column.allowFiltering) {
      throw new ui_errors_default.Error("E1049", column.caption);
    }
  }));
}
var getEmptyFilterValues = function() {
  return {
    filterType: "include",
    filterValues: void 0
  };
};
var canSyncHeaderFilterWithFilterRow = function(column) {
  const filterValues = column.filterValues || [];
  return !filtering_default.getGroupInterval(column) && !(column.headerFilter && column.headerFilter.dataSource) || 1 === filterValues.length && null === filterValues[0];
};
var getHeaderFilterFromCondition = function(headerFilterCondition, column) {
  if (!headerFilterCondition) {
    return getEmptyFilterValues();
  }
  let filterType;
  const selectedFilterOperation = headerFilterCondition[1];
  const value2 = headerFilterCondition[2];
  const hasArrayValue = Array.isArray(value2);
  if (!hasArrayValue) {
    if (!canSyncHeaderFilterWithFilterRow(column)) {
      return getEmptyFilterValues();
    }
  }
  switch (selectedFilterOperation) {
    case "anyof":
    case "=":
      filterType = "include";
      break;
    case "noneof":
    case "<>":
      filterType = "exclude";
      break;
    default:
      return getEmptyFilterValues();
  }
  return {
    filterType,
    filterValues: hasArrayValue ? value2 : [value2]
  };
};
var getConditionFromFilterRow = function(column) {
  const value2 = column.filterValue;
  if (isDefined(value2)) {
    const operation = column.selectedFilterOperation || column.defaultFilterOperation || getDefaultOperation(column);
    const filter = [getColumnIdentifier(column), operation, column.filterValue];
    return filter;
  }
  return null;
};
var getConditionFromHeaderFilter = function(column) {
  let selectedOperation;
  let value2;
  const {
    filterValues
  } = column;
  if (!filterValues) {
    return null;
  }
  if (1 === filterValues.length && canSyncHeaderFilterWithFilterRow(column) && !Array.isArray(filterValues[0])) {
    "exclude" === column.filterType ? selectedOperation = "<>" : selectedOperation = "=";
    value2 = filterValues[0];
  } else {
    "exclude" === column.filterType ? selectedOperation = "noneof" : selectedOperation = "anyof";
    value2 = filterValues;
  }
  return [getColumnIdentifier(column), selectedOperation, value2];
};
var updateHeaderFilterCondition = function(columnsController, column, headerFilterCondition) {
  const headerFilter = getHeaderFilterFromCondition(headerFilterCondition, column);
  columnsController.columnOption(getColumnIdentifier(column), headerFilter);
};
var updateFilterRowCondition = function(columnsController, column, condition) {
  let filterRowOptions;
  let selectedFilterOperation = null === condition || void 0 === condition ? void 0 : condition[1];
  const filterValue = null === condition || void 0 === condition ? void 0 : condition[2];
  const filterOperations = column.filterOperations || column.defaultFilterOperations;
  const selectedOperationExists = !filterOperations || filterOperations.indexOf(selectedFilterOperation) >= 0;
  const defaultOperationSelected = selectedFilterOperation === column.defaultFilterOperation;
  const builtInOperationSelected = FILTER_ROW_OPERATIONS.includes(selectedFilterOperation);
  const filterValueNotNullOrEmpty = null !== filterValue && "" !== filterValue;
  if ((selectedOperationExists || defaultOperationSelected) && builtInOperationSelected && filterValueNotNullOrEmpty) {
    if (defaultOperationSelected && !isDefined(column.selectedFilterOperation)) {
      selectedFilterOperation = column.selectedFilterOperation;
    }
    filterRowOptions = {
      filterValue,
      selectedFilterOperation
    };
  } else {
    filterRowOptions = {
      filterValue: void 0,
      selectedFilterOperation: void 0
    };
  }
  columnsController.columnOption(getColumnIdentifier(column), filterRowOptions);
};
var FilterSyncController = class extends m_modules_default.Controller {
  init() {
    this._dataController = this.getController("data");
    this._columnsController = this.getController("columns");
    if (this._dataController.isFilterSyncActive()) {
      if (this._columnsController.isAllDataTypesDefined()) {
        this._initSync();
      } else {
        this._dataController.dataSourceChanged.add((() => this._initSync()));
      }
    }
  }
  publicMethods() {
    return ["getCustomFilterOperations"];
  }
  syncFilterValue() {
    const that = this;
    const columns7 = this._columnsController.getFilteringColumns();
    this._skipSyncColumnOptions = true;
    columns7.forEach(((column) => {
      const filterConditions = getMatchedConditions(that.option("filterValue"), getColumnIdentifier(column));
      if (1 === filterConditions.length) {
        const filterCondition = filterConditions[0];
        updateHeaderFilterCondition(this._columnsController, column, filterCondition);
        updateFilterRowCondition(this._columnsController, column, filterCondition);
      } else {
        isDefined(column.filterValues) && updateHeaderFilterCondition(this._columnsController, column, null);
        isDefined(column.filterValue) && updateFilterRowCondition(this._columnsController, column, null);
      }
    }));
    this._skipSyncColumnOptions = false;
  }
  _initSync() {
    const columns7 = this._columnsController.getColumns();
    const pageIndex = this._dataController.pageIndex();
    checkForErrors(columns7);
    if (!this.option("filterValue")) {
      const filteringColumns = this._columnsController.getFilteringColumns();
      const filterValue = this.getFilterValueFromColumns(filteringColumns);
      this._silentOption("filterValue", filterValue);
    }
    this.syncFilterValue();
    this._dataController.pageIndex(pageIndex);
  }
  _getSyncFilterRow(filterValue, column) {
    const filter = getConditionFromFilterRow(column);
    if (isDefined(filter)) {
      return syncFilters(filterValue, filter);
    }
    return removeFieldConditionsFromFilter(filterValue, getColumnIdentifier(column));
  }
  _getSyncHeaderFilter(filterValue, column) {
    const filter = getConditionFromHeaderFilter(column);
    if (filter) {
      return syncFilters(filterValue, filter);
    }
    return removeFieldConditionsFromFilter(filterValue, getColumnIdentifier(column));
  }
  getFilterValueFromColumns(columns7) {
    if (!this._dataController.isFilterSyncActive()) {
      return null;
    }
    const filterValue = ["and"];
    columns7 && columns7.forEach(((column) => {
      const headerFilter = getConditionFromHeaderFilter(column);
      const filterRow = getConditionFromFilterRow(column);
      headerFilter && addItem(headerFilter, filterValue);
      filterRow && addItem(filterRow, filterValue);
    }));
    return getNormalizedFilter(filterValue);
  }
  syncFilterRow(column, filterValue) {
    this.option("filterValue", this._getSyncFilterRow(this.option("filterValue"), column));
  }
  syncHeaderFilter(column) {
    this.option("filterValue", this._getSyncHeaderFilter(this.option("filterValue"), column));
  }
  getCustomFilterOperations() {
    const filterBuilderCustomOperations = this.option("filterBuilder.customOperations") ?? [];
    return [anyOf(this.component), noneOf(this.component)].concat(filterBuilderCustomOperations);
  }
};
var data10 = (Base) => class extends Base {
  optionChanged(args) {
    switch (args.name) {
      case "filterValue":
        this._applyFilter();
        this.isFilterSyncActive() && this._filterSyncController.syncFilterValue();
        args.handled = true;
        break;
      case "filterSyncEnabled":
        args.handled = true;
        break;
      case "columns":
        if (this.isFilterSyncActive()) {
          const column = this._columnsController.getColumnByPath(args.fullName);
          if (column && !this._filterSyncController._skipSyncColumnOptions) {
            const propertyName = this._parseColumnPropertyName(args.fullName);
            this._filterSyncController._skipSyncColumnOptions = true;
            if ("filterType" === propertyName) {
              if ("exclude" === args.value || "exclude" === args.previousValue) {
                this._filterSyncController.syncHeaderFilter(column);
              }
            } else if ("filterValues" === propertyName) {
              this._filterSyncController.syncHeaderFilter(column);
            } else if (["filterValue", "selectedFilterOperation"].includes(propertyName)) {
              this._filterSyncController.syncFilterRow(column, column.filterValue);
            }
            this._filterSyncController._skipSyncColumnOptions = false;
          }
        }
        super.optionChanged(args);
        break;
      default:
        super.optionChanged(args);
    }
  }
  isFilterSyncActive() {
    const filterSyncEnabledValue = this.option("filterSyncEnabled");
    return "auto" === filterSyncEnabledValue ? this.option("filterPanel.visible") : filterSyncEnabledValue;
  }
  skipCalculateColumnFilters() {
    return (isDefined(this.option("filterValue")) || this._filterSyncController._skipSyncColumnOptions) && this.isFilterSyncActive();
  }
  _calculateAdditionalFilter() {
    if (false === this.option("filterPanel.filterEnabled")) {
      return super._calculateAdditionalFilter();
    }
    const filters = [super._calculateAdditionalFilter()];
    const columns7 = this._columnsController.getFilteringColumns();
    let filterValue = this.option("filterValue");
    if (this.isFilterSyncActive()) {
      const currentColumnForHeaderFilter = this._headerFilterController.getCurrentColumn();
      const currentColumnForFilterRow = this._applyFilterController.getCurrentColumnForFiltering();
      const currentColumn = currentColumnForHeaderFilter || currentColumnForFilterRow;
      const needRemoveCurrentColumnFilter = currentColumnForHeaderFilter || isDefined(null === currentColumnForFilterRow || void 0 === currentColumnForFilterRow ? void 0 : currentColumnForFilterRow.filterValue);
      if (needRemoveCurrentColumnFilter && filterValue) {
        filterValue = removeFieldConditionsFromFilter(filterValue, getColumnIdentifier(currentColumn));
      }
    }
    const customOperations = this._filterSyncController.getCustomFilterOperations();
    const calculatedFilterValue = getFilterExpression(filterValue, columns7, customOperations, "filterBuilder");
    if (calculatedFilterValue) {
      filters.push(calculatedFilterValue);
    }
    return m_utils_default.combineFilters(filters);
  }
  _parseColumnPropertyName(fullName) {
    const matched = fullName.match(/.*\.(.*)/);
    if (matched) {
      return matched[1];
    }
    return null;
  }
  clearFilter(filterName) {
    this.component.beginUpdate();
    if (arguments.length > 0) {
      if ("filterValue" === filterName) {
        this.option("filterValue", null);
      }
      super.clearFilter(filterName);
    } else {
      this.option("filterValue", null);
      super.clearFilter();
    }
    this.component.endUpdate();
  }
  _applyFilter() {
    if (this._filterSyncController._skipSyncColumnOptions) {
      return new Deferred().resolve();
    }
    return super._applyFilter.apply(this, arguments);
  }
};
var columnHeadersView5 = (Base) => class extends Base {
  optionChanged(args) {
    if ("filterValue" === args.name) {
      this._updateHeaderFilterIndicators();
    } else {
      super.optionChanged(args);
    }
  }
  _isHeaderFilterEmpty(column) {
    if (this._dataController.isFilterSyncActive()) {
      return !filterHasField(this.option("filterValue"), getColumnIdentifier(column));
    }
    return super._isHeaderFilterEmpty(column);
  }
  _needUpdateFilterIndicators() {
    return !this._dataController.isFilterSyncActive();
  }
};
var filterSyncModule = {
  defaultOptions: () => ({
    filterValue: null,
    filterSyncEnabled: "auto"
  }),
  controllers: {
    filterSync: FilterSyncController
  },
  extenders: {
    controllers: {
      data: data10
    },
    views: {
      columnHeadersView: columnHeadersView5
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/filter_sync.js
m_core_default.registerModule("filterSync", filterSyncModule);

// node_modules/devextreme/esm/__internal/filter_builder/m_filter_builder.js
var FILTER_BUILDER_IMAGE_CLASS = "dx-filterbuilder-action-icon";
var ACTIVE_CLASS = "dx-state-active";
var SOURCE = "filterBuilder";
var TREEVIEW_NODE_CONTAINER = "dx-treeview-node-container";
var ACTIONS2 = [{
  name: "onEditorPreparing",
  config: {
    excludeValidators: ["disabled", "readOnly"],
    category: "rendering"
  }
}, {
  name: "onEditorPrepared",
  config: {
    excludeValidators: ["disabled", "readOnly"],
    category: "rendering"
  }
}, {
  name: "onValueChanged",
  config: {
    excludeValidators: ["disabled", "readOnly"]
  }
}];
var OPERATORS = {
  and: "and",
  or: "or",
  notAnd: "!and",
  notOr: "!or"
};
var EditorFactory2 = ui_editor_factory_mixin_default(class {
});
var FilterBuilder = class extends ui_widget_default {
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      onEditorPreparing: null,
      onEditorPrepared: null,
      onValueChanged: null,
      fields: [],
      groupOperations: ["and", "or", "notAnd", "notOr"],
      maxGroupLevel: void 0,
      value: null,
      allowHierarchicalFields: false,
      groupOperationDescriptions: {
        and: message_default.format("dxFilterBuilder-and"),
        or: message_default.format("dxFilterBuilder-or"),
        notAnd: message_default.format("dxFilterBuilder-notAnd"),
        notOr: message_default.format("dxFilterBuilder-notOr")
      },
      customOperations: [],
      closePopupOnTargetScroll: true,
      filterOperationDescriptions: {
        between: message_default.format("dxFilterBuilder-filterOperationBetween"),
        equal: message_default.format("dxFilterBuilder-filterOperationEquals"),
        notEqual: message_default.format("dxFilterBuilder-filterOperationNotEquals"),
        lessThan: message_default.format("dxFilterBuilder-filterOperationLess"),
        lessThanOrEqual: message_default.format("dxFilterBuilder-filterOperationLessOrEquals"),
        greaterThan: message_default.format("dxFilterBuilder-filterOperationGreater"),
        greaterThanOrEqual: message_default.format("dxFilterBuilder-filterOperationGreaterOrEquals"),
        startsWith: message_default.format("dxFilterBuilder-filterOperationStartsWith"),
        contains: message_default.format("dxFilterBuilder-filterOperationContains"),
        notContains: message_default.format("dxFilterBuilder-filterOperationNotContains"),
        endsWith: message_default.format("dxFilterBuilder-filterOperationEndsWith"),
        isBlank: message_default.format("dxFilterBuilder-filterOperationIsBlank"),
        isNotBlank: message_default.format("dxFilterBuilder-filterOperationIsNotBlank")
      }
    });
  }
  _optionChanged(args) {
    switch (args.name) {
      case "closePopupOnTargetScroll":
        break;
      case "onEditorPreparing":
      case "onEditorPrepared":
      case "onValueChanged":
        this._initActions();
        break;
      case "customOperations":
        this._initCustomOperations();
        this._invalidate();
        break;
      case "fields":
      case "maxGroupLevel":
      case "groupOperations":
      case "allowHierarchicalFields":
      case "groupOperationDescriptions":
      case "filterOperationDescriptions":
        this._invalidate();
        break;
      case "value":
        if (args.value !== args.previousValue) {
          const disableInvalidateForValue = this._disableInvalidateForValue;
          if (!disableInvalidateForValue) {
            this._initModel();
            this._invalidate();
          }
          this._disableInvalidateForValue = false;
          this.executeAction("onValueChanged", {
            value: args.value,
            previousValue: args.previousValue
          });
          this._disableInvalidateForValue = disableInvalidateForValue;
        }
        break;
      default:
        super._optionChanged(args);
    }
  }
  getFilterExpression() {
    const fields = this._getNormalizedFields();
    const value2 = extend(true, [], this._model);
    return getFilterExpression(getNormalizedFilter(value2), fields, this._customOperations, SOURCE);
  }
  _getNormalizedFields() {
    return getNormalizedFields(this.option("fields"));
  }
  _updateFilter() {
    this._disableInvalidateForValue = true;
    const value2 = extend(true, [], this._model);
    const normalizedValue = getNormalizedFilter(value2);
    const oldValue = getNormalizedFilter(this._getModel(this.option("value")));
    if (JSON.stringify(oldValue) !== JSON.stringify(normalizedValue)) {
      this.option("value", normalizedValue);
    }
    this._disableInvalidateForValue = false;
    this._fireContentReadyAction();
  }
  _init() {
    this._initCustomOperations();
    this._initModel();
    this._initEditorFactory();
    this._initActions();
    super._init();
  }
  _initEditorFactory() {
    this._editorFactory = new EditorFactory2();
  }
  _initCustomOperations() {
    this._customOperations = getMergedOperations(this.option("customOperations"), this.option("filterOperationDescriptions.between"), this);
  }
  _getDefaultGroupOperation() {
    var _this$option;
    return (null === (_this$option = this.option("groupOperations")) || void 0 === _this$option ? void 0 : _this$option[0]) ?? OPERATORS.and;
  }
  _getModel(value2) {
    return convertToInnerStructure(value2, this._customOperations, this._getDefaultGroupOperation());
  }
  _initModel() {
    this._model = this._getModel(this.option("value"));
  }
  _initActions() {
    const that = this;
    that._actions = {};
    ACTIONS2.forEach(((action) => {
      const actionConfig = extend({}, action.config);
      that._actions[action.name] = that._createActionByOption(action.name, actionConfig);
    }));
  }
  executeAction(actionName, options) {
    const action = this._actions[actionName];
    return action && action(options);
  }
  _initMarkup() {
    this.$element().addClass("dx-filterbuilder");
    super._initMarkup();
    this._addAriaAttributes(this.$element(), message_default.format("dxFilterBuilder-filterAriaRootElement"), "group");
    this._createGroupElementByCriteria(this._model).appendTo(this.$element());
  }
  _addAriaAttributes($element, ariaLabel, role, hasPopup, hasExpanded, ariaLevel) {
    if (!$element || !$element.length) {
      return;
    }
    const attributes = {
      role
    };
    if (ariaLabel) {
      if ($element.text().length > 0) {
        attributes.title = ariaLabel;
      } else {
        attributes["aria-label"] = ariaLabel;
      }
    }
    if (isDefined(hasPopup)) {
      attributes["aria-haspopup"] = `${hasPopup}`;
    }
    if (isDefined(hasExpanded)) {
      attributes["aria-expanded"] = `${hasExpanded}`;
    }
    if (isDefined(ariaLevel)) {
      attributes["aria-level"] = `${ariaLevel}`;
    }
    $element.attr(attributes);
  }
  _createConditionElement(condition, parent, groupLevel) {
    return renderer_default("<div>").addClass("dx-filterbuilder-group").append(this._createConditionItem(condition, parent, groupLevel)).attr("role", "group");
  }
  _createGroupElementByCriteria(criteria, parent) {
    let groupLevel = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    const $group = this._createGroupElement(criteria, parent, groupLevel);
    const $groupContent = $group.find(".dx-filterbuilder-group-content");
    const groupCriteria = getGroupCriteria(criteria);
    for (let i = 0; i < groupCriteria.length; i++) {
      const innerCriteria = groupCriteria[i];
      if (isGroup(innerCriteria)) {
        this._createGroupElementByCriteria(innerCriteria, criteria, groupLevel + 1).appendTo($groupContent);
      } else if (isCondition(innerCriteria)) {
        this._createConditionElement(innerCriteria, criteria, `${groupLevel + 1}`).appendTo($groupContent);
      }
    }
    return $group;
  }
  _createGroupElement(criteria, parent, groupLevel) {
    const $guid = new guid_default();
    const $groupItem = renderer_default("<div>").addClass("dx-filterbuilder-group-item");
    const $groupContent = renderer_default("<div>").addClass("dx-filterbuilder-group-content").attr("id", `${$guid}`);
    const $group = renderer_default("<div>").addClass("dx-filterbuilder-group").append($groupItem).append($groupContent);
    if (null != parent) {
      this._createRemoveButton((() => {
        removeItem(parent, criteria);
        $group.remove();
        this._updateFilter();
      }), "group").appendTo($groupItem);
    }
    let groupItemLevel = groupLevel;
    if (0 === groupLevel) {
      this._addAriaAttributes($group, "", "tree");
      groupItemLevel += 1;
    }
    this._addAriaAttributes($groupItem, message_default.format("dxFilterBuilder-filterAriaGroupItem"), "treeitem", null, null, groupItemLevel);
    $groupItem.attr("aria-owns", `${$guid}`);
    this._createGroupOperationButton(criteria).appendTo($groupItem);
    this._createAddButton((() => {
      const newGroup = createEmptyGroup(this._getDefaultGroupOperation());
      addItem(newGroup, criteria);
      this._createGroupElement(newGroup, criteria, groupLevel + 1).appendTo($groupContent);
      this._updateFilter();
    }), (() => {
      const field = this.option("fields")[0];
      const newCondition = createCondition(field, this._customOperations);
      addItem(newCondition, criteria);
      this._createConditionElement(newCondition, criteria, groupLevel + 1).appendTo($groupContent);
      this._updateFilter();
    }), groupLevel).appendTo($groupItem);
    return $group;
  }
  _createButton(caption) {
    return renderer_default("<div>").text(caption);
  }
  _createGroupOperationButton(criteria) {
    const groupOperations = this._getGroupOperations(criteria);
    let groupMenuItem = getGroupMenuItem(criteria, groupOperations);
    const caption = groupMenuItem.text;
    const $operationButton = groupOperations && groupOperations.length < 2 ? this._createButton(caption).addClass("dx-state-disabled") : this._createButtonWithMenu({
      caption,
      menu: {
        items: groupOperations,
        displayExpr: "text",
        keyExpr: "value",
        onItemClick: (e) => {
          if (groupMenuItem !== e.itemData) {
            setGroupValue(criteria, e.itemData.value);
            $operationButton.text(e.itemData.text);
            groupMenuItem = e.itemData;
            this._updateFilter();
          }
        },
        onContentReady(e) {
          e.component.selectItem(groupMenuItem);
        },
        cssClass: "dx-filterbuilder-group-operations"
      }
    });
    this._addAriaAttributes($operationButton, message_default.format("dxFilterBuilder-filterAriaOperationButton"), "combobox", true, false);
    return $operationButton.addClass("dx-filterbuilder-text").addClass("dx-filterbuilder-group-operation").attr("tabindex", 0);
  }
  _createButtonWithMenu(options) {
    const that = this;
    const removeMenu = function() {
      that.$element().find(`.${ACTIVE_CLASS}`).removeClass(ACTIVE_CLASS).attr("aria-expanded", "false");
      that.$element().find(".dx-overlay .dx-treeview").remove();
      that.$element().find(".dx-overlay").remove();
    };
    const rtlEnabled = this.option("rtlEnabled");
    const position = rtlEnabled ? "right" : "left";
    const $button = this._createButton(options.caption);
    const $guid = new guid_default();
    $button.attr("aria-controls", `${$guid}`);
    extend(options.menu, {
      id: $guid,
      focusStateEnabled: true,
      selectionMode: "single",
      onItemClick: (handler = options.menu.onItemClick, function(e) {
        handler(e);
        if ("dxclick" === e.event.type) {
          removeMenu();
        }
      }),
      onHiding() {
        $button.removeClass(ACTIVE_CLASS).attr("aria-expanded", "false");
      },
      position: {
        my: `${position} top`,
        at: `${position} bottom`,
        offset: "0 1",
        of: $button,
        collision: "flip"
      },
      animation: null,
      onHidden() {
        removeMenu();
      },
      cssClass: `dx-filterbuilder-overlay ${options.menu.cssClass}`,
      rtlEnabled
    });
    var handler;
    options.popup = {
      onShown(info) {
        const treeViewContentElement = renderer_default(info.component.content());
        const treeViewElement = treeViewContentElement.find(".dx-treeview");
        if (treeViewElement.length) {
          that._applyAccessibilityAttributes(treeViewElement);
        }
        m_events_engine_default.on(treeViewElement, "keyup keydown", ((e) => {
          const keyName = normalizeKeyName(e);
          if ("keydown" === e.type && "tab" === keyName || "keyup" === e.type && ("escape" === keyName || "enter" === keyName)) {
            info.component.hide();
            m_events_engine_default.trigger(options.menu.position.of, "focus");
          }
        }));
        const treeView = treeViewElement.dxTreeView("instance");
        treeView.focus();
        treeView.option("focusedElement", null);
      }
    };
    this._subscribeOnClickAndEnterKey($button, (() => {
      removeMenu();
      that._createPopupWithTreeView(options, that.$element());
      $button.addClass(ACTIVE_CLASS).attr("aria-expanded", "true");
    }));
    return $button;
  }
  _hasValueButton(condition) {
    const customOperation = getCustomOperation(this._customOperations, condition[1]);
    return customOperation ? false !== customOperation.hasValue : null !== condition[2];
  }
  _createOperationButtonWithMenu(condition, field) {
    const that = this;
    const availableOperations = getAvailableOperations(field, this.option("filterOperationDescriptions"), this._customOperations);
    let currentOperation = getOperationFromAvailable(getOperationValue(condition), availableOperations);
    const $operationButton = this._createButtonWithMenu({
      caption: currentOperation.text,
      menu: {
        items: availableOperations,
        displayExpr: "text",
        onItemRendered(e) {
          e.itemData.isCustom && renderer_default(e.itemElement).addClass("dx-filterbuilder-menu-custom-operation");
        },
        onContentReady(e) {
          e.component.selectItem(currentOperation);
        },
        onItemClick: (e) => {
          if (currentOperation !== e.itemData) {
            currentOperation = e.itemData;
            updateConditionByOperation(condition, currentOperation.value, that._customOperations);
            const $valueButton = $operationButton.siblings().filter(".dx-filterbuilder-item-value");
            if (that._hasValueButton(condition)) {
              if (0 !== $valueButton.length) {
                $valueButton.remove();
              }
              that._createValueButton(condition, field).appendTo($operationButton.parent());
            } else {
              $valueButton.remove();
            }
            $operationButton.text(currentOperation.text);
            this._updateFilter();
          }
        },
        cssClass: "dx-filterbuilder-operations"
      }
    }).addClass("dx-filterbuilder-text").addClass("dx-filterbuilder-item-operation").attr("tabindex", 0);
    this._addAriaAttributes($operationButton, message_default.format("dxFilterBuilder-filterAriaItemOperation"), "combobox", true, false);
    return $operationButton;
  }
  _createOperationAndValueButtons(condition, field, $item) {
    this._createOperationButtonWithMenu(condition, field).appendTo($item);
    if (this._hasValueButton(condition)) {
      this._createValueButton(condition, field).appendTo($item);
    }
  }
  _createFieldButtonWithMenu(fields, condition, field) {
    const that = this;
    const allowHierarchicalFields = this.option("allowHierarchicalFields");
    const items = getItems(fields, allowHierarchicalFields);
    let item = getField(field.name || field.dataField, items);
    const getFullCaption = function(item2, items2) {
      return allowHierarchicalFields ? getCaptionWithParents(item2, items2) : item2.caption;
    };
    condition[0] = item.name || item.dataField;
    const $fieldButton = this._createButtonWithMenu({
      caption: getFullCaption(item, items),
      menu: {
        items,
        dataStructure: "plain",
        keyExpr: "id",
        parentId: "parentId",
        displayExpr: "caption",
        onItemClick: (e) => {
          if (item !== e.itemData) {
            item = e.itemData;
            condition[0] = item.name || item.dataField;
            condition[2] = "object" === item.dataType ? null : "";
            updateConditionByOperation(condition, getDefaultOperation(item), that._customOperations);
            $fieldButton.siblings().filter(".dx-filterbuilder-text").remove();
            that._createOperationAndValueButtons(condition, item, $fieldButton.parent());
            const caption = getFullCaption(item, e.component.option("items"));
            $fieldButton.text(caption);
            this._updateFilter();
          }
        },
        onContentReady(e) {
          e.component.selectItem(item);
        },
        cssClass: "dx-filterbuilder-fields"
      }
    }).addClass("dx-filterbuilder-text").addClass("dx-filterbuilder-item-field").attr("tabindex", 0);
    this._addAriaAttributes($fieldButton, message_default.format("dxFilterBuilder-filterAriaItemField"), "combobox", true, false);
    return $fieldButton;
  }
  _createConditionItem(condition, parent, groupLevel) {
    const $item = renderer_default("<div>").addClass("dx-filterbuilder-group-item");
    const fields = this._getNormalizedFields();
    const field = getField(condition[0], fields);
    this._addAriaAttributes($item, "", "treeitem", null, null, groupLevel);
    this._createRemoveButton((() => {
      removeItem(parent, condition);
      const isSingleChild = 1 === $item.parent().children().length;
      if (isSingleChild) {
        $item.parent().remove();
      } else {
        $item.remove();
      }
      this._updateFilter();
    }), "condition").appendTo($item);
    this._createFieldButtonWithMenu(fields, condition, field).appendTo($item);
    this._createOperationAndValueButtons(condition, field, $item);
    return $item;
  }
  _getGroupOperations(criteria) {
    let groupOperations = this.option("groupOperations");
    const groupOperationDescriptions = this.option("groupOperationDescriptions");
    if (!groupOperations || !groupOperations.length) {
      groupOperations = [getGroupValue(criteria).replace("!", "not")];
    }
    return groupOperations.map(((operation) => ({
      text: groupOperationDescriptions[operation],
      value: OPERATORS[operation]
    })));
  }
  _createRemoveButton(handler, type2) {
    const $removeButton = renderer_default("<div>").addClass(FILTER_BUILDER_IMAGE_CLASS).addClass("dx-icon-remove").addClass("dx-filterbuilder-action").attr("tabindex", 0);
    if (type2) {
      const removeMessage = message_default.format("dxFilterBuilder-filterAriaRemoveButton", type2);
      this._addAriaAttributes($removeButton, removeMessage, "button");
    }
    this._subscribeOnClickAndEnterKey($removeButton, handler);
    return $removeButton;
  }
  _createAddButton(addGroupHandler, addConditionHandler, groupLevel) {
    let $button;
    const maxGroupLevel = this.option("maxGroupLevel");
    if (isDefined(maxGroupLevel) && groupLevel >= maxGroupLevel) {
      $button = this._createButton();
      this._subscribeOnClickAndEnterKey($button, addConditionHandler);
    } else {
      $button = this._createButtonWithMenu({
        menu: {
          items: [{
            caption: message_default.format("dxFilterBuilder-addCondition"),
            click: addConditionHandler
          }, {
            caption: message_default.format("dxFilterBuilder-addGroup"),
            click: addGroupHandler
          }],
          displayExpr: "caption",
          onItemClick(e) {
            e.itemData.click();
          },
          cssClass: "dx-filterbuilder-add-condition"
        }
      });
    }
    this._addAriaAttributes($button, message_default.format("dxFilterBuilder-filterAriaAddButton"), "combobox", true, false);
    return $button.addClass(FILTER_BUILDER_IMAGE_CLASS).addClass("dx-icon-plus").addClass("dx-filterbuilder-action").attr("tabindex", 0);
  }
  _createValueText(item, field, $container) {
    const that = this;
    const $text = renderer_default("<div>").html("&nbsp;").addClass("dx-filterbuilder-item-value-text").attr("tabindex", 0).appendTo($container);
    this._addAriaAttributes($text, message_default.format("dxFilterBuilder-filterAriaItemValue"), "button", true);
    const value2 = item[2];
    const customOperation = getCustomOperation(that._customOperations, item[1]);
    if (!customOperation && field.lookup) {
      getCurrentLookupValueText(field, value2, ((result) => {
        renderValueText($text, result);
      }));
    } else {
      when(getCurrentValueText(field, value2, customOperation)).done(((result) => {
        renderValueText($text, result, customOperation);
      }));
    }
    that._subscribeOnClickAndEnterKey($text, ((e) => {
      if ("keyup" === e.type) {
        e.stopPropagation();
      }
      that._createValueEditorWithEvents(item, field, $container);
    }));
    return $text;
  }
  _updateConditionValue(item, value2, callback) {
    const areValuesDifferent = item[2] !== value2;
    if (areValuesDifferent) {
      item[2] = value2;
    }
    callback();
    this._updateFilter();
  }
  _addDocumentKeyUp($editor, handler) {
    let isComposing = false;
    let hasCompositionJustEnded = false;
    const document = dom_adapter_default.getDocument();
    const documentKeyUpHandler = (e) => {
      if (isComposing || hasCompositionJustEnded) {
        hasCompositionJustEnded = false;
        return;
      }
      handler(e);
    };
    m_events_engine_default.on(document, "keyup", documentKeyUpHandler);
    const input = $editor.find("input");
    m_events_engine_default.on(input, "compositionstart", (() => {
      isComposing = true;
    }));
    m_events_engine_default.on(input, "compositionend", (() => {
      isComposing = false;
      hasCompositionJustEnded = true;
    }));
    m_events_engine_default.on(input, "keydown", ((event) => {
      if (229 !== event.which) {
        hasCompositionJustEnded = false;
      }
    }));
    this._documentKeyUpHandler = documentKeyUpHandler;
  }
  _addDocumentClick($editor, closeEditorFunc) {
    const document = dom_adapter_default.getDocument();
    const documentClickHandler = (e) => {
      if (!this._isFocusOnEditorParts($editor, e.target)) {
        m_events_engine_default.trigger($editor.find("input"), "change");
        closeEditorFunc();
      }
    };
    m_events_engine_default.on(document, "dxpointerdown", documentClickHandler);
    this._documentClickHandler = documentClickHandler;
  }
  _isFocusOnEditorParts($editor, target) {
    const activeElement = target || dom_adapter_default.getActiveElement();
    return renderer_default(activeElement).closest($editor.children()).length || renderer_default(activeElement).closest(".dx-dropdowneditor-overlay").length;
  }
  _removeEvents() {
    const document = dom_adapter_default.getDocument();
    isDefined(this._documentKeyUpHandler) && m_events_engine_default.off(document, "keyup", this._documentKeyUpHandler);
    isDefined(this._documentClickHandler) && m_events_engine_default.off(document, "dxpointerdown", this._documentClickHandler);
  }
  _dispose() {
    this._removeEvents();
    super._dispose();
  }
  _createValueEditorWithEvents(item, field, $container) {
    let value2 = item[2];
    const createValueText = () => {
      $container.empty();
      this._removeEvents();
      return this._createValueText(item, field, $container);
    };
    const closeEditor = () => {
      this._updateConditionValue(item, value2, (() => {
        createValueText();
      }));
    };
    const options = {
      value: "" === value2 ? null : value2,
      filterOperation: getOperationValue(item),
      setValue(data17) {
        value2 = null === data17 ? "" : data17;
      },
      closeEditor,
      text: $container.text()
    };
    $container.empty();
    const $editor = this._createValueEditor($container, field, options);
    m_events_engine_default.trigger($editor.find("input").not(":hidden").eq(0), "focus");
    this._removeEvents();
    this._addDocumentClick($editor, closeEditor);
    this._addDocumentKeyUp($editor, ((e) => {
      const keyName = normalizeKeyName(e);
      if ("tab" === keyName) {
        if (this._isFocusOnEditorParts($editor)) {
          return;
        }
        this._updateConditionValue(item, value2, (() => {
          createValueText();
          if (e.shiftKey) {
            m_events_engine_default.trigger($container.prev(), "focus");
          }
        }));
      }
      if ("escape" === keyName) {
        m_events_engine_default.trigger(createValueText(), "focus");
      }
      if ("enter" === keyName) {
        this._updateConditionValue(item, value2, (() => {
          m_events_engine_default.trigger(createValueText(), "focus");
        }));
      }
    }));
    this._fireContentReadyAction();
  }
  _createValueButton(item, field) {
    const $valueButton = renderer_default("<div>").addClass("dx-filterbuilder-text").addClass("dx-filterbuilder-item-value");
    this._createValueText(item, field, $valueButton);
    return $valueButton;
  }
  _createValueEditor($container, field, options) {
    const $editor = renderer_default("<div>").attr("tabindex", 0).appendTo($container);
    const customOperation = getCustomOperation(this._customOperations, options.filterOperation);
    const editorTemplate2 = customOperation && customOperation.editorTemplate ? customOperation.editorTemplate : field.editorTemplate;
    if (editorTemplate2) {
      const template = this._getTemplate(editorTemplate2);
      template.render({
        model: extend({
          field
        }, options),
        container: $editor
      });
    } else {
      this._editorFactory.createEditor.call(this, $editor, extend({}, field, options, {
        parentType: SOURCE
      }));
    }
    return $editor;
  }
  _createPopupWithTreeView(options, $container) {
    const that = this;
    const $popup = renderer_default("<div>").addClass(options.menu.cssClass).appendTo($container);
    this._createComponent($popup, ui_popup_default, {
      onHiding: options.menu.onHiding,
      onHidden: options.menu.onHidden,
      rtlEnabled: options.menu.rtlEnabled,
      position: options.menu.position,
      animation: options.menu.animation,
      contentTemplate(contentElement) {
        const $menuContainer = renderer_default("<div>").appendTo(contentElement);
        that._createComponent($menuContainer, tree_view_default, options.menu);
        $menuContainer.attr("id", `${options.menu.id}`);
        this.repaint();
      },
      _ignoreFunctionValueDeprecation: true,
      maxHeight: () => getElementMaxHeightByWindow(options.menu.position.of),
      visible: true,
      focusStateEnabled: false,
      preventScrollEvents: false,
      container: $popup,
      hideOnOutsideClick: true,
      onShown: options.popup.onShown,
      shading: false,
      width: "auto",
      height: "auto",
      showTitle: false,
      _wrapperClassExternal: options.menu.cssClass,
      _ignorePreventScrollEventsDeprecation: true
    });
  }
  _subscribeOnClickAndEnterKey($button, handler) {
    m_events_engine_default.on($button, "dxclick", handler);
    m_events_engine_default.on($button, "keyup", ((e) => {
      if ("enter" === normalizeKeyName(e)) {
        handler(e);
      }
    }));
  }
  _applyAccessibilityAttributes($element) {
    var _treeViewPopup$find;
    const treeViewPopup = $element.closest(".dx-overlay-content");
    null === treeViewPopup || void 0 === treeViewPopup || treeViewPopup.removeAttr("role");
    const treeViewNode = null === treeViewPopup || void 0 === treeViewPopup || null === (_treeViewPopup$find = treeViewPopup.find) || void 0 === _treeViewPopup$find ? void 0 : _treeViewPopup$find.call(treeViewPopup, `.${TREEVIEW_NODE_CONTAINER}`);
    null === treeViewNode || void 0 === treeViewNode || treeViewNode.attr("role", "presentation");
  }
};
component_registrator_default("dxFilterBuilder", FilterBuilder);
var m_filter_builder_default = FilterBuilder;

// node_modules/devextreme/esm/ui/filter_builder.js
var filter_builder_default = m_filter_builder_default;

// node_modules/devextreme/esm/__internal/grids/grid_core/filter/m_filter_builder.js
var FilterBuilderView = class extends m_modules_default.View {
  init() {
    super.init();
    this._columnsController = this.getController("columns");
    this._filterSyncController = this.getController("filterSync");
  }
  optionChanged(args) {
    switch (args.name) {
      case "filterBuilder":
      case "filterBuilderPopup":
        this._invalidate();
        args.handled = true;
        break;
      default:
        super.optionChanged(args);
    }
  }
  _renderCore() {
    this._updatePopupOptions();
  }
  _updatePopupOptions() {
    if (this.option("filterBuilderPopup.visible")) {
      this._initPopup();
    } else if (this._filterBuilderPopup) {
      this._filterBuilderPopup.hide();
    }
  }
  _disposePopup() {
    if (this._filterBuilderPopup) {
      this._filterBuilderPopup.dispose();
      this._filterBuilderPopup = void 0;
    }
    if (this._filterBuilder) {
      this._filterBuilder.dispose();
      this._filterBuilder = void 0;
    }
  }
  _initPopup() {
    const that = this;
    that._disposePopup();
    that._filterBuilderPopup = that._createComponent(that.element(), ui_popup_default, extend({
      title: message_default.format("dxDataGrid-filterBuilderPopupTitle"),
      contentTemplate: ($contentElement) => that._getPopupContentTemplate($contentElement),
      onOptionChanged(args) {
        if ("visible" === args.name) {
          that.option("filterBuilderPopup.visible", args.value);
        }
      },
      toolbarItems: that._getPopupToolbarItems()
    }, that.option("filterBuilderPopup"), {
      onHidden() {
        restoreFocus(that);
        that._disposePopup();
      }
    }));
  }
  _getPopupContentTemplate(contentElement) {
    const $contentElement = renderer_default(contentElement);
    const $filterBuilderContainer = renderer_default("<div>").appendTo(renderer_default(contentElement));
    this._filterBuilder = this._createComponent($filterBuilderContainer, filter_builder_default, extend({
      value: this.option("filterValue"),
      fields: this._columnsController.getFilteringColumns()
    }, this.option("filterBuilder"), {
      customOperations: this._filterSyncController.getCustomFilterOperations()
    }));
    this._createComponent($contentElement, scroll_view_default, {
      direction: "both"
    });
  }
  _getPopupToolbarItems() {
    const that = this;
    return [{
      toolbar: "bottom",
      location: "after",
      widget: "dxButton",
      options: {
        text: message_default.format("OK"),
        onClick() {
          const filter = that._filterBuilder.option("value");
          that.option("filterValue", filter);
          that._filterBuilderPopup.hide();
        }
      }
    }, {
      toolbar: "bottom",
      location: "after",
      widget: "dxButton",
      options: {
        text: message_default.format("Cancel"),
        onClick() {
          that._filterBuilderPopup.hide();
        }
      }
    }];
  }
};
var filterBuilderModule = {
  defaultOptions: () => ({
    filterBuilder: {
      groupOperationDescriptions: {
        and: message_default.format("dxFilterBuilder-and"),
        or: message_default.format("dxFilterBuilder-or"),
        notAnd: message_default.format("dxFilterBuilder-notAnd"),
        notOr: message_default.format("dxFilterBuilder-notOr")
      },
      filterOperationDescriptions: {
        between: message_default.format("dxFilterBuilder-filterOperationBetween"),
        equal: message_default.format("dxFilterBuilder-filterOperationEquals"),
        notEqual: message_default.format("dxFilterBuilder-filterOperationNotEquals"),
        lessThan: message_default.format("dxFilterBuilder-filterOperationLess"),
        lessThanOrEqual: message_default.format("dxFilterBuilder-filterOperationLessOrEquals"),
        greaterThan: message_default.format("dxFilterBuilder-filterOperationGreater"),
        greaterThanOrEqual: message_default.format("dxFilterBuilder-filterOperationGreaterOrEquals"),
        startsWith: message_default.format("dxFilterBuilder-filterOperationStartsWith"),
        contains: message_default.format("dxFilterBuilder-filterOperationContains"),
        notContains: message_default.format("dxFilterBuilder-filterOperationNotContains"),
        endsWith: message_default.format("dxFilterBuilder-filterOperationEndsWith"),
        isBlank: message_default.format("dxFilterBuilder-filterOperationIsBlank"),
        isNotBlank: message_default.format("dxFilterBuilder-filterOperationIsNotBlank")
      }
    },
    filterBuilderPopup: {}
  }),
  views: {
    filterBuilderView: FilterBuilderView
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/filter_builder.js
m_core_default.registerModule("filterBuilder", filterBuilderModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/filter/m_filter_panel.js
var FilterPanelView = class extends m_modules_default.View {
  init() {
    this._dataController = this.getController("data");
    this._columnsController = this.getController("columns");
    this._filterSyncController = this.getController("filterSync");
    this._dataController.dataSourceChanged.add((() => this.render()));
  }
  isVisible() {
    return this.option("filterPanel.visible") && this._dataController.dataSource();
  }
  _renderCore() {
    const $element = this.element();
    $element.empty();
    const isColumnsDefined = !!this._columnsController.getColumns().length;
    if (!isColumnsDefined) {
      return;
    }
    $element.addClass(this.addWidgetPrefix("filter-panel"));
    const $leftContainer = renderer_default("<div>").addClass(this.addWidgetPrefix("filter-panel-left")).appendTo($element);
    this._renderFilterBuilderText($element, $leftContainer);
  }
  _renderFilterBuilderText($element, $leftContainer) {
    const $filterElement = this._getFilterElement();
    const $textElement = this._getTextElement();
    if (this.option("filterValue") || this._filterValueBuffer) {
      const $checkElement = this._getCheckElement();
      const $removeButtonElement = this._getRemoveButtonElement();
      $leftContainer.append($checkElement).append($filterElement).append($textElement);
      $element.append($removeButtonElement);
      return;
    }
    $leftContainer.append($filterElement).append($textElement);
  }
  _getCheckElement() {
    const that = this;
    const $element = renderer_default("<div>").addClass(this.addWidgetPrefix("filter-panel-checkbox"));
    that._createComponent($element, check_box_default, {
      value: that.option("filterPanel.filterEnabled"),
      onValueChanged(e) {
        that.option("filterPanel.filterEnabled", e.value);
      }
    });
    $element.attr("title", this.option("filterPanel.texts.filterEnabledHint"));
    return $element;
  }
  _getFilterElement() {
    const that = this;
    const $element = renderer_default("<div>").addClass("dx-icon-filter");
    m_events_engine_default.on($element, "click", (() => that._showFilterBuilder()));
    registerKeyboardAction2("filterPanel", that, $element, void 0, (() => that._showFilterBuilder()));
    that._addTabIndexToElement($element);
    return $element;
  }
  _getTextElement() {
    const that = this;
    const $textElement = renderer_default("<div>").addClass(that.addWidgetPrefix("filter-panel-text"));
    let filterText;
    const filterValue = that.option("filterValue");
    if (filterValue) {
      when(that.getFilterText(filterValue, this._filterSyncController.getCustomFilterOperations())).done(((filterText2) => {
        const customizeText = that.option("filterPanel.customizeText");
        if (customizeText) {
          const customText = customizeText({
            component: that.component,
            filterValue,
            text: filterText2
          });
          if ("string" === typeof customText) {
            filterText2 = customText;
          }
        }
        $textElement.text(filterText2);
      }));
    } else {
      filterText = that.option("filterPanel.texts.createFilter");
      $textElement.text(filterText);
    }
    m_events_engine_default.on($textElement, "click", (() => that._showFilterBuilder()));
    registerKeyboardAction2("filterPanel", that, $textElement, void 0, (() => that._showFilterBuilder()));
    that._addTabIndexToElement($textElement);
    return $textElement;
  }
  _showFilterBuilder() {
    this.option("filterBuilderPopup.visible", true);
  }
  _getRemoveButtonElement() {
    const that = this;
    const clearFilterValue = () => that.option("filterValue", null);
    const $element = renderer_default("<div>").addClass(that.addWidgetPrefix("filter-panel-clear-filter")).text(that.option("filterPanel.texts.clearFilter"));
    m_events_engine_default.on($element, "click", clearFilterValue);
    registerKeyboardAction2("filterPanel", this, $element, void 0, clearFilterValue);
    that._addTabIndexToElement($element);
    return $element;
  }
  _addTabIndexToElement($element) {
    if (!this.option("useLegacyKeyboardNavigation")) {
      const tabindex = this.option("tabindex") || 0;
      $element.attr("tabindex", tabindex);
    }
  }
  optionChanged(args) {
    switch (args.name) {
      case "filterValue":
        this._invalidate();
        this.option("filterPanel.filterEnabled", true);
        args.handled = true;
        break;
      case "filterPanel":
        this._invalidate();
        args.handled = true;
        break;
      default:
        super.optionChanged(args);
    }
  }
  _getConditionText(fieldText, operationText, valueText) {
    let result = `[${fieldText}] ${operationText}`;
    if (isDefined(valueText)) {
      result += valueText;
    }
    return result;
  }
  _getValueMaskedText(value2) {
    return Array.isArray(value2) ? `('${value2.join("', '")}')` : ` '${value2}'`;
  }
  _getValueText(field, customOperation, value2) {
    const deferred = new Deferred();
    const hasCustomOperation = customOperation && customOperation.customizeText;
    if (isDefined(value2) || hasCustomOperation) {
      if (!hasCustomOperation && field.lookup) {
        getCurrentLookupValueText(field, value2, ((data17) => {
          deferred.resolve(this._getValueMaskedText(data17));
        }));
      } else {
        const displayValue = Array.isArray(value2) ? value2 : m_utils_default.getDisplayValue(field, value2, null);
        when(getCurrentValueText(field, displayValue, customOperation, "filterPanel")).done(((data17) => {
          deferred.resolve(this._getValueMaskedText(data17));
        }));
      }
    } else {
      deferred.resolve("");
    }
    return deferred.promise();
  }
  getConditionText(filterValue, options) {
    const that = this;
    const operation = filterValue[1];
    const deferred = new Deferred();
    const customOperation = getCustomOperation(options.customOperations, operation);
    let operationText;
    const field = getField(filterValue[0], options.columns);
    const fieldText = field.caption || "";
    const value2 = filterValue[2];
    if (customOperation) {
      operationText = customOperation.caption || m_inflector_default.captionize(customOperation.name);
    } else if (null === value2) {
      operationText = getCaptionByOperation("=" === operation ? "isblank" : "isnotblank", options.filterOperationDescriptions);
    } else {
      operationText = getCaptionByOperation(operation, options.filterOperationDescriptions);
    }
    this._getValueText(field, customOperation, value2).done(((valueText) => {
      deferred.resolve(that._getConditionText(fieldText, operationText, valueText));
    }));
    return deferred;
  }
  getGroupText(filterValue, options, isInnerGroup) {
    const that = this;
    const result = new Deferred();
    const textParts = [];
    const groupValue = getGroupValue(filterValue);
    filterValue.forEach(((item) => {
      if (isCondition(item)) {
        textParts.push(that.getConditionText(item, options));
      } else if (isGroup(item)) {
        textParts.push(that.getGroupText(item, options, true));
      }
    }));
    when.apply(this, textParts).done((function() {
      let text;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (groupValue.startsWith("!")) {
        const groupText = options.groupOperationDescriptions[`not${groupValue.substring(1, 2).toUpperCase()}${groupValue.substring(2)}`].split(" ");
        text = `${groupText[0]} ${args[0]}`;
      } else {
        text = args.join(` ${options.groupOperationDescriptions[groupValue]} `);
      }
      if (isInnerGroup) {
        text = `(${text})`;
      }
      result.resolve(text);
    }));
    return result;
  }
  getFilterText(filterValue, customOperations) {
    const options = {
      customOperations,
      columns: this._columnsController.getFilteringColumns(),
      filterOperationDescriptions: this.option("filterBuilder.filterOperationDescriptions"),
      groupOperationDescriptions: this.option("filterBuilder.groupOperationDescriptions")
    };
    return isCondition(filterValue) ? this.getConditionText(filterValue, options) : this.getGroupText(filterValue, options);
  }
};
var data11 = (Base) => class extends Base {
  optionChanged(args) {
    if ("filterPanel" === args.name) {
      this._applyFilter();
      args.handled = true;
    } else {
      super.optionChanged(args);
    }
  }
};
var filterPanelModule = {
  defaultOptions: () => ({
    filterPanel: {
      visible: false,
      filterEnabled: true,
      texts: {
        createFilter: message_default.format("dxDataGrid-filterPanelCreateFilter"),
        clearFilter: message_default.format("dxDataGrid-filterPanelClearFilter"),
        filterEnabledHint: message_default.format("dxDataGrid-filterPanelFilterEnabledHint")
      }
    }
  }),
  views: {
    filterPanelView: FilterPanelView
  },
  extenders: {
    controllers: {
      data: data11
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/filter_panel.js
m_core_default.registerModule("filterPanel", filterPanelModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/search/m_search.js
function allowSearch(column) {
  return !!(column.allowSearch ?? column.allowFiltering);
}
function parseValue(column, text) {
  const {
    lookup
  } = column;
  if (!column.parseValue) {
    return text;
  }
  if (lookup) {
    return column.parseValue.call(lookup, text);
  }
  return column.parseValue(text);
}
var dataController = (base) => class extends base {
  optionChanged(args) {
    switch (args.fullName) {
      case "searchPanel.text":
      case "searchPanel":
        this._applyFilter();
        args.handled = true;
        break;
      default:
        super.optionChanged(args);
    }
  }
  publicMethods() {
    return super.publicMethods().concat(["searchByText"]);
  }
  _calculateAdditionalFilter() {
    var _this$_dataController, _this$_dataController2, _dataSource$loadOptio;
    const dataSource = null === (_this$_dataController = this._dataController) || void 0 === _this$_dataController || null === (_this$_dataController2 = _this$_dataController.getDataSource) || void 0 === _this$_dataController2 ? void 0 : _this$_dataController2.call(_this$_dataController);
    const langParams = null === dataSource || void 0 === dataSource || null === (_dataSource$loadOptio = dataSource.loadOptions) || void 0 === _dataSource$loadOptio || null === (_dataSource$loadOptio = _dataSource$loadOptio.call(dataSource)) || void 0 === _dataSource$loadOptio ? void 0 : _dataSource$loadOptio.langParams;
    const filter = super._calculateAdditionalFilter();
    const searchFilter = this.calculateSearchFilter(this.option("searchPanel.text"), langParams);
    return m_utils_default.combineFilters([filter, searchFilter]);
  }
  searchByText(text) {
    this.option("searchPanel.text", text);
  }
  calculateSearchFilter(text, langParams) {
    let column;
    const columns7 = this._columnsController.getColumns();
    const searchVisibleColumnsOnly = this.option("searchPanel.searchVisibleColumnsOnly");
    let lookup;
    const filters = [];
    if (!text) {
      return null;
    }
    function onQueryDone(items) {
      const valueGetter = compileGetter(lookup.valueExpr);
      for (let i = 0; i < items.length; i++) {
        const value2 = valueGetter(items[i]);
        filters.push(column.createFilterExpression(value2, null, "search"));
      }
    }
    for (let i = 0; i < columns7.length; i++) {
      column = columns7[i];
      if (searchVisibleColumnsOnly && !column.visible) {
        continue;
      }
      if (allowSearch(column) && column.calculateFilterExpression) {
        var _lookup;
        lookup = column.lookup;
        const filterValue = parseValue(column, text);
        if (null !== (_lookup = lookup) && void 0 !== _lookup && _lookup.items) {
          m_query_default(lookup.items, {
            langParams
          }).filter(column.createFilterExpression.call({
            dataField: lookup.displayExpr,
            dataType: lookup.dataType,
            calculateFilterExpression: column.calculateFilterExpression
          }, filterValue, null, "search")).enumerate().done(onQueryDone);
        } else if (void 0 !== filterValue) {
          filters.push(column.createFilterExpression(filterValue, null, "search"));
        }
      }
    }
    if (0 === filters.length) {
      return ["!"];
    }
    return m_utils_default.combineFilters(filters, "or");
  }
};
var headerPanel6 = (Base) => class extends Base {
  optionChanged(args) {
    if ("searchPanel" === args.name) {
      if ("searchPanel.text" === args.fullName) {
        const editor = this.getSearchTextEditor();
        if (editor) {
          editor.option("value", args.value);
        }
      } else {
        this._invalidate();
      }
      args.handled = true;
    } else {
      super.optionChanged(args);
    }
  }
  _getToolbarItems() {
    const items = super._getToolbarItems();
    return this._prepareSearchItem(items);
  }
  _prepareSearchItem(items) {
    const that = this;
    const dataController2 = this._dataController;
    const searchPanelOptions = this.option("searchPanel");
    if (searchPanelOptions && searchPanelOptions.visible) {
      const toolbarItem = {
        template(data17, index, container) {
          const $search = renderer_default("<div>").addClass(that.addWidgetPrefix("search-panel")).appendTo(container);
          that._editorFactoryController.createEditor($search, {
            width: searchPanelOptions.width,
            placeholder: searchPanelOptions.placeholder,
            parentType: "searchPanel",
            value: that.option("searchPanel.text"),
            updateValueTimeout: 700,
            setValue(value2) {
              dataController2.searchByText(value2);
            },
            editorOptions: {
              inputAttr: {
                "aria-label": message_default.format(`${that.component.NAME}-ariaSearchInGrid`)
              }
            }
          });
          that.resize();
        },
        name: "searchPanel",
        location: "after",
        locateInMenu: "never",
        sortIndex: 40
      };
      items.push(toolbarItem);
    }
    return items;
  }
  getSearchTextEditor() {
    const that = this;
    const $element = that.element();
    const $searchPanel = $element.find(`.${that.addWidgetPrefix("search-panel")}`).filter((function() {
      return renderer_default(this).closest(`.${that.addWidgetPrefix("header-panel")}`).is($element);
    }));
    if ($searchPanel.length) {
      return $searchPanel.dxTextBox("instance");
    }
    return null;
  }
};
var rowsView8 = (Base) => class extends Base {
  init() {
    super.init.apply(this, arguments);
    this._searchParams = [];
    this._dataController = this.getController("data");
  }
  dispose() {
    clearTimeout(this._highlightTimer);
    super.dispose();
  }
  _getFormattedSearchText(column, searchText) {
    const value2 = parseValue(column, searchText);
    const formatOptions = m_utils_default.getFormatOptionsByColumn(column, "search");
    return m_utils_default.formatValue(value2, formatOptions);
  }
  _getStringNormalizer() {
    var _this$_dataController3, _this$_dataController4, _dataSource$loadOptio2;
    const isCaseSensitive = this.option("searchPanel.highlightCaseSensitive");
    const dataSource = null === (_this$_dataController3 = this._dataController) || void 0 === _this$_dataController3 || null === (_this$_dataController4 = _this$_dataController3.getDataSource) || void 0 === _this$_dataController4 ? void 0 : _this$_dataController4.call(_this$_dataController3);
    const langParams = null === dataSource || void 0 === dataSource || null === (_dataSource$loadOptio2 = dataSource.loadOptions) || void 0 === _dataSource$loadOptio2 || null === (_dataSource$loadOptio2 = _dataSource$loadOptio2.call(dataSource)) || void 0 === _dataSource$loadOptio2 ? void 0 : _dataSource$loadOptio2.langParams;
    return (str) => toComparable(str, isCaseSensitive, langParams);
  }
  _findHighlightingTextNodes(column, cellElement, searchText) {
    var _$items;
    const that = this;
    let $parent = cellElement.parent();
    let $items;
    const stringNormalizer = this._getStringNormalizer();
    const normalizedSearchText = stringNormalizer(searchText);
    const resultTextNodes = [];
    if (!$parent.length) {
      $parent = renderer_default("<div>").append(cellElement);
    } else if (column) {
      if (column.groupIndex >= 0 && !column.showWhenGrouped) {
        $items = cellElement;
      } else {
        const columnIndex = that._columnsController.getVisibleIndex(column.index);
        $items = $parent.children("td").eq(columnIndex).find("*");
      }
    }
    $items = null !== (_$items = $items) && void 0 !== _$items && _$items.length ? $items : $parent.find("*");
    $items.each(((_, element) => {
      const $contents = renderer_default(element).contents();
      for (let i = 0; i < $contents.length; i++) {
        const node = $contents.get(i);
        if (3 === node.nodeType) {
          const normalizedText = stringNormalizer(node.textContent ?? node.nodeValue ?? "");
          if (normalizedText.includes(normalizedSearchText)) {
            resultTextNodes.push(node);
          }
        }
      }
    }));
    return resultTextNodes;
  }
  _highlightSearchTextCore($textNode, searchText) {
    const that = this;
    const $searchTextSpan = renderer_default("<span>").addClass(that.addWidgetPrefix("search-text"));
    const text = $textNode.text();
    const firstContentElement = $textNode[0];
    const stringNormalizer = this._getStringNormalizer();
    const index = stringNormalizer(text).indexOf(stringNormalizer(searchText));
    if (index >= 0) {
      if (firstContentElement.textContent) {
        firstContentElement.textContent = text.substr(0, index);
      } else {
        firstContentElement.nodeValue = text.substr(0, index);
      }
      $textNode.after($searchTextSpan.text(text.substr(index, searchText.length)));
      $textNode = renderer_default(dom_adapter_default.createTextNode(text.substr(index + searchText.length))).insertAfter($searchTextSpan);
      return that._highlightSearchTextCore($textNode, searchText);
    }
  }
  _highlightSearchText(cellElement, isEquals, column) {
    const that = this;
    const stringNormalizer = this._getStringNormalizer();
    let searchText = that.option("searchPanel.text");
    if (isEquals && column) {
      searchText = searchText && that._getFormattedSearchText(column, searchText);
    }
    if (searchText && that.option("searchPanel.highlightSearchText")) {
      const textNodes = that._findHighlightingTextNodes(column, cellElement, searchText);
      textNodes.forEach(((textNode) => {
        if (isEquals) {
          if (stringNormalizer(renderer_default(textNode).text()) === stringNormalizer(searchText ?? "")) {
            renderer_default(textNode).replaceWith(renderer_default("<span>").addClass(that.addWidgetPrefix("search-text")).text(renderer_default(textNode).text()));
          }
        } else {
          that._highlightSearchTextCore(renderer_default(textNode), searchText);
        }
      }));
    }
  }
  _renderCore() {
    const deferred = super._renderCore.apply(this, arguments);
    if (this.option().rowTemplate || this.option("dataRowTemplate")) {
      if (this.option("templatesRenderAsynchronously")) {
        clearTimeout(this._highlightTimer);
        this._highlightTimer = setTimeout((() => {
          this._highlightSearchText(this.getTableElement());
        }));
      } else {
        this._highlightSearchText(this.getTableElement());
      }
    }
    return deferred;
  }
  _updateCell($cell, parameters) {
    const {
      column
    } = parameters;
    const dataType = column.lookup && column.lookup.dataType || column.dataType;
    const isEquals = "string" !== dataType;
    if (allowSearch(column) && !parameters.isOnForm) {
      if (this.option("templatesRenderAsynchronously")) {
        if (!this._searchParams.length) {
          clearTimeout(this._highlightTimer);
          this._highlightTimer = setTimeout((() => {
            this._searchParams.forEach(((params) => {
              this._highlightSearchText.apply(this, params);
            }));
            this._searchParams = [];
          }));
        }
        this._searchParams.push([$cell, isEquals, column]);
      } else {
        this._highlightSearchText($cell, isEquals, column);
      }
    }
    super._updateCell($cell, parameters);
  }
};
var searchModule = {
  defaultOptions: () => ({
    searchPanel: {
      visible: false,
      width: 160,
      placeholder: message_default.format("dxDataGrid-searchPanelPlaceholder"),
      highlightSearchText: true,
      highlightCaseSensitive: false,
      text: "",
      searchVisibleColumnsOnly: false
    }
  }),
  extenders: {
    controllers: {
      data: dataController
    },
    views: {
      headerPanel: headerPanel6,
      rowsView: rowsView8
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/search.js
m_core_default.registerModule("search", searchModule);

// node_modules/devextreme/esm/__internal/pagination/common/base_pagination_props.js
var BasePaginationDefaultProps = _extends({}, BaseWidgetDefaultProps, {
  isGridCompatibilityMode: false,
  showInfo: false,
  displayMode: "adaptive",
  maxPagesCount: 10,
  pageCount: 1,
  visible: true,
  hasKnownLastPage: true,
  pagesNavigatorVisible: "auto",
  showPageSizeSelector: "auto",
  allowedPageSizes: [5, 10],
  showNavigationButtons: false,
  itemCount: 1,
  label: message_default.format("dxPagination-ariaLabel")
});

// node_modules/devextreme/esm/__internal/pagination/common/pagination_props.js
var PaginationDefaultProps = _extends({}, BasePaginationDefaultProps, {
  pageSize: 5,
  pageIndex: 1,
  pageIndexChangedInternal: () => {
  },
  pageSizeChangedInternal: () => {
  }
});

// node_modules/devextreme/esm/__internal/pagination/common/consts.js
var PAGER_CLASS = "dx-pager";
var PAGINATION_CLASS = "dx-pagination";
var LIGHT_MODE_CLASS = "dx-light-mode";
var PAGINATION_PAGES_CLASS = "dx-pages";
var PAGINATION_PAGE_INDEXES_CLASS = "dx-page-indexes";
var PAGINATION_PAGE_CLASS = "dx-page";
var PAGINATION_SELECTION_CLASS = "dx-selection";
var PAGINATION_PAGE_SIZE_CLASS = "dx-page-size";
var PAGINATION_PAGE_SIZES_CLASS = "dx-page-sizes";
var PAGINATION_SELECTED_PAGE_SIZE_CLASS = "dx-page-size dx-selection";
var FIRST_CHILD_CLASS = "dx-first-child";

// node_modules/devextreme/esm/__internal/pagination/common/keyboard_action_context.js
var KeyboardActionContext = createContext(void 0);

// node_modules/devextreme/esm/__internal/pagination/common/pagination_config_context.js
var PaginationConfigContext = createContext(void 0);

// node_modules/devextreme/esm/__internal/pagination/common/pagination_config_provider.js
var PaginationConfigProviderDefaultProps = {};
var PaginationConfigProvider = class extends BaseInfernoComponent {
  constructor() {
    super(...arguments);
    this.state = {};
  }
  getConfig() {
    return {
      isGridCompatibilityMode: this.props.isGridCompatibilityMode
    };
  }
  getChildContext() {
    return _extends({}, this.context, {
      [PaginationConfigContext.id]: this.getConfig() || PaginationConfigContext.defaultValue
    });
  }
  render() {
    return this.props.children;
  }
};
PaginationConfigProvider.defaultProps = PaginationConfigProviderDefaultProps;

// node_modules/devextreme/esm/__internal/pagination/utils/compatibility_utils.js
function getPaginationConfig(context) {
  if (context[PaginationConfigContext.id]) {
    return context[PaginationConfigContext.id];
  }
  return PaginationConfigContext.defaultValue;
}
function isGridCompatibilityMode(context) {
  var _getPaginationConfig;
  return !!(null !== (_getPaginationConfig = getPaginationConfig(context)) && void 0 !== _getPaginationConfig && _getPaginationConfig.isGridCompatibilityMode);
}
function getLocalizationMessage(context, key) {
  let actualKey = key;
  if (isGridCompatibilityMode(context)) {
    actualKey = key.replace("dxPagination", "dxPager");
  }
  return message_default.getFormatter(actualKey)();
}

// node_modules/devextreme/esm/__internal/pagination/info.js
var PAGER_INFO_CLASS = "dx-info";
var InfoTextDefaultProps = {
  pageCount: PaginationDefaultProps.pageCount,
  pageIndex: PaginationDefaultProps.pageIndex,
  itemCount: PaginationDefaultProps.itemCount
};
var InfoText = class extends BaseInfernoComponent {
  constructor() {
    super(...arguments);
    this.state = {};
    this.refs = null;
    this.rootElementRef = createRef();
  }
  getInfoText() {
    return this.props.infoText ?? getLocalizationMessage(this.context, "dxPagination-infoText");
  }
  getText() {
    const {
      pageCount,
      pageIndex,
      itemCount
    } = this.props;
    return format(this.getInfoText(), (pageIndex + 1).toString(), null === pageCount || void 0 === pageCount ? void 0 : pageCount.toString(), null === itemCount || void 0 === itemCount ? void 0 : itemCount.toString());
  }
  render() {
    return createVNode(1, "div", "dx-info", this.getText(), 0, null, null, this.props.rootElementRef);
  }
};
InfoText.defaultProps = InfoTextDefaultProps;

// node_modules/devextreme/esm/__internal/pagination/common/light_button.js
var LightButtonDefaultProps = {
  className: "",
  label: "",
  tabIndex: 0,
  selected: false
};
var LightButton = class extends InfernoComponent {
  constructor(props) {
    super(props);
    this.state = {};
    this.refs = null;
    this.widgetRef = createRef();
    this.keyboardEffect = this.keyboardEffect.bind(this);
    this.subscribeToClick = this.subscribeToClick.bind(this);
  }
  getComponentProps() {
    return this.props;
  }
  getKeyboardContext() {
    if (this.context[KeyboardActionContext.id]) {
      return this.context[KeyboardActionContext.id];
    }
    return KeyboardActionContext.defaultValue;
  }
  componentWillUpdate(nextProps, nextState, context) {
    super.componentWillUpdate(nextProps, nextState, context);
  }
  createEffects() {
    return [new InfernoEffect(this.keyboardEffect, [this.getKeyboardContext(), this.props.onClick]), new InfernoEffect(this.subscribeToClick, [this.props.onClick])];
  }
  updateEffects() {
    var _this$_effects$, _this$_effects$2;
    null === (_this$_effects$ = this._effects[0]) || void 0 === _this$_effects$ || _this$_effects$.update([this.getKeyboardContext(), this.props.onClick]);
    null === (_this$_effects$2 = this._effects[1]) || void 0 === _this$_effects$2 || _this$_effects$2.update([this.props.onClick]);
  }
  keyboardEffect() {
    return this.getKeyboardContext().registerKeyboardAction(this.widgetRef.current, this.props.onClick);
  }
  subscribeToClick() {
    return subscribeToClickEvent(this.widgetRef.current, this.props.onClick);
  }
  render() {
    return createVNode(1, "div", this.props.className, this.props.children, 0, {
      tabindex: this.props.tabIndex,
      role: "button",
      "aria-label": this.props.label,
      "aria-current": this.props.selected ? "page" : void 0
    }, null, this.widgetRef);
  }
};
LightButton.defaultProps = LightButtonDefaultProps;

// node_modules/devextreme/esm/__internal/pagination/page_size/large.js
var PageSizeLargeDefaultProps = {
  allowedPageSizes: [],
  pageSize: PaginationDefaultProps.pageSize,
  pageSizeChangedInternal: PaginationDefaultProps.pageSizeChangedInternal
};
var PageSizeLarge = class extends BaseInfernoComponent {
  constructor(props) {
    super(props);
    this.state = {};
    this.refs = null;
    this.__getterCache = {
      pageSizesText: void 0
    };
    this.state = {};
    this.onPageSizeChange = this.onPageSizeChange.bind(this);
  }
  getPageSizesText() {
    if (void 0 !== this.__getterCache.pageSizesText) {
      return this.__getterCache.pageSizesText;
    }
    const result = (() => {
      const {
        pageSize,
        allowedPageSizes
      } = this.props;
      return allowedPageSizes.map(((_ref3, index) => {
        const {
          text,
          value: processedPageSize
        } = _ref3;
        const selected = processedPageSize === pageSize;
        const className = combineClasses({
          [selected ? PAGINATION_SELECTED_PAGE_SIZE_CLASS : PAGINATION_PAGE_SIZE_CLASS]: true,
          [FIRST_CHILD_CLASS]: 0 === index
        });
        return {
          className,
          click: this.onPageSizeChange(processedPageSize),
          label: format(getLocalizationMessage(this.context, "dxPagination-pageSize"), processedPageSize || getLocalizationMessage(this.context, "dxPagination-pageSizesAllText")),
          text
        };
      }));
    })();
    this.__getterCache.pageSizesText = result;
    return result;
  }
  onPageSizeChange(processedPageSize) {
    return () => {
      this.props.pageSizeChangedInternal(processedPageSize);
      return this.props.pageSize;
    };
  }
  componentWillUpdate(nextProps) {
    const componentChanged = this.props.pageSize !== nextProps.pageSize || this.props.allowedPageSizes !== nextProps.allowedPageSizes || this.props.pageSizeChangedInternal !== nextProps.pageSizeChangedInternal;
    if (componentChanged) {
      this.__getterCache.pageSizesText = void 0;
    }
  }
  render() {
    return createFragment(this.getPageSizesText().map(((_ref) => {
      let {
        text,
        className,
        label,
        click
      } = _ref;
      return createComponentVNode(2, LightButton, {
        className,
        label,
        onClick: click,
        children: text
      }, text);
    })), 0);
  }
};
PageSizeLarge.defaultProps = PageSizeLargeDefaultProps;

// node_modules/devextreme/esm/__internal/pagination/editors/common/editor_label_props.js
var EditorLabelDefaultProps = {
  label: "",
  labelMode: isMaterial(current()) ? "floating" : "static"
};

// node_modules/devextreme/esm/__internal/pagination/editors/common/base_widget_props.js
var BaseWidgetDefaultProps2 = {
  className: "",
  activeStateEnabled: false,
  disabled: false,
  focusStateEnabled: false,
  hoverStateEnabled: false,
  tabIndex: 0,
  visible: true,
  rtlEnabled: false
};

// node_modules/devextreme/esm/__internal/pagination/editors/common/widget_props.js
var WidgetDefaultProps = _extends({}, BaseWidgetDefaultProps, {
  _feedbackHideTimeout: 400,
  _feedbackShowTimeout: 30,
  cssText: "",
  aria: {},
  classes: "",
  name: "",
  addWidgetClass: true
});

// node_modules/devextreme/esm/__internal/pagination/editors/common/editor_props.js
var EditorDefaultProps = _extends({}, BaseWidgetDefaultProps2, {
  aria: WidgetDefaultProps.aria,
  classes: WidgetDefaultProps.classes,
  readOnly: false,
  name: "",
  value: null,
  validationError: null,
  validationErrors: null,
  validationMessageMode: "auto",
  validationMessagePosition: "bottom",
  validationStatus: "valid",
  isValid: true,
  isDirty: false,
  inputAttr: {}
});

// node_modules/devextreme/esm/__internal/pagination/editors/common/editor_state_props.js
var EditorStateDefaultProps = {
  hoverStateEnabled: true,
  activeStateEnabled: true,
  focusStateEnabled: "desktop" === devices_default.real().deviceType && !devices_default.isSimulator()
};

// node_modules/devextreme/esm/__internal/pagination/drop_down_editors/select_box.js
var NumberBoxDefaultProps = _extends({}, EditorDefaultProps, EditorStateDefaultProps, EditorLabelDefaultProps, {
  placeholder: "",
  hoverStateEnabled: true,
  searchEnabled: false,
  value: null,
  isReactComponentWrapper: true
});
var SelectBox = class extends BaseInfernoComponent {
  constructor() {
    super(...arguments);
    this.state = {};
    this.refs = null;
  }
  get componentProps() {
    return this.props;
  }
  render() {
    return createComponentVNode(2, DomComponentWrapper, {
      componentType: select_box_default,
      componentProps: this.componentProps,
      templateNames: ["dropDownButtonTemplate", "groupTemplate", "itemTemplate"]
    });
  }
};
SelectBox.defaultProps = NumberBoxDefaultProps;

// node_modules/devextreme/esm/__internal/pagination/utils/calculate_values_fitted_width.js
function calculateValuesFittedWidth(minWidth, values) {
  return minWidth + 10 * Math.max(...values).toString().length;
}

// node_modules/devextreme/esm/__internal/core/r1/utils/get_computed_style.js
function getElementComputedStyle(el) {
  var _window$getComputedSt;
  const window2 = getWindow();
  return el ? null === (_window$getComputedSt = window2.getComputedStyle) || void 0 === _window$getComputedSt ? void 0 : _window$getComputedSt.call(window2, el) : null;
}

// node_modules/devextreme/esm/__internal/core/r1/utils/type_conversion.js
function toNumber(attribute) {
  return attribute ? Number(attribute.replace("px", "")) : 0;
}

// node_modules/devextreme/esm/__internal/pagination/utils/get_element_width.js
function getElementStyle(name, element) {
  const computedStyle = getElementComputedStyle(element) ?? {};
  return toNumber(computedStyle[name]);
}
function getElementContentWidth(element) {
  const padding = getElementStyle("paddingLeft", element) + getElementStyle("paddingRight", element);
  const width = getElementStyle("width", element);
  return width - padding;
}
function getElementWidth(element) {
  const margin = getElementStyle("marginLeft", element) + getElementStyle("marginRight", element);
  const width = getElementStyle("width", element);
  return margin + width;
}
function getElementMinWidth(element) {
  return getElementStyle("minWidth", element);
}

// node_modules/devextreme/esm/__internal/pagination/page_size/small.js
var PaginationSmallDefaultProps = {
  allowedPageSizes: []
};
var PageSizeSmallDefaultProps = _extends({}, PaginationSmallDefaultProps, {
  pageSize: PaginationDefaultProps.pageSize,
  pageSizeChangedInternal: PaginationDefaultProps.pageSizeChangedInternal
});
var PageSizeSmall = class extends InfernoComponent {
  constructor(props) {
    super(props);
    this.state = {
      minWidth: 10
    };
    this.refs = null;
    this.updateWidth = this.updateWidth.bind(this);
  }
  componentWillUpdate(nextProps, nextState, context) {
    super.componentWillUpdate(nextProps, nextState, context);
  }
  createEffects() {
    const dependency = [this.props, this.state.minWidth, this.props.pageSize, this.props.pageSizeChangedInternal, this.props.allowedPageSizes];
    return [new InfernoEffect(this.updateWidth, dependency)];
  }
  updateEffects() {
    var _this$_effects$;
    const dependency = [this.props, this.state.minWidth, this.props.pageSize, this.props.pageSizeChangedInternal, this.props.allowedPageSizes];
    null === (_this$_effects$ = this._effects[0]) || void 0 === _this$_effects$ || _this$_effects$.update(dependency);
  }
  updateWidth() {
    var _this$props$parentRef;
    const minWidth = getElementMinWidth(null === (_this$props$parentRef = this.props.parentRef) || void 0 === _this$props$parentRef ? void 0 : _this$props$parentRef.current);
    this.setState(((state) => ({
      minWidth: minWidth > 0 ? minWidth : state.minWidth
    })));
  }
  getWidth() {
    var _this$props$allowedPa;
    return calculateValuesFittedWidth(this.state.minWidth, null === (_this$props$allowedPa = this.props.allowedPageSizes) || void 0 === _this$props$allowedPa ? void 0 : _this$props$allowedPa.map(((p) => p.value)));
  }
  getInputAttributes() {
    return {
      "aria-label": getLocalizationMessage(this.context, "dxPagination-ariaPageSize")
    };
  }
  render() {
    const {
      allowedPageSizes,
      pageSize,
      pageSizeChangedInternal
    } = this.props;
    return createComponentVNode(2, SelectBox, {
      displayExpr: "text",
      valueExpr: "value",
      dataSource: allowedPageSizes,
      value: pageSize,
      valueChange: pageSizeChangedInternal,
      width: this.getWidth(),
      inputAttr: this.getInputAttributes()
    });
  }
};
PageSizeSmall.defaultProps = PageSizeSmallDefaultProps;

// node_modules/devextreme/esm/__internal/pagination/page_size/selector.js
var PageSizeSelectorDefaultProps = {
  isLargeDisplayMode: true,
  pageSize: PaginationDefaultProps.pageSize,
  pageSizeChangedInternal: PaginationDefaultProps.pageSizeChangedInternal,
  allowedPageSizes: PaginationDefaultProps.allowedPageSizes
};
var PageSizeSelector = class extends InfernoComponent {
  constructor(props) {
    super(props);
    this.state = {};
    this.refs = null;
    this.rootElementRef = createRef();
    this.htmlRef = createRef();
    this.__getterCache = {
      normalizedPageSizes: void 0
    };
    this.setRootElementRef = this.setRootElementRef.bind(this);
  }
  createEffects() {
    return [new InfernoEffect(this.setRootElementRef, [])];
  }
  setRootElementRef() {
    const {
      rootElementRef
    } = this.props;
    if (rootElementRef) {
      rootElementRef.current = this.htmlRef.current;
    }
  }
  getAllText() {
    return getLocalizationMessage(this.context, "dxPagination-pageSizesAllText");
  }
  getNormalizedPageSizes() {
    if (void 0 !== this.__getterCache.normalizedPageSizes) {
      return this.__getterCache.normalizedPageSizes;
    }
    const result = this.props.allowedPageSizes.map(((p) => "all" === p || 0 === p ? {
      text: this.getAllText(),
      value: 0
    } : {
      text: String(p),
      value: p
    }));
    this.__getterCache.normalizedPageSizes = result;
    return result;
  }
  componentWillUpdate(nextProps) {
    super.componentWillUpdate();
    if (this.props.allowedPageSizes !== nextProps.allowedPageSizes) {
      this.__getterCache.normalizedPageSizes = void 0;
    }
  }
  render() {
    const normalizedPageSizes = this.getNormalizedPageSizes();
    const {
      pageSize,
      pageSizeChangedInternal,
      isLargeDisplayMode
    } = this.props;
    return createVNode(1, "div", PAGINATION_PAGE_SIZES_CLASS, [isLargeDisplayMode && createComponentVNode(2, PageSizeLarge, {
      allowedPageSizes: normalizedPageSizes,
      pageSize,
      pageSizeChangedInternal
    }), !isLargeDisplayMode && createComponentVNode(2, PageSizeSmall, {
      parentRef: this.htmlRef,
      allowedPageSizes: normalizedPageSizes,
      pageSize,
      pageSizeChangedInternal
    })], 0, null, null, this.htmlRef);
  }
};
PageSizeSelector.defaultProps = PageSizeSelectorDefaultProps;

// node_modules/devextreme/esm/__internal/pagination/pages/page.js
var PageDefaultProps = {
  index: 0,
  selected: false,
  className: PAGINATION_PAGE_CLASS
};
var Page = class extends BaseInfernoComponent {
  constructor() {
    super(...arguments);
    this.state = {};
    this.refs = null;
  }
  getLabel() {
    return format(getLocalizationMessage(this.context, "dxPagination-page"), this.getValue());
  }
  getValue() {
    return this.props.index + 1;
  }
  getClassName() {
    return combineClasses({
      [`${this.props.className}`]: !!this.props.className,
      [PAGINATION_SELECTION_CLASS]: !!this.props.selected
    });
  }
  render() {
    return createComponentVNode(2, LightButton, {
      className: this.getClassName(),
      label: this.getLabel(),
      onClick: this.props.onClick,
      selected: this.props.selected,
      children: this.getValue()
    });
  }
};
Page.defaultProps = PageDefaultProps;

// node_modules/devextreme/esm/__internal/pagination/pages/large.js
var PagesLargeDefaultProps = {
  maxPagesCount: PaginationDefaultProps.maxPagesCount,
  pageCount: PaginationDefaultProps.pageCount,
  pageIndex: PaginationDefaultProps.pageIndex,
  pageIndexChangedInternal: PaginationDefaultProps.pageIndexChangedInternal
};
function getDelimiterType(startIndex, slidingWindowSize, pageCount) {
  switch (true) {
    case 1 === startIndex:
      return "high";
    case startIndex + slidingWindowSize === pageCount - 1:
      return "low";
    default:
      return "both";
  }
}
function createPageIndexesBySlidingWindowIndexes(slidingWindowIndexes, pageCount, delimiter) {
  let pageIndexes = [];
  let indexesForReuse = [];
  switch (delimiter) {
    case "none":
      pageIndexes = [...slidingWindowIndexes];
      break;
    case "both":
      pageIndexes = [0, "low", ...slidingWindowIndexes, "high", pageCount - 1];
      indexesForReuse = slidingWindowIndexes.slice(1, -1);
      break;
    case "high":
      pageIndexes = [0, ...slidingWindowIndexes, "high", pageCount - 1];
      indexesForReuse = slidingWindowIndexes.slice(0, -1);
      break;
    case "low":
      pageIndexes = [0, "low", ...slidingWindowIndexes, pageCount - 1];
      indexesForReuse = slidingWindowIndexes.slice(1);
  }
  return {
    slidingWindowIndexes,
    indexesForReuse,
    pageIndexes
  };
}
function createPageIndexes(startIndex, slidingWindowSize, pageCount, delimiter) {
  const slidingWindowIndexes = [];
  for (let i = 0; i < slidingWindowSize; i += 1) {
    slidingWindowIndexes.push(i + startIndex);
  }
  return createPageIndexesBySlidingWindowIndexes(slidingWindowIndexes, pageCount, delimiter);
}
var PagesLarge = class extends BaseInfernoComponent {
  constructor(props) {
    super(props);
    this.state = {};
    this.refs = null;
    this.canReuseSlidingWindow = this.canReuseSlidingWindow.bind(this);
    this.generatePageIndexes = this.generatePageIndexes.bind(this);
    this.isSlidingWindowMode = this.isSlidingWindowMode.bind(this);
    this.onPageClick = this.onPageClick.bind(this);
  }
  getConfig() {
    if (this.context[ConfigContext.id]) {
      return this.context[ConfigContext.id];
    }
    return ConfigContext.defaultValue;
  }
  getSlidingWindowState() {
    const slidingWindowState = this.slidingWindowStateHolder;
    if (!slidingWindowState) {
      return {
        indexesForReuse: [],
        slidingWindowIndexes: []
      };
    }
    return slidingWindowState;
  }
  canReuseSlidingWindow(currentPageCount, pageIndex) {
    const {
      indexesForReuse
    } = this.getSlidingWindowState();
    const lastPageIsFartherThanWindow = indexesForReuse.slice(-1)[0] < currentPageCount - 1;
    const pageIndexExistInIndexes = indexesForReuse.includes(pageIndex);
    return lastPageIsFartherThanWindow && pageIndexExistInIndexes;
  }
  generatePageIndexes() {
    const {
      pageCount,
      pageIndex
    } = this.props;
    let startIndex = 0;
    const {
      slidingWindowIndexes
    } = this.getSlidingWindowState();
    if (pageIndex === slidingWindowIndexes[0]) {
      startIndex = pageIndex - 1;
    } else if (pageIndex === slidingWindowIndexes[slidingWindowIndexes.length - 1]) {
      startIndex = pageIndex + 2 - 4;
    } else if (pageIndex < 4) {
      startIndex = 1;
    } else if (pageIndex >= pageCount - 4) {
      startIndex = pageCount - 4 - 1;
    } else {
      startIndex = pageIndex - 1;
    }
    const delimiter = getDelimiterType(startIndex, 4, pageCount);
    const indexes = createPageIndexes(startIndex, 4, pageCount, delimiter);
    const {
      pageIndexes
    } = indexes;
    this.slidingWindowStateHolder = indexes;
    return pageIndexes;
  }
  isSlidingWindowMode() {
    const {
      maxPagesCount,
      pageCount
    } = this.props;
    return pageCount <= 4 || pageCount <= maxPagesCount;
  }
  onPageClick(pageIndex) {
    this.props.pageIndexChangedInternal(pageIndex);
  }
  getPageIndexes() {
    const {
      pageCount
    } = this.props;
    if (this.isSlidingWindowMode()) {
      return createPageIndexes(0, pageCount, pageCount, "none").pageIndexes;
    }
    if (this.canReuseSlidingWindow(pageCount, this.props.pageIndex)) {
      const {
        slidingWindowIndexes
      } = this.getSlidingWindowState();
      const delimiter = getDelimiterType(slidingWindowIndexes[0], 4, pageCount);
      return createPageIndexesBySlidingWindowIndexes(slidingWindowIndexes, pageCount, delimiter).pageIndexes;
    }
    return this.generatePageIndexes();
  }
  getPages() {
    var _this$getConfig;
    const {
      pageIndex
    } = this.props;
    const createPage = (index) => {
      const paginationProps = "low" === index || "high" === index ? null : {
        index,
        onClick: () => this.onPageClick(index),
        selected: pageIndex === index
      };
      return {
        key: index.toString(),
        pageProps: paginationProps
      };
    };
    const indices = this.getPageIndexes();
    const rtlPageIndexes = null !== (_this$getConfig = this.getConfig()) && void 0 !== _this$getConfig && _this$getConfig.rtlEnabled ? [...indices].reverse() : indices;
    return rtlPageIndexes.map(((index) => createPage(index)));
  }
  render() {
    const PagesMarkup = this.getPages().map(((_ref) => {
      let {
        key,
        pageProps
      } = _ref;
      return pageProps ? createComponentVNode(2, Page, {
        index: pageProps.index,
        selected: pageProps.selected,
        onClick: pageProps.onClick
      }, key) : createVNode(1, "div", "dx-separator", ". . .", 16, null, key);
    }));
    return createFragment(PagesMarkup, 0);
  }
};
PagesLarge.defaultProps = PagesLargeDefaultProps;

// node_modules/devextreme/esm/__internal/pagination/editors/number_box.js
var NumberBoxDefaultProps2 = _extends({}, EditorDefaultProps, EditorStateDefaultProps, EditorLabelDefaultProps, {
  value: 0,
  isReactComponentWrapper: true
});
var NumberBox = class extends BaseInfernoComponent {
  constructor() {
    super(...arguments);
    this.state = {};
    this.refs = null;
  }
  get componentProps() {
    return this.props;
  }
  render() {
    return createComponentVNode(2, DomComponentWrapper, {
      componentType: number_box_default,
      componentProps: this.componentProps,
      templateNames: []
    });
  }
};
NumberBox.defaultProps = NumberBoxDefaultProps2;

// node_modules/devextreme/esm/__internal/pagination/pages/small.js
var PAGER_INFO_TEXT_CLASS = `${PAGER_INFO_CLASS}  dx-info-text`;
var PaginationSmallDefaultProps2 = {
  pageIndex: PaginationDefaultProps.pageIndex,
  pageCount: PaginationDefaultProps.pageCount,
  pageIndexChangedInternal: PaginationDefaultProps.pageIndexChangedInternal
};
var PagesSmall = class extends InfernoComponent {
  constructor(props) {
    super(props);
    this.state = {
      minWidth: 10
    };
    this.refs = null;
    this.pageIndexRef = createRef();
    this.updateWidth = this.updateWidth.bind(this);
    this.selectLastPageIndex = this.selectLastPageIndex.bind(this);
    this.valueChange = this.valueChange.bind(this);
  }
  componentWillUpdate(nextProps, nextState, context) {
    super.componentWillUpdate(nextProps, nextState, context);
  }
  createEffects() {
    return [new InfernoEffect(this.updateWidth, [this.state.minWidth])];
  }
  updateEffects() {
    var _this$_effects$;
    null === (_this$_effects$ = this._effects[0]) || void 0 === _this$_effects$ || _this$_effects$.update([this.state.minWidth]);
  }
  updateWidth() {
    var _this$pageIndexRef$cu;
    const el = null === (_this$pageIndexRef$cu = this.pageIndexRef.current) || void 0 === _this$pageIndexRef$cu ? void 0 : _this$pageIndexRef$cu.querySelector(".dx-page-index");
    const minWidth = el ? getElementMinWidth(el) : 0;
    this.setState(((state) => ({
      minWidth: minWidth > 0 ? minWidth : state.minWidth
    })));
  }
  getValue() {
    return this.props.pageIndex + 1;
  }
  getWidth() {
    return calculateValuesFittedWidth(this.state.minWidth, [this.props.pageCount]);
  }
  getPagesCountText() {
    return (this.props.pagesCountText ?? "") || getLocalizationMessage(this.context, "dxPagination-pagesCountText");
  }
  getInputAttributes() {
    return {
      "aria-label": getLocalizationMessage(this.context, "dxPagination-ariaPageNumber")
    };
  }
  selectLastPageIndex() {
    this.props.pageIndexChangedInternal(this.props.pageCount - 1);
  }
  valueChange(value2) {
    this.props.pageIndexChangedInternal(value2 - 1);
  }
  render() {
    return createVNode(1, "div", "dx-light-pages", [createComponentVNode(2, NumberBox, {
      className: "dx-page-index",
      min: 1,
      max: Math.max(this.props.pageCount, this.getValue()),
      width: this.getWidth(),
      value: this.getValue(),
      valueChange: this.valueChange,
      inputAttr: this.getInputAttributes()
    }), createVNode(1, "span", PAGER_INFO_TEXT_CLASS, this.getPagesCountText(), 0), createComponentVNode(2, Page, {
      className: "dx-pages-count",
      selected: false,
      index: this.props.pageCount - 1,
      onClick: this.selectLastPageIndex
    })], 4, null, null, this.pageIndexRef);
  }
};
PagesSmall.defaultProps = PaginationSmallDefaultProps2;

// node_modules/devextreme/esm/__internal/pagination/pages/page_index_selector.js
var classNames = {
  nextEnabledClass: "dx-navigate-button dx-next-button",
  prevEnabledClass: "dx-navigate-button dx-prev-button",
  nextDisabledClass: "dx-button-disable dx-navigate-button dx-next-button",
  prevDisabledClass: "dx-button-disable dx-navigate-button dx-prev-button"
};
var reverseDirections = {
  next: "prev",
  prev: "next"
};
function getIncrement(direction) {
  return "next" === direction ? 1 : -1;
}
var PageIndexSelectorDefaultProps = {
  isLargeDisplayMode: true,
  maxPagesCount: PaginationDefaultProps.maxPagesCount,
  pageCount: PaginationDefaultProps.pageCount,
  pageIndex: PaginationDefaultProps.pageIndex,
  pageIndexChangedInternal: PaginationDefaultProps.pageIndexChangedInternal,
  showNavigationButtons: PaginationDefaultProps.showNavigationButtons,
  itemCount: PaginationDefaultProps.itemCount
};
var PageIndexSelector = class extends BaseInfernoComponent {
  constructor(props) {
    super(props);
    this.state = {};
    this.refs = null;
    this.__getterCache = {
      prevButtonProps: void 0,
      nextButtonProps: void 0
    };
    this.pageIndexChangedInternal = this.pageIndexChangedInternal.bind(this);
    this.getButtonProps = this.getButtonProps.bind(this);
    this.canNavigateToPage = this.canNavigateToPage.bind(this);
    this.getNextPageIndex = this.getNextPageIndex.bind(this);
    this.canNavigateTo = this.canNavigateTo.bind(this);
    this.navigateToPage = this.navigateToPage.bind(this);
  }
  getConfig() {
    if (this.context[ConfigContext.id]) {
      return this.context[ConfigContext.id];
    }
    return ConfigContext.defaultValue;
  }
  pageIndexChangedInternal(pageIndex) {
    if (this.canNavigateToPage(pageIndex)) {
      this.props.pageIndexChangedInternal(pageIndex);
    }
  }
  getButtonProps(direction) {
    var _this$getConfig;
    const rtlAwareDirection = null !== (_this$getConfig = this.getConfig()) && void 0 !== _this$getConfig && _this$getConfig.rtlEnabled ? reverseDirections[direction] : direction;
    const canNavigate = this.canNavigateTo(rtlAwareDirection);
    const className = classNames[`${direction}${canNavigate ? "Enabled" : "Disabled"}Class`];
    return {
      className,
      tabIndex: canNavigate ? 0 : -1,
      navigate: () => this.navigateToPage(rtlAwareDirection)
    };
  }
  canNavigateToPage(pageIndex) {
    if (!this.props.hasKnownLastPage) {
      return pageIndex >= 0;
    }
    return pageIndex >= 0 && pageIndex <= this.props.pageCount - 1;
  }
  getNextPageIndex(direction) {
    return this.props.pageIndex + getIncrement(direction);
  }
  canNavigateTo(direction) {
    return this.canNavigateToPage(this.getNextPageIndex(direction));
  }
  navigateToPage(direction) {
    this.pageIndexChangedInternal(this.getNextPageIndex(direction));
  }
  getRenderPrevButton() {
    const {
      isLargeDisplayMode,
      showNavigationButtons
    } = this.props;
    return (!isLargeDisplayMode || showNavigationButtons) ?? false;
  }
  getRenderNextButton() {
    return this.getRenderPrevButton() || !this.props.hasKnownLastPage;
  }
  getPrevButtonProps() {
    if (void 0 !== this.__getterCache.prevButtonProps) {
      return this.__getterCache.prevButtonProps;
    }
    const result = (() => this.getButtonProps("prev"))();
    this.__getterCache.prevButtonProps = result;
    return result;
  }
  getNextButtonProps() {
    if (void 0 !== this.__getterCache.nextButtonProps) {
      return this.__getterCache.nextButtonProps;
    }
    const result = (() => this.getButtonProps("next"))();
    this.__getterCache.nextButtonProps = result;
    return result;
  }
  componentWillUpdate(nextProps, nextState, context) {
    const isComponentUpdated = this.context[ConfigContext.id] !== context[ConfigContext.id] || this.props.hasKnownLastPage !== nextProps.hasKnownLastPage || this.props.pageCount !== nextProps.pageCount || this.props.pageIndex !== nextProps.pageIndex || this.props.pageIndexChangedInternal !== nextProps.pageIndexChangedInternal;
    if (isComponentUpdated) {
      this.__getterCache.prevButtonProps = void 0;
      this.__getterCache.nextButtonProps = void 0;
    }
  }
  getPrevButtonLabel() {
    return getLocalizationMessage(this.context, "dxPagination-prevPage");
  }
  getNextButtonLabel() {
    return getLocalizationMessage(this.context, "dxPagination-nextPage");
  }
  render() {
    const {
      className,
      tabIndex,
      navigate
    } = this.getPrevButtonProps();
    const {
      isLargeDisplayMode,
      maxPagesCount,
      pageCount,
      pageIndex,
      pagesCountText
    } = this.props;
    return createFragment([this.getRenderPrevButton() && createComponentVNode(2, LightButton, {
      label: this.getPrevButtonLabel(),
      className,
      tabIndex,
      onClick: navigate
    }), isLargeDisplayMode && createComponentVNode(2, PagesLarge, {
      maxPagesCount,
      pageCount,
      pageIndex,
      pageIndexChangedInternal: this.pageIndexChangedInternal
    }), !isLargeDisplayMode && createComponentVNode(2, PagesSmall, {
      pageCount,
      pageIndex,
      pageIndexChangedInternal: this.pageIndexChangedInternal,
      pagesCountText
    }), this.getRenderNextButton() && createComponentVNode(2, LightButton, {
      label: this.getNextButtonLabel(),
      className: this.getNextButtonProps().className,
      tabIndex: this.getNextButtonProps().tabIndex,
      onClick: this.getNextButtonProps().navigate
    })], 0);
  }
};
PageIndexSelector.defaultProps = PageIndexSelectorDefaultProps;

// node_modules/devextreme/esm/__internal/pagination/content.js
var PaginationContentDefaultProps = _extends({}, PaginationDefaultProps, {
  infoTextVisible: true,
  isLargeDisplayMode: true
});
var PaginationContent = class extends InfernoComponent {
  constructor(props) {
    super(props);
    this.state = {};
    this.refs = null;
    this.widgetElementRef = createRef();
    this.widgetRootElementRef = createRef();
    this.pagesRef = createRef();
    this.infoTextRef = createRef();
    this.__getterCache = {
      keyboardAction: void 0
    };
    this.state = {};
    this.__getterCache = {};
    this.setRootElementRef = this.setRootElementRef.bind(this);
    this.createFakeInstance = this.createFakeInstance.bind(this);
  }
  createEffects() {
    return [new InfernoEffect(this.setRootElementRef, [])];
  }
  getChildContext() {
    return _extends({}, this.context, {
      [KeyboardActionContext.id]: this.getKeyboardAction() || KeyboardActionContext.defaultValue
    });
  }
  setRootElementRef() {
    const {
      rootElementRef
    } = this.props;
    if (rootElementRef && this.widgetRootElementRef) {
      rootElementRef.current = this.widgetRootElementRef.current;
    }
  }
  getWidgetRootElement() {
    var _this$widgetRootEleme;
    return null === (_this$widgetRootEleme = this.widgetRootElementRef) || void 0 === _this$widgetRootEleme ? void 0 : _this$widgetRootEleme.current;
  }
  createFakeInstance() {
    return {
      option: () => false,
      element: () => this.getWidgetRootElement(),
      component: this.props._getParentComponentRootNode ? {
        element: () => {
          var _this$props$_getParen, _this$props;
          return null === (_this$props$_getParen = (_this$props = this.props)._getParentComponentRootNode) || void 0 === _this$props$_getParen ? void 0 : _this$props$_getParen.call(_this$props);
        }
      } : {
        element: () => this.getWidgetRootElement()
      },
      _createActionByOption: () => (e) => {
        var _this$props$onKeyDown, _this$props2;
        null === (_this$props$onKeyDown = (_this$props2 = this.props).onKeyDown) || void 0 === _this$props$onKeyDown || _this$props$onKeyDown.call(_this$props2, e);
      }
    };
  }
  getKeyboardAction() {
    return {
      registerKeyboardAction: (element, action) => {
        const fakePaginationInstance = this.createFakeInstance();
        return registerKeyboardAction("pager", fakePaginationInstance, element, void 0, action);
      }
    };
  }
  getInfoVisible() {
    const {
      infoTextVisible,
      showInfo
    } = this.props;
    return !!showInfo && infoTextVisible;
  }
  getPageIndexSelectorVisible() {
    return 0 !== this.props.pageSize;
  }
  getNormalizedDisplayMode() {
    const {
      displayMode,
      lightModeEnabled
    } = this.props;
    if ("adaptive" === displayMode && void 0 !== lightModeEnabled) {
      return lightModeEnabled ? "compact" : "full";
    }
    return displayMode ?? "adaptive";
  }
  getPagesContainerVisible() {
    return !!this.props.pagesNavigatorVisible && this.props.pageCount > 0;
  }
  getPagesContainerVisibility() {
    const {
      pagesNavigatorVisible,
      pageCount,
      hasKnownLastPage,
      showInfo,
      showNavigationButtons,
      showPageSizeSelector
    } = this.props;
    const shouldHideBasedOnPageCount = "auto" === pagesNavigatorVisible && 1 === pageCount && hasKnownLastPage;
    const hasExplicitVisibleComponents = Boolean(showInfo) || Boolean(showNavigationButtons) || true === showPageSizeSelector;
    const shouldHide = shouldHideBasedOnPageCount && !hasExplicitVisibleComponents;
    const result = shouldHide ? "hidden" : void 0;
    return result;
  }
  getIsLargeDisplayMode() {
    const displayMode = this.getNormalizedDisplayMode();
    let result = false;
    if ("adaptive" === displayMode) {
      result = this.props.isLargeDisplayMode;
    } else {
      result = "full" === displayMode;
    }
    return result;
  }
  getClasses() {
    const classesMap = {
      [`${this.props.className}`]: !!this.props.className,
      [PAGER_CLASS]: !!this.props.isGridCompatibilityMode,
      [PAGINATION_CLASS]: !this.props.isGridCompatibilityMode,
      [LIGHT_MODE_CLASS]: !this.getIsLargeDisplayMode()
    };
    return combineClasses(classesMap);
  }
  getAria() {
    return {
      role: "navigation",
      label: this.props.label ?? ""
    };
  }
  componentWillUpdate(nextProps) {
    super.componentWillUpdate();
    if (this.props.onKeyDown !== nextProps.onKeyDown) {
      this.__getterCache.keyboardAction = void 0;
    }
  }
  render() {
    const {
      isGridCompatibilityMode: isGridCompatibilityMode2,
      rtlEnabled,
      visible,
      showPageSizeSelector,
      allowedPageSizesRef,
      pageSize,
      pageSizeChangedInternal,
      allowedPageSizes,
      infoTextRef,
      infoText,
      pageCount,
      pageIndex,
      itemCount,
      pagesRef,
      hasKnownLastPage,
      maxPagesCount,
      pageIndexChangedInternal,
      pagesCountText,
      showNavigationButtons,
      style,
      width,
      height,
      elementAttr,
      hint,
      disabled,
      tabIndex,
      accessKey,
      activeStateEnabled,
      focusStateEnabled,
      hoverStateEnabled
    } = this.props;
    const content = normalizeProps(createComponentVNode(2, Widget, _extends({
      rootElementRef: this.widgetRootElementRef,
      rtlEnabled,
      classes: this.getClasses(),
      visible,
      aria: this.getAria(),
      style,
      width,
      height,
      hint,
      disabled,
      tabIndex,
      accessKey,
      activeStateEnabled,
      focusStateEnabled,
      hoverStateEnabled
    }, elementAttr, {
      children: [showPageSizeSelector && createComponentVNode(2, PageSizeSelector, {
        rootElementRef: allowedPageSizesRef,
        isLargeDisplayMode: this.getIsLargeDisplayMode(),
        itemCount,
        pageSize,
        pageSizeChangedInternal,
        allowedPageSizes
      }), this.getPagesContainerVisible() && createVNode(1, "div", PAGINATION_PAGES_CLASS, [this.getInfoVisible() && createComponentVNode(2, InfoText, {
        rootElementRef: infoTextRef,
        infoText,
        pageCount,
        pageIndex,
        itemCount
      }), this.getPageIndexSelectorVisible() && createVNode(1, "div", PAGINATION_PAGE_INDEXES_CLASS, createComponentVNode(2, PageIndexSelector, {
        hasKnownLastPage,
        isLargeDisplayMode: this.getIsLargeDisplayMode(),
        maxPagesCount,
        pageCount,
        pageIndex,
        pageIndexChangedInternal,
        pagesCountText,
        showNavigationButtons,
        itemCount
      }), 2, null, null, pagesRef)], 0, {
        style: {
          visibility: this.getPagesContainerVisibility()
        }
      })]
    })));
    return createComponentVNode(2, PaginationConfigProvider, {
      isGridCompatibilityMode: isGridCompatibilityMode2,
      children: content
    });
  }
};
PaginationContent.defaultProps = PaginationContentDefaultProps;

// node_modules/devextreme/esm/__internal/pagination/resizable_container.js
function calculateLargeDisplayMode(_ref) {
  let {
    parent: parentWidth,
    allowedPageSizes: pageSizesWidth,
    pages: pagesWidth
  } = _ref;
  return parentWidth - (pageSizesWidth + pagesWidth) > 0;
}
function calculateInfoTextVisible(_ref2) {
  let {
    parent: parentWidth,
    allowedPageSizes: pageSizesWidth,
    pages: pagesWidth,
    info: infoWidth
  } = _ref2;
  const minimalWidth = pageSizesWidth + pagesWidth + infoWidth;
  return parentWidth - minimalWidth > 0;
}
function getElementsWidth(_ref3) {
  let {
    parent,
    allowedPageSizes,
    pages,
    info
  } = _ref3;
  const parentWidth = getElementContentWidth(parent);
  const pageSizesWidth = getElementWidth(allowedPageSizes);
  const infoWidth = getElementWidth(info);
  const pagesHtmlWidth = getElementWidth(pages);
  return {
    parent: parentWidth,
    allowedPageSizes: pageSizesWidth,
    info: infoWidth + getElementStyle("marginLeft", info) + getElementStyle("marginRight", info),
    pages: pagesHtmlWidth
  };
}
var ResizableContainerDefaultProps = {
  paginationProps: _extends({}, PaginationDefaultProps)
};
var ResizableContainer = class extends InfernoComponent {
  constructor(props) {
    super(props);
    this.state = {
      infoTextVisible: true,
      isLargeDisplayMode: true
    };
    this.refs = null;
    this.parentRef = createRef();
    this.infoTextRef = createRef();
    this.pagesRef = createRef();
    this.allowedPageSizesRef = createRef();
    this.elementsWidth = {};
    this.actualIsLargeDisplayMode = true;
    this.actualInfoTextVisible = true;
    this.subscribeToResize = this.subscribeToResize.bind(this);
    this.effectUpdateChildProps = this.effectUpdateChildProps.bind(this);
    this.updateAdaptivityProps = this.updateAdaptivityProps.bind(this);
  }
  componentWillUpdate(nextProps, nextState, context) {
    super.componentWillUpdate(nextProps, nextState, context);
  }
  createEffects() {
    return [new InfernoEffect(this.subscribeToResize, [this.state.infoTextVisible, this.state.isLargeDisplayMode]), new InfernoEffect(this.effectUpdateChildProps, [this.props, this.state.infoTextVisible, this.state.isLargeDisplayMode, this.props.paginationProps, this.props.contentTemplate])];
  }
  updateEffects() {
    var _this$_effects$, _this$_effects$2;
    null === (_this$_effects$ = this._effects[0]) || void 0 === _this$_effects$ || _this$_effects$.update([this.state.infoTextVisible, this.state.isLargeDisplayMode]);
    null === (_this$_effects$2 = this._effects[1]) || void 0 === _this$_effects$2 || _this$_effects$2.update([this.props, this.state.infoTextVisible, this.state.isLargeDisplayMode, this.props.paginationProps, this.props.contentTemplate]);
  }
  subscribeToResize() {
    const callback = () => {
      if (this.getParentWidth() > 0) {
        this.updateAdaptivityProps();
      }
    };
    resize_callbacks_default.add(callback);
    return () => {
      resize_callbacks_default.remove(callback);
    };
  }
  effectUpdateChildProps() {
    if (this.getParentWidth() > 0) {
      this.updateAdaptivityProps();
    }
  }
  getContentAttributes() {
    const {
      className,
      displayMode,
      isGridCompatibilityMode: isGridCompatibilityMode2,
      _getParentComponentRootNode,
      hasKnownLastPage,
      infoText,
      label,
      lightModeEnabled,
      maxPagesCount,
      onKeyDown,
      pageCount,
      pageIndex,
      pageIndexChangedInternal,
      pageSize,
      pageSizeChangedInternal,
      allowedPageSizes,
      pagesCountText,
      pagesNavigatorVisible,
      rtlEnabled,
      showInfo,
      showNavigationButtons,
      showPageSizeSelector,
      itemCount,
      visible,
      style,
      width,
      height,
      elementAttr,
      hint,
      disabled,
      tabIndex,
      accessKey,
      activeStateEnabled,
      focusStateEnabled,
      hoverStateEnabled
    } = this.props.paginationProps;
    return {
      pageSize,
      pageIndex,
      pageIndexChangedInternal,
      pageSizeChangedInternal,
      isGridCompatibilityMode: isGridCompatibilityMode2,
      _getParentComponentRootNode,
      className,
      showInfo,
      infoText,
      lightModeEnabled,
      displayMode,
      maxPagesCount,
      pageCount,
      pagesCountText,
      visible,
      hasKnownLastPage,
      pagesNavigatorVisible,
      showPageSizeSelector,
      allowedPageSizes,
      rtlEnabled,
      showNavigationButtons,
      itemCount,
      onKeyDown,
      label,
      style,
      width,
      height,
      elementAttr,
      hint,
      disabled,
      tabIndex,
      accessKey,
      activeStateEnabled,
      focusStateEnabled,
      hoverStateEnabled
    };
  }
  getParentWidth() {
    var _this$parentRef;
    return null !== (_this$parentRef = this.parentRef) && void 0 !== _this$parentRef && _this$parentRef.current ? getElementWidth(this.parentRef.current) : 0;
  }
  updateAdaptivityProps() {
    var _this$parentRef2, _this$allowedPageSize, _this$infoTextRef, _this$pagesRef;
    const currentElementsWidth = getElementsWidth({
      parent: null === (_this$parentRef2 = this.parentRef) || void 0 === _this$parentRef2 ? void 0 : _this$parentRef2.current,
      allowedPageSizes: null === (_this$allowedPageSize = this.allowedPageSizesRef) || void 0 === _this$allowedPageSize ? void 0 : _this$allowedPageSize.current,
      info: null === (_this$infoTextRef = this.infoTextRef) || void 0 === _this$infoTextRef ? void 0 : _this$infoTextRef.current,
      pages: null === (_this$pagesRef = this.pagesRef) || void 0 === _this$pagesRef ? void 0 : _this$pagesRef.current
    });
    if (this.actualInfoTextVisible !== this.state.infoTextVisible || this.actualIsLargeDisplayMode !== this.state.isLargeDisplayMode) {
      return;
    }
    const isEmpty3 = !isDefined(this.elementsWidth);
    if (isEmpty3) {
      this.elementsWidth = {};
    }
    if (isEmpty3 || this.state.isLargeDisplayMode) {
      this.elementsWidth.allowedPageSizes = currentElementsWidth.allowedPageSizes;
      this.elementsWidth.pages = currentElementsWidth.pages;
    }
    if (isEmpty3 || this.state.infoTextVisible) {
      this.elementsWidth.info = currentElementsWidth.info;
    }
    this.actualIsLargeDisplayMode = calculateLargeDisplayMode({
      parent: currentElementsWidth.parent,
      allowedPageSizes: this.elementsWidth.allowedPageSizes,
      pages: this.elementsWidth.pages
    });
    this.actualInfoTextVisible = calculateInfoTextVisible(_extends({}, currentElementsWidth, {
      info: this.elementsWidth.info
    }));
    this.setState((() => ({
      infoTextVisible: this.actualInfoTextVisible
    })));
    this.setState((() => ({
      isLargeDisplayMode: this.actualIsLargeDisplayMode
    })));
  }
  render() {
    const {
      infoTextVisible,
      isLargeDisplayMode
    } = this.state;
    const {
      props: {
        contentTemplate: Content
      }
    } = this;
    return normalizeProps(createComponentVNode(2, Content, _extends({
      rootElementRef: this.parentRef,
      allowedPageSizesRef: this.allowedPageSizesRef,
      infoTextRef: this.infoTextRef,
      pagesRef: this.pagesRef,
      infoTextVisible,
      isLargeDisplayMode
    }, this.getContentAttributes())));
  }
};
ResizableContainer.defaultProps = ResizableContainerDefaultProps;

// node_modules/devextreme/esm/__internal/pagination/pagination.js
var Pagination = class extends InfernoWrapperComponent {
  constructor(props) {
    super(props);
    this.__getterCache = {};
    this.pageIndexChangedInternal = this.pageIndexChangedInternal.bind(this);
    this.pageSizeChangedInternal = this.pageSizeChangedInternal.bind(this);
  }
  createEffects() {
    return [createReRenderEffect()];
  }
  pageIndexChangedInternal(newPageIndex) {
    const newValue = newPageIndex + 1;
    this.setState((() => ({
      pageIndex: newValue
    })));
    this.props.pageIndexChangedInternal(newValue);
  }
  getPageIndex() {
    return this.props.pageIndex - 1;
  }
  pageSizeChangedInternal(newPageSize) {
    this.setState((() => ({
      pageSize: newPageSize
    })));
    this.props.pageSizeChangedInternal(newPageSize);
  }
  getClassName() {
    return combineClasses({
      "dx-datagrid-pager": isGridCompatibilityMode(this.context),
      [`${this.props.className}`]: !!this.props.className
    });
  }
  getPaginationProps() {
    return _extends({}, this.props, {
      className: this.getClassName(),
      pageIndex: this.getPageIndex(),
      pageIndexChangedInternal: (pageIndex) => this.pageIndexChangedInternal(pageIndex),
      pageSizeChangedInternal: (pageSize) => this.pageSizeChangedInternal(pageSize)
    });
  }
  render() {
    return createComponentVNode(2, ResizableContainer, {
      contentTemplate: PaginationContent,
      paginationProps: this.getPaginationProps()
    });
  }
};
Pagination.defaultProps = PaginationDefaultProps;

// node_modules/devextreme/esm/__internal/pagination/utils/validation_utils.js
function getPageSize(pageSize) {
  if (pageSize < 0) {
    return 1;
  }
  return pageSize;
}
function getItemCount(itemCount) {
  if (itemCount < 0) {
    return 0;
  }
  return itemCount;
}
function getPageCount(pageSize, itemCount) {
  if (pageSize > 0 && itemCount > 0) {
    return Math.max(1, Math.ceil(itemCount / pageSize));
  }
  return 1;
}
function getPageIndex(pageIndex, pageSize, itemCount) {
  if (pageIndex < 1) {
    return 1;
  }
  const pageCount = getPageCount(pageSize, itemCount);
  return Math.min(pageIndex, pageCount);
}
function validateOptions(oldPageSize, oldPageIndex, oldItemCount) {
  const pageSize = getPageSize(oldPageSize);
  const itemCount = getItemCount(oldItemCount);
  const pageCount = getPageCount(pageSize, oldItemCount);
  const pageIndex = getPageIndex(oldPageIndex, pageSize, itemCount);
  return {
    pageSize,
    pageIndex,
    itemCount,
    pageCount
  };
}

// node_modules/devextreme/esm/__internal/pagination/wrappers/pagination_wrapper.js
var _excluded2 = ["pageSize", "pageIndex", "itemCount"];
var PaginationWrapper = class extends ComponentWrapper {
  _optionChanged(args) {
    switch (args.name) {
      case "pageIndex": {
        const pageIndexChanged = this.option("pageIndexChanged");
        if (pageIndexChanged) {
          pageIndexChanged(args.value);
        }
        break;
      }
      case "pageSize": {
        const pageSizeChanged = this.option("pageSizeChanged");
        if (pageSizeChanged) {
          pageSizeChanged(args.value);
        }
        break;
      }
    }
    super._optionChanged(args);
  }
  getPageCount() {
    return this.option("pageCount");
  }
  _validateOptions(options) {
    if (options._skipValidation || this.option("_skipValidation")) {
      return options;
    }
    const initialOptions = super._validateOptions(options);
    let {
      pageSize,
      pageIndex,
      itemCount
    } = initialOptions, rest = _objectWithoutPropertiesLoose(initialOptions, _excluded2);
    if (void 0 === pageSize) {
      pageSize = this.option("pageSize");
    }
    if (void 0 === pageIndex) {
      pageIndex = this.option("pageIndex");
    }
    if (void 0 === itemCount) {
      itemCount = this.option("itemCount");
    }
    const validatedOptions = validateOptions(pageSize, pageIndex, itemCount);
    return _extends({}, rest, validatedOptions);
  }
};

// node_modules/devextreme/esm/__internal/pagination/wrappers/pagination.js
var Pagination2 = class extends PaginationWrapper {
  getProps() {
    const props = super.getProps();
    props.onKeyDown = this._wrapKeyDownHandler(props.onKeyDown);
    return props;
  }
  get _propsInfo() {
    return {
      twoWay: [
        ["pageSize", "defaultPageSize", "pageSizeChangedInternal", "pageSizeChanged"],
        ["pageIndex", "defaultPageIndex", "pageIndexChangedInternal", "pageIndexChanged"]
      ],
      allowNull: [],
      elements: [],
      templates: [],
      props: ["defaultPageSize", "pageSizeChanged", "pageSizeChangedInternal", "defaultPageIndex", "pageIndexChanged", "pageIndexChangedInternal", "isGridCompatibilityMode", "className", "showInfo", "infoText", "lightModeEnabled", "displayMode", "maxPagesCount", "pageCount", "pagesCountText", "visible", "hasKnownLastPage", "pagesNavigatorVisible", "showPageSizeSelector", "allowedPageSizes", "rtlEnabled", "showNavigationButtons", "itemCount", "label", "onKeyDown", "pageSize", "pageIndex", "width", "height", "elementAttr", "hint", "disabled", "tabIndex", "accessKey", "activeStateEnabled", "focusStateEnabled", "hoverStateEnabled", "_skipValidation", "_getParentComponentRootNode"]
    };
  }
  get _viewComponent() {
    return Pagination;
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/pager/m_pager.js
var MAX_PAGES_COUNT = 10;
var getPageIndex2 = function(dataController2) {
  return 1 + (parseInt(dataController2.pageIndex()) || 0);
};
var PagerView = class extends m_modules_default.View {
  init() {
    const dataController2 = this.getController("data");
    dataController2.changed.add(((e) => {
      if (e && e.repaintChangesOnly) {
        const pager = this._pager;
        if (pager) {
          pager.option({
            pageIndex: getPageIndex2(dataController2),
            pageSize: dataController2.pageSize(),
            pageCount: dataController2.pageCount(),
            itemCount: dataController2.totalCount(),
            hasKnownLastPage: dataController2.hasKnownLastPage()
          });
        } else {
          this.render();
        }
      } else if (!e || "update" !== e.changeType && "updateSelection" !== e.changeType && "updateFocusedRow" !== e.changeType) {
        this._pager = null;
        this.render();
      }
    }));
  }
  dispose() {
    this._pager = null;
  }
  optionChanged(args) {
    const {
      name
    } = args;
    const isPager = "pager" === name;
    const isPaging = "paging" === name;
    const isDataSource = "dataSource" === name;
    const isScrolling = "scrolling" === name;
    const dataController2 = this.getController("data");
    if (isPager || isPaging || isScrolling || isDataSource) {
      args.handled = true;
      if (dataController2.skipProcessingPagingChange(args.fullName)) {
        return;
      }
      if (isPager || isPaging) {
        this._pageSizes = null;
      }
      if (!isDataSource) {
        this._pager = null;
        this._invalidate();
        if (hasWindow() && isPager && this.component) {
          this.component.resize();
        }
      }
    }
  }
  _renderCore() {
    const that = this;
    const $element = that.element().addClass(that.addWidgetPrefix("pager"));
    const pagerOptions = that.option("pager") ?? {};
    const dataController2 = that.getController("data");
    const keyboardController = that.getController("keyboardNavigation");
    const options = {
      maxPagesCount: 10,
      pageIndex: getPageIndex2(dataController2),
      pageCount: dataController2.pageCount(),
      pageSize: dataController2.pageSize(),
      showPageSizeSelector: pagerOptions.showPageSizeSelector,
      showInfo: pagerOptions.showInfo,
      displayMode: pagerOptions.displayMode,
      pagesNavigatorVisible: pagerOptions.visible,
      showNavigationButtons: pagerOptions.showNavigationButtons,
      label: pagerOptions.label,
      allowedPageSizes: that.getPageSizes(),
      itemCount: dataController2.totalCount(),
      hasKnownLastPage: dataController2.hasKnownLastPage(),
      rtlEnabled: that.option("rtlEnabled"),
      isGridCompatibilityMode: true,
      _getParentComponentRootNode: () => this.component.element(),
      _skipValidation: true,
      pageIndexChanged(pageIndex) {
        if (dataController2.pageIndex() !== pageIndex - 1) {
          dataController2.pageIndex(pageIndex - 1);
        }
      },
      pageSizeChanged(pageSize) {
        dataController2.pageSize(pageSize);
      },
      onKeyDown: (e) => keyboardController && keyboardController.executeAction("onKeyDown", e)
    };
    if (isDefined(pagerOptions.infoText)) {
      options.infoText = pagerOptions.infoText;
    }
    if (this._pager) {
      this._pager.repaint();
      return;
    }
    if (hasWindow()) {
      this._pager = that._createComponent($element, Pagination2, options);
    } else {
      $element.addClass("dx-pager").html('<div class="dx-pages"><div class="dx-page"></div></div>');
    }
  }
  getPager() {
    return this._pager;
  }
  getPageSizes() {
    const that = this;
    const dataController2 = that.getController("data");
    const pagerOptions = that.option("pager");
    const allowedPageSizes = pagerOptions && pagerOptions.allowedPageSizes;
    const pageSize = dataController2.pageSize();
    if (!isDefined(that._pageSizes) || !that._pageSizes.includes(pageSize)) {
      that._pageSizes = [];
      if (pagerOptions) {
        if (Array.isArray(allowedPageSizes)) {
          that._pageSizes = allowedPageSizes;
        } else if (allowedPageSizes && pageSize > 1) {
          that._pageSizes = [Math.floor(pageSize / 2), pageSize, 2 * pageSize];
        }
      }
    }
    return that._pageSizes;
  }
  isVisible() {
    const dataController2 = this.getController("data");
    const pagerOptions = this.option("pager");
    let pagerVisible = pagerOptions && pagerOptions.visible;
    const scrolling = this.option("scrolling");
    if ("auto" === pagerVisible) {
      if (scrolling && ("virtual" === scrolling.mode || "infinite" === scrolling.mode)) {
        pagerVisible = false;
      } else {
        pagerVisible = dataController2.pageCount() > 1 || dataController2.isLoaded() && !dataController2.hasKnownLastPage();
      }
    }
    return !!pagerVisible;
  }
  getHeight() {
    return this.getElementHeight();
  }
};
var pagerModule = {
  defaultOptions: () => ({
    pager: {
      visible: "auto",
      showPageSizeSelector: false,
      allowedPageSizes: "auto",
      label: message_default.format("dxPager-ariaLabel")
    }
  }),
  views: {
    pagerView: PagerView
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/pager.js
m_core_default.registerModule("pager", pagerModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/columns_resizing_reordering/m_columns_resizing_reordering.js
var COLUMNS_SEPARATOR_TRANSPARENT = "columns-separator-transparent";
var MODULE_NAMESPACE2 = "dxDataGridResizingReordering";
var allowResizing = function(that) {
  return that.option("allowColumnResizing") || that.getController("columns").isColumnOptionUsed("allowResizing");
};
var allowReordering = function(that) {
  return that.option("allowColumnReordering") || that.getController("columns").isColumnOptionUsed("allowReordering");
};
var TrackerView = class extends m_modules_default.View {
  init() {
    super.init();
    this._tablePositionController = this.getController("tablePosition");
    this._subscribeToCallback();
  }
  dispose() {
    this._unsubscribeFromCallback();
    super.dispose();
  }
  optionChanged(args) {
    if ("allowColumnResizing" === args.name) {
      this._unsubscribeFromCallback();
      if (args.value) {
        this._subscribeToCallback();
        this._invalidate();
      }
    }
    super.optionChanged(args);
  }
  _renderCore() {
    const deferred = super._renderCore();
    this.element().addClass(this.addWidgetPrefix("tracker"));
    this.hide();
    return deferred;
  }
  _unsubscribeFromCallback() {
    if (this._positionChanged) {
      this._tablePositionController.positionChanged.remove(this._positionChanged);
    }
  }
  _subscribeToCallback() {
    const that = this;
    that._positionChanged = function(position) {
      const $element = that.element();
      if (null !== $element && void 0 !== $element && $element.hasClass(that.addWidgetPrefix("tracker"))) {
        $element.css({
          top: position.top
        });
        setHeight($element, position.height);
      }
    };
    this._tablePositionController.positionChanged.add(that._positionChanged);
  }
  isVisible() {
    return allowResizing(this);
  }
  show() {
    this.element().show();
  }
  hide() {
    var _this$element;
    null === (_this$element = this.element()) || void 0 === _this$element || _this$element.hide();
  }
  setHeight(value2) {
    setHeight(this.element(), value2);
  }
};
var SeparatorView = class extends m_modules_default.View {
  _renderSeparator() {
  }
  _renderCore(options) {
    const deferred = super._renderCore(options);
    this._isShown = true;
    this._renderSeparator();
    this.hide();
    return deferred;
  }
  show() {
    this._isShown = true;
  }
  hide() {
    this._isShown = false;
  }
  height(value2) {
    const $element = this.element();
    if ($element) {
      if (isDefined(value2)) {
        setHeight($element, value2);
      } else {
        return getHeight($element);
      }
    }
  }
  width(value2) {
    const $element = this.element();
    if ($element) {
      if (isDefined(value2)) {
        setWidth($element, value2);
      } else {
        return getWidth($element);
      }
    }
  }
};
var ColumnsSeparatorView = class extends SeparatorView {
  init() {
    super.init();
    this._tablePositionController = this.getController("tablePosition");
    this._init();
  }
  dispose() {
    this._unsubscribeFromCallback();
    super.dispose();
  }
  optionChanged(args) {
    if ("allowColumnResizing" === args.name) {
      if (args.value) {
        this._init();
        this._invalidate();
        this.hide(true);
      } else {
        this._unsubscribeFromCallback();
        this._isTransparent = allowResizing(this);
        this.hide(true);
      }
    }
    super.optionChanged(args);
  }
  _renderSeparator() {
    super._renderSeparator();
    const $element = this.element();
    $element.addClass(this.addWidgetPrefix("columns-separator"));
  }
  _subscribeToCallback() {
    const that = this;
    let $element;
    that._positionChanged = function(position) {
      $element = that.element();
      if ($element) {
        $element.css({
          top: position.top
        });
        setHeight($element, position.height);
      }
    };
    that._tablePositionController.positionChanged.add(that._positionChanged);
  }
  _unsubscribeFromCallback() {
    this._positionChanged && this._tablePositionController.positionChanged.remove(this._positionChanged);
  }
  _init() {
    this._isTransparent = allowResizing(this);
    if (this.isVisible()) {
      this._subscribeToCallback();
    }
  }
  isVisible() {
    return this.option("showColumnHeaders") && (allowReordering(this) || allowResizing(this));
  }
  show() {
    const that = this;
    const $element = this.element();
    if ($element && !that._isShown) {
      if (that._isTransparent) {
        $element.removeClass(that.addWidgetPrefix(COLUMNS_SEPARATOR_TRANSPARENT));
      } else {
        $element.show();
      }
    }
    super.show();
  }
  hide(force) {
    const $element = this.element();
    const columnsSeparatorTransparent = this.addWidgetPrefix(COLUMNS_SEPARATOR_TRANSPARENT);
    if ($element && (this._isShown || force)) {
      if (this._isTransparent) {
        $element.addClass(columnsSeparatorTransparent);
        $element.css("left", "");
        $element.show();
      } else {
        if ($element.hasClass(columnsSeparatorTransparent)) {
          $element.removeClass(columnsSeparatorTransparent);
        }
        $element.hide();
      }
    }
    super.hide();
  }
  moveByX(outerX) {
    const $element = this.element();
    if ($element) {
      $element.css("left", null === outerX ? 0 : outerX - this._parentElement().offset().left);
    }
  }
  changeCursor(cursorName) {
    cursorName = isDefined(cursorName) ? cursorName : "";
    const $element = this.element();
    if ($element) {
      $element.css("cursor", cursorName);
    }
  }
};
var BlockSeparatorView = class extends SeparatorView {
  init() {
    super.init();
    const dataController2 = this.getController("data");
    dataController2.loadingChanged.add(((isLoading) => {
      if (!isLoading) {
        this.hide();
      }
    }));
  }
  _renderSeparator() {
    super._renderSeparator();
    this.element().addClass("dx-block-separator").html("&nbsp;");
  }
  hide() {
    const that = this;
    const $parent = this._parentElement();
    const $element = this.element();
    if ($element && this._isShown) {
      $element.css("display", "none");
    }
    if ($parent && !$parent.children(".dx-block-separator").length) {
      $parent.prepend(that.element());
    }
    super.hide();
  }
  isVisible() {
    const groupPanelOptions = this.option("groupPanel");
    const columnChooserOptions = this.option("columnChooser");
    return (null === groupPanelOptions || void 0 === groupPanelOptions ? void 0 : groupPanelOptions.visible) || (null === columnChooserOptions || void 0 === columnChooserOptions ? void 0 : columnChooserOptions.enabled);
  }
  show(targetLocation) {
    const $element = this.element();
    if ($element && !this._isShown) {
      switch (targetLocation) {
        case "group":
          this.element().css("display", "block");
          break;
        case "columnChooser":
          !(function(toOptions) {
            fx_default.stop($element, true);
            fx_default.animate($element, {
              type: "slide",
              from: {
                width: 0,
                display: toOptions.display
              },
              to: toOptions,
              duration: 300,
              easing: "swing"
            });
          })({
            width: "100%",
            display: "block"
          });
          break;
        default:
          $element.css("display", "");
      }
    }
    super.show();
  }
};
var DraggingHeaderView = class extends m_modules_default.View {
  init() {
    super.init();
    const dataController2 = this.getController("data");
    this._controller = this.getController("draggingHeader");
    this._columnsResizerViewController = this.getController("columnsResizer");
    this._columnsController = this.getController("columns");
    this._isDragging = false;
    dataController2.loadingChanged.add(((isLoading) => {
      const element = this.element();
      if (!isLoading && element) {
        element.hide();
      }
    }));
  }
  isDragging() {
    return this._isDragging;
  }
  _getDraggingPanelByPos(pos) {
    let result;
    each(this._dragOptions.draggingPanels, ((index, draggingPanel) => {
      if (draggingPanel) {
        const boundingRect = draggingPanel.getBoundingRect();
        if (boundingRect && (void 0 === boundingRect.bottom || pos.y < boundingRect.bottom) && (void 0 === boundingRect.top || pos.y > boundingRect.top) && (void 0 === boundingRect.left || pos.x > boundingRect.left) && (void 0 === boundingRect.right || pos.x < boundingRect.right)) {
          result = draggingPanel;
          return false;
        }
      }
      return;
    }));
    return result;
  }
  _renderCore() {
    this.element().addClass(`${this.addWidgetPrefix("drag-header")} ${this.addWidgetPrefix("text-content")} dx-widget`).hide();
  }
  _resetTargetColumnOptions() {
    const params = this._dropOptions;
    params.targetColumnIndex = -1;
    delete params.targetColumnElement;
    delete params.isLast;
    delete params.posX;
    delete params.posY;
  }
  _getVisibleIndexObject(rowIndex, visibleIndex) {
    if (isDefined(rowIndex)) {
      return {
        columnIndex: visibleIndex,
        rowIndex
      };
    }
    return visibleIndex;
  }
  dispose() {
    const element = this.element();
    this._dragOptions = null;
    null === element || void 0 === element || element.parent().find(`.${this.addWidgetPrefix("drag-header")}`).remove();
  }
  isVisible() {
    const commonColumnSettings = this._columnsController.getCommonSettings();
    return this.option("showColumnHeaders") && (allowReordering(this) || commonColumnSettings.allowGrouping || commonColumnSettings.allowHiding);
  }
  dragHeader(options) {
    const {
      columnElement
    } = options;
    const isCommandColumn = !!options.sourceColumn.type;
    this._isDragging = true;
    this._dragOptions = options;
    this._dropOptions = {
      sourceIndex: options.index,
      sourceColumnIndex: this._getVisibleIndexObject(options.rowIndex, options.columnIndex),
      sourceColumnElement: options.columnElement,
      sourceLocation: options.sourceLocation
    };
    const document = dom_adapter_default.getDocument();
    this._onSelectStart = document.onselectstart;
    document.onselectstart = function() {
      return false;
    };
    this._controller.drag(this._dropOptions);
    this.element().css({
      textAlign: null === columnElement || void 0 === columnElement ? void 0 : columnElement.css("textAlign"),
      height: columnElement && (isCommandColumn && columnElement.get(0).clientHeight || getHeight(columnElement)),
      width: columnElement && (isCommandColumn && columnElement.get(0).clientWidth || getWidth(columnElement)),
      whiteSpace: null === columnElement || void 0 === columnElement ? void 0 : columnElement.css("whiteSpace")
    }).addClass(this.addWidgetPrefix("drag-action")).toggleClass("dx-drag-command-cell", isCommandColumn).text(isCommandColumn ? "" : options.sourceColumn.caption);
    this.element().appendTo(swatch_container_default.getSwatchContainer(columnElement));
  }
  moveHeader(args) {
    const e = args.event;
    const {
      that
    } = e.data;
    const eventData2 = eventData(e);
    const isResizing = that._columnsResizerViewController ? that._columnsResizerViewController.isResizing() : false;
    const dragOptions = that._dragOptions;
    if (that._isDragging && !isResizing) {
      const $element = that.element();
      const moveDeltaX = Math.abs(eventData2.x - dragOptions.columnElement.offset().left - dragOptions.deltaX);
      const moveDeltaY = Math.abs(eventData2.y - dragOptions.columnElement.offset().top - dragOptions.deltaY);
      if ($element.is(":visible") || moveDeltaX > 5 || moveDeltaY > 5) {
        $element.show();
        const newLeft = eventData2.x - dragOptions.deltaX;
        const newTop = eventData2.y - dragOptions.deltaY;
        $element.css({
          left: newLeft,
          top: newTop
        });
        that.dockHeader(eventData2);
      }
      e.preventDefault();
    }
  }
  dockHeader(eventData2) {
    const that = this;
    const targetDraggingPanel = that._getDraggingPanelByPos(eventData2);
    const controller = that._controller;
    const params = that._dropOptions;
    const dragOptions = that._dragOptions;
    if (targetDraggingPanel) {
      const rtlEnabled = that.option("rtlEnabled");
      const isVerticalOrientation = "columnChooser" === targetDraggingPanel.getName();
      const axisName = isVerticalOrientation ? "y" : "x";
      const targetLocation = targetDraggingPanel.getName();
      const rowIndex = "headers" === targetLocation ? dragOptions.rowIndex : void 0;
      const {
        sourceColumn
      } = dragOptions;
      const columnElements = targetDraggingPanel.getColumnElements(rowIndex, null === sourceColumn || void 0 === sourceColumn ? void 0 : sourceColumn.ownerBand) || [];
      const pointsByTarget = dragOptions.pointsByTarget = dragOptions.pointsByTarget || {};
      const pointsByColumns = "columnChooser" === targetLocation ? [] : pointsByTarget[targetLocation] || controller._generatePointsByColumns(extend({}, dragOptions, {
        targetDraggingPanel,
        columns: targetDraggingPanel.getColumns(rowIndex),
        columnElements,
        isVerticalOrientation,
        startColumnIndex: "headers" === targetLocation ? renderer_default(columnElements[0]).index() : 0
      }));
      pointsByTarget[targetLocation] = pointsByColumns;
      params.targetLocation = targetLocation;
      if (pointsByColumns.length > 0) {
        for (let i = 0; i < pointsByColumns.length; i++) {
          const centerPosition = pointsByColumns[i + 1] && (pointsByColumns[i][axisName] + pointsByColumns[i + 1][axisName]) / 2;
          if (void 0 === centerPosition || (rtlEnabled && "x" === axisName ? eventData2[axisName] > centerPosition : eventData2[axisName] < centerPosition)) {
            params.targetColumnIndex = that._getVisibleIndexObject(rowIndex, pointsByColumns[i].columnIndex);
            if (columnElements[i]) {
              params.targetColumnElement = columnElements.eq(i);
              params.isLast = false;
            } else {
              params.targetColumnElement = columnElements.last();
              params.isLast = true;
            }
            params.posX = pointsByColumns[i].x;
            params.posY = pointsByColumns[i].y;
            controller.dock(params);
            break;
          }
        }
      } else {
        that._resetTargetColumnOptions();
        controller.dock(params);
      }
    }
  }
  dropHeader(args) {
    const e = args.event;
    const {
      that
    } = e.data;
    const controller = that._controller;
    that.element().hide();
    if (controller && that._isDragging) {
      controller.drop(that._dropOptions);
    }
    that.element().appendTo(that._parentElement());
    that._dragOptions = null;
    that._dropOptions = null;
    that._isDragging = false;
    dom_adapter_default.getDocument().onselectstart = that._onSelectStart || null;
  }
};
var isNextColumnResizingMode = function(that) {
  return "widget" !== that.option("columnResizingMode");
};
var ColumnsResizerViewController = class extends m_modules_default.ViewController {
  init() {
    this._subscribesToCallbacks = [];
    if (allowResizing(this)) {
      this._init();
    }
  }
  dispose() {
    this._unsubscribes();
    super.dispose();
  }
  optionChanged(args) {
    super.optionChanged(args);
    if ("allowColumnResizing" === args.name) {
      if (args.value) {
        this._init();
        this._subscribeToEvents();
      } else {
        this._unsubscribes();
      }
    }
  }
  _isHeadersRowArea(posY) {
    if (this._columnHeadersView) {
      const element = this._columnHeadersView.element();
      if (element) {
        const offsetTop = element.offset().top;
        const headersRowHeight = this._columnHeadersView.getHeadersRowHeight();
        return posY >= offsetTop && posY <= offsetTop + headersRowHeight;
      }
    }
    return false;
  }
  _isRtlParentStyle() {
    var _this$_$parentContain;
    const rtlEnabled = this.option("rtlEnabled");
    return rtlEnabled && "rtl" === (null === (_this$_$parentContain = this._$parentContainer) || void 0 === _this$_$parentContain ? void 0 : _this$_$parentContain.parent().css("direction"));
  }
  _correctColumnIndexForPoint(point, correctionValue, columns7) {
    point.columnIndex -= correctionValue;
  }
  _pointCreated(point, cellsLength, columns7) {
    const isNextColumnMode = isNextColumnResizingMode(this);
    const rtlEnabled = this.option("rtlEnabled");
    const isRtlParentStyle = this._isRtlParentStyle();
    const firstPointColumnIndex = !isNextColumnMode && rtlEnabled && !isRtlParentStyle ? 0 : 1;
    if (point.index >= firstPointColumnIndex && point.index < cellsLength + (!isNextColumnMode && (!rtlEnabled || isRtlParentStyle) ? 1 : 0)) {
      this._correctColumnIndexForPoint(point, firstPointColumnIndex, columns7);
      const currentColumn = columns7[point.columnIndex] || {};
      const nextColumn = columns7[point.columnIndex + 1] || {};
      return !(isNextColumnMode ? currentColumn.allowResizing && nextColumn.allowResizing : currentColumn.allowResizing);
    }
    return true;
  }
  _getTargetPoint(pointsByColumns, currentX, deltaX) {
    if (pointsByColumns) {
      for (let i = 0; i < pointsByColumns.length; i++) {
        if (pointsByColumns[i].x === pointsByColumns[0].x && pointsByColumns[i + 1] && pointsByColumns[i].x === pointsByColumns[i + 1].x) {
          continue;
        }
        if (pointsByColumns[i].x - deltaX <= currentX && currentX <= pointsByColumns[i].x + deltaX) {
          return pointsByColumns[i];
        }
      }
    }
    return null;
  }
  getSeparatorOffsetX($cell) {
    var _$cell$offset;
    const isNextColumnMode = isNextColumnResizingMode(this);
    const rtlEnabled = this.option("rtlEnabled");
    const isRtlParentStyle = this._isRtlParentStyle();
    const outerWidth = $cell[0].getBoundingClientRect().width;
    const cellOffset = (null === (_$cell$offset = $cell.offset()) || void 0 === _$cell$offset ? void 0 : _$cell$offset.left) ?? 0;
    return cellOffset + ((isNextColumnMode || isRtlParentStyle) && rtlEnabled ? 0 : outerWidth);
  }
  _moveSeparator(args) {
    var _that$_draggingHeader;
    const e = args.event;
    const that = e.data;
    const columnsSeparatorWidth = that._columnsSeparatorView.width();
    const isNextColumnMode = isNextColumnResizingMode(that);
    const deltaX = columnsSeparatorWidth / 2;
    const parentOffset = that._$parentContainer.offset();
    const parentOffsetLeft = parentOffset.left;
    const eventData2 = eventData(e);
    const isRtlParentStyle = this._isRtlParentStyle();
    const isDragging = null === (_that$_draggingHeader = that._draggingHeaderView) || void 0 === _that$_draggingHeader ? void 0 : _that$_draggingHeader.isDragging();
    if (that._isResizing && that._resizingInfo) {
      if ((parentOffsetLeft <= eventData2.x || !isNextColumnMode && isRtlParentStyle) && (!isNextColumnMode || eventData2.x <= parentOffsetLeft + getWidth(that._$parentContainer))) {
        if (that._updateColumnsWidthIfNeeded(eventData2.x)) {
          const $cell = that._columnHeadersView.getColumnElements().eq(that._resizingInfo.currentColumnIndex);
          if ($cell.length) {
            const offsetX = this.getSeparatorOffsetX($cell);
            that._columnsSeparatorView.moveByX(offsetX);
            that._tablePositionController.update(that._targetPoint.y);
            e.preventDefault();
          }
        }
      }
    } else if (!isDragging) {
      if (that._isHeadersRowArea(eventData2.y)) {
        if (that._previousParentOffset) {
          if (that._previousParentOffset.left !== parentOffset.left || that._previousParentOffset.top !== parentOffset.top) {
            that.pointsByColumns(null);
          }
        }
        that._targetPoint = that._getTargetPoint(that.pointsByColumns(), eventData2.x, columnsSeparatorWidth);
        that._previousParentOffset = parentOffset;
        that._isReadyResizing = false;
        if (that._targetPoint) {
          that._columnsSeparatorView.changeCursor("col-resize");
          that._columnsSeparatorView.moveByX(that._targetPoint.x - deltaX);
          that._tablePositionController.update(that._targetPoint.y);
          that._isReadyResizing = true;
          e.preventDefault();
        } else {
          that._columnsSeparatorView.changeCursor();
          that._columnsSeparatorView.moveByX(null);
        }
      } else {
        that.pointsByColumns(null);
        that._isReadyResizing = false;
        that._columnsSeparatorView.changeCursor();
        that._columnsSeparatorView.moveByX(null);
      }
    }
  }
  _endResizing(args) {
    const e = args.event;
    const that = e.data;
    if (that._isResizing) {
      that.pointsByColumns(null);
      that._resizingInfo = null;
      that._columnsSeparatorView.hide();
      that._columnsSeparatorView.changeCursor();
      that._trackerView.hide();
      that._isReadyResizing = false;
      that._isResizing = false;
    }
  }
  _getNextColumnIndex(currentColumnIndex) {
    return currentColumnIndex + 1;
  }
  _setupResizingInfo(posX) {
    const currentColumnIndex = this._targetPoint.columnIndex;
    const nextColumnIndex = this._getNextColumnIndex(currentColumnIndex);
    const $currentHeader = this._columnHeadersView.getHeaderElement(currentColumnIndex);
    const $nextHeader = this._columnHeadersView.getHeaderElement(nextColumnIndex);
    this._resizingInfo = {
      startPosX: posX,
      currentColumnIndex,
      currentColumnWidth: null !== $currentHeader && void 0 !== $currentHeader && $currentHeader.length ? getBoundingRect($currentHeader[0]).width : 0,
      nextColumnIndex,
      nextColumnWidth: null !== $nextHeader && void 0 !== $nextHeader && $nextHeader.length ? getBoundingRect($nextHeader[0]).width : 0,
      needToInvertResizing: this._needToInvertResizing($currentHeader)
    };
  }
  _startResizing(args) {
    const e = args.event;
    const that = e.data;
    const eventData2 = eventData(e);
    if (isTouchEvent(e)) {
      if (that._isHeadersRowArea(eventData2.y)) {
        that._targetPoint = that._getTargetPoint(that.pointsByColumns(), eventData2.x, 10);
        if (that._targetPoint) {
          that._columnsSeparatorView.moveByX(that._targetPoint.x - that._columnsSeparatorView.width() / 2);
          that._isReadyResizing = true;
        }
      } else {
        that._isReadyResizing = false;
      }
    }
    if (that._isReadyResizing) {
      that._setupResizingInfo(eventData2.x);
      that._isResizing = true;
      that._tablePositionController.update(that._targetPoint.y);
      that._columnsSeparatorView.show();
      that._trackerView.show();
      const scrollable = that.component.getScrollable();
      if (scrollable && that._isRtlParentStyle()) {
        that._scrollRight = getWidth(scrollable.$content()) - getWidth(scrollable.container()) - scrollable.scrollLeft();
      }
      e.preventDefault();
      e.stopPropagation();
    }
    if (this.isResizing()) {
      this._editorFactoryController.loseFocus();
    }
  }
  _generateColumnsTopYIndex() {
    let needToCheckPrevPoint = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : false;
    const that = this;
    const rowCount = that._columnsController.getRowCount();
    const topYMap = {};
    const pointCreated = (point) => {
      const x = Math.ceil(point.x);
      if (!topYMap[x]) {
        topYMap[x] = point.y;
      }
      return true;
    };
    for (let rowIndex = 0; rowIndex < rowCount - 1; rowIndex++) {
      const cells = that._columnHeadersView.getColumnElements(rowIndex);
      if (cells && cells.length > 0) {
        m_utils_default.getPointsByColumns(cells, pointCreated, false, 0, needToCheckPrevPoint);
      }
    }
    return topYMap;
  }
  _generatePointsByColumns() {
    let needToCheckPrevPoint = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : false;
    const that = this;
    const topYMap = that._generateColumnsTopYIndex(needToCheckPrevPoint);
    const columns7 = that._columnsController ? that._columnsController.getVisibleColumns() : [];
    const cells = that._columnHeadersView.getColumnElements();
    that._pointsByColumns = [];
    if (cells && cells.length > 0) {
      that._pointsByColumns = m_utils_default.getPointsByColumns(cells, ((point) => that._pointCreated(((point2) => {
        const x = Math.ceil(point2.x);
        if (topYMap[x]) {
          point2.y = topYMap[x];
        }
        return point2;
      })(point), cells.length, columns7)), false, 0, needToCheckPrevPoint);
    }
  }
  _needToInvertResizing($cell) {
    const rtlEnabled = this.option("rtlEnabled");
    const isRtlParentStyle = this._isRtlParentStyle();
    const isNextColumnMode = isNextColumnResizingMode(this);
    return (isNextColumnMode || isRtlParentStyle) && rtlEnabled;
  }
  _unsubscribeFromEvents() {
    this._moveSeparatorHandler && m_events_engine_default.off(dom_adapter_default.getDocument(), addNamespace(m_pointer_default.move, MODULE_NAMESPACE2), this._moveSeparatorHandler);
    this._startResizingHandler && m_events_engine_default.off(this._$parentContainer, addNamespace(m_pointer_default.down, MODULE_NAMESPACE2), this._startResizingHandler);
    if (this._endResizingHandler) {
      m_events_engine_default.off(this._columnsSeparatorView.element(), addNamespace(m_pointer_default.up, MODULE_NAMESPACE2), this._endResizingHandler);
      m_events_engine_default.off(dom_adapter_default.getDocument(), addNamespace(m_pointer_default.up, MODULE_NAMESPACE2), this._endResizingHandler);
    }
  }
  _subscribeToEvents() {
    this._moveSeparatorHandler = this.createAction(this._moveSeparator);
    this._startResizingHandler = this.createAction(this._startResizing);
    this._endResizingHandler = this.createAction(this._endResizing);
    m_events_engine_default.on(dom_adapter_default.getDocument(), addNamespace(m_pointer_default.move, MODULE_NAMESPACE2), this, this._moveSeparatorHandler);
    m_events_engine_default.on(this._$parentContainer, addNamespace(m_pointer_default.down, MODULE_NAMESPACE2), this, this._startResizingHandler);
    m_events_engine_default.on(this._columnsSeparatorView.element(), addNamespace(m_pointer_default.up, MODULE_NAMESPACE2), this, this._endResizingHandler);
    m_events_engine_default.on(dom_adapter_default.getDocument(), addNamespace(m_pointer_default.up, MODULE_NAMESPACE2), this, this._endResizingHandler);
  }
  _updateColumnsWidthIfNeeded(posX) {
    let deltaX;
    let needUpdate = false;
    let contentWidth = this._rowsView.contentWidth();
    const resizingInfo = this._resizingInfo;
    const columnsController = this._columnsController;
    const visibleColumns = columnsController.getVisibleColumns();
    const columnsSeparatorWidth = this._columnsSeparatorView.width();
    const isNextColumnMode = isNextColumnResizingMode(this);
    const adaptColumnWidthByRatio = isNextColumnMode && this.option("adaptColumnWidthByRatio") && !this.option("columnAutoWidth");
    const isRtlParentStyle = this._isRtlParentStyle();
    const column = visibleColumns[resizingInfo.currentColumnIndex];
    const nextColumn = visibleColumns[resizingInfo.nextColumnIndex];
    const {
      needToInvertResizing
    } = resizingInfo;
    function isPercentWidth2(width) {
      return isString(width) && width.endsWith("%");
    }
    function setColumnWidth(column2, columnWidth, contentWidth2, adaptColumnWidthByRatio2) {
      if (column2) {
        const oldColumnWidth = column2.width;
        if (oldColumnWidth) {
          adaptColumnWidthByRatio2 = isPercentWidth2(oldColumnWidth);
        }
        if (adaptColumnWidthByRatio2) {
          columnsController.columnOption(column2.index, "visibleWidth", columnWidth);
          columnsController.columnOption(column2.index, "width", `${(columnWidth / contentWidth2 * 100).toFixed(3)}%`);
        } else {
          columnsController.columnOption(column2.index, "visibleWidth", null);
          columnsController.columnOption(column2.index, "width", columnWidth);
        }
      }
    }
    deltaX = posX - resizingInfo.startPosX;
    if (needToInvertResizing) {
      deltaX = -deltaX;
    }
    let {
      cellWidth,
      nextCellWidth
    } = (function(delta) {
      let nextMinWidth;
      let nextCellWidth2;
      let needCorrectionNextCellWidth;
      const cellWidth2 = resizingInfo.currentColumnWidth + delta;
      const minWidth = (null === column || void 0 === column ? void 0 : column.minWidth) || columnsSeparatorWidth;
      const result = {};
      if (cellWidth2 >= minWidth) {
        result.cellWidth = cellWidth2;
      } else {
        result.cellWidth = minWidth;
        needCorrectionNextCellWidth = true;
      }
      if (isNextColumnMode) {
        nextCellWidth2 = resizingInfo.nextColumnWidth - delta;
        nextMinWidth = (null === nextColumn || void 0 === nextColumn ? void 0 : nextColumn.minWidth) || columnsSeparatorWidth;
        if (nextCellWidth2 >= nextMinWidth) {
          if (needCorrectionNextCellWidth) {
            result.nextCellWidth = resizingInfo.nextColumnWidth - (delta + minWidth - cellWidth2);
          } else {
            result.nextCellWidth = nextCellWidth2;
          }
        } else {
          result.nextCellWidth = nextMinWidth;
          result.cellWidth = resizingInfo.currentColumnWidth + (delta - nextMinWidth + nextCellWidth2);
        }
      }
      return result;
    })(deltaX);
    needUpdate = column.width !== cellWidth;
    if (needUpdate) {
      columnsController.beginUpdate();
      cellWidth = Math.floor(cellWidth);
      contentWidth = (function(contentWidth2, visibleColumns2) {
        const allColumnsHaveWidth = visibleColumns2.every(((column2) => column2.width));
        if (allColumnsHaveWidth) {
          const totalPercent = visibleColumns2.reduce(((sum, column2) => {
            if (isPercentWidth2(column2.width)) {
              sum += parseFloat(column2.width);
            }
            return sum;
          }), 0);
          if (totalPercent > 100) {
            contentWidth2 = contentWidth2 / totalPercent * 100;
          }
        }
        return contentWidth2;
      })(contentWidth, visibleColumns);
      setColumnWidth(column, cellWidth, contentWidth, adaptColumnWidthByRatio);
      if (isNextColumnMode) {
        nextCellWidth = Math.floor(nextCellWidth);
        setColumnWidth(nextColumn, nextCellWidth, contentWidth, adaptColumnWidthByRatio);
      } else {
        const columnWidths = this._columnHeadersView.getColumnWidths();
        columnWidths[resizingInfo.currentColumnIndex] = cellWidth;
        const hasScroll = columnWidths.reduce(((totalWidth, width) => totalWidth + width), 0) > this._rowsView.contentWidth();
        if (!hasScroll) {
          const lastColumnIndex = m_utils_default.getLastResizableColumnIndex(visibleColumns);
          if (lastColumnIndex >= 0) {
            columnsController.columnOption(visibleColumns[lastColumnIndex].index, "visibleWidth", "auto");
          }
        }
        for (let i = 0; i < columnWidths.length; i++) {
          if (visibleColumns[i] && visibleColumns[i] !== column && void 0 === visibleColumns[i].width) {
            columnsController.columnOption(visibleColumns[i].index, "width", columnWidths[i]);
          }
        }
      }
      columnsController.endUpdate();
      if (!isNextColumnMode) {
        this.component.updateDimensions();
        const scrollable = this.component.getScrollable();
        if (scrollable && isRtlParentStyle) {
          const left = getWidth(scrollable.$content()) - getWidth(scrollable.container()) - this._scrollRight;
          scrollable.scrollTo({
            left
          });
        }
      }
    }
    return needUpdate;
  }
  _subscribeToCallback(callback, handler) {
    callback.add(handler);
    this._subscribesToCallbacks.push({
      callback,
      handler
    });
  }
  _unsubscribeFromCallbacks() {
    for (let i = 0; i < this._subscribesToCallbacks.length; i++) {
      const subscribe = this._subscribesToCallbacks[i];
      subscribe.callback.remove(subscribe.handler);
    }
    this._subscribesToCallbacks = [];
  }
  _unsubscribes() {
    this._unsubscribeFromEvents();
    this._unsubscribeFromCallbacks();
  }
  _init() {
    const generatePointsByColumnsHandler = () => {
      if (!this._isResizing) {
        this.pointsByColumns(null);
      }
    };
    const generatePointsByColumnsScrollHandler = (offset) => {
      if (this._scrollLeft !== offset.left) {
        this._scrollLeft = offset.left;
        this.pointsByColumns(null);
      }
    };
    this._columnsSeparatorView = this.getView("columnsSeparatorView");
    this._columnHeadersView = this.getView("columnHeadersView");
    this._trackerView = this.getView("trackerView");
    this._rowsView = this.getView("rowsView");
    this._columnsController = this.getController("columns");
    this._tablePositionController = this.getController("tablePosition");
    this._editorFactoryController = this.getController("editorFactory");
    this._draggingHeaderView = this.component.getView("draggingHeaderView");
    this._$parentContainer = this.component.$element();
    this._subscribeToCallback(this._columnHeadersView.renderCompleted, generatePointsByColumnsHandler);
    this._subscribeToCallback(this._columnHeadersView.resizeCompleted, generatePointsByColumnsHandler);
    this._subscribeToCallback(this._columnsSeparatorView.renderCompleted, (() => {
      this._unsubscribeFromEvents();
      this._subscribeToEvents();
    }));
    this._subscribeToCallback(this._rowsView.renderCompleted, (() => {
      this._rowsView.scrollChanged.remove(generatePointsByColumnsScrollHandler);
      this._rowsView.scrollChanged.add(generatePointsByColumnsScrollHandler);
    }));
    let previousScrollbarVisibility = 0 !== this._rowsView.getScrollbarWidth();
    let previousTableHeight = 0;
    this._subscribeToCallback(this._tablePositionController.positionChanged, ((e) => {
      if (this._isResizing && !this._rowsView.isResizing) {
        const scrollbarVisibility = 0 !== this._rowsView.getScrollbarWidth();
        if (previousScrollbarVisibility !== scrollbarVisibility || previousTableHeight && previousTableHeight !== e.height) {
          previousScrollbarVisibility = scrollbarVisibility;
          previousTableHeight = e.height;
          this.component.updateDimensions();
        } else {
          this._rowsView.updateFreeSpaceRowHeight();
        }
      }
      previousTableHeight = e.height;
    }));
  }
  isResizing() {
    return this._isResizing;
  }
  pointsByColumns(value2) {
    if (void 0 !== value2) {
      this._pointsByColumns = value2;
    } else {
      if (!this._pointsByColumns) {
        this._generatePointsByColumns();
      }
      return this._pointsByColumns;
    }
  }
};
var TablePositionViewController = class extends m_modules_default.ViewController {
  constructor(component) {
    super(component);
    this.positionChanged = callbacks_default();
  }
  init() {
    super.init();
    this._columnsResizerController = this.getController("columnsResizer");
    this._columnHeadersView = this.getView("columnHeadersView");
    this._rowsView = this.getView("rowsView");
    this._pagerView = this.getView("pagerView");
    this._rowsView.resizeCompleted.add((() => {
      if (this.option("allowColumnResizing")) {
        const targetPoint = this._columnsResizerController._targetPoint;
        this.update(targetPoint ? targetPoint.y : null);
      }
    }));
  }
  update(top) {
    const params = {};
    const $element = this._columnHeadersView.element();
    const offset = null === $element || void 0 === $element ? void 0 : $element.offset();
    const offsetTop = (null === offset || void 0 === offset ? void 0 : offset.top) || 0;
    const diffOffsetTop = isDefined(top) ? Math.abs(top - offsetTop) : 0;
    const columnsHeadersHeight = this._columnHeadersView ? this._columnHeadersView.getHeight() : 0;
    const scrollBarWidth = this._rowsView.getScrollbarWidth(true);
    const rowsHeight = this._rowsView ? this._rowsView.height() - scrollBarWidth : 0;
    const draggingHeaderView = this.component.getView("draggingHeaderView");
    params.height = columnsHeadersHeight;
    const isDraggingOrResizing = this._columnsResizerController.isResizing() || draggingHeaderView.isDragging();
    if (isDraggingOrResizing) {
      params.height += rowsHeight - diffOffsetTop;
    }
    if (null !== top && null !== $element && void 0 !== $element && $element.length) {
      params.top = $element[0].offsetTop + diffOffsetTop;
    }
    this.positionChanged.fire(params);
  }
};
var DraggingHeaderViewController = class extends m_modules_default.ViewController {
  init() {
    var _this$_headerPanelVie, _this$_columnChooserV;
    super.init();
    this._columnsController = this.getController("columns");
    this._tablePositionController = this.getController("tablePosition");
    this._columnHeadersView = this.getView("columnHeadersView");
    this._columnsSeparatorView = this.getView("columnsSeparatorView");
    this._draggingHeaderView = this.getView("draggingHeaderView");
    this._rowsView = this.getView("rowsView");
    this._blockSeparatorView = this.getView("blockSeparatorView");
    this._headerPanelView = this.getView("headerPanel");
    this._columnChooserView = this.getView("columnChooserView");
    const subscribeToEvents = () => {
      if (this._draggingHeaderView) {
        const draggingPanels = [this._columnChooserView, this._columnHeadersView, this._headerPanelView];
        this._unsubscribeFromEvents(this._draggingHeaderView, draggingPanels);
        this._subscribeToEvents(this._draggingHeaderView, draggingPanels);
      }
    };
    this._columnHeadersView.renderCompleted.add(subscribeToEvents);
    null === (_this$_headerPanelVie = this._headerPanelView) || void 0 === _this$_headerPanelVie || _this$_headerPanelVie.renderCompleted.add(subscribeToEvents);
    null === (_this$_columnChooserV = this._columnChooserView) || void 0 === _this$_columnChooserV || _this$_columnChooserV.renderCompleted.add(subscribeToEvents);
  }
  dispose() {
    if (this._draggingHeaderView) {
      this._unsubscribeFromEvents(this._draggingHeaderView, [this._columnChooserView, this._columnHeadersView, this._headerPanelView]);
    }
  }
  _generatePointsByColumns(options) {
    let needToCheckPrevPoint = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;
    this.isCustomGroupColumnPosition = this.checkIsCustomGroupColumnPosition(options);
    const points = m_utils_default.getPointsByColumns(options.columnElements, ((point) => this._pointCreated(point, options.columns, options.targetDraggingPanel.getName(), options.sourceColumn)), options.isVerticalOrientation, options.startColumnIndex, needToCheckPrevPoint);
    return points;
  }
  checkIsCustomGroupColumnPosition(options) {
    let wasOnlyCommandColumns = true;
    for (let i = 0; i < options.columns.length; i += 1) {
      const col = options.columns[i];
      if ("expand" === col.command && !wasOnlyCommandColumns) {
        return true;
      }
      if (!col.command) {
        wasOnlyCommandColumns = false;
      }
    }
    return false;
  }
  _pointCreated(point, columns7, location, sourceColumn) {
    const targetColumn = columns7[point.columnIndex];
    const prevColumn = columns7[point.columnIndex - 1];
    const isColumnAfterExpandColumn = "expand" === (null === prevColumn || void 0 === prevColumn ? void 0 : prevColumn.command);
    const isFirstExpandColumn = "expand" === (null === targetColumn || void 0 === targetColumn ? void 0 : targetColumn.command) && "expand" !== (null === prevColumn || void 0 === prevColumn ? void 0 : prevColumn.command);
    const sourceColumnReorderingDisabled = sourceColumn && !sourceColumn.allowReordering;
    const otherColumnsReorderingDisabled = !(null !== targetColumn && void 0 !== targetColumn && targetColumn.allowReordering) && !(null !== prevColumn && void 0 !== prevColumn && prevColumn.allowReordering);
    switch (location) {
      case "columnChooser":
        return true;
      case "headers":
        if (sourceColumnReorderingDisabled) {
          return true;
        }
        if (!isFirstExpandColumn) {
          return isColumnAfterExpandColumn || otherColumnsReorderingDisabled;
        }
        if (this.isCustomGroupColumnPosition) {
          return false;
        }
        while ("expand" === (null === (_columns$point$column = columns7[point.columnIndex]) || void 0 === _columns$point$column ? void 0 : _columns$point$column.command)) {
          var _columns$point$column;
          point.columnIndex += 1;
        }
        return false;
      default:
        return 0 === columns7.length;
    }
  }
  _subscribeToEvents(draggingHeader4, draggingPanels) {
    const that = this;
    each(draggingPanels, ((_, draggingPanel) => {
      if (draggingPanel) {
        let columns7;
        const rowCount = draggingPanel.getRowCount ? draggingPanel.getRowCount() : 1;
        const nameDraggingPanel = draggingPanel.getName();
        const subscribeToEvents = function(index, columnElement) {
          if (!columnElement) {
            return;
          }
          const $columnElement = renderer_default(columnElement);
          const column = columns7[index];
          if (column && draggingPanel.allowDragging(column)) {
            $columnElement.addClass(that.addWidgetPrefix("drag-action"));
            m_events_engine_default.on($columnElement, addNamespace(DRAG_START_EVENT, MODULE_NAMESPACE2), that.createAction(((args) => {
              const e = args.event;
              const eventData2 = eventData(e);
              draggingHeader4.dragHeader({
                deltaX: eventData2.x - renderer_default(e.currentTarget).offset().left,
                deltaY: eventData2.y - renderer_default(e.currentTarget).offset().top,
                sourceColumn: column,
                index: column.index,
                columnIndex: index,
                columnElement: $columnElement,
                sourceLocation: nameDraggingPanel,
                draggingPanels,
                rowIndex: that._columnsController.getRowIndex(column.index, true)
              });
            })));
            m_events_engine_default.on($columnElement, addNamespace(DRAG_EVENT, MODULE_NAMESPACE2), {
              that: draggingHeader4
            }, that.createAction(draggingHeader4.moveHeader));
            m_events_engine_default.on($columnElement, addNamespace(DRAG_END_EVENT, MODULE_NAMESPACE2), {
              that: draggingHeader4
            }, that.createAction(draggingHeader4.dropHeader));
          }
        };
        for (let i = 0; i < rowCount; i++) {
          const columnElements = draggingPanel.getColumnElements(i) || [];
          if (columnElements.length) {
            columns7 = draggingPanel.getColumns(i) || [];
            each(columnElements, subscribeToEvents);
          }
        }
      }
    }));
  }
  _unsubscribeFromEvents(draggingHeader4, draggingPanels) {
    const that = this;
    each(draggingPanels, ((_, draggingPanel) => {
      if (draggingPanel) {
        const columnElements = draggingPanel.getColumnElements() || [];
        each(columnElements, ((index, columnElement) => {
          const $columnElement = renderer_default(columnElement);
          m_events_engine_default.off($columnElement, addNamespace(DRAG_START_EVENT, MODULE_NAMESPACE2));
          m_events_engine_default.off($columnElement, addNamespace(DRAG_EVENT, MODULE_NAMESPACE2));
          m_events_engine_default.off($columnElement, addNamespace(DRAG_END_EVENT, MODULE_NAMESPACE2));
          $columnElement.removeClass(that.addWidgetPrefix("drag-action"));
        }));
      }
    }));
  }
  _getSeparator(targetLocation) {
    return "headers" === targetLocation ? this._columnsSeparatorView : this._blockSeparatorView;
  }
  hideSeparators(type2) {
    const blockSeparator = this._blockSeparatorView;
    const columnsSeparator = this._columnsSeparatorView;
    this._animationColumnIndex = void 0;
    blockSeparator && blockSeparator.hide();
    "block" !== type2 && columnsSeparator && columnsSeparator.hide();
  }
  allowDrop(parameters) {
    return this._columnsController.allowMoveColumn(this.addColumnIndexOffset(parameters.sourceColumnIndex), this.addColumnIndexOffset(parameters.targetColumnIndex), parameters.sourceLocation, parameters.targetLocation);
  }
  drag(parameters) {
    const {
      sourceIndex
    } = parameters;
    const {
      sourceLocation
    } = parameters;
    const {
      sourceColumnElement
    } = parameters;
    const headersView = this._columnHeadersView;
    const rowsView18 = this._rowsView;
    if (sourceColumnElement) {
      sourceColumnElement.addClass(this.addWidgetPrefix(CLASSES.draggableColumn));
      if ("headers" === sourceLocation) {
        headersView && headersView.toggleDraggableColumnClass(sourceIndex, true);
        rowsView18 && rowsView18.toggleDraggableColumnClass(sourceIndex, true);
      }
    }
  }
  dock(parameters) {
    const that = this;
    const targetColumnIndex = isObject(parameters.targetColumnIndex) ? parameters.targetColumnIndex.columnIndex : parameters.targetColumnIndex;
    const {
      sourceLocation
    } = parameters;
    const {
      targetLocation
    } = parameters;
    const separator = that._getSeparator(targetLocation);
    const hasTargetVisibleIndex = targetColumnIndex >= 0;
    that._columnHeadersView.element().find(".dx-header-row").toggleClass(that.addWidgetPrefix("drop-highlight"), "headers" !== sourceLocation && "headers" === targetLocation && !hasTargetVisibleIndex);
    if (separator) {
      if (that.allowDrop(parameters) && hasTargetVisibleIndex) {
        if ("group" === targetLocation || "columnChooser" === targetLocation) {
          !(function() {
            if (that._animationColumnIndex !== targetColumnIndex) {
              that.hideSeparators();
              separator.element()[parameters.isLast ? "insertAfter" : "insertBefore"](parameters.targetColumnElement);
              that._animationColumnIndex = targetColumnIndex;
              separator.show(targetLocation);
            }
          })();
        } else {
          that.hideSeparators("block");
          that._tablePositionController.update(parameters.posY);
          separator.moveByX(parameters.posX - separator.width());
          separator.show();
        }
      } else {
        that.hideSeparators();
      }
    }
  }
  addColumnIndexOffset(columnIndex) {
    const offset = this._columnsController.getColumnIndexOffset();
    if (isObject(columnIndex)) {
      return _extends({}, columnIndex, {
        columnIndex: columnIndex.columnIndex + offset
      });
    }
    return columnIndex + offset;
  }
  drop(parameters) {
    const {
      sourceColumnElement
    } = parameters;
    if (sourceColumnElement) {
      sourceColumnElement.removeClass(this.addWidgetPrefix(CLASSES.draggableColumn));
      this._columnHeadersView.toggleDraggableColumnClass(parameters.sourceIndex, false);
      this._rowsView.toggleDraggableColumnClass(parameters.sourceIndex, false);
      this._columnHeadersView.element().find(".dx-header-row").removeClass(this.addWidgetPrefix("drop-highlight"));
    }
    if (this.allowDrop(parameters)) {
      const separator = this._getSeparator(parameters.targetLocation);
      if (separator) {
        separator.hide();
      }
      this._columnsController.moveColumn(this.addColumnIndexOffset(parameters.sourceColumnIndex), this.addColumnIndexOffset(parameters.targetColumnIndex), parameters.sourceLocation, parameters.targetLocation);
    }
  }
};
var rowsView9 = (Base) => class extends Base {
  _needUpdateRowHeight(itemCount) {
    const wordWrapEnabled = this.option("wordWrapEnabled");
    const isResizing = this._columnsResizerController.isResizing();
    return super._needUpdateRowHeight.apply(this, arguments) || itemCount > 0 && !!wordWrapEnabled && !!isResizing;
  }
};
var editorFactory = (Base) => class extends Base {
  renderFocusOverlay() {
    if (this._columnsResizerController.isResizing()) {
      return;
    }
    return super.renderFocusOverlay.apply(this, arguments);
  }
};
var columnsResizingReorderingModule = {
  views: {
    columnsSeparatorView: ColumnsSeparatorView,
    blockSeparatorView: BlockSeparatorView,
    draggingHeaderView: DraggingHeaderView,
    trackerView: TrackerView
  },
  controllers: {
    draggingHeader: DraggingHeaderViewController,
    tablePosition: TablePositionViewController,
    columnsResizer: ColumnsResizerViewController
  },
  extenders: {
    views: {
      rowsView: rowsView9
    },
    controllers: {
      editorFactory
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/columns_resizing_reordering.js
var DraggingHeaderView2 = columnsResizingReorderingModule.views.draggingHeaderView;
var DraggingHeaderViewController2 = columnsResizingReorderingModule.controllers.draggingHeader;
var ColumnsSeparatorView2 = columnsResizingReorderingModule.views.columnsSeparatorView;
var TablePositionViewController2 = columnsResizingReorderingModule.controllers.tablePosition;
var ColumnsResizerViewController2 = columnsResizingReorderingModule.controllers.columnsResizer;
var TrackerView2 = columnsResizingReorderingModule.views.trackerView;
m_core_default.registerModule("columnsResizingReordering", columnsResizingReorderingModule);

// node_modules/devextreme/esm/__internal/utils/memoize.js
var compareByReference = (args, lastArgs) => args.length === lastArgs.length && !Object.keys(args).some(((key) => args[key] !== lastArgs[key]));
var compareByValue = (args, lastArgs) => equalByValue(args, lastArgs, {
  maxDepth: 4
});
var createCacheFunc = (firstArgs, firstResult, originFunc, compareFunc) => {
  let lastArgs = firstArgs;
  let lastResult = firstResult;
  return function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    const argsEquals = compareFunc(args, lastArgs);
    if (argsEquals) {
      return lastResult;
    }
    lastArgs = args;
    lastResult = originFunc(...lastArgs);
    return lastResult;
  };
};
var MEMOIZE_DEFAULT_OPTIONS = {
  compareType: "reference"
};
var memoize = function(func) {
  let {
    compareType
  } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : MEMOIZE_DEFAULT_OPTIONS;
  let cachedFunc = null;
  return function() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    if (!cachedFunc) {
      const firstResult = func(...args);
      cachedFunc = createCacheFunc(args, firstResult, func, "reference" === compareType ? compareByReference : compareByValue);
      return firstResult;
    }
    return cachedFunc(...args);
  };
};

// node_modules/devextreme/esm/__internal/grids/grid_core/keyboard_navigation/dom.js
var isDragCell = ($cell) => void 0 !== $cell.attr(ATTRIBUTES.dragCell);
var getFocusableCellSelector = (columnIndex) => [`[${ATTRIBUTES.ariaColIndex}="${columnIndex + 1}"]`, `:not([${ATTRIBUTES.dragCell}])`, ":not([aria-hidden=true])"].join("");
var getCellToFocus = ($cellElements, columnIndex) => $cellElements.filter(getFocusableCellSelector(columnIndex)).first();
var GridCoreKeyboardNavigationDom = {
  isDragCell,
  getCellToFocus
};

// node_modules/devextreme/esm/__internal/grids/grid_core/keyboard_navigation/m_keyboard_navigation_utils.js
function isGroupRow2($row) {
  return $row && $row.hasClass(GROUP_ROW_CLASS);
}
function isGroupFooterRow($row) {
  return $row && $row.hasClass("dx-datagrid-group-footer");
}
function isDetailRow2($row) {
  return $row && $row.hasClass(MASTER_DETAIL_ROW_CLASS);
}
function isAdaptiveItem($element) {
  return $element && $element.hasClass(ADAPTIVE_ITEM_TEXT_CLASS);
}
function isEditRow($row) {
  return null === $row || void 0 === $row ? void 0 : $row.hasClass(EDIT_ROW);
}
function isEditForm($row) {
  return $row && $row.hasClass(MASTER_DETAIL_ROW_CLASS) && $row.hasClass(EDIT_FORM_CLASS);
}
function isDataRow($row) {
  return $row && $row.hasClass(DATA_ROW_CLASS);
}
function isNotFocusedRow($row) {
  return !$row || $row.hasClass(FREESPACE_ROW_CLASS) || $row.hasClass(VIRTUAL_ROW_CLASS);
}
function isEditorCell(that, $cell) {
  return !that._isRowEditMode() && $cell && !$cell.hasClass(COMMAND_SELECT_CLASS) && $cell.hasClass(EDITOR_CELL_CLASS);
}
function isElementDefined($element) {
  return isDefined($element) && $element.length > 0;
}
function isMobile() {
  return "desktop" !== devices_default.current().deviceType;
}
function isCellInHeaderRow($cell) {
  return !!$cell.parent(`.${HEADER_ROW_CLASS}`).length;
}
function isFixedColumnIndexOffsetRequired(that, column) {
  const rtlEnabled = that.option("rtlEnabled");
  if (rtlEnabled) {
    return !("right" === column.fixedPosition || isDefined(column.command) && !isDefined(column.fixedPosition));
  }
  return !(!isDefined(column.fixedPosition) || "left" === column.fixedPosition);
}
function shouldPreventScroll(that) {
  const keyboardController = that.getController("keyboardNavigation");
  return keyboardController._isVirtualScrolling() ? that.option("focusedRowIndex") === keyboardController.getRowIndex() : false;
}
function getInteractiveElements($cell) {
  return $cell.find(INTERACTIVE_ELEMENTS_SELECTOR).filter(":visible");
}
function getInteractiveElement($cell, isLast) {
  const $focusedElement = getInteractiveElements($cell);
  return isLast ? $focusedElement.last() : $focusedElement.first();
}

// node_modules/devextreme/esm/__internal/grids/grid_core/keyboard_navigation/m_keyboard_navigation_core.js
var KeyboardNavigationController = class extends m_modules_default.ViewController {
  constructor() {
    super(...arguments);
    this.needToRestoreFocus = false;
  }
  _applyColumnIndexBoundaries(columnIndex) {
    const visibleColumnCount = this._columnsController.getVisibleColumns(null, true).length;
    if (columnIndex < 0) {
      columnIndex = 0;
    } else if (columnIndex >= visibleColumnCount) {
      columnIndex = visibleColumnCount - 1;
    }
    return columnIndex;
  }
  unsubscribeFromKeyDownEvent() {
    if (this.keyDownListener) {
      keyboard.off(this.keyDownListener);
    }
  }
  subscribeToKeyDownEvent() {
    const $focusedViewElement = this.getFocusedViewElement();
    if ($focusedViewElement) {
      this.keyDownListener = keyboard.on($focusedViewElement, null, ((e) => this.keyDownHandler(e)));
    }
  }
  resizeCompleted() {
  }
  getColumnIndexOffset(visibleIndex) {
    let offset = 0;
    const column = this._columnsController.getVisibleColumns()[visibleIndex];
    if (null !== column && void 0 !== column && column.fixed) {
      offset = this._getFixedColumnIndexOffset(column);
    } else if (visibleIndex >= 0) {
      offset = this._columnsController.getColumnIndexOffset();
    }
    return offset;
  }
  getFocusedViewElement() {
    var _this$getFocusedView;
    return null === (_this$getFocusedView = this.getFocusedView()) || void 0 === _this$getFocusedView ? void 0 : _this$getFocusedView.element();
  }
  keyDownHandler(e) {
  }
  initKeyDownHandler() {
    this.unsubscribeFromKeyDownEvent();
    this.subscribeToKeyDownEvent();
  }
  unsubscribeFromFocusinEvent() {
    const $focusedView = this.getFocusedViewElement();
    if ($focusedView) {
      m_events_engine_default.off($focusedView, "focusin", this.focusinHandlerContext);
    }
  }
  subscribeToFocusinEvent() {
    const $focusedView = this.getFocusedViewElement();
    const focusinSelector = this.getFocusinSelector();
    if ($focusedView) {
      m_events_engine_default.on($focusedView, "focusin", focusinSelector, this.focusinHandlerContext);
    }
  }
  getFocusinSelector() {
    return "";
  }
  focusinHandler(e) {
  }
  initHandlers() {
    var _focusedView$renderCo, _this$_resizeControll;
    const focusedView = this.getFocusedView();
    this.unsubscribeFromKeyDownEvent();
    null === focusedView || void 0 === focusedView || null === (_focusedView$renderCo = focusedView.renderCompleted) || void 0 === _focusedView$renderCo || _focusedView$renderCo.remove(this.renderCompletedWithContext);
    null === (_this$_resizeControll = this._resizeController) || void 0 === _this$_resizeControll || null === (_this$_resizeControll = _this$_resizeControll.resizeCompleted) || void 0 === _this$_resizeControll || _this$_resizeControll.remove(this.resizeCompletedWithContext);
    if (this.isKeyboardEnabled()) {
      var _focusedView$renderCo2, _this$_resizeControll2;
      null === focusedView || void 0 === focusedView || null === (_focusedView$renderCo2 = focusedView.renderCompleted) || void 0 === _focusedView$renderCo2 || _focusedView$renderCo2.add(this.renderCompletedWithContext);
      null === (_this$_resizeControll2 = this._resizeController) || void 0 === _this$_resizeControll2 || null === (_this$_resizeControll2 = _this$_resizeControll2.resizeCompleted) || void 0 === _this$_resizeControll2 || _this$_resizeControll2.add(this.resizeCompletedWithContext);
    }
  }
  getFocusedView() {
  }
  _getCell(cellPosition) {
  }
  _getRowIndex($row) {
    return null === $row || void 0 === $row ? void 0 : $row.index();
  }
  getCellIndex($cell, rowIndex) {
    return null === $cell || void 0 === $cell ? void 0 : $cell.index();
  }
  _getFixedColumnIndexOffset(column) {
    const visibleColumnCount = this._columnsController.getVisibleColumns(null, true).length;
    const offset = isFixedColumnIndexOffsetRequired(this, column) ? visibleColumnCount - this._columnsController.getVisibleColumns().length : 0;
    return offset;
  }
  getNewVisibleIndex(visibleIndex, rowIndex, direction) {
    return "previous" === direction ? visibleIndex - 1 : visibleIndex + 1;
  }
  _getCellPosition($cell, direction) {
    const $row = isElementDefined($cell) && $cell.closest("tr");
    if (isElementDefined($row)) {
      const rowIndex = this._getRowIndex($row);
      let columnIndex = this.getCellIndex($cell, rowIndex);
      columnIndex += this.getColumnIndexOffset(columnIndex);
      if (direction) {
        columnIndex = this.getNewVisibleIndex(columnIndex, rowIndex, direction);
        columnIndex = this._applyColumnIndexBoundaries(columnIndex);
      }
      return {
        rowIndex,
        columnIndex
      };
    }
    return;
  }
  _getColumnByCellElement($cell, rowIndex) {
    const cellIndex = this.getCellIndex($cell);
    const columnIndex = cellIndex + this._columnsController.getColumnIndexOffset();
    return this._columnsController.getVisibleColumns(rowIndex, true)[columnIndex];
  }
  processOnKeyDown(eventArgs) {
    const {
      originalEvent
    } = eventArgs;
    const args = {
      handled: false,
      event: originalEvent
    };
    this.executeAction("onKeyDown", args);
    eventArgs.ctrl = originalEvent.ctrlKey;
    eventArgs.alt = originalEvent.altKey;
    eventArgs.shift = originalEvent.shiftKey;
    return !!args.handled;
  }
  setFocusedColumnIndex(columnIndex) {
    if (!this._focusedCellPosition) {
      this._focusedCellPosition = {};
    }
    this._focusedCellPosition.columnIndex = columnIndex;
  }
  _updateFocusedCellPosition($cell, direction) {
    const position = this._getCellPosition($cell, direction);
    if (position) {
      if (!$cell.length || position.rowIndex >= 0 && position.columnIndex >= 0) {
        this.setFocusedCellPosition(position.rowIndex, position.columnIndex);
      }
    }
    return position;
  }
  renderCompleted(e) {
    this.initKeyDownHandler();
    this.unsubscribeFromFocusinEvent();
    this.subscribeToFocusinEvent();
  }
  init() {
    this._columnsController = this.getController("columns");
    this._resizeController = this.getController("resizing");
    this._focusedCellPosition = {};
    if (this.isKeyboardEnabled()) {
      this.createAction("onKeyDown");
    }
    this.renderCompletedWithContext = this.renderCompletedWithContext ?? this.renderCompleted.bind(this);
    this.resizeCompletedWithContext = this.resizeCompletedWithContext ?? this.resizeCompleted.bind(this);
    this.focusinHandlerContext = this.focusinHandlerContext ?? this.focusinHandler.bind(this);
    this.initHandlers();
  }
  dispose() {
    keyboard.off(this.keyDownListener);
  }
  setFocusedRowIndex(rowIndex) {
    if (!this._focusedCellPosition) {
      this._focusedCellPosition = {};
    }
    this._focusedCellPosition.rowIndex = rowIndex;
  }
  setFocusedCellPosition(rowIndex, columnIndex) {
    this.setFocusedRowIndex(rowIndex);
    this.setFocusedColumnIndex(columnIndex);
  }
  optionChanged(args) {
    switch (args.name) {
      case "keyboardNavigation":
        if ("keyboardNavigation.enabled" === args.fullName) {
          this.init();
        }
        args.handled = true;
        break;
      case "useLegacyKeyboardNavigation":
        this.init();
        args.handled = true;
        break;
      default:
        super.optionChanged(args);
    }
  }
  isKeyboardEnabled() {
    return this.option("keyboardNavigation.enabled");
  }
  _getFocusedCell() {
    return renderer_default(this._getCell(this._focusedCellPosition));
  }
  getDirectionByKeyName(keyName) {
    const rtlEnabled = this.option("rtlEnabled");
    switch (keyName) {
      case "leftArrow":
        return rtlEnabled ? Direction.Next : Direction.Previous;
      case "rightArrow":
        return rtlEnabled ? Direction.Previous : Direction.Next;
      default:
        return Direction.Next;
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/keyboard_navigation/scrollable_a11y.js
var keyboardNavigationScrollableA11yExtender = (Base) => class extends Base {
  focusinHandler(event) {
    const $target = renderer_default(event.target);
    this.translateFocusIfNeed(event, $target);
    super.focusinHandler(event);
  }
  focusOutHandler(e) {
    super.focusOutHandler(e);
    this.makeScrollableFocusableIfNeed();
  }
  translateFocusIfNeed(event, $target) {
    const needTranslateFocus = this.isScrollableNeedFocusable();
    const isFirstCellFixed = this._isFixedColumn(0);
    if (!needTranslateFocus || !isFirstCellFixed) {
      return;
    }
    const $firstCell = this._rowsView.getCell({
      rowIndex: 0,
      columnIndex: 0
    });
    const firstCellHasTabIndex = !!$firstCell.attr("tabindex");
    const notFixedCellIsTarget = $target.is(this._$firstNotFixedCell);
    if (firstCellHasTabIndex && notFixedCellIsTarget) {
      event.preventDefault();
      this._focus($firstCell);
    }
  }
  renderCompleted(e) {
    this._$firstNotFixedCell = this.getFirstNotFixedCell();
    this.makeScrollableFocusableIfNeed();
    super.renderCompleted(e);
  }
  _focus($cell, disableFocus, skipFocusEvent) {
    super._focus($cell, disableFocus, skipFocusEvent);
    this.makeScrollableFocusableIfNeed();
  }
  _tabKeyHandler(eventArgs, isEditing) {
    const isCellPositionDefined = isDefined(this._focusedCellPosition) && !isEmptyObject(this._focusedCellPosition);
    const isOriginalHandlerRequired = !isCellPositionDefined || !eventArgs.shift && this._isLastValidCell(this._focusedCellPosition) || eventArgs.shift && this._isFirstValidCell(this._focusedCellPosition);
    const isNeedFocusable = this.isScrollableNeedFocusable();
    if (isOriginalHandlerRequired && isNeedFocusable) {
      var _this$_$firstNotFixed;
      null === (_this$_$firstNotFixed = this._$firstNotFixedCell) || void 0 === _this$_$firstNotFixed || _this$_$firstNotFixed.removeAttr("tabIndex");
    }
    super._tabKeyHandler(eventArgs, isEditing);
  }
  getFirstNotFixedCell() {
    var _this$_editingControl;
    const columns7 = this._columnsController.getVisibleColumns();
    const columnIndex = columns7.findIndex(((_ref) => {
      let {
        fixed
      } = _ref;
      return !fixed;
    }));
    const isEditing = null === (_this$_editingControl = this._editingController) || void 0 === _this$_editingControl ? void 0 : _this$_editingControl.isEditing();
    return -1 === columnIndex || isEditing ? void 0 : this._rowsView._getCellElement(0, columnIndex);
  }
  isScrollableNeedFocusable() {
    var _this$_rowsView$_fixe, _this$_rowsView$getCe;
    const hasScrollable = !!this._rowsView.getScrollable();
    const hasFixedTable = !!(null !== (_this$_rowsView$_fixe = this._rowsView._fixedTableElement) && void 0 !== _this$_rowsView$_fixe && _this$_rowsView$_fixe.length);
    const isCellsRendered = !!(null !== (_this$_rowsView$getCe = this._rowsView.getCellElements(0)) && void 0 !== _this$_rowsView$getCe && _this$_rowsView$getCe.length);
    return hasScrollable && hasFixedTable && isCellsRendered;
  }
  makeScrollableFocusableIfNeed() {
    const needFocusable = this.isScrollableNeedFocusable();
    if (!needFocusable || !this._$firstNotFixedCell) {
      return;
    }
    this._applyTabIndexToElement(this._$firstNotFixedCell);
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/keyboard_navigation/m_keyboard_navigation.js
var KeyboardNavigationController2 = class extends KeyboardNavigationController {
  constructor() {
    super(...arguments);
    this._needNavigationToCell = false;
  }
  init() {
    this._dataController = this.getController("data");
    this._selectionController = this.getController("selection");
    this._editingController = this.getController("editing");
    this._headerPanel = this.getView("headerPanel");
    this._editorFactory = this.getController("editorFactory");
    this._focusController = this.getController("focus");
    this._adaptiveColumnsController = this.getController("adaptiveColumns");
    this._columnResizerController = this.getController("columnsResizer");
    this._rowsView = this.getView("rowsView");
    super.init();
    this._memoFireFocusedCellChanged = memoize(this._memoFireFocusedCellChanged.bind(this), {
      compareType: "value"
    });
    this._memoFireFocusedRowChanged = memoize(this._memoFireFocusedRowChanged.bind(this), {
      compareType: "value"
    });
    this.focusedHandlerWithContext = this.focusedHandlerWithContext || this.focusedHandler.bind(this);
    this.focusOutHandlerContext = this.focusOutHandlerContext ?? this.focusOutHandler.bind(this);
    this._updateFocusTimeout = null;
    this._fastEditingStarted = false;
    this._canceledCellPosition = null;
    if (this.isKeyboardEnabled()) {
      var _this$_editorFactory;
      subscribeVisibilityChange();
      null === (_this$_editorFactory = this._editorFactory) || void 0 === _this$_editorFactory || _this$_editorFactory.focused.add(this.focusedHandlerWithContext);
    } else {
      var _this$_editorFactory2;
      unsubscribeVisibilityChange();
      null === (_this$_editorFactory2 = this._editorFactory) || void 0 === _this$_editorFactory2 || _this$_editorFactory2.focused.remove(this.focusedHandlerWithContext);
    }
    this.initDocumentHandlers();
  }
  dispose() {
    super.dispose();
    this._resetFocusedView();
    m_events_engine_default.off(dom_adapter_default.getDocument(), addNamespace(m_pointer_default.down, "dxDataGridKeyboardNavigation"), this._documentClickHandler);
    clearTimeout(this._updateFocusTimeout);
    unsubscribeVisibilityChange();
  }
  focusedHandler($element) {
    this.setupFocusedView();
    if (this._isNeedScroll) {
      if ($element.is(":visible") && this._focusedView && this._focusedView.getScrollable()) {
        this._focusedView._scrollToElement($element);
        this._isNeedScroll = false;
      }
    }
  }
  focusinHandler(event) {
    const $element = renderer_default(event.target);
    const isRelatedTargetInRowsView = renderer_default(event.relatedTarget).closest(this._rowsView.element()).length;
    const isLink = $element.is("a");
    if (event.relatedTarget && isLink && !isRelatedTargetInRowsView && this._isEventInCurrentGrid(event)) {
      let $focusedCell = this._getFocusedCell();
      $focusedCell = !isElementDefined($focusedCell) ? this._rowsView.getCellElements(0).filter("[tabindex]").eq(0) : $focusedCell;
      if (!$element.closest($focusedCell).length) {
        event.preventDefault();
        m_events_engine_default.trigger($focusedCell, "focus");
      }
    }
    const isCell = $element.is("td");
    const needSetFocusPosition = (this.option("focusedRowIndex") ?? -1) < 0;
    if (isCell && needSetFocusPosition) {
      this._updateFocusedCellPosition($element);
    }
  }
  focusOutHandler(e) {
    const {
      relatedTarget
    } = e;
    this._toggleInertAttr(false);
    if (relatedTarget && !this.isInsideFocusedView(renderer_default(relatedTarget))) {
      this._isNeedFocus = false;
      this._isHiddenFocus = false;
      this._isNeedScroll = false;
    }
  }
  subscribeToRowsViewFocusEvent() {
    var _this$_rowsView;
    const $rowsView = null === (_this$_rowsView = this._rowsView) || void 0 === _this$_rowsView ? void 0 : _this$_rowsView.element();
    m_events_engine_default.on($rowsView, "focusin", this.focusinHandlerContext);
    m_events_engine_default.on($rowsView, "focusout", this.focusOutHandlerContext);
  }
  unsubscribeFromRowsViewFocusEvent() {
    var _this$_rowsView2;
    const $rowsView = null === (_this$_rowsView2 = this._rowsView) || void 0 === _this$_rowsView2 ? void 0 : _this$_rowsView2.element();
    m_events_engine_default.off($rowsView, "focusin", this.focusinHandlerContext);
    m_events_engine_default.off($rowsView, "focusout", this.focusOutHandlerContext);
  }
  resizeCompleted() {
    var _this$_rowsView3;
    if (this.navigationToCellInProgress()) {
      this._resizeController.resetLastResizeTime();
    }
    if (!this.needToRestoreFocus) {
      return;
    }
    const scrollLeft = (null === (_this$_rowsView3 = this._rowsView) || void 0 === _this$_rowsView3 || null === (_this$_rowsView3 = _this$_rowsView3.getScrollable()) || void 0 === _this$_rowsView3 ? void 0 : _this$_rowsView3.scrollLeft()) ?? 0;
    if (!this._columnsController.isNeedToRenderVirtualColumns(scrollLeft)) {
      this.needToRestoreFocus = false;
      this.focusFirstOrLastCell();
    }
  }
  renderCompleted(e) {
    const $rowsView = this._rowsView.element();
    const isFullUpdate = !e || "refresh" === e.changeType;
    const isFocusedViewCorrect = this._focusedView && this._focusedView.name === this._rowsView.name;
    let needUpdateFocus = false;
    const isAppend = e && ("append" === e.changeType || "prepend" === e.changeType);
    const root = renderer_default(dom_adapter_default.getRootNode($rowsView.get && $rowsView.get(0)));
    const $focusedElement = root.find(":focus");
    const isFocusedElementCorrect = this._isFocusedElementCorrect($focusedElement, $rowsView, e);
    this.unsubscribeFromRowsViewFocusEvent();
    this.subscribeToRowsViewFocusEvent();
    this.initPointerEventHandler();
    this.initKeyDownHandler();
    this._setRowsViewAttributes();
    if (isFocusedViewCorrect && isFocusedElementCorrect) {
      needUpdateFocus = this._isNeedFocus ? !isAppend : this._isHiddenFocus && isFullUpdate && !(null !== e && void 0 !== e && e.virtualColumnsScrolling);
      if (needUpdateFocus) {
        var _e$event;
        const isScrollEvent = !!(null !== e && void 0 !== e && null !== (_e$event = e.event) && void 0 !== _e$event && _e$event.type);
        const skipFocusEvent = (null === e || void 0 === e ? void 0 : e.virtualColumnsScrolling) && isScrollEvent;
        this._updateFocus(true, skipFocusEvent);
      }
    }
  }
  _isFocusedElementCorrect($focusedElement, $rowsView, e) {
    if ($focusedElement.length && !$focusedElement.closest($rowsView).length) {
      return false;
    }
    if (!$focusedElement.length && null !== e && void 0 !== e && e.virtualColumnsScrolling) {
      var _this$_focusedCellPos;
      const focusedColumnIndex = (null === (_this$_focusedCellPos = this._focusedCellPosition) || void 0 === _this$_focusedCellPos ? void 0 : _this$_focusedCellPos.columnIndex) ?? -1;
      return this._isColumnRendered(focusedColumnIndex);
    }
    return true;
  }
  initHandlers() {
    this.unsubscribeFromRowsViewFocusEvent();
    this.unsubscribeFromPointerEvent();
    super.initHandlers();
  }
  initDocumentHandlers() {
    const document = dom_adapter_default.getDocument();
    this._documentClickHandler = this._documentClickHandler || this.createAction(((e) => {
      var _this$_columnResizerC;
      const $target = renderer_default(e.event.target);
      const tableSelector = `.${this.addWidgetPrefix(TABLE_CLASS)}`;
      const rowsViewSelector = `.${this.addWidgetPrefix(ROWS_VIEW_CLASS)}`;
      const editorOverlaySelector = `.${DROPDOWN_EDITOR_OVERLAY_CLASS}`;
      const needKeepFocus = !!$target.closest(tableSelector).length && !isElementInDom($target);
      if (needKeepFocus) {
        e.event.preventDefault();
        return;
      }
      const isRowsViewClick = this._isEventInCurrentGrid(e.event) && !!$target.closest(rowsViewSelector).length;
      const isEditorOverlayClick = !!$target.closest(editorOverlaySelector).length;
      const isColumnResizing = !!(null !== (_this$_columnResizerC = this._columnResizerController) && void 0 !== _this$_columnResizerC && _this$_columnResizerC.isResizing());
      if (!isRowsViewClick && !isEditorOverlayClick && !isColumnResizing) {
        const isClickOutsideFocusedView = this._focusedView ? 0 === $target.closest(this._focusedView.element()).length : true;
        if (isClickOutsideFocusedView) {
          this._resetFocusedCell(true);
        }
        this._resetFocusedView();
      }
    }));
    m_events_engine_default.off(document, addNamespace(m_pointer_default.down, "dxDataGridKeyboardNavigation"), this._documentClickHandler);
    if (this.isKeyboardEnabled()) {
      m_events_engine_default.on(document, addNamespace(m_pointer_default.down, "dxDataGridKeyboardNavigation"), this._documentClickHandler);
    }
  }
  _setRowsViewAttributes() {
    const $rowsView = this._getRowsViewElement();
    const isGridEmpty = !this._dataController.getVisibleRows().length;
    if (isGridEmpty) {
      this._applyTabIndexToElement($rowsView);
    }
  }
  unsubscribeFromPointerEvent() {
    const pointerEventName = !isMobile() ? m_pointer_default.down : CLICK_EVENT_NAME;
    const $rowsView = this._getRowsViewElement();
    this._pointerEventAction && m_events_engine_default.off($rowsView, addNamespace(pointerEventName, "dxDataGridKeyboardNavigation"), this._pointerEventAction);
  }
  subscribeToPointerEvent() {
    const pointerEventName = !isMobile() ? m_pointer_default.down : CLICK_EVENT_NAME;
    const $rowsView = this._getRowsViewElement();
    const clickSelector = `.${ROW_CLASS} > td, .${ROW_CLASS}`;
    m_events_engine_default.on($rowsView, addNamespace(pointerEventName, "dxDataGridKeyboardNavigation"), clickSelector, this._pointerEventAction);
  }
  initPointerEventHandler() {
    this._pointerEventAction = this._pointerEventAction || this.createAction(this._pointerEventHandler);
    this.unsubscribeFromPointerEvent();
    this.subscribeToPointerEvent();
  }
  isRowFocusType() {
    return this.focusType === FOCUS_TYPE_ROW;
  }
  isCellFocusType() {
    return this.focusType === FOCUS_TYPE_CELL;
  }
  setRowFocusType() {
    if (this.option("focusedRowEnabled")) {
      this.focusType = FOCUS_TYPE_ROW;
    }
  }
  setCellFocusType() {
    this.focusType = FOCUS_TYPE_CELL;
  }
  keyDownHandler(e) {
    var _this$_editingControl;
    let needStopPropagation = true;
    this._isNeedFocus = true;
    this._isNeedScroll = true;
    let isHandled = this.processOnKeyDown(e);
    const isEditing = null === (_this$_editingControl = this._editingController) || void 0 === _this$_editingControl ? void 0 : _this$_editingControl.isEditing();
    const {
      originalEvent
    } = e;
    if (originalEvent.isDefaultPrevented()) {
      this._isNeedFocus = false;
      this._isNeedScroll = false;
      return;
    }
    !FUNCTIONAL_KEYS.includes(e.keyName) && this._updateFocusedCellPositionByTarget(originalEvent.target);
    if (!isHandled) {
      switch (e.keyName) {
        case "leftArrow":
        case "rightArrow":
          this._leftRightKeysHandler(e, isEditing);
          isHandled = true;
          break;
        case "upArrow":
        case "downArrow":
          if (e.ctrl) {
            selectView("rowsView", this, originalEvent);
          } else {
            this._upDownKeysHandler(e, isEditing);
          }
          isHandled = true;
          break;
        case "pageUp":
        case "pageDown":
          this._pageUpDownKeyHandler(e);
          isHandled = true;
          break;
        case "space":
          isHandled = this._spaceKeyHandler(e, isEditing);
          break;
        case "A":
          if (isCommandKeyPressed(e.originalEvent)) {
            this._ctrlAKeyHandler(e, isEditing);
            isHandled = true;
          } else {
            isHandled = this._beginFastEditing(e.originalEvent);
          }
          break;
        case "tab":
          this._tabKeyHandler(e, isEditing);
          isHandled = true;
          break;
        case "enter":
          this._enterKeyHandler(e, isEditing);
          isHandled = true;
          break;
        case "escape":
          isHandled = this._escapeKeyHandler(e, isEditing);
          break;
        case "F":
          if (isCommandKeyPressed(e.originalEvent)) {
            this._ctrlFKeyHandler(e);
            isHandled = true;
          } else {
            isHandled = this._beginFastEditing(e.originalEvent);
          }
          break;
        case "F2":
          this._f2KeyHandler();
          isHandled = true;
          break;
        case "del":
        case "backspace":
          if (this._isFastEditingAllowed() && !this._isFastEditingStarted()) {
            isHandled = this._beginFastEditing(originalEvent, true);
          }
          break;
        case "home":
        case "end":
          this.homeOrEndKeyHandler(e);
      }
      if (!isHandled && !this._beginFastEditing(originalEvent)) {
        this._isNeedFocus = false;
        this._isNeedScroll = false;
        needStopPropagation = false;
      }
      if (needStopPropagation) {
        originalEvent.stopPropagation();
      }
    }
  }
  _closeEditCell() {
    const d = Deferred();
    setTimeout((() => {
      this._editingController.closeEditCell().always(d.resolve);
    }));
    return d;
  }
  _leftRightKeysHandler(eventArgs, isEditing) {
    const rowIndex = this.getVisibleRowIndex();
    const $event = eventArgs.originalEvent;
    const $row = this._focusedView && this._focusedView.getRow(rowIndex);
    const directionCode = this._getDirectionCodeByKey(eventArgs.keyName);
    const isEditingNavigationMode = this._isFastEditingStarted();
    const allowNavigate = (!isEditing || isEditingNavigationMode) && isDataRow($row);
    if (allowNavigate) {
      this.setCellFocusType();
      isEditingNavigationMode && this._closeEditCell();
      if (this._isVirtualColumnRender()) {
        this._processVirtualHorizontalPosition(directionCode);
      }
      const $cell = this._getNextCell(directionCode);
      if (isElementDefined($cell)) {
        this._arrowKeysHandlerFocusCell($event, $cell, directionCode);
      }
      $event && $event.preventDefault();
    }
  }
  isInsideMasterDetail($target) {
    const $masterDetail = $target.closest(`.${MASTER_DETAIL_CELL_CLASS}`);
    return !!$masterDetail.get(0) && this.elementIsInsideGrid($masterDetail) && !$target.is($masterDetail);
  }
  _upDownKeysHandler(eventArgs, isEditing) {
    var _this$_editingControl2, _this$_editingControl3;
    const visibleRowIndex = this.getVisibleRowIndex();
    const $row = this._focusedView && this._focusedView.getRow(visibleRowIndex);
    const $event = eventArgs.originalEvent;
    const isUpArrow = "upArrow" === eventArgs.keyName;
    const dataSource = this._dataController.dataSource();
    const isRowEditingInCurrentRow = null === (_this$_editingControl2 = this._editingController) || void 0 === _this$_editingControl2 || null === (_this$_editingControl3 = _this$_editingControl2.isEditRowByIndex) || void 0 === _this$_editingControl3 ? void 0 : _this$_editingControl3.call(_this$_editingControl2, visibleRowIndex);
    const isEditingNavigationMode = this._isFastEditingStarted();
    const isInsideMasterDetail = this.isInsideMasterDetail(renderer_default(null === $event || void 0 === $event ? void 0 : $event.target));
    const allowNavigate = (!isRowEditingInCurrentRow || !isEditing || isEditingNavigationMode) && $row && !isEditForm($row) && !isInsideMasterDetail;
    if (allowNavigate) {
      isEditingNavigationMode && this._closeEditCell();
      if (!this._navigateNextCell($event, eventArgs.keyName)) {
        if (this._isVirtualRowRender() && isUpArrow && dataSource && !dataSource.isLoading()) {
          const rowHeight = getOuterHeight($row);
          const rowIndex = this._focusedCellPosition.rowIndex - 1;
          this._scrollBy(0, -rowHeight, rowIndex, $event);
        }
      }
      $event && $event.preventDefault();
    }
  }
  _pageUpDownKeyHandler(eventArgs) {
    const pageIndex = this._dataController.pageIndex();
    const pageCount = this._dataController.pageCount();
    const pagingEnabled = this.option("paging.enabled");
    const isPageUp = "pageUp" === eventArgs.keyName;
    const pageStep = isPageUp ? -1 : 1;
    const scrollable = this._rowsView.getScrollable();
    if (pagingEnabled && !this._isVirtualScrolling()) {
      if ((isPageUp ? pageIndex > 0 : pageIndex < pageCount - 1) && !this._isVirtualScrolling()) {
        this._dataController.pageIndex(pageIndex + pageStep);
        eventArgs.originalEvent.preventDefault();
      }
    } else if (scrollable && getHeight(scrollable.container()) < getHeight(scrollable.$content())) {
      this._scrollBy(0, getHeight(scrollable.container()) * pageStep);
      eventArgs.originalEvent.preventDefault();
    }
  }
  _spaceKeyHandler(eventArgs, isEditing) {
    const rowIndex = this.getVisibleRowIndex();
    const $target = renderer_default(eventArgs.originalEvent && eventArgs.originalEvent.target);
    if (this.option("selection") && "none" !== this.option("selection").mode && !isEditing) {
      const isFocusedRowElement = "row" === this._getElementType($target) && this.isRowFocusType() && isDataRow($target);
      const isFocusedSelectionCell = $target.hasClass(COMMAND_SELECT_CLASS);
      if (isFocusedSelectionCell && "onClick" === this.option("selection.showCheckBoxesMode")) {
        this._selectionController.startSelectionWithCheckboxes();
      }
      if (isFocusedRowElement || $target.parent().hasClass(DATA_ROW_CLASS) || $target.hasClass(this.addWidgetPrefix(ROWS_VIEW_CLASS))) {
        this._selectionController.changeItemSelection(rowIndex, {
          shift: eventArgs.shift,
          control: eventArgs.ctrl
        });
        eventArgs.originalEvent.preventDefault();
        return true;
      }
      return false;
    }
    return this._beginFastEditing(eventArgs.originalEvent);
  }
  _ctrlAKeyHandler(eventArgs, isEditing) {
    if (!isEditing && !eventArgs.alt && "multiple" === this.option("selection.mode") && this.option("selection.allowSelectAll")) {
      this._selectionController.selectAll();
      eventArgs.originalEvent.preventDefault();
    }
  }
  _toggleInertAttr(value2) {
  }
  _tabKeyHandler(eventArgs, isEditing) {
    const editingOptions = this.option("editing");
    const direction = eventArgs.shift ? "previous" : "next";
    const isCellPositionDefined = isDefined(this._focusedCellPosition) && !isEmptyObject(this._focusedCellPosition);
    const isFirstValidCell = eventArgs.shift && this._isFirstValidCell(this._focusedCellPosition);
    const isLastValidCell = !eventArgs.shift && this._isLastValidCell(this._focusedCellPosition);
    let isOriginalHandlerRequired = !isCellPositionDefined || isFirstValidCell || isLastValidCell;
    const eventTarget = eventArgs.originalEvent.target;
    const focusedViewElement = this._focusedView && this._focusedView.element();
    if (this._handleTabKeyOnMasterDetailCell(eventTarget, direction)) {
      return;
    }
    renderer_default(focusedViewElement).addClass(FOCUS_STATE_CLASS);
    if (editingOptions && eventTarget && !isOriginalHandlerRequired) {
      if (renderer_default(eventTarget).hasClass(this.addWidgetPrefix(ROWS_VIEW_CLASS))) {
        this._resetFocusedCell();
      }
      if (this._isVirtualColumnRender()) {
        this._processVirtualHorizontalPosition(direction);
      }
      if (isEditing) {
        if (!this._editingCellTabHandler(eventArgs, direction)) {
          return;
        }
      } else if (this._targetCellTabHandler(eventArgs, direction)) {
        isOriginalHandlerRequired = true;
      }
    }
    if (isOriginalHandlerRequired) {
      const $cell = this._getFocusedCell();
      const isCommandCell = $cell.is(COMMAND_CELL_SELECTOR);
      if (isLastValidCell && !isCommandCell) {
        this._toggleInertAttr(true);
      }
      this._editorFactory.loseFocus();
      if (this._editingController.isEditing() && !this._isRowEditMode()) {
        this._resetFocusedCell(true);
        this._resetFocusedView();
        this._closeEditCell();
      }
    } else {
      eventArgs.originalEvent.preventDefault();
    }
  }
  _getMaxVerticalOffset() {
    const scrollable = this.component.getScrollable();
    return scrollable ? scrollable.scrollHeight() - getHeight(this._rowsView.element()) : 0;
  }
  _getMaxHorizontalOffset() {
    const scrollable = this.component.getScrollable();
    return scrollable ? scrollable.scrollWidth() - getWidth(this._rowsView.element()) : 0;
  }
  _isColumnRendered(columnIndex) {
    const allVisibleColumns = this._columnsController.getVisibleColumns(null, true);
    const renderedVisibleColumns = this._columnsController.getVisibleColumns();
    const column = allVisibleColumns[columnIndex];
    let result = false;
    if (column) {
      result = renderedVisibleColumns.indexOf(column) >= 0;
    }
    return result;
  }
  _isFixedColumn(columnIndex) {
    const allVisibleColumns = this._columnsController.getVisibleColumns(null, true);
    const column = allVisibleColumns[columnIndex];
    return !!column && !!column.fixed;
  }
  _isColumnVirtual(columnIndex) {
    const localColumnIndex = columnIndex - this._columnsController.getColumnIndexOffset();
    const visibleColumns = this._columnsController.getVisibleColumns();
    const column = visibleColumns[localColumnIndex];
    return !!column && "virtual" === column.command;
  }
  _processVirtualHorizontalPosition(direction) {
    const scrollable = this.component.getScrollable();
    const columnIndex = this.getColumnIndex();
    let nextColumnIndex;
    let horizontalScrollPosition = 0;
    let needToScroll = false;
    switch (direction) {
      case "next":
      case "nextInRow": {
        const columnsCount = this._getVisibleColumnCount();
        nextColumnIndex = columnIndex + 1;
        horizontalScrollPosition = this.option("rtlEnabled") ? this._getMaxHorizontalOffset() : 0;
        if ("next" === direction) {
          needToScroll = columnsCount === nextColumnIndex || this._isFixedColumn(columnIndex) && !this._isColumnRendered(nextColumnIndex);
        } else {
          needToScroll = columnsCount > nextColumnIndex && this._isFixedColumn(columnIndex) && !this._isColumnRendered(nextColumnIndex);
        }
        break;
      }
      case "previous":
      case "previousInRow":
        nextColumnIndex = columnIndex - 1;
        horizontalScrollPosition = this.option("rtlEnabled") ? 0 : this._getMaxHorizontalOffset();
        if ("previous" === direction) {
          const columnIndexOffset = this._columnsController.getColumnIndexOffset();
          const leftEdgePosition = nextColumnIndex < 0 && 0 === columnIndexOffset;
          needToScroll = leftEdgePosition || this._isFixedColumn(columnIndex) && !this._isColumnRendered(nextColumnIndex);
        } else {
          needToScroll = nextColumnIndex >= 0 && this._isFixedColumn(columnIndex) && !this._isColumnRendered(nextColumnIndex);
        }
    }
    if (needToScroll) {
      scrollable.scrollTo({
        left: horizontalScrollPosition
      });
    } else if (isDefined(nextColumnIndex) && isDefined(direction) && this._isColumnVirtual(nextColumnIndex)) {
      horizontalScrollPosition = this._getHorizontalScrollPositionOffset(direction);
      0 !== horizontalScrollPosition && scrollable.scrollBy({
        left: horizontalScrollPosition,
        top: 0
      });
    }
  }
  _getHorizontalScrollPositionOffset(direction) {
    let positionOffset = 0;
    const $currentCell = this._getCell(this._focusedCellPosition);
    const currentCellWidth = $currentCell && getOuterWidth($currentCell);
    if (currentCellWidth > 0) {
      const rtlMultiplier = this.option("rtlEnabled") ? -1 : 1;
      positionOffset = "nextInRow" === direction || "next" === direction ? currentCellWidth * rtlMultiplier : currentCellWidth * rtlMultiplier * -1;
    }
    return positionOffset;
  }
  _editingCellTabHandler(eventArgs, direction) {
    const eventTarget = eventArgs.originalEvent.target;
    const $targetCell = this._getCellElementFromTarget(eventTarget);
    const isCommandCell = $targetCell.is(COMMAND_CELL_SELECTOR);
    if (this.isOriginalTabHandlerRequired($targetCell, eventArgs)) {
      return false;
    }
    if (isCommandCell) {
      return !this._targetCellTabHandler(eventArgs, direction);
    }
    this._updateFocusedCellPosition($targetCell);
    const elementType = this._getElementType(eventTarget);
    const nextCellInfo = this._getNextCellByTabKey(eventArgs.originalEvent, direction, elementType);
    const $nextCell = nextCellInfo.$cell;
    if (!$nextCell || this._handleTabKeyOnMasterDetailCell($nextCell, direction)) {
      return false;
    }
    let isEditingAllowed = false;
    const column = this._getColumnByCellElement($nextCell);
    if (null !== column && void 0 !== column && column.allowEditing) {
      const $row = $nextCell.parent();
      const rowIndex = this._getLocalRowIndex($row);
      const row = this._dataController.items()[rowIndex];
      const isDataRow2 = !row || "data" === row.rowType;
      isEditingAllowed = this._editingController.allowUpdating({
        row
      }) ? isDataRow2 : null === row || void 0 === row ? void 0 : row.isNewRow;
    }
    if (!isEditingAllowed) {
      this._closeEditCell();
    }
    const nextCellFocused = this._focusCell($nextCell, !nextCellInfo.isHighlighted);
    if (nextCellFocused) {
      const isRowMode = this._isRowEditMode();
      if (!isRowMode && isEditingAllowed) {
        this._editFocusedCell();
      } else {
        this._focusInteractiveElement($nextCell, eventArgs.shift);
      }
    }
    return true;
  }
  isOriginalTabHandlerRequired($cell, event) {
    const eventTarget = event.originalEvent.target;
    const elementType = this._getElementType(eventTarget);
    const $lastInteractiveElement = getInteractiveElement($cell, !event.shift);
    if ("cell" !== elementType || 0 === $lastInteractiveElement.length) {
      return false;
    }
    return eventTarget !== $lastInteractiveElement.get(0);
  }
  _targetCellTabHandler(eventArgs, direction) {
    const $event = eventArgs.originalEvent;
    let eventTarget = $event.target;
    let elementType = this._getElementType(eventTarget);
    let $cell = this._getCellElementFromTarget(eventTarget);
    if (!isEditorCell(this, $cell) && this.isOriginalTabHandlerRequired($cell, eventArgs)) {
      return true;
    }
    if (void 0 === this._focusedCellPosition.rowIndex && renderer_default(eventTarget).hasClass(ROW_CLASS)) {
      this._updateFocusedCellPosition($cell);
    }
    if (this.isRowFocusType()) {
      this.setCellFocusType();
      if ("row" === elementType && isDataRow(renderer_default(eventTarget))) {
        eventTarget = this.getFirstValidCellInRow(renderer_default(eventTarget));
        elementType = this._getElementType(eventTarget);
      }
    }
    const nextCellInfo = this._getNextCellByTabKey($event, direction, elementType);
    $cell = nextCellInfo.$cell;
    if (!$cell) {
      return false;
    }
    $cell = this._checkNewLineTransition($event, $cell);
    if (!$cell) {
      return false;
    }
    this._focusCell($cell, !nextCellInfo.isHighlighted);
    if (!isEditorCell(this, $cell)) {
      this._focusInteractiveElement($cell, eventArgs.shift);
    }
    return false;
  }
  _getNextCellByTabKey($event, direction, elementType) {
    let $cell = this._getNextCell(direction, elementType);
    const args = $cell && this._fireFocusedCellChanging($event, $cell, true);
    if (!args || args.cancel) {
      return {};
    }
    if (args.$newCellElement) {
      $cell = args.$newCellElement;
    }
    return {
      $cell,
      isHighlighted: args.isHighlighted
    };
  }
  _checkNewLineTransition($event, $cell) {
    const rowIndex = this.getVisibleRowIndex();
    const $row = $cell.parent();
    if (rowIndex !== this._getRowIndex($row)) {
      const cellPosition = this._getCellPosition($cell);
      const args = this._fireFocusedRowChanging($event, $row);
      if (args.cancel) {
        return;
      }
      if (args.rowIndexChanged && cellPosition) {
        this.setFocusedColumnIndex(cellPosition.columnIndex);
        $cell = this._getFocusedCell();
      }
    }
    return $cell;
  }
  _enterKeyHandler(eventArgs, isEditing) {
    var _this$_focusedView, _this$getMasterDetail;
    const rowIndex = this.getVisibleRowIndex();
    const key = this._dataController.getKeyByRowIndex(rowIndex);
    const $row = null === (_this$_focusedView = this._focusedView) || void 0 === _this$_focusedView ? void 0 : _this$_focusedView.getRow(rowIndex);
    const $cell = this._getFocusedCell();
    const needExpandGroupRow = this.option("grouping.allowCollapsing") && isGroupRow2($row);
    const needExpandMasterDetailRow = this.option("masterDetail.enabled") && (null === $cell || void 0 === $cell ? void 0 : $cell.hasClass(COMMAND_EXPAND_CLASS));
    const needExpandAdaptiveRow = null === $cell || void 0 === $cell ? void 0 : $cell.hasClass(ADAPTIVE_COLUMN_NAME_CLASS);
    if (needExpandGroupRow || needExpandMasterDetailRow) {
      const item = this._dataController.items()[rowIndex];
      const isNotContinuation = (null === item || void 0 === item ? void 0 : item.data) && !item.data.isContinuation;
      if (isDefined(key) && isNotContinuation) {
        this._dataController.changeRowExpand(key);
      }
    } else if (needExpandAdaptiveRow) {
      this._adaptiveColumnsController.toggleExpandAdaptiveDetailRow(key);
      this._updateFocusedCellPosition($cell);
    } else if (null !== (_this$getMasterDetail = this.getMasterDetailCell($cell)) && void 0 !== _this$getMasterDetail && _this$getMasterDetail.is($cell)) {
      if ($cell.is(":focus")) {
        this.focusFirstInteractiveElementInside($cell);
      }
    } else if (!(null !== $cell && void 0 !== $cell && $cell.hasClass(COMMAND_EDIT_CLASS))) {
      this._processEnterKeyForDataCell(eventArgs, isEditing);
    }
  }
  focusFirstInteractiveElementInside($el) {
    $el.find(INTERACTIVE_ELEMENTS_SELECTOR).get(0).focus();
  }
  _processEnterKeyForDataCell(eventArgs, isEditing) {
    const direction = this._getEnterKeyDirection(eventArgs);
    const allowEditingOnEnterKey = this._allowEditingOnEnterKey();
    if (isEditing || !allowEditingOnEnterKey && direction) {
      this._handleEnterKeyEditingCell(eventArgs.originalEvent).done((() => {
        if ("next" === direction || "previous" === direction) {
          this._targetCellTabHandler(eventArgs, direction);
        } else if ("upArrow" === direction || "downArrow" === direction) {
          this._navigateNextCell(eventArgs.originalEvent, direction);
        }
      }));
    } else if (allowEditingOnEnterKey) {
      this._startEditing(eventArgs);
    }
  }
  _getEnterKeyDirection(eventArgs) {
    const enterKeyDirection = this.option("keyboardNavigation.enterKeyDirection");
    const isShift = eventArgs.shift;
    if ("column" === enterKeyDirection) {
      return isShift ? "upArrow" : "downArrow";
    }
    if ("row" === enterKeyDirection) {
      return isShift ? "previous" : "next";
    }
    return;
  }
  _handleEnterKeyEditingCell(event) {
    const d = Deferred();
    const {
      target
    } = event;
    const $cell = this._getCellElementFromTarget(target);
    const isRowEditMode = this._isRowEditMode();
    this._updateFocusedCellPosition($cell);
    if (isRowEditMode) {
      this._focusEditFormCell($cell);
      setTimeout(this._editingController.saveEditData.bind(this._editingController));
      d.resolve();
    } else {
      m_events_engine_default.trigger(renderer_default(target), "change");
      this._closeEditCell().always(d.resolve);
      event.preventDefault();
    }
    return d;
  }
  _escapeKeyHandler(eventArgs, isEditing) {
    const $cell = this._getCellElementFromTarget(eventArgs.originalEvent.target);
    if (isEditing) {
      this._updateFocusedCellPosition($cell);
      if (!this._isRowEditMode()) {
        if ("cell" === this._editingController.getEditMode()) {
          this._editingController.cancelEditData();
        } else {
          this._closeEditCell();
        }
      } else {
        this._focusEditFormCell($cell);
        this._editingController.cancelEditData();
        if (0 === this._dataController.items().length) {
          this._resetFocusedCell();
          this._editorFactory.loseFocus();
        }
      }
      eventArgs.originalEvent.preventDefault();
      return true;
    }
    const masterDetailCell = this.getMasterDetailCell($cell);
    if (masterDetailCell) {
      this._focusCell(masterDetailCell);
      return true;
    }
    return false;
  }
  _ctrlFKeyHandler(eventArgs) {
    if (this.option("searchPanel.visible")) {
      const searchTextEditor = this._headerPanel.getSearchTextEditor();
      if (searchTextEditor) {
        searchTextEditor.focus();
        eventArgs.originalEvent.preventDefault();
      }
    }
  }
  _f2KeyHandler() {
    const isEditing = this._editingController.isEditing();
    const rowIndex = this.getVisibleRowIndex();
    const $row = this._focusedView && this._focusedView.getRow(rowIndex);
    if (!isEditing && isDataRow($row)) {
      this._startEditing();
    }
  }
  _navigateNextCell($event, keyCode) {
    const $cell = this._getNextCell(keyCode);
    const directionCode = this._getDirectionCodeByKey(keyCode);
    const isCellValid = $cell && this._isCellValid($cell);
    const result = isCellValid ? this._arrowKeysHandlerFocusCell($event, $cell, directionCode) : false;
    return result;
  }
  _arrowKeysHandlerFocusCell($event, $nextCell, direction) {
    const isVerticalDirection = "prevRow" === direction || "nextRow" === direction;
    const args = this._fireFocusChangingEvents($event, $nextCell, isVerticalDirection, true);
    $nextCell = args.$newCellElement;
    if (!args.cancel && this._isCellValid($nextCell)) {
      this._focus($nextCell, !args.isHighlighted);
      return true;
    }
    return false;
  }
  _beginFastEditing(originalEvent, isDeleting) {
    if (!this._isFastEditingAllowed() || originalEvent.altKey || originalEvent.ctrlKey || this._editingController.isEditing()) {
      return false;
    }
    if (isDeleting) {
      this._startEditing(originalEvent, FAST_EDITING_DELETE_KEY);
    } else {
      const {
        key
      } = originalEvent;
      const keyCode = originalEvent.keyCode || originalEvent.which;
      const fastEditingKey = key || keyCode && String.fromCharCode(keyCode);
      if (fastEditingKey && (1 === fastEditingKey.length || fastEditingKey === FAST_EDITING_DELETE_KEY)) {
        this._startEditing(originalEvent, fastEditingKey);
      }
    }
    return true;
  }
  isQuickNavigationPossible() {
    var _this$_rowsView4, _this$_editingControl4, _this$_editingControl5;
    const visibleRowIndex = this.getVisibleRowIndex();
    const $row = null === (_this$_rowsView4 = this._rowsView) || void 0 === _this$_rowsView4 ? void 0 : _this$_rowsView4.getRow(visibleRowIndex);
    const dataRowTemplate = this.option("dataRowTemplate");
    const isEditRowByIndex = null === (_this$_editingControl4 = this._editingController) || void 0 === _this$_editingControl4 || null === (_this$_editingControl5 = _this$_editingControl4.isEditRowByIndex) || void 0 === _this$_editingControl5 ? void 0 : _this$_editingControl5.call(_this$_editingControl4, visibleRowIndex);
    return !isEditRowByIndex && !dataRowTemplate && isDataRow($row);
  }
  getFirstOrLastColumnIndex(needFirstColumnIndex) {
    const allVisibleColumns = this._columnsController.getVisibleColumns(null, true);
    const findColumnIndex = (column) => this.isFocusableColumn(column);
    return needFirstColumnIndex ? allVisibleColumns.findIndex(findColumnIndex) : allVisibleColumns.findLastIndex(findColumnIndex);
  }
  getFirstOrLastRowIndex(needFirstRow) {
    var _this$_dataController;
    const rowCount = this._isVirtualScrolling() ? this._dataController.totalItemsCount() : null === (_this$_dataController = this._dataController.items(true)) || void 0 === _this$_dataController ? void 0 : _this$_dataController.length;
    return needFirstRow ? 0 : rowCount - 1;
  }
  calculateScrollLeft(needScrollToFirstCell) {
    var _this$_columnsControl;
    const result = needScrollToFirstCell ? 0 : this._getMaxHorizontalOffset();
    const isNeedToRenderVirtualColumns = null === (_this$_columnsControl = this._columnsController) || void 0 === _this$_columnsControl ? void 0 : _this$_columnsControl.isNeedToRenderVirtualColumns(result);
    return isNeedToRenderVirtualColumns ? result : -1;
  }
  calculateScrollTop(needScrollToFirstCell) {
    const maxVerticalOffset = this._getMaxVerticalOffset();
    const hasScroll = maxVerticalOffset > 0;
    const isVirtualRowRender = this._isVirtualRowRender();
    if (isVirtualRowRender && hasScroll) {
      return needScrollToFirstCell ? 0 : maxVerticalOffset;
    }
    return -1;
  }
  scrollTo(scrollOffset) {
    var _this$_rowsView5;
    const scrollable = null === (_this$_rowsView5 = this._rowsView) || void 0 === _this$_rowsView5 ? void 0 : _this$_rowsView5.getScrollable();
    null === scrollable || void 0 === scrollable || scrollable.scrollTo(scrollOffset);
  }
  focusFirstOrLastCell(e) {
    var _this$_rowsView$getSc;
    const $cell = this._getFocusedCell();
    this._focusElement($cell, true, e);
    null === (_this$_rowsView$getSc = this._rowsView.getScrollable()) || void 0 === _this$_rowsView$getSc || _this$_rowsView$getSc.update();
  }
  navigateToFirstOrLastRow(needNavigateToFirstCell, e) {
    const scrollTop = this.calculateScrollTop(needNavigateToFirstCell);
    const firstOrLastRowIndex = this.getFirstOrLastRowIndex(needNavigateToFirstCell);
    const firstOrLastColumnIndex = this.getFirstOrLastColumnIndex(needNavigateToFirstCell);
    this.silentUpdateFocusedCellPosition({
      columnIndex: firstOrLastColumnIndex,
      rowIndex: firstOrLastRowIndex
    });
    if (scrollTop >= 0) {
      this._needNavigationToCell = true;
      this.scrollTo({
        top: scrollTop
      });
    } else {
      this.navigateToFirstOrLastCell(needNavigateToFirstCell, e);
    }
  }
  homeOrEndKeyHandler(e) {
    if (!this.isQuickNavigationPossible()) {
      return;
    }
    const needNavigateToFirstCell = "home" === e.keyName;
    const {
      originalEvent
    } = e;
    if (isCommandKeyPressed(originalEvent)) {
      this.navigateToFirstOrLastRow(needNavigateToFirstCell, originalEvent);
    } else {
      this.navigateToFirstOrLastCell(needNavigateToFirstCell, originalEvent);
    }
    originalEvent.preventDefault();
  }
  isFocusableColumn(column) {
    return column.type !== DRAG_COLUMN_NAME;
  }
  navigateToFirstOrLastCell(needNavigateToFirstCell, e) {
    const firstOrLastColumnIndex = this.getFirstOrLastColumnIndex(needNavigateToFirstCell);
    this._needNavigationToCell = false;
    if (firstOrLastColumnIndex < 0) {
      return;
    }
    const scrollLeft = this.calculateScrollLeft(needNavigateToFirstCell);
    this.silentUpdateFocusedCellPosition({
      columnIndex: firstOrLastColumnIndex
    });
    if (scrollLeft >= 0) {
      this.needToRestoreFocus = true;
      this.scrollTo({
        left: scrollLeft
      });
    } else {
      this.focusFirstOrLastCell(e);
    }
  }
  isQuickNavigationToFirstCell() {
    var _this$_focusedCellPos2;
    const firstColumnIndex = this.getFirstOrLastColumnIndex(true);
    return (null === (_this$_focusedCellPos2 = this._focusedCellPosition) || void 0 === _this$_focusedCellPos2 ? void 0 : _this$_focusedCellPos2.columnIndex) === firstColumnIndex;
  }
  _pointerEventHandler(e) {
    var _this$_rowsView6;
    const event = e.event || e;
    let $target = renderer_default(event.currentTarget);
    const focusedViewElement = null === (_this$_rowsView6 = this._rowsView) || void 0 === _this$_rowsView6 ? void 0 : _this$_rowsView6.element();
    const $parent = $target.parent();
    const isInteractiveElement = renderer_default(event.target).is(INTERACTIVE_ELEMENTS_SELECTOR);
    const isRevertButton = !!renderer_default(event.target).closest(`.${REVERT_BUTTON_CLASS}`).length;
    const isExpandCommandCell = $target.hasClass(COMMAND_EXPAND_CLASS);
    if (!this._isEventInCurrentGrid(event)) {
      return;
    }
    if (!isRevertButton && (this._isCellValid($target, !isInteractiveElement) || isExpandCommandCell)) {
      $target = this._isInsideEditForm($target) ? renderer_default(event.target) : $target;
      this._focusView();
      renderer_default(focusedViewElement).removeClass(FOCUS_STATE_CLASS);
      if ($parent.hasClass(FREESPACE_ROW_CLASS)) {
        this._updateFocusedCellPosition($target);
        this._applyTabIndexToElement(this._focusedView.element());
        this._focusedView.focus(true);
      } else if (!this.getMasterDetailCell($target)) {
        this._clickTargetCellHandler(event, $target);
      } else {
        this._updateFocusedCellPosition($target);
      }
    } else if ($target.is("td")) {
      this._resetFocusedCell();
    }
  }
  _clickTargetCellHandler(event, $cell) {
    const column = this._getColumnByCellElement($cell);
    const isCellEditMode = this._isCellEditMode();
    const isEditing = this._editingController.isEditing();
    this.setCellFocusType();
    const args = this._fireFocusChangingEvents(event, $cell, true);
    $cell = args.$newCellElement;
    if (!args.cancel) {
      if (args.resetFocusedRow) {
        this._focusController._resetFocusedRow();
        return;
      }
      if (args.rowIndexChanged) {
        $cell = this._getFocusedCell();
      }
      if (!args.isHighlighted && !isCellEditMode) {
        this.setRowFocusType();
      }
      this._updateFocusedCellPosition($cell);
      if (this._allowRowUpdating() && isCellEditMode && column && column.allowEditing) {
        this._isNeedFocus = false;
        this._isHiddenFocus = false;
      } else {
        $cell = this._getFocusedCell();
        const $target = event && renderer_default(event.target).closest(`${NON_FOCUSABLE_ELEMENTS_SELECTOR}, td`);
        const skipFocusEvent = $target && $target.not($cell).is(NON_FOCUSABLE_ELEMENTS_SELECTOR);
        const isEditCell = !(null !== column && void 0 !== column && column.command) && isEditing && $cell.hasClass(EDITOR_CELL_CLASS);
        const isDisabled = !isEditCell && (!args.isHighlighted || skipFocusEvent);
        this._focus($cell, isDisabled, skipFocusEvent);
      }
    } else {
      this.setRowFocusType();
      this.setFocusedRowIndex(args.prevRowIndex);
      if (isEditing && isCellEditMode) {
        this._closeEditCell();
      }
    }
  }
  _allowRowUpdating() {
    const rowIndex = this.getVisibleRowIndex();
    const row = this._dataController.items()[rowIndex];
    return this._editingController.allowUpdating({
      row
    }, "click");
  }
  focus(element) {
    let activeElementSelector;
    const focusedRowEnabled = this.option("focusedRowEnabled");
    const isHighlighted = this._isCellElement(renderer_default(element));
    if (!element) {
      activeElementSelector = `.${this.addWidgetPrefix(ROWS_VIEW_CLASS)} .dx-row[tabindex]`;
      if (!focusedRowEnabled) {
        activeElementSelector += `, .${this.addWidgetPrefix(ROWS_VIEW_CLASS)} .dx-row > td[tabindex]`;
      }
      element = this.component.$element().find(activeElementSelector).first();
    }
    element && this._focusElement(renderer_default(element), isHighlighted);
  }
  getFocusedView() {
    return this.getView("rowsView");
  }
  setupFocusedView() {
    if (this.isKeyboardEnabled() && !isDefined(this._focusedView)) {
      this._focusView();
    }
  }
  _focusElement($element, isHighlighted, event) {
    const rowsViewElement = renderer_default(this._getRowsViewElement());
    const $focusedView = $element.closest(rowsViewElement);
    const isRowFocusType = this.isRowFocusType();
    let args = {};
    if (!$focusedView.length || this._isCellElement($element) && !this._isCellValid($element)) {
      return;
    }
    this._focusView();
    this._isNeedFocus = true;
    this._isNeedScroll = true;
    if (this._isCellElement($element) || isGroupRow2($element)) {
      this.setCellFocusType();
      args = this._fireFocusChangingEvents(event, $element, true, isHighlighted);
      $element = args.$newCellElement;
      if (isRowFocusType && !args.isHighlighted) {
        this.setRowFocusType();
      }
    }
    if (!args.cancel) {
      this._focus($element, !args.isHighlighted);
      if ("row" !== this._getElementType($element) || isEditRow($element)) {
        this._focusInteractiveElement($element);
      }
    }
  }
  isInsideFocusedView($element) {
    var _this$_focusedView2;
    return 0 !== $element.closest(null === (_this$_focusedView2 = this._focusedView) || void 0 === _this$_focusedView2 ? void 0 : _this$_focusedView2.element()).length;
  }
  _focusView() {
    this._focusedView = this._rowsView;
  }
  _resetFocusedView() {
    this.setRowFocusType();
    this._focusedView = null;
  }
  _focusInteractiveElement($cell, isLast) {
    if (!$cell) {
      return;
    }
    const $focusedElement = getInteractiveElement($cell, isLast);
    m_utils_default.focusAndSelectElement(this, $focusedElement);
  }
  _focus($cell, disableFocus, skipFocusEvent) {
    const $row = $cell && !$cell.hasClass(ROW_CLASS) ? $cell.closest(`.${ROW_CLASS}`) : $cell;
    if ($row && isNotFocusedRow($row)) {
      return;
    }
    const focusedView = this._focusedView;
    const $focusViewElement = focusedView && focusedView.element();
    let $focusElement;
    this._isHiddenFocus = disableFocus;
    const isRowFocus = isGroupRow2($row) || isGroupFooterRow($row) || this.isRowFocusType();
    if (isRowFocus) {
      $focusElement = $row;
      if (focusedView) {
        this.setFocusedRowIndex(this._getRowIndex($row));
      }
    } else if (this._isCellElement($cell)) {
      $focusElement = $cell;
      this._updateFocusedCellPosition($cell);
    }
    if ($focusElement) {
      if ($focusViewElement) {
        $focusViewElement.find(".dx-row[tabindex], .dx-row > td[tabindex]").filter(((i, node) => m_utils_default.isElementInCurrentGrid(this, renderer_default(node)))).not($focusElement).removeClass(CELL_FOCUS_DISABLED_CLASS).removeClass(FOCUSED_CLASS).removeAttr("tabindex");
      }
      m_events_engine_default.one($focusElement, "blur", ((e) => {
        if (e.relatedTarget) {
          $focusElement.removeClass(CELL_FOCUS_DISABLED_CLASS).removeClass(FOCUSED_CLASS);
        }
      }));
      if (!skipFocusEvent) {
        this._applyTabIndexToElement($focusElement);
        m_events_engine_default.trigger($focusElement, "focus");
      }
      if (disableFocus) {
        $focusElement.addClass(CELL_FOCUS_DISABLED_CLASS);
        if (isRowFocus) {
          $cell.addClass(CELL_FOCUS_DISABLED_CLASS);
        }
      } else {
        this._editorFactory.focus($focusElement);
      }
    }
  }
  _updateFocus(isRenderView) {
    let skipFocusEvent = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;
    this._updateFocusTimeout = setTimeout((() => {
      if (this._needFocusEditingCell()) {
        this._editingController._focusEditingCell();
        return;
      }
      let $cell = this._getFocusedCell();
      const isEditing = this._editingController.isEditing();
      if (!this.getMasterDetailCell($cell) || this._isRowEditMode()) {
        if (this._hasSkipRow($cell.parent())) {
          const direction = this._focusedCellPosition && this._focusedCellPosition.rowIndex > 0 ? "upArrow" : "downArrow";
          $cell = this._getNextCell(direction);
        }
        if (isElementDefined($cell)) {
          if ($cell.is("td") || $cell.hasClass(this.addWidgetPrefix(EDIT_FORM_ITEM_CLASS))) {
            const isCommandCell = $cell.is(COMMAND_CELL_SELECTOR);
            const $focusedElementInsideCell = $cell.find(":focus");
            const isFocusedElementDefined = isElementDefined($focusedElementInsideCell);
            const column = this._getColumnByCellElement($cell);
            if ((isRenderView || !isCommandCell) && this._editorFactory.focus()) {
              if (isCommandCell && isFocusedElementDefined) {
                m_utils_default.focusAndSelectElement(this, $focusedElementInsideCell);
                return;
              }
              !isFocusedElementDefined && this._focus($cell, false, skipFocusEvent);
            } else if (!isFocusedElementDefined && (this._isNeedFocus || this._isHiddenFocus)) {
              this._focus($cell, this._isHiddenFocus, skipFocusEvent);
            }
            if (isEditing && !(null !== column && void 0 !== column && column.showEditorAlways)) {
              this._focusInteractiveElement.bind(this)($cell);
            }
          } else {
            m_events_engine_default.trigger($cell, "focus");
          }
        }
      }
    }));
  }
  _needFocusEditingCell() {
    const isCellEditMode = this._editingController.getEditMode() === EDIT_MODE_CELL;
    const isBatchEditMode = this._editingController.getEditMode() === EDIT_MODE_BATCH;
    const cellEditModeHasChanges = isCellEditMode && this._editingController.hasChanges();
    const isNewRowBatchEditMode = isBatchEditMode && this._editingController.isNewRowInEditMode();
    const $cell = this._getFocusedCell();
    return (0 === $cell.children().length || $cell.find(FOCUSABLE_ELEMENT_SELECTOR).length > 0) && (cellEditModeHasChanges || isNewRowBatchEditMode);
  }
  _updateFocusedCellPositionByTarget(target) {
    var _this$_focusedCellPos3;
    const elementType = this._getElementType(target);
    if ("row" === elementType && isDefined(null === (_this$_focusedCellPos3 = this._focusedCellPosition) || void 0 === _this$_focusedCellPos3 ? void 0 : _this$_focusedCellPos3.columnIndex)) {
      const $row = renderer_default(target);
      this._focusedView && isGroupRow2($row) && this.setFocusedRowIndex(this._getRowIndex($row));
    } else {
      this._updateFocusedCellPosition(this._getCellElementFromTarget(target));
    }
  }
  _focusCell($cell, isDisabled) {
    if (this._isCellValid($cell)) {
      this._focus($cell, isDisabled);
      return true;
    }
    return;
  }
  _focusEditFormCell($cell) {
    if ($cell.hasClass(MASTER_DETAIL_CELL_CLASS)) {
      this._editorFactory.focus($cell, true);
    }
  }
  _resetFocusedCell(preventScroll) {
    var _this$_focusedView3;
    const $cell = this._getFocusedCell();
    isElementDefined($cell) && $cell.removeAttr("tabindex").removeClass(CELL_FOCUS_DISABLED_CLASS);
    this._isNeedFocus = false;
    this._isNeedScroll = false;
    this._focusedCellPosition = {};
    clearTimeout(this._updateFocusTimeout);
    null === (_this$_focusedView3 = this._focusedView) || void 0 === _this$_focusedView3 || _this$_focusedView3.renderFocusState({
      preventScroll
    });
  }
  restoreFocusableElement(rowIndex, $event) {
    const that = this;
    let args;
    let $rowElement;
    const isUpArrow = isDefined(rowIndex);
    const $rowsViewElement = this._rowsView.element();
    const {
      columnIndex
    } = that._focusedCellPosition;
    const rowIndexOffset = that._dataController.getRowIndexOffset();
    rowIndex = isUpArrow ? rowIndex : this._rowsView.getTopVisibleItemIndex() + rowIndexOffset;
    if (!isUpArrow) {
      that._editorFactory.loseFocus();
      that._applyTabIndexToElement($rowsViewElement);
      m_events_engine_default.trigger($rowsViewElement, "focus");
    } else {
      $rowElement = this._rowsView.getRow(rowIndex - rowIndexOffset);
      args = that._fireFocusedRowChanging($event, $rowElement);
      if (!args.cancel && args.rowIndexChanged) {
        rowIndex = args.newRowIndex;
      }
    }
    if (!isUpArrow || !args.cancel) {
      that.setFocusedCellPosition(rowIndex, columnIndex);
    }
    isUpArrow && that._updateFocus();
  }
  silentUpdateFocusedCellPosition(newFocusedCellPosition) {
    this._focusedCellPosition = _extends({}, this._focusedCellPosition ?? {}, newFocusedCellPosition);
  }
  _getNewPositionByCode(cellPosition, elementType, code) {
    let {
      columnIndex
    } = cellPosition;
    let {
      rowIndex
    } = cellPosition;
    let visibleColumnsCount;
    if (void 0 === cellPosition.rowIndex && "next" === code) {
      return {
        columnIndex: 0,
        rowIndex: 0
      };
    }
    switch (code) {
      case "nextInRow":
      case "next":
        visibleColumnsCount = this._getVisibleColumnCount();
        if (columnIndex < visibleColumnsCount - 1 && "row" !== elementType && this._hasValidCellAfterPosition({
          columnIndex,
          rowIndex
        })) {
          columnIndex++;
        } else if (!this._isLastRow(rowIndex) && "next" === code) {
          columnIndex = 0;
          rowIndex++;
        }
        break;
      case "previousInRow":
      case "previous":
        if (columnIndex > 0 && "row" !== elementType && this._hasValidCellBeforePosition({
          columnIndex,
          rowIndex
        })) {
          columnIndex--;
        } else if (rowIndex > 0 && "previous" === code) {
          rowIndex--;
          visibleColumnsCount = this._getVisibleColumnCount();
          columnIndex = visibleColumnsCount - 1;
        }
        break;
      case "upArrow":
        rowIndex = rowIndex > 0 ? rowIndex - 1 : rowIndex;
        break;
      case "downArrow":
        rowIndex = !this._isLastRow(rowIndex) ? rowIndex + 1 : rowIndex;
    }
    return {
      columnIndex,
      rowIndex
    };
  }
  getRowIndex() {
    return this._focusedCellPosition ? this._focusedCellPosition.rowIndex : -1;
  }
  getColumnIndex() {
    return this._focusedCellPosition ? this._focusedCellPosition.columnIndex : -1;
  }
  getVisibleRowIndex() {
    var _this$_focusedCellPos4;
    const rowIndex = null === (_this$_focusedCellPos4 = this._focusedCellPosition) || void 0 === _this$_focusedCellPos4 ? void 0 : _this$_focusedCellPos4.rowIndex;
    return !isDefined(rowIndex) || rowIndex < 0 ? -1 : rowIndex - this._dataController.getRowIndexOffset();
  }
  getVisibleColumnIndex() {
    var _this$_focusedCellPos5;
    const columnIndex = null === (_this$_focusedCellPos5 = this._focusedCellPosition) || void 0 === _this$_focusedCellPos5 ? void 0 : _this$_focusedCellPos5.columnIndex;
    return !isDefined(columnIndex) ? -1 : columnIndex - this._columnsController.getColumnIndexOffset();
  }
  _isCellByPositionValid(cellPosition) {
    const $cell = renderer_default(this._getCell(cellPosition));
    return this._isCellValid($cell);
  }
  _isLastRow(rowIndex) {
    const dataController2 = this._dataController;
    if (this._isVirtualRowRender()) {
      return rowIndex >= dataController2.getMaxRowIndex();
    }
    const lastVisibleIndex = Math.max(...dataController2.items().map(((item, index) => false !== item.visible ? index : -1)));
    return rowIndex === lastVisibleIndex;
  }
  _isFirstValidCell(cellPosition) {
    let isFirstValidCell = false;
    if (0 === cellPosition.rowIndex && cellPosition.columnIndex >= 0) {
      isFirstValidCell = isFirstValidCell || !this._hasValidCellBeforePosition(cellPosition);
    }
    return isFirstValidCell;
  }
  _hasValidCellBeforePosition(cellPosition) {
    let {
      columnIndex
    } = cellPosition;
    let hasValidCells = false;
    while (columnIndex > 0 && !hasValidCells) {
      const checkingPosition = {
        columnIndex: --columnIndex,
        rowIndex: cellPosition.rowIndex
      };
      hasValidCells = this._isCellByPositionValid(checkingPosition);
    }
    return hasValidCells;
  }
  _hasValidCellAfterPosition(cellPosition) {
    let {
      columnIndex
    } = cellPosition;
    let hasValidCells = false;
    const visibleColumnCount = this._getVisibleColumnCount();
    while (columnIndex < visibleColumnCount - 1 && !hasValidCells) {
      const checkingPosition = {
        columnIndex: ++columnIndex,
        rowIndex: cellPosition.rowIndex
      };
      hasValidCells = this._isCellByPositionValid(checkingPosition);
    }
    return hasValidCells;
  }
  _isLastValidCell(cellPosition) {
    const nextColumnIndex = cellPosition.columnIndex >= 0 ? cellPosition.columnIndex + 1 : 0;
    const {
      rowIndex
    } = cellPosition;
    const checkingPosition = {
      columnIndex: nextColumnIndex,
      rowIndex
    };
    const visibleRows = this._dataController.getVisibleRows();
    const row = visibleRows && visibleRows[rowIndex];
    const isLastRow = this._isLastRow(rowIndex);
    if (!isLastRow) {
      return false;
    }
    const isFullRowFocus = "group" === (null === row || void 0 === row ? void 0 : row.rowType) || "groupFooter" === (null === row || void 0 === row ? void 0 : row.rowType);
    if (isFullRowFocus && cellPosition.columnIndex > 0) {
      return true;
    }
    if (cellPosition.columnIndex === this._getVisibleColumnCount() - 1) {
      return true;
    }
    if (this._isCellByPositionValid(checkingPosition)) {
      return false;
    }
    return this._isLastValidCell(checkingPosition);
  }
  _isCellValid($cell, isClick) {
    if (isElementDefined($cell)) {
      const $row = $cell.parent();
      const columnIndex = this._rowsView.getCellIndex($cell) + this._columnsController.getColumnIndexOffset();
      const column = this._getColumnByCellElement($cell);
      const visibleColumnCount = this._getVisibleColumnCount();
      const editingController = this._editingController;
      const isMasterDetailRow = isDetailRow2($row);
      const isShowWhenGrouped = column && column.showWhenGrouped;
      const isDataCell = column && !$cell.hasClass(COMMAND_EXPAND_CLASS) && isDataRow($row);
      const isValidGroupSpaceColumn = function() {
        return !isMasterDetailRow && column && (!isDefined(column.groupIndex) || isShowWhenGrouped && isDataCell) || parseInt($cell.attr("colspan"), 10) > 1;
      };
      const isDragCell2 = GridCoreKeyboardNavigationDom.isDragCell($cell);
      if (isDragCell2) {
        return false;
      }
      if (this.getMasterDetailCell($cell)) {
        return true;
      }
      if (visibleColumnCount > columnIndex && isValidGroupSpaceColumn()) {
        const rowItems = this._dataController.items();
        const visibleRowIndex = this._rowsView.getRowIndex($row);
        const row = rowItems[visibleRowIndex];
        const isCellEditing = editingController && this._isCellEditMode() && editingController.isEditing();
        const isRowEditingInCurrentRow = editingController && editingController.isEditRow(visibleRowIndex);
        const isEditing = isRowEditingInCurrentRow || isCellEditing;
        if (column.command) {
          if (this._isLegacyNavigation()) {
            return !isEditing && "expand" === column.command;
          }
          if (isCellEditing) {
            return false;
          }
          if (isRowEditingInCurrentRow) {
            return "select" !== column.command;
          }
          return !isEditing;
        }
        if (isCellEditing && row && "data" !== row.rowType) {
          return false;
        }
        return !isEditing || column.allowEditing || isClick;
      }
    }
  }
  getFirstValidCellInRow($row, columnIndex) {
    const that = this;
    const $cells = $row.find("> td");
    let $cell;
    let $result;
    columnIndex = columnIndex || 0;
    for (let i = columnIndex; i < $cells.length; ++i) {
      $cell = $cells.eq(i);
      if (that._isCellValid($cell)) {
        $result = $cell;
        break;
      }
    }
    return $result;
  }
  _getNextCell(keyCode, elementType, cellPosition) {
    const focusedCellPosition = cellPosition || this._focusedCellPosition;
    const isRowFocusType = this.isRowFocusType();
    const includeCommandCells = isRowFocusType || ["next", "previous"].includes(keyCode);
    let $cell;
    let $row;
    if (this._focusedView && focusedCellPosition) {
      const newFocusedCellPosition = this._getNewPositionByCode(focusedCellPosition, elementType, keyCode);
      $cell = renderer_default(this._getCell(newFocusedCellPosition));
      const isLastCellOnDirection = "previous" === keyCode ? this._isFirstValidCell(newFocusedCellPosition) : this._isLastValidCell(newFocusedCellPosition);
      if (isElementDefined($cell) && !this._isCellValid($cell) && this._isCellInRow(newFocusedCellPosition, includeCommandCells) && !isLastCellOnDirection) {
        if (isRowFocusType) {
          $cell = this.getFirstValidCellInRow($cell.parent(), newFocusedCellPosition.columnIndex);
        } else {
          $cell = this._getNextCell(keyCode, "cell", newFocusedCellPosition);
        }
      }
      $row = isElementDefined($cell) && $cell.parent();
      if (this._hasSkipRow($row)) {
        const rowIndex = this._getRowIndex($row);
        if (!this._isLastRow(rowIndex)) {
          $cell = this._getNextCell(keyCode, "row", {
            columnIndex: focusedCellPosition.columnIndex,
            rowIndex
          });
        } else {
          return null;
        }
      }
      return isElementDefined($cell) ? $cell : null;
    }
    return null;
  }
  _startEditing(eventArgs, fastEditingKey) {
    const focusedCellPosition = this._focusedCellPosition;
    const visibleRowIndex = this.getVisibleRowIndex();
    const visibleColumnIndex = this.getVisibleColumnIndex();
    const row = this._dataController.items()[visibleRowIndex];
    const column = this._columnsController.getVisibleColumns()[visibleColumnIndex];
    if (this._isAllowEditing(row, column)) {
      if (this._isRowEditMode()) {
        this._editingController.editRow(visibleRowIndex);
      } else if (focusedCellPosition) {
        this._startEditCell(eventArgs, fastEditingKey);
      }
    }
  }
  _isAllowEditing(row, column) {
    return this._editingController.allowUpdating({
      row
    }) && column && column.allowEditing;
  }
  _editFocusedCell() {
    const rowIndex = this.getVisibleRowIndex();
    const colIndex = this.getVisibleColumnIndex();
    return this._editingController.editCell(rowIndex, colIndex);
  }
  _startEditCell(eventArgs, fastEditingKey) {
    this._fastEditingStarted = isDefined(fastEditingKey);
    const editResult = this._editFocusedCell();
    const isEditResultDeferred = isDeferred(editResult);
    const isFastEditingStarted = this._isFastEditingStarted();
    if (!isFastEditingStarted || !isEditResultDeferred && !editResult) {
      return;
    }
    const editorValue = isEditResultDeferred && fastEditingKey === FAST_EDITING_DELETE_KEY ? "" : fastEditingKey;
    const editResultDeferred = isEditResultDeferred ? editResult : Deferred().resolve();
    const waitTemplatesDeferred = this._rowsView.waitAsyncTemplates(true);
    when(editResultDeferred, waitTemplatesDeferred).done((() => {
      this._editingCellHandler(eventArgs, editorValue);
    }));
  }
  _editingCellHandler(eventArgs, editorValue) {
    var _$inputElement$select;
    const $input = this._getFocusedCell().find(INTERACTIVE_ELEMENTS_SELECTOR).eq(0);
    const $inputElement = $input.get(0);
    if (!$inputElement) {
      return;
    }
    const keyDownEvent = createEvent(eventArgs, {
      type: "keydown",
      target: $inputElement
    });
    const keyPressEvent = createEvent(eventArgs, {
      type: "keypress",
      target: $inputElement
    });
    const inputEvent = createEvent(eventArgs, {
      type: "input",
      target: $inputElement
    });
    if (inputEvent.originalEvent) {
      inputEvent.originalEvent = createEvent(inputEvent.originalEvent, {
        data: editorValue
      });
    }
    null === (_$inputElement$select = $inputElement.select) || void 0 === _$inputElement$select || _$inputElement$select.call($inputElement);
    m_events_engine_default.trigger($input, keyDownEvent);
    if (!keyDownEvent.isDefaultPrevented()) {
      m_events_engine_default.trigger($input, keyPressEvent);
      if (!keyPressEvent.isDefaultPrevented()) {
        const timeout = browser_default.mozilla ? 25 : 0;
        setTimeout((() => {
          const inputValue = this._getKeyPressInputValue($input, editorValue);
          $input.val(inputValue);
          const $widgetContainer = $input.closest(`.${WIDGET_CLASS}`);
          m_events_engine_default.off($widgetContainer, "focusout");
          m_events_engine_default.one($widgetContainer, "focusout", (() => {
            m_events_engine_default.trigger($input, "change");
          }));
          m_events_engine_default.trigger($input, inputEvent);
        }), timeout);
      }
    }
  }
  _getKeyPressInputValue($input, editorValue) {
    const inputCurrentValue = $input.val();
    return "-" === editorValue && "-0" === inputCurrentValue ? "-0" : editorValue;
  }
  _fireFocusChangingEvents($event, $cell, fireRowEvent, isHighlighted) {
    let args = {};
    const cellPosition = this._getCellPosition($cell) ?? {};
    if (this.isCellFocusType()) {
      args = this._fireFocusedCellChanging($event, $cell, isHighlighted);
      if (!args.cancel) {
        cellPosition.columnIndex = args.newColumnIndex;
        cellPosition.rowIndex = args.newRowIndex;
        isHighlighted = args.isHighlighted;
        $cell = renderer_default(this._getCell(cellPosition));
      }
    }
    if (!args.cancel && fireRowEvent && $cell) {
      args = this._fireFocusedRowChanging($event, $cell.parent());
      if (!args.cancel) {
        cellPosition.rowIndex = args.newRowIndex;
        args.isHighlighted = isHighlighted;
      }
    }
    args.$newCellElement = renderer_default(this._getCell(cellPosition));
    if (!args.$newCellElement.length) {
      args.$newCellElement = $cell;
    }
    return args;
  }
  _fireFocusedCellChanging($event, $cellElement, isHighlighted) {
    const prevColumnIndex = this.option("focusedColumnIndex");
    const prevRowIndex = this.option("focusedRowIndex");
    const cellPosition = this._getCellPosition($cellElement);
    const columnIndex = cellPosition ? cellPosition.columnIndex : -1;
    const rowIndex = cellPosition ? cellPosition.rowIndex : -1;
    const visibleRows = this._dataController.getVisibleRows();
    const visibleColumns = this._columnsController.getVisibleColumns();
    const args = {
      cellElement: $cellElement,
      prevColumnIndex,
      prevRowIndex,
      newColumnIndex: columnIndex,
      newRowIndex: rowIndex,
      rows: visibleRows,
      columns: visibleColumns,
      event: $event,
      isHighlighted: isHighlighted || false,
      cancel: false
    };
    this._canceledCellPosition = null;
    this.executeAction("onFocusedCellChanging", args);
    if (args.newColumnIndex !== columnIndex || args.newRowIndex !== rowIndex) {
      args.$newCellElement = renderer_default(this._getCell({
        columnIndex: args.newColumnIndex,
        rowIndex: args.newRowIndex
      }));
    }
    if (args.cancel) {
      this._canceledCellPosition = {
        rowIndex,
        columnIndex
      };
    }
    return args;
  }
  _fireFocusedCellChanged($cell) {
    const columnIndex = this._rowsView.getCellIndex($cell);
    const rowOptions = null === $cell || void 0 === $cell ? void 0 : $cell.parent().data("options");
    const focusedRowKey = null === rowOptions || void 0 === rowOptions ? void 0 : rowOptions.key;
    this._memoFireFocusedCellChanged(focusedRowKey, columnIndex);
  }
  _memoFireFocusedCellChanged(rowKey, columnIndex) {
    const $cell = this._getFocusedCell();
    const $row = null === $cell || void 0 === $cell ? void 0 : $cell.parent();
    const rowIndex = this.getRowIndex();
    const localRowIndex = Math.min(this._getLocalRowIndex($row), this._dataController.items().length - 1);
    const isEditingCell2 = this._editingController.isEditCell(localRowIndex, columnIndex);
    if (isEditingCell2) {
      return;
    }
    const row = this._dataController.items()[localRowIndex];
    const column = this._columnsController.getVisibleColumns()[columnIndex];
    this.executeAction("onFocusedCellChanged", {
      cellElement: $cell ? getPublicElement($cell) : void 0,
      columnIndex,
      rowIndex,
      row,
      column
    });
  }
  _fireFocusedRowChanging(eventArgs, $newFocusedRow) {
    const newRowIndex = this._getRowIndex($newFocusedRow);
    const prevFocusedRowIndex = this.option("focusedRowIndex");
    const loadingOperationTypes = this._dataController.loadingOperationTypes();
    const args = {
      rowElement: $newFocusedRow,
      prevRowIndex: prevFocusedRowIndex,
      newRowIndex,
      event: eventArgs,
      rows: this._dataController.getVisibleRows(),
      cancel: false
    };
    const loadingOperations = loadingOperationTypes.sorting || loadingOperationTypes.grouping || loadingOperationTypes.filtering || loadingOperationTypes.paging;
    if (!this._dataController || this._dataController.isLoading() && loadingOperations) {
      args.cancel = true;
      return args;
    }
    if (this.option("focusedRowEnabled")) {
      this.executeAction("onFocusedRowChanging", args);
      if (!args.cancel && args.newRowIndex !== newRowIndex) {
        args.resetFocusedRow = args.newRowIndex < 0;
        if (!args.resetFocusedRow) {
          this.setFocusedRowIndex(args.newRowIndex);
        }
        args.rowIndexChanged = true;
      }
    }
    return args;
  }
  _fireFocusedRowChanged() {
    var _this$_focusControlle;
    const focusedRowEnabled = this.option("focusedRowEnabled");
    const focusedRowKey = this.option("focusedRowKey");
    const focusedRowIndex = null === (_this$_focusControlle = this._focusController) || void 0 === _this$_focusControlle ? void 0 : _this$_focusControlle.getFocusedRowIndexByKey(focusedRowKey);
    if (!focusedRowEnabled || isDefined(focusedRowKey) && focusedRowIndex < 0) {
      return;
    }
    this._memoFireFocusedRowChanged(focusedRowKey, focusedRowIndex);
  }
  _memoFireFocusedRowChanged(focusedRowKey, focusedRowIndex) {
    const localRowIndex = focusedRowIndex - this._dataController.getRowIndexOffset();
    this.executeAction("onFocusedRowChanged", {
      rowElement: focusedRowIndex < 0 ? void 0 : this._rowsView.getRowElement(localRowIndex),
      rowIndex: focusedRowIndex,
      row: focusedRowIndex < 0 ? void 0 : this._dataController.getVisibleRows()[localRowIndex]
    });
  }
  _isEventInCurrentGrid(event) {
    return m_utils_default.isElementInCurrentGrid(this, renderer_default(event.target));
  }
  _isRowEditMode() {
    const editMode = this._editingController.getEditMode();
    return editMode === EDIT_MODE_ROW || editMode === EDIT_MODE_FORM;
  }
  _isCellEditMode() {
    const editMode = this._editingController.getEditMode();
    return editMode === EDIT_MODE_CELL || editMode === EDIT_MODE_BATCH;
  }
  _isFastEditingAllowed() {
    return this._isCellEditMode() && this.option("keyboardNavigation.editOnKeyPress");
  }
  _applyTabIndexToElement($element) {
    const tabIndex = this.option("tabIndex") ?? 0;
    $element.attr("tabindex", tabIndex);
  }
  _getCell(cellPosition) {
    if (this._focusedView && cellPosition) {
      const rowIndexOffset = this._dataController.getRowIndexOffset();
      const column = this._columnsController.getVisibleColumns(null, true)[cellPosition.columnIndex];
      const columnIndexOffset = column && column.fixed ? this._getFixedColumnIndexOffset(column) : this._columnsController.getColumnIndexOffset();
      const rowIndex = cellPosition.rowIndex >= 0 ? cellPosition.rowIndex - rowIndexOffset : -1;
      const columnIndex = cellPosition.columnIndex >= 0 ? cellPosition.columnIndex - columnIndexOffset : -1;
      return this._focusedView.getCell({
        rowIndex,
        columnIndex
      });
    }
  }
  _getRowIndex($row) {
    let rowIndex = this._getLocalRowIndex($row);
    if (rowIndex >= 0) {
      rowIndex += this._dataController.getRowIndexOffset();
    }
    return rowIndex;
  }
  _getLocalRowIndex($row) {
    const rowIndex = this._rowsView.getRowIndex($row);
    return rowIndex;
  }
  getCellIndex($cell, rowIndex) {
    return this._rowsView.getCellIndex($cell, rowIndex);
  }
  _hasSkipRow($row) {
    const row = $row && $row.get(0);
    return row && "none" === row.style.display;
  }
  _allowEditingOnEnterKey() {
    return "startEdit" === this.option("keyboardNavigation.enterKeyAction");
  }
  _isLegacyNavigation() {
    return this.option("useLegacyKeyboardNavigation");
  }
  _getDirectionCodeByKey(key) {
    let directionCode;
    switch (key) {
      case "upArrow":
        directionCode = "prevRow";
        break;
      case "downArrow":
        directionCode = "nextRow";
        break;
      case "leftArrow":
        directionCode = this.option("rtlEnabled") ? "nextInRow" : "previousInRow";
        break;
      case "rightArrow":
        directionCode = this.option("rtlEnabled") ? "previousInRow" : "nextInRow";
    }
    return directionCode;
  }
  _isVirtualScrolling() {
    const scrollingMode = this.option("scrolling.mode");
    return "virtual" === scrollingMode || "infinite" === scrollingMode;
  }
  _isVirtualRowRender() {
    return this._isVirtualScrolling() || m_utils_default.isVirtualRowRendering(this);
  }
  _isVirtualColumnRender() {
    return "virtual" === this.option("scrolling.columnRenderingMode");
  }
  _scrollBy(left, top, rowIndex, $event) {
    const that = this;
    const scrollable = this._rowsView.getScrollable();
    if (that._focusedCellPosition) {
      const scrollHandler = function() {
        scrollable.off("scroll", scrollHandler);
        setTimeout(that.restoreFocusableElement.bind(that, rowIndex, $event));
      };
      scrollable.on("scroll", scrollHandler);
    }
    return scrollable.scrollBy({
      left,
      top
    });
  }
  _isInsideEditForm(element) {
    const $editForm = renderer_default(element).closest(`.${this.addWidgetPrefix(EDIT_FORM_CLASS2)}`);
    return $editForm.length && this.elementIsInsideGrid($editForm);
  }
  getMasterDetailCell(element) {
    const $masterDetailCell = renderer_default(element).closest(`.${MASTER_DETAIL_CELL_CLASS}`);
    if ($masterDetailCell.length && this.elementIsInsideGrid($masterDetailCell)) {
      return $masterDetailCell;
    }
    return null;
  }
  _processNextCellInMasterDetail($nextCell, _$cell) {
    if (!this._isInsideEditForm($nextCell) && $nextCell) {
      this._applyTabIndexToElement($nextCell);
    }
  }
  _handleTabKeyOnMasterDetailCell(target, direction) {
    if (this.getMasterDetailCell(target)) {
      this._updateFocusedCellPosition(renderer_default(target), direction);
      const $nextCell = this._getNextCell(direction, "row");
      this._processNextCellInMasterDetail($nextCell, renderer_default(target));
      return true;
    }
    return false;
  }
  _getElementType(target) {
    return renderer_default(target).is("tr") ? "row" : "cell";
  }
  _isFastEditingStarted() {
    return this._isFastEditingAllowed() && this._fastEditingStarted;
  }
  _getVisibleColumnCount() {
    return this._columnsController.getVisibleColumns(null, true).length;
  }
  _isCellInRow(cellPosition, includeCommandCells) {
    const {
      columnIndex
    } = cellPosition;
    const visibleColumnsCount = this._getVisibleColumnCount();
    return includeCommandCells ? columnIndex >= 0 && columnIndex <= visibleColumnsCount - 1 : columnIndex > 0 && columnIndex < visibleColumnsCount - 1;
  }
  _isCellElement($element) {
    return $element.length && "TD" === $element[0].tagName;
  }
  _getCellElementFromTarget(target) {
    const elementType = this._getElementType(target);
    const $targetElement = renderer_default(target);
    let $cell;
    if ("cell" === elementType) {
      $cell = $targetElement.closest(`.${ROW_CLASS} > td`);
    } else {
      $cell = $targetElement.children().not(`.${COMMAND_EXPAND_CLASS}`).first();
    }
    return $cell;
  }
  _getRowsViewElement() {
    var _this$_rowsView7;
    return null === (_this$_rowsView7 = this._rowsView) || void 0 === _this$_rowsView7 ? void 0 : _this$_rowsView7.element();
  }
  _processCanceledEditCellPosition(rowIndex, columnIndex) {
    if (this._canceledCellPosition) {
      const isCanceled = this._canceledCellPosition.rowIndex === rowIndex && this._canceledCellPosition.columnIndex === columnIndex;
      this._canceledCellPosition = null;
      return isCanceled;
    }
    return;
  }
  updateFocusedRowIndex() {
    const dataController2 = this._dataController;
    const visibleRowIndex = this.getVisibleRowIndex();
    const visibleItems = dataController2.items();
    const lastVisibleIndex = visibleItems.length ? visibleItems.length - 1 : -1;
    const rowIndexOffset = dataController2.getRowIndexOffset();
    if (lastVisibleIndex >= 0 && visibleRowIndex > lastVisibleIndex) {
      this.setFocusedRowIndex(lastVisibleIndex + rowIndexOffset);
    }
  }
  needNavigationToCell() {
    return this._needNavigationToCell;
  }
  navigationToCellInProgress() {
    return this.needToRestoreFocus || this.needNavigationToCell();
  }
};
var rowsView10 = (Base) => class extends Base {
  _rowClick(e) {
    const editRowIndex = this._editingController.getEditRowIndex();
    const isKeyboardEnabled = this._keyboardNavigationController.isKeyboardEnabled();
    if (editRowIndex === e.rowIndex) {
      this._keyboardNavigationController.setCellFocusType();
    }
    const needTriggerPointerEventHandler = (isMobile() || !isKeyboardEnabled) && this.option("focusedRowEnabled");
    if (needTriggerPointerEventHandler) {
      this._triggerPointerDownEventHandler(e, !isKeyboardEnabled);
    }
    super._rowClick.apply(this, arguments);
  }
  _triggerPointerDownEventHandler(e, force) {
    const {
      originalEvent
    } = e.event;
    if (originalEvent) {
      const $cell = renderer_default(originalEvent.target);
      const columnIndex = this.getCellIndex($cell);
      const column = this._columnsController.getVisibleColumns()[columnIndex];
      const row = this._dataController.items()[e.rowIndex];
      if (this._keyboardNavigationController._isAllowEditing(row, column) || force) {
        const eventArgs = createEvent(originalEvent, {
          currentTarget: originalEvent.target
        });
        this._keyboardNavigationController._pointerEventHandler(eventArgs);
      }
    }
  }
  renderFocusState(params) {
    super.renderFocusState(params);
    if (this._keyboardNavigationController.navigationToCellInProgress()) {
      return;
    }
    const {
      preventScroll,
      pageSizeChanged
    } = params ?? {};
    const $rowsViewElement = this.element();
    if ($rowsViewElement && !focused($rowsViewElement)) {
      $rowsViewElement.attr("tabindex", null);
    }
    pageSizeChanged && this._keyboardNavigationController.updateFocusedRowIndex();
    let rowIndex = this._keyboardNavigationController.getVisibleRowIndex();
    if (!isDefined(rowIndex) || rowIndex < 0) {
      rowIndex = 0;
    }
    const cellElements = this.getCellElements(rowIndex);
    if (this._keyboardNavigationController.isKeyboardEnabled() && null !== cellElements && void 0 !== cellElements && cellElements.length) {
      this.updateFocusElementTabIndex(cellElements, preventScroll);
    }
  }
  updateFocusElementTabIndex(cellElements, preventScroll) {
    const $row = cellElements.eq(0).parent();
    if (isGroupRow2($row)) {
      this._keyboardNavigationController._applyTabIndexToElement($row);
    } else {
      let columnIndex = this._keyboardNavigationController.getColumnIndex();
      if (!isDefined(columnIndex) || columnIndex < 0) {
        columnIndex = 0;
      }
      this._updateFocusedCellTabIndex(cellElements, columnIndex);
    }
  }
  _updateFocusedCellTabIndex(cellElements, columnIndex) {
    const keyboardController = this._keyboardNavigationController;
    const cellElementsLength = cellElements ? cellElements.length : -1;
    const updateCellTabIndex = function($cell2) {
      const isMasterDetailCell = !!keyboardController.getMasterDetailCell($cell2);
      const isValidCell = keyboardController._isCellValid($cell2);
      if (!isMasterDetailCell && isValidCell && keyboardController._isCellElement($cell2)) {
        keyboardController._applyTabIndexToElement($cell2);
        keyboardController.setCellFocusType();
        return true;
      }
      return;
    };
    const $cell = GridCoreKeyboardNavigationDom.getCellToFocus(cellElements, columnIndex);
    if ($cell.length) {
      updateCellTabIndex($cell);
    } else {
      if (cellElementsLength <= columnIndex) {
        columnIndex = cellElementsLength - 1;
      }
      for (let i = columnIndex; i < cellElementsLength; ++i) {
        if (updateCellTabIndex(renderer_default(cellElements[i]))) {
          break;
        }
      }
    }
  }
  renderDelayedTemplates(change) {
    super.renderDelayedTemplates.apply(this, arguments);
    this.waitAsyncTemplates().done((() => {
      this._renderFocusByChange(change);
    }));
  }
  _renderFocusByChange(change) {
    const {
      operationTypes,
      repaintChangesOnly
    } = change ?? {};
    const {
      fullReload,
      pageSize
    } = operationTypes ?? {};
    if (!change || !repaintChangesOnly || fullReload || pageSize) {
      const preventScroll = shouldPreventScroll(this);
      this.renderFocusState({
        preventScroll,
        pageSizeChanged: pageSize
      });
    }
  }
  _renderCore(change) {
    const deferred = super._renderCore.apply(this, arguments);
    this._renderFocusByChange(change);
    return deferred;
  }
  _editCellPrepared($cell) {
    var _this$_keyboardNaviga;
    const editorInstance = this._getEditorInstance($cell);
    const isEditingNavigationMode = null === (_this$_keyboardNaviga = this._keyboardNavigationController) || void 0 === _this$_keyboardNaviga ? void 0 : _this$_keyboardNaviga._isFastEditingStarted();
    if (editorInstance && isEditingNavigationMode) {
      this._handleEditingNavigationMode(editorInstance);
    }
    super._editCellPrepared.apply(this, arguments);
  }
  _handleEditingNavigationMode(editorInstance) {
    ["downArrow", "upArrow"].forEach(((keyName) => {
      const originalKeyHandler = editorInstance._supportedKeys()[keyName];
      editorInstance.registerKeyHandler(keyName, ((e) => {
        const isDropDownOpened = "true" === editorInstance._input().attr("aria-expanded");
        if (isDropDownOpened) {
          return originalKeyHandler && originalKeyHandler.call(editorInstance, e);
        }
      }));
    }));
    editorInstance.registerKeyHandler("leftArrow", noop);
    editorInstance.registerKeyHandler("rightArrow", noop);
    const isDateBoxWithMask = editorInstance.NAME === DATEBOX_WIDGET_NAME && editorInstance.option("useMaskBehavior");
    if (isDateBoxWithMask) {
      editorInstance.registerKeyHandler("enter", noop);
    }
  }
  _getEditorInstance($cell) {
    const $editor = $cell.find(".dx-texteditor").eq(0);
    return m_utils_default.getWidgetInstance($editor);
  }
  _handleScroll(e) {
    super._handleScroll(e);
    if (this._keyboardNavigationController.needNavigationToCell()) {
      this._keyboardNavigationController.navigateToFirstOrLastCell(this._keyboardNavigationController.isQuickNavigationToFirstCell());
    }
  }
  init() {
    super.init();
    this._resizeController = this.getController("resizing");
  }
};
var editing2 = (Base) => class extends Base {
  editCell(rowIndex, columnIndex) {
    if (this._keyboardNavigationController._processCanceledEditCellPosition(rowIndex, columnIndex)) {
      return false;
    }
    const isCellEditing = super.editCell(rowIndex, columnIndex);
    if (isCellEditing) {
      this._keyboardNavigationController.setupFocusedView();
    }
    return isCellEditing;
  }
  editRow(rowIndex) {
    const visibleColumnIndex = this._keyboardNavigationController.getVisibleColumnIndex();
    const column = this._columnsController.getVisibleColumns()[visibleColumnIndex];
    if (column && column.type || this.option("editing.mode") === EDIT_MODE_FORM) {
      this._keyboardNavigationController._resetFocusedCell();
    }
    super.editRow(rowIndex);
    return;
  }
  addRow(parentKey) {
    this._keyboardNavigationController.setupFocusedView();
    this._keyboardNavigationController.setCellFocusType();
    return super.addRow.apply(this, arguments);
  }
  getFocusedCellInRow(rowIndex) {
    let $cell = super.getFocusedCellInRow(rowIndex);
    const rowIndexOffset = this._dataController.getRowIndexOffset();
    const focusedRowIndex = this._keyboardNavigationController._focusedCellPosition.rowIndex - rowIndexOffset;
    if (this._keyboardNavigationController.isKeyboardEnabled() && focusedRowIndex === rowIndex) {
      const $focusedCell = this._keyboardNavigationController._getFocusedCell();
      if (isElementDefined($focusedCell) && !$focusedCell.hasClass(COMMAND_EDIT_CLASS)) {
        $cell = $focusedCell;
      }
    }
    return $cell;
  }
  _processCanceledEditingCell() {
    this.closeEditCell().done((() => {
      this._keyboardNavigationController._updateFocus();
    }));
  }
  closeEditCell() {
    const keyboardNavigation4 = this._keyboardNavigationController;
    keyboardNavigation4._fastEditingStarted = false;
    const result = super.closeEditCell.apply(this, arguments);
    const $focusedElement = this._getFocusedElement();
    const isFilterCell = !!$focusedElement.closest(`.${this.addWidgetPrefix(FILTER_ROW_CLASS)}`).length;
    if (!isFilterCell) {
      keyboardNavigation4._updateFocus();
    }
    return result;
  }
  _getFocusedElement() {
    var _this$component$eleme, _this$component;
    const $element = renderer_default(null === (_this$component$eleme = (_this$component = this.component).element) || void 0 === _this$component$eleme ? void 0 : _this$component$eleme.call(_this$component));
    const $focusedElement = $element.find(":focus");
    return $focusedElement;
  }
  _delayedInputFocus() {
    this._keyboardNavigationController._isNeedScroll = true;
    super._delayedInputFocus.apply(this, arguments);
  }
  _isEditingStart() {
    const cancel = super._isEditingStart.apply(this, arguments);
    if (cancel && !this._keyboardNavigationController._isNeedFocus) {
      const $cell = this._keyboardNavigationController._getFocusedCell();
      this._keyboardNavigationController._focus($cell, true);
    }
    return cancel;
  }
};
var data12 = (Base) => class extends Base {
  _correctRowIndices(getRowIndexCorrection) {
    const focusedCellPosition = this._keyboardNavigationController._focusedCellPosition;
    super._correctRowIndices.apply(this, arguments);
    if (focusedCellPosition && focusedCellPosition.rowIndex >= 0) {
      const focusedRowIndexCorrection = getRowIndexCorrection(focusedCellPosition.rowIndex);
      if (focusedRowIndexCorrection) {
        focusedCellPosition.rowIndex += focusedRowIndexCorrection;
        this._editorFactoryController.refocus();
      }
    }
  }
  getMaxRowIndex() {
    let result = this.items().length - 1;
    const virtualItemsCount = this.virtualItemsCount();
    if (virtualItemsCount) {
      const rowIndexOffset = this.getRowIndexOffset();
      result += rowIndexOffset + virtualItemsCount.end;
    }
    return result;
  }
};
var adaptiveColumns = (Base) => class extends Base {
  _showHiddenCellsInView(_ref) {
    let {
      viewName: viewName2,
      $cells,
      isCommandColumn
    } = _ref;
    super._showHiddenCellsInView.apply(this, arguments);
    viewName2 === COLUMN_HEADERS_VIEW && !isCommandColumn && $cells.each(((_, cellElement) => {
      const $cell = renderer_default(cellElement);
      isCellInHeaderRow($cell) && $cell.attr("tabindex", 0);
    }));
  }
  _hideVisibleCellInView(_ref2) {
    let {
      viewName: viewName2,
      $cell,
      isCommandColumn
    } = _ref2;
    super._hideVisibleCellInView.apply(this, arguments);
    if (viewName2 === COLUMN_HEADERS_VIEW && !isCommandColumn && isCellInHeaderRow($cell)) {
      $cell.removeAttr("tabindex");
    }
  }
  _hideVisibleColumnInView(_ref3) {
    let {
      view,
      isCommandColumn,
      visibleIndex
    } = _ref3;
    super._hideVisibleColumnInView({
      view,
      isCommandColumn,
      visibleIndex
    });
    if (view.name === ROWS_VIEW) {
      this._rowsView.renderFocusState({
        preventScroll: shouldPreventScroll(this)
      });
    }
  }
};
var keyboardNavigationModule = {
  defaultOptions: () => ({
    useLegacyKeyboardNavigation: false,
    keyboardNavigation: {
      enabled: true,
      enterKeyAction: "startEdit",
      enterKeyDirection: "none",
      editOnKeyPress: false
    }
  }),
  controllers: {
    keyboardNavigation: KeyboardNavigationController2
  },
  extenders: {
    views: {
      rowsView: rowsView10
    },
    controllers: {
      editing: editing2,
      data: data12,
      adaptiveColumns,
      keyboardNavigation: keyboardNavigationScrollableA11yExtender
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/keyboard_navigation.js
m_core_default.registerModule("keyboardNavigation", keyboardNavigationModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/sticky_columns/dom.js
var addStickyColumnBorderLeftClass = ($cell, addWidgetPrefix) => {
  $cell.addClass(addWidgetPrefix(CLASSES3.stickyColumnBorderLeft));
};
var addStickyColumnBorderRightClass = ($cell, addWidgetPrefix) => {
  $cell.addClass(addWidgetPrefix(CLASSES3.stickyColumnBorderRight));
};
var addStickyColumnClass = ($cell, fixedPosition, addWidgetPrefix) => {
  switch (fixedPosition) {
    case StickyPosition.Right:
      $cell.addClass(addWidgetPrefix(CLASSES3.stickyColumnRight));
      break;
    case StickyPosition.Sticky:
      $cell.addClass(addWidgetPrefix(CLASSES3.stickyColumn));
      break;
    default:
      $cell.addClass(addWidgetPrefix(CLASSES3.stickyColumnLeft));
  }
};
var toggleFirstHeaderClass = ($cell, value2, addWidgetPrefix) => {
  $cell.toggleClass(addWidgetPrefix(CLASSES3.firstHeader), value2);
};
var toggleColumnNoBorderClass = ($cell, value2, addWidgetPrefix) => {
  $cell.toggleClass(addWidgetPrefix(CLASSES3.columnNoBorder), value2);
};
var toggleStickyColumnsClass = ($element, hasStickyColumns, addWidgetPrefix) => {
  $element.toggleClass(addWidgetPrefix(CLASSES3.stickyColumns), hasStickyColumns);
};
var isStickyCellPinnedToLeft = ($cell, $container, addWidgetPrefix) => {
  const isStickyCell2 = $cell.hasClass(addWidgetPrefix(CLASSES3.stickyColumn));
  if (!isStickyCell2) {
    return false;
  }
  const cellLeft = parseFloat($cell[0].style.left);
  const cellRect = getBoundingRect($cell[0]);
  const containerRect = getBoundingRect($container[0]);
  const calculatedCellLeft = cellRect.left - containerRect.left;
  return Math.round(cellLeft) >= Math.round(calculatedCellLeft);
};
var isStickyCellPinnedToRight = ($cell, $container, addWidgetPrefix) => {
  const isStickyCell2 = $cell.hasClass(addWidgetPrefix(CLASSES3.stickyColumn));
  if (!isStickyCell2) {
    return false;
  }
  const cellRight = parseFloat($cell[0].style.right);
  const cellRect = getBoundingRect($cell[0]);
  const containerRect = getBoundingRect($container[0]);
  const calculatedCellRight = containerRect.right - cellRect.right;
  return Math.round(cellRight) >= Math.round(calculatedCellRight);
};
var isStickyCellPinned = ($cell, $container, addWidgetPrefix) => isStickyCellPinnedToLeft($cell, $container, addWidgetPrefix) || isStickyCellPinnedToRight($cell, $container, addWidgetPrefix);
var isFixedCellPinnedToRight = ($cell, $container, addWidgetPrefix) => $cell.hasClass(addWidgetPrefix(CLASSES3.stickyColumnRight)) || isStickyCellPinnedToRight($cell, $container, addWidgetPrefix);
var isLastLeftFixedCell = ($cell, addWidgetPrefix) => $cell.hasClass(addWidgetPrefix(CLASSES3.stickyColumnLeft)) && $cell.hasClass(addWidgetPrefix(CLASSES3.stickyColumnBorderRight));
var isFirstRightFixedCell = ($cell, addWidgetPrefix) => $cell.hasClass(addWidgetPrefix(CLASSES3.stickyColumnRight)) && $cell.hasClass(addWidgetPrefix(CLASSES3.stickyColumnBorderLeft));
var isStickyCell = ($cell, addWidgetPrefix) => $cell.hasClass(addWidgetPrefix(CLASSES3.stickyColumn));
var isFixedCell = ($cell, addWidgetPrefix) => $cell.hasClass(addWidgetPrefix(CLASSES3.stickyColumnLeft)) || $cell.hasClass(addWidgetPrefix(CLASSES3.stickyColumnRight)) || $cell.hasClass(addWidgetPrefix(CLASSES3.stickyColumn));
var getLeftFixedCells = ($cells, addWidgetPrefix) => $cells.filter(((_, cell) => renderer_default(cell).hasClass(addWidgetPrefix(CLASSES3.stickyColumnLeft))));
var getRightFixedCells = ($cells, addWidgetPrefix) => $cells.filter(((_, cell) => renderer_default(cell).hasClass(addWidgetPrefix(CLASSES3.stickyColumnRight))));
var getNonFixedAndStickyCells = ($cells, addWidgetPrefix) => $cells.filter(((_, cell) => renderer_default(cell).hasClass(addWidgetPrefix(CLASSES3.stickyColumn)) || !isFixedCell(renderer_default(cell), addWidgetPrefix)));
var getLastLeftFixedCell = ($cells, $container, addWidgetPrefix) => {
  const rtlEnabled = "rtl" === $container.css("direction");
  const processedCells = rtlEnabled ? $cells.toArray() : $cells.toArray().reverse();
  const lastLeftFixedCell = processedCells.find(((cell) => isStickyCellPinnedToLeft(renderer_default(cell), $container, addWidgetPrefix) || isLastLeftFixedCell(renderer_default(cell), addWidgetPrefix)));
  return renderer_default(lastLeftFixedCell ?? "");
};
var getFirstRightFixedCell = ($cells, $container, addWidgetPrefix) => {
  const rtlEnabled = "rtl" === $container.css("direction");
  const processedCells = rtlEnabled ? $cells.toArray().reverse() : $cells.toArray();
  const firstRightFixedCell = processedCells.find(((cell) => isStickyCellPinnedToRight(renderer_default(cell), $container, addWidgetPrefix) || isFirstRightFixedCell(renderer_default(cell), addWidgetPrefix)));
  return renderer_default(firstRightFixedCell ?? "");
};
var getNonFixedAreaBoundingRect = ($cells, $container, addWidgetPrefix) => {
  const containerRect = getBoundingRect($container.get(0));
  const result = {
    left: containerRect.left,
    right: containerRect.right
  };
  if (null !== $cells && void 0 !== $cells && $cells.length) {
    const $lastLeftFixedCell = getLastLeftFixedCell($cells, $container, addWidgetPrefix);
    const $firstRightFixedCell = getFirstRightFixedCell($cells, $container, addWidgetPrefix);
    if (null !== $lastLeftFixedCell && void 0 !== $lastLeftFixedCell && $lastLeftFixedCell.length) {
      result.left = Math.round(getBoundingRect($lastLeftFixedCell[0]).right);
    }
    if (null !== $firstRightFixedCell && void 0 !== $firstRightFixedCell && $firstRightFixedCell.length) {
      result.right = Math.round(getBoundingRect($firstRightFixedCell[0]).left);
    }
  }
  return result;
};
var noNeedToCreateResizingPoint = (that, _ref, addWidgetPrefix) => {
  let {
    point,
    column,
    nextColumn
  } = _ref;
  const {
    item,
    isLeftBoundary,
    isRightBoundary
  } = point;
  const $item = renderer_default(item);
  const offsetX = Math.round(point.x);
  const rtlEnabled = that.option("rtlEnabled");
  const isSplitPoint = isDefined(isLeftBoundary) || isDefined(isRightBoundary);
  const $cells = renderer_default(that.getColumnElements() ?? "");
  const $container = renderer_default(that.getContent());
  const isFixedPoint = (null === column || void 0 === column ? void 0 : column.fixed) && (null === nextColumn || void 0 === nextColumn ? void 0 : nextColumn.fixed);
  const nonFixedAreaBoundingRect = getNonFixedAreaBoundingRect($cells, $container, addWidgetPrefix);
  if (isFixedPoint || isFixedEdge(point, column, nextColumn)) {
    return false;
  }
  if (isSplitPoint) {
    if (isLastLeftFixedCell($item, addWidgetPrefix) || isStickyCellPinnedToLeft($item, $container, addWidgetPrefix)) {
      return isLeftBoundary;
    }
    if (isFirstRightFixedCell($item, addWidgetPrefix) || isStickyCellPinnedToRight($item, $container, addWidgetPrefix)) {
      return isRightBoundary;
    }
  }
  const isOutsideVisibleArea2 = offsetX < nonFixedAreaBoundingRect.left || offsetX > nonFixedAreaBoundingRect.right;
  const isPointBoundary = offsetX === nonFixedAreaBoundingRect.left || offsetX === nonFixedAreaBoundingRect.right;
  const isLastOrFirstPoint = rtlEnabled ? 0 === point.index : point.index === $cells.length;
  return isOutsideVisibleArea2 || !isLastOrFirstPoint && isPointBoundary;
};
var noNeedToCreateReorderingPoint = (point, $cells, $container, addWidgetPrefix) => {
  const {
    item,
    isLeftBoundary,
    isRightBoundary
  } = point;
  const $item = renderer_default(item);
  const pointX = Math.round(point.x);
  const isSplitPoint = isDefined(isLeftBoundary) || isDefined(isRightBoundary);
  const nonFixedAreaBoundingRect = getNonFixedAreaBoundingRect($cells, $container, addWidgetPrefix);
  if (isStickyCellPinnedToLeft($item, $container, addWidgetPrefix)) {
    return isSplitPoint && !isLeftBoundary;
  }
  if (isStickyCellPinnedToRight($item, $container, addWidgetPrefix)) {
    return isSplitPoint && !isRightBoundary;
  }
  return pointX < nonFixedAreaBoundingRect.left || pointX > nonFixedAreaBoundingRect.right;
};
var doesGroupCellEndInFirstColumn = ($groupCell) => {
  const $groupRow = $groupCell.parent();
  const commandColumns = $groupRow.children().filter(((i) => i < $groupCell.index()));
  const groupColSpanWithoutCommand = $groupCell.attr("colspan") - commandColumns.length;
  return 1 === groupColSpanWithoutCommand;
};
var getScrollPadding = ($cells, $container, addWidgetPrefix) => {
  const containerRect = getBoundingRect($container.get(0));
  const nonFixedAreaBoundingRect = getNonFixedAreaBoundingRect($cells, $container, addWidgetPrefix);
  return {
    left: nonFixedAreaBoundingRect.left - containerRect.left,
    right: containerRect.right - nonFixedAreaBoundingRect.right
  };
};
var isOutsideVisibleArea = ($element, $cells, $container, addWidgetPrefix) => {
  const elementRect = getBoundingRect($element.get(0));
  const elementRectLeft = Math.round(elementRect.left);
  const elementRectRight = Math.round(elementRect.right);
  const nonFixedAreaBoundingRect = getNonFixedAreaBoundingRect($cells, $container, addWidgetPrefix);
  return elementRectLeft < nonFixedAreaBoundingRect.left || elementRectRight > nonFixedAreaBoundingRect.right;
};
var isLastCell = ($cell) => {
  if (!$cell.is("td")) {
    return false;
  }
  const $lastCell = $cell.parent().children().last();
  return $cell[0] === $lastCell[0];
};
var needToSkipHeaderCell = ($cell) => !$cell.is("[tabindex]");
var getNextHeaderCell = function($cell) {
  let direction = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "next";
  let $nextCell = $cell;
  let $nextRow = $cell.parent();
  do {
    $nextCell = "next" === direction ? $nextCell.next() : $nextCell.prev();
    if (!$nextCell.length) {
      $nextRow = "next" === direction ? $nextRow.next() : $nextRow.prev();
      if ($nextRow.length) {
        $nextCell = "next" === direction ? $nextRow.children().first() : $nextRow.children().last();
      }
    }
  } while ($nextCell.length && needToSkipHeaderCell($nextCell));
  return $nextCell;
};
var GridCoreStickyColumnsDom = {
  toggleFirstHeaderClass,
  toggleColumnNoBorderClass,
  addStickyColumnClass,
  addStickyColumnBorderLeftClass,
  addStickyColumnBorderRightClass,
  doesGroupCellEndInFirstColumn,
  toggleStickyColumnsClass,
  getLeftFixedCells,
  getRightFixedCells,
  getNonFixedAndStickyCells,
  getNonFixedAreaBoundingRect,
  getScrollPadding,
  getNextHeaderCell,
  noNeedToCreateResizingPoint,
  isFixedCellPinnedToRight,
  noNeedToCreateReorderingPoint,
  isFixedCell,
  isStickyCell,
  isStickyCellPinned,
  isOutsideVisibleArea,
  isLastCell
};

// node_modules/devextreme/esm/__internal/grids/grid_core/keyboard_navigation/m_column_focus_dispatcher.js
var ColumnFocusDispatcher = class extends Controller {
  constructor() {
    super(...arguments);
    this.keyboardNavigationControllers = [];
  }
  registerKeyboardNavigationController(keyboardNavigationController) {
    this.keyboardNavigationControllers.push(keyboardNavigationController);
  }
  updateFocusPosition(keyboardNavigationController, cellPosition) {
    if (isDefined(cellPosition)) {
      keyboardNavigationController.updateFocusPosition(cellPosition);
    } else {
      this.keyboardNavigationControllers.forEach(((keyboardController) => {
        if (keyboardController === keyboardNavigationController) {
          return;
        }
        keyboardController.updateFocusPosition();
      }));
    }
  }
  restoreFocus(keyboardNavigationController) {
    if (keyboardNavigationController.getFirstFocusableVisibleIndex() >= 0) {
      keyboardNavigationController.restoreFocus();
    } else {
      this.keyboardNavigationControllers.forEach(((keyboardController) => {
        if (keyboardController === keyboardNavigationController) {
          return;
        }
        const firstFocusableVisibleIndex = keyboardController.getFirstFocusableVisibleIndex();
        if (firstFocusableVisibleIndex >= 0) {
          keyboardController.restoreFocus();
        }
      }));
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/keyboard_navigation/m_column_keyboard_navigation_core.js
var ColumnKeyboardNavigationController = class extends KeyboardNavigationController {
  keyDownHandler(e) {
    return this.processOnKeyDown(e);
  }
  getVisibleIndex(column, rowIndex) {
    const visibleIndex = this._columnsController.getVisibleIndex(column.index, rowIndex);
    const columnIndexOffset = this.getColumnIndexOffset(visibleIndex);
    return visibleIndex >= 0 ? visibleIndex + columnIndexOffset : -1;
  }
  getNewVisibleIndex(visibleIndex, rowIndex, direction) {
    return "previous" === direction ? visibleIndex - 1 : visibleIndex + 2;
  }
  getNewFocusedColumnIndex(newVisibleIndex, direction) {
    return direction === Direction.Next ? newVisibleIndex - 1 : newVisibleIndex;
  }
  resizeCompleted() {
    if (this.needToRestoreFocus) {
      this.restoreFocus();
    }
  }
  resetFocusedCellPosition() {
    this._focusedCellPosition = {};
  }
  canReorderColumn(column, direction, rowIndex) {
    return false;
  }
  init() {
    var _this$columnFocusDisp;
    super.init();
    this.columnFocusDispatcher = this.getController("columnFocusDispatcher");
    null === (_this$columnFocusDisp = this.columnFocusDispatcher) || void 0 === _this$columnFocusDisp || _this$columnFocusDisp.registerKeyboardNavigationController(this);
  }
  moveColumn(column) {
    let direction = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Direction.Next;
    let rowIndex = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    const viewName2 = this.getFocusedView().getName();
    const visibleIndex = this.getVisibleIndex(column, rowIndex);
    const newVisibleIndex = this.getNewVisibleIndex(visibleIndex, rowIndex, direction);
    const newFocusedColumnIndex = this.getNewFocusedColumnIndex(newVisibleIndex, direction);
    this.updateViewFocusPosition({
      rowIndex,
      columnIndex: newFocusedColumnIndex
    });
    this._columnsController.moveColumn({
      columnIndex: visibleIndex,
      rowIndex
    }, {
      columnIndex: newVisibleIndex,
      rowIndex
    }, viewName2, viewName2);
  }
  getFirstFocusableVisibleIndex() {
    return -1;
  }
  updateViewFocusPosition(cellPosition) {
    var _this$columnFocusDisp2;
    null === (_this$columnFocusDisp2 = this.columnFocusDispatcher) || void 0 === _this$columnFocusDisp2 || _this$columnFocusDisp2.updateFocusPosition(this, cellPosition);
  }
  updateFocusPosition(cellPosition) {
    this.needToRestoreFocus = true;
    if (isDefined(cellPosition)) {
      this.setFocusedCellPosition(cellPosition.rowIndex, cellPosition.columnIndex);
    } else {
      this.resetFocusedCellPosition();
    }
  }
  restoreViewFocus() {
    var _this$columnFocusDisp3;
    null === (_this$columnFocusDisp3 = this.columnFocusDispatcher) || void 0 === _this$columnFocusDisp3 || _this$columnFocusDisp3.restoreFocus(this);
  }
  restoreFocus() {
    var _$focusedCell$;
    this.needToRestoreFocus = false;
    if (isEmptyObject(this._focusedCellPosition)) {
      this.setFocusedCellPosition(0, this.getFirstFocusableVisibleIndex());
    }
    const $focusedCell = this._getFocusedCell();
    null === $focusedCell || void 0 === $focusedCell || null === (_$focusedCell$ = $focusedCell[0]) || void 0 === _$focusedCell$ || _$focusedCell$.focus({
      preventScroll: true
    });
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/keyboard_navigation/m_headers_keyboard_navigation.js
var HeadersKeyboardNavigationController = class extends ColumnKeyboardNavigationController {
  constructor() {
    super(...arguments);
    this.isOutsideVisibleArea = ($element, $container) => {
      const elementRect = getBoundingRect($element.get(0));
      const elementRectLeft = Math.round(elementRect.left);
      const elementRectRight = Math.round(elementRect.right);
      const containerBoundingRect = this.getContainerBoundingRect($container);
      return elementRectLeft < containerBoundingRect.left || elementRectRight > containerBoundingRect.right;
    };
  }
  leftRightKeysHandler(e) {
    const {
      originalEvent
    } = e;
    if (isCommandKeyPressed(originalEvent)) {
      const $cell = renderer_default(originalEvent.target).closest("td");
      const direction = this.getDirectionByKeyName(e.keyName);
      const rowIndex = this._getRowIndex($cell.parent());
      const column = this._getColumnByCellElement($cell, rowIndex);
      if (this.canReorderColumn(column, direction, rowIndex)) {
        this.moveColumn(column, direction, rowIndex);
      }
      null === originalEvent || void 0 === originalEvent || originalEvent.preventDefault();
    }
  }
  getColumnVisibleIndexCorrection(visibleColumnIndex, rowIndex, direction) {
    return 0;
  }
  getNewVisibleIndex(visibleIndex, rowIndex, direction) {
    const newVisibleIndex = super.getNewVisibleIndex(visibleIndex, rowIndex, direction);
    const indexCorrection = this.getColumnVisibleIndexCorrection(visibleIndex, rowIndex, direction);
    return newVisibleIndex + indexCorrection;
  }
  getDraggableColumns(column, rowIndex) {
    var _columnsController$ge;
    const columnsController = this._columnsController;
    const visibleColumns = null === (_columnsController$ge = columnsController.getVisibleColumns(rowIndex, true)) || void 0 === _columnsController$ge ? void 0 : _columnsController$ge.filter(((col) => col.ownerBand === (null === column || void 0 === column ? void 0 : column.ownerBand) && (!isDefined(col.type) || columnsController.isCustomCommandColumn(col))));
    if (null !== column && void 0 !== column && column.fixed) {
      const fixedPosition = getColumnFixedPosition(columnsController, column);
      if (fixedPosition !== StickyPosition.Sticky) {
        return visibleColumns.filter(((col) => col.fixed && getColumnFixedPosition(columnsController, col) === fixedPosition));
      }
    }
    return visibleColumns.filter(((column2) => !column2.fixed || column2.fixedPosition === StickyPosition.Sticky));
  }
  keyDownHandler(e) {
    let isHandled = super.keyDownHandler(e);
    if (isHandled) {
      return true;
    }
    switch (e.keyName) {
      case "tab":
        this.tabKeyHandler(e);
        isHandled = true;
        break;
      case "leftArrow":
      case "rightArrow":
        this.leftRightKeysHandler(e);
        isHandled = true;
    }
    return isHandled;
  }
  tabKeyHandler(e) {
  }
  getCellIndex($cell) {
    return this._columnHeadersView.getCellIndex($cell);
  }
  _getCell(cellPosition) {
    var _this$_columnHeadersV;
    const columnIndexOffset = this.getColumnIndexOffset(cellPosition.columnIndex);
    const columnIndex = cellPosition.columnIndex >= 0 ? cellPosition.columnIndex - columnIndexOffset : -1;
    return null === (_this$_columnHeadersV = this._columnHeadersView) || void 0 === _this$_columnHeadersV ? void 0 : _this$_columnHeadersV.getCell({
      rowIndex: cellPosition.rowIndex,
      columnIndex
    });
  }
  getFocusedView() {
    return this.getView("columnHeadersView");
  }
  focusinHandler(e) {
    this._updateFocusedCellPosition(renderer_default(e.target));
  }
  getFocusinSelector() {
    return ".dx-header-row > td";
  }
  getFocusableColumns(rowIndex, bandColumnId) {
    const visibleColumns = this._columnsController.getVisibleColumns(rowIndex);
    const result = visibleColumns.filter(((column) => !isDefined(column.type) || this._columnsController.isCustomCommandColumn(column)));
    if (isDefined(bandColumnId)) {
      return result.filter(((column) => column.ownerBand === bandColumnId));
    }
    return result;
  }
  getContainerBoundingRect($container) {
    const containerRect = getBoundingRect($container.get(0));
    return {
      left: containerRect.left,
      right: containerRect.right
    };
  }
  getScrollPadding($container) {
    const containerRect = getBoundingRect($container.get(0));
    const containerBoundingRect = this.getContainerBoundingRect($container);
    return {
      left: containerBoundingRect.left - containerRect.left,
      right: containerRect.right - containerBoundingRect.right
    };
  }
  scrollToColumn($cell) {
    var _this$getView;
    const scrollable = null === (_this$getView = this.getView("rowsView")) || void 0 === _this$getView ? void 0 : _this$getView.getScrollable();
    if (!scrollable) {
      return;
    }
    const scrollPadding = this.getScrollPadding(renderer_default(scrollable.container()));
    const scrollPosition = getElementLocationInternal($cell[0], "horizontal", renderer_default(this._columnHeadersView.getContent())[0], scrollable.scrollOffset(), scrollPadding, this.addWidgetPrefix("table"));
    scrollable.scrollTo({
      x: scrollPosition
    });
  }
  init() {
    super.init();
    this._columnHeadersView = this.getView("columnHeadersView");
  }
  canReorderColumn(column, direction, rowIndex) {
    const allowReordering2 = this._columnHeadersView.isColumnReorderingEnabled(column);
    if (!allowReordering2) {
      return false;
    }
    const draggableColumns = this.getDraggableColumns(column, rowIndex);
    const isFirstColumn = column.index === draggableColumns[0].index;
    const isLastColumn = column.index === draggableColumns[draggableColumns.length - 1].index;
    return direction === Direction.Next ? !isLastColumn : !isFirstColumn;
  }
  getFirstFocusableVisibleIndex() {
    const focusableColumns = this.getFocusableColumns();
    if (null !== focusableColumns && void 0 !== focusableColumns && focusableColumns.length) {
      return this._columnsController.getVisibleIndex(focusableColumns[0].index);
    }
    return -1;
  }
  restoreFocus() {
    const $focusedCell = this._getFocusedCell();
    const isFixedCell2 = GridCoreStickyColumnsDom.isFixedCell($focusedCell, this.addWidgetPrefix.bind(this));
    if (isFixedCell2) {
      super.restoreFocus();
      return;
    }
    const focusedCellIsOutsideVisibleArea = $focusedCell.length && this.isOutsideVisibleArea($focusedCell, renderer_default(this._columnHeadersView.getContent()));
    if (focusedCellIsOutsideVisibleArea) {
      this.scrollToColumn($focusedCell);
    } else {
      super.restoreFocus();
    }
  }
  needToFocus() {
    return this.needToRestoreFocus;
  }
};
var columnHeadersView6 = (Base) => class extends Base {
  handleScroll(e) {
    var _this$_headersKeyboar, _this$_columnsControl;
    super.handleScroll(e);
    if (!(null !== (_this$_headersKeyboar = this._headersKeyboardNavigation) && void 0 !== _this$_headersKeyboar && _this$_headersKeyboar.needToFocus())) {
      return;
    }
    const isNeedToRenderVirtualColumns = null === (_this$_columnsControl = this._columnsController) || void 0 === _this$_columnsControl ? void 0 : _this$_columnsControl.isNeedToRenderVirtualColumns(e.target.scrollLeft);
    if (!isNeedToRenderVirtualColumns) {
      this._headersKeyboardNavigation.restoreFocus();
    }
  }
};
var headersKeyboardNavigationModule = {
  controllers: {
    headersKeyboardNavigation: HeadersKeyboardNavigationController,
    columnFocusDispatcher: ColumnFocusDispatcher
  },
  extenders: {
    views: {
      columnHeadersView: columnHeadersView6
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/keyboard_navigation/m_column_keyboard_navigation_mixin.js
var ColumnKeyboardNavigationMixin = (Base) => class extends Base {
  ungroupColumnByPressingKey(e) {
    var _e$originalEvent;
    const column = this.getColumnFromEvent(e);
    const rowIndex = this.getRowIndexFromEvent(e);
    this.ungroupColumn(column, rowIndex);
    null === (_e$originalEvent = e.originalEvent) || void 0 === _e$originalEvent || _e$originalEvent.preventDefault();
  }
  getFocusedCellPositionByColumn(column) {
    if (!column) {
      return;
    }
    const newRowIndex = this._columnsController.getRowIndex(column.index, true);
    return {
      rowIndex: newRowIndex,
      columnIndex: this.getVisibleIndex(column, newRowIndex)
    };
  }
  getRowIndexFromEvent(e) {
    return 0;
  }
  getColumnFromEvent(e) {
  }
  getNewFocusedColumnBeforeUngrouping(column, rowIndex) {
    return column;
  }
  keyDownHandler(e) {
    let isHandled = super.keyDownHandler(e);
    if (isHandled) {
      return true;
    }
    if (this.canUngroupColumnByPressingKey(e)) {
      this.ungroupColumnByPressingKey(e);
      isHandled = true;
    } else if (this.canUngroupAllColumnByPressingKey(e)) {
      this.ungroupAllColumns();
      isHandled = true;
    }
    return isHandled;
  }
  changeGroupColumnIndex(groupIndex, column, newFocusedColumn) {
    this._columnsController.beginUpdate();
    this._columnsController.columnOption(column.dataField, "groupIndex", groupIndex);
    const newFocusedCellPosition = this.getFocusedCellPositionByColumn(newFocusedColumn);
    this.updateViewFocusPosition(newFocusedCellPosition);
    this._columnsController.endUpdate();
  }
  canUngroupColumnByPressingKey(e) {
    return e.which === KEY_CODES.G && e.shift && isCommandKeyPressed(e.originalEvent);
  }
  canUngroupAllColumnByPressingKey(e) {
    return e.which === KEY_CODES.G && e.shift && e.alt;
  }
  ungroupColumn(column) {
    let rowIndex = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    if (isDefined(null === column || void 0 === column ? void 0 : column.groupIndex)) {
      const newFocusedColumn = this.getNewFocusedColumnBeforeUngrouping(column, rowIndex);
      this.changeGroupColumnIndex(-1, column, newFocusedColumn);
    }
  }
  ungroupAllColumns() {
    this._columnsController.clearGrouping();
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/keyboard_navigation/m_headers_keyboard_navigation.js
var headersKeyboardNavigation = (Base) => class extends ColumnKeyboardNavigationMixin(Base) {
  getNewFocusedColumnBeforeGrouping(column, rowIndex) {
    if (column.showWhenGrouped) {
      return column;
    }
    const focusableColumns = this.getFocusableColumns(rowIndex, column.ownerBand);
    if (1 === focusableColumns.length && isDefined(column.ownerBand)) {
      return this._columnsController.getParentColumn(column, true);
    }
    if (1 === focusableColumns.length) {
      return;
    }
    const visibleColumnIndex = focusableColumns.findIndex(((col) => col.index === column.index));
    return visibleColumnIndex === focusableColumns.length - 1 ? focusableColumns[visibleColumnIndex - 1] : focusableColumns[visibleColumnIndex + 1];
  }
  groupColumnByPressingKey(e) {
    var _e$originalEvent;
    const $cell = renderer_default(e.originalEvent.target).closest("td");
    const rowIndex = this._getRowIndex($cell.parent());
    const column = this._getColumnByCellElement($cell, rowIndex);
    this.groupColumn(column, rowIndex);
    null === (_e$originalEvent = e.originalEvent) || void 0 === _e$originalEvent || _e$originalEvent.preventDefault();
  }
  canGroupColumnByPressingKey(e) {
    return e.which === KEY_CODES.G && isCommandKeyPressed(e.originalEvent);
  }
  getRowIndexFromEvent(e) {
    const $cell = renderer_default(e.originalEvent.target).closest("td");
    return this._getRowIndex($cell.parent());
  }
  getColumnFromEvent(e) {
    const $cell = renderer_default(e.originalEvent.target).closest("td");
    const rowIndex = this._getRowIndex($cell.parent());
    return this._getColumnByCellElement($cell, rowIndex);
  }
  keyDownHandler(e) {
    let isHandled = super.keyDownHandler(e);
    if (isHandled) {
      return true;
    }
    if (this.canGroupColumnByPressingKey(e)) {
      this.groupColumnByPressingKey(e);
      isHandled = true;
    }
    return isHandled;
  }
  groupColumn(column) {
    let rowIndex = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    if (!isDefined(column.groupIndex) && null !== column && void 0 !== column && column.allowGrouping) {
      var _this$_columnsControl;
      const newGroupIndex = (null === (_this$_columnsControl = this._columnsController.getGroupColumns()) || void 0 === _this$_columnsControl ? void 0 : _this$_columnsControl.length) ?? 0;
      const newFocusedColumn = this.getNewFocusedColumnBeforeGrouping(column, rowIndex);
      this.changeGroupColumnIndex(newGroupIndex, column, newFocusedColumn);
    }
  }
  ungroupAllColumns() {
    const $focusedCell = this._getFocusedCell();
    const focusedColumn = this._getColumnByCellElement($focusedCell);
    this._columnsController.beginUpdate();
    super.ungroupAllColumns();
    const rowIndex = this._columnsController.getRowIndex(focusedColumn.index, true);
    const newVisibleIndex = this.getVisibleIndex(focusedColumn);
    this.updateFocusPosition({
      rowIndex,
      columnIndex: newVisibleIndex
    });
    this._columnsController.endUpdate();
  }
};
m_core_default.registerModule("headersKeyboardNavigation", _extends({}, headersKeyboardNavigationModule, {
  extenders: {
    controllers: {
      headersKeyboardNavigation
    },
    views: _extends({}, headersKeyboardNavigationModule.extenders.views)
  }
}));

// node_modules/devextreme/esm/__internal/grids/data_grid/keyboard_navigation/m_group_panel_keyboard_navigation.js
var GroupPanelKeyboardNavigationController = class extends ColumnKeyboardNavigationMixin(ColumnKeyboardNavigationController) {
  constructor() {
    super(...arguments);
    this.isNeedToHiddenFocusAfterClick = false;
  }
  groupItemClickHandler(e) {
    var _this$_columnsControl;
    const $groupedColumnElement = renderer_default(e.originalEvent.target);
    const groupColumn = this._columnsController.columnOption(`groupIndex:${$groupedColumnElement.index()}`);
    this.isNeedToHiddenFocusAfterClick = null === (_this$_columnsControl = this._columnsController) || void 0 === _this$_columnsControl ? void 0 : _this$_columnsControl.allowColumnSorting(groupColumn);
  }
  unsubscribeFromGroupItemClick() {
    const $focusedView = this.getFocusedViewElement();
    if ($focusedView) {
      m_events_engine_default.off($focusedView, CLICK_EVENT_NAME, this.groupItemClickHandlerContext);
    }
  }
  subscribeToGroupItemClick() {
    const $focusedView = this.getFocusedViewElement();
    if ($focusedView) {
      m_events_engine_default.on($focusedView, CLICK_EVENT_NAME, `.${CLASSES5.groupPanelItem}`, this.groupItemClickHandlerContext);
    }
  }
  leftRightKeysHandler(e) {
    const {
      originalEvent
    } = e;
    if (isCommandKeyPressed(originalEvent)) {
      const $groupedColumnElement = renderer_default(originalEvent.target);
      const column = this._columnsController.columnOption(`groupIndex:${$groupedColumnElement.index()}`);
      const direction = this.getDirectionByKeyName(e.keyName);
      if (this.canReorderColumn(column, direction)) {
        this.moveColumn(column, direction);
      }
      null === originalEvent || void 0 === originalEvent || originalEvent.preventDefault();
    }
  }
  getVisibleIndex(column) {
    return column.groupIndex;
  }
  getColumnFromEvent(e) {
    const $groupedColumnElement = renderer_default(e.originalEvent.target);
    return this._columnsController.columnOption(`groupIndex:${$groupedColumnElement.index()}`);
  }
  getNewFocusedColumnBeforeUngrouping(column) {
    const visibleColumnIndex = column.groupIndex;
    const groupColumns = this._columnsController.getGroupColumns();
    return visibleColumnIndex === groupColumns.length - 1 ? groupColumns[visibleColumnIndex - 1] : groupColumns[visibleColumnIndex + 1];
  }
  _getCell(cellPosition) {
    var _this$headerPanel;
    const $groupColumnElements = null === (_this$headerPanel = this.headerPanel) || void 0 === _this$headerPanel ? void 0 : _this$headerPanel.getColumnElements();
    return null === $groupColumnElements || void 0 === $groupColumnElements ? void 0 : $groupColumnElements.eq(cellPosition.columnIndex);
  }
  getFocusedView() {
    return this.getView("headerPanel");
  }
  getFocusedViewElement() {
    var _this$headerPanel2;
    return null === (_this$headerPanel2 = this.headerPanel) || void 0 === _this$headerPanel2 || null === (_this$headerPanel2 = _this$headerPanel2.element()) || void 0 === _this$headerPanel2 ? void 0 : _this$headerPanel2.find(`.${CLASSES5.groupPanel}`);
  }
  getFocusinSelector() {
    return `.${CLASSES5.groupPanelItem}`;
  }
  focusinHandler(e) {
    this.setFocusedCellPosition(0, renderer_default(e.target).index());
  }
  keyDownHandler(e) {
    let isHandled = super.keyDownHandler(e);
    if (isHandled) {
      return true;
    }
    if ("leftArrow" === e.keyName || "rightArrow" === e.keyName) {
      this.leftRightKeysHandler(e);
      isHandled = true;
    }
    return isHandled;
  }
  renderCompleted(e) {
    const {
      needToRestoreFocus
    } = this;
    super.renderCompleted(e);
    this.unsubscribeFromGroupItemClick();
    this.subscribeToGroupItemClick();
    if (!needToRestoreFocus && this.isNeedToHiddenFocusAfterClick) {
      const $focusElement = this._getFocusedCell();
      if (null !== $focusElement && void 0 !== $focusElement && $focusElement.length) {
        hiddenFocus($focusElement.get(0));
      }
      this.isNeedToHiddenFocusAfterClick = false;
    }
  }
  canUngroupColumnByPressingKey(e) {
    return super.canUngroupColumnByPressingKey(e) || "backspace" === e.keyName || "del" === e.keyName;
  }
  getFirstFocusableVisibleIndex() {
    var _this$headerPanel3;
    const columns7 = null === (_this$headerPanel3 = this.headerPanel) || void 0 === _this$headerPanel3 ? void 0 : _this$headerPanel3.getColumns();
    return null !== columns7 && void 0 !== columns7 && columns7.length ? 0 : -1;
  }
  init() {
    this.headerPanel = this.getView("headerPanel");
    this.groupItemClickHandlerContext = this.groupItemClickHandlerContext ?? this.groupItemClickHandler.bind(this);
    super.init();
  }
  canReorderColumn(groupColumn, direction) {
    const allowDragging2 = this.headerPanel.allowDragging(groupColumn);
    if (!allowDragging2) {
      return false;
    }
    const groupedColumns = this._columnsController.getGroupColumns();
    return direction === Direction.Next ? groupColumn.groupIndex !== groupedColumns.length - 1 : 0 !== groupColumn.groupIndex;
  }
  ungroupAllColumns() {
    this.updateViewFocusPosition();
    super.ungroupAllColumns();
  }
};
m_core_default.registerModule("groupPanelKeyboardNavigation", {
  controllers: {
    groupPanelKeyboardNavigation: GroupPanelKeyboardNavigationController
  }
});

// node_modules/devextreme/esm/__internal/grids/data_grid/m_aggregate_calculator.js
function depthFirstSearch(i, depth, root, callback) {
  let j = 0;
  if (i < depth) {
    for (; j < root.items.length; j++) {
      depthFirstSearch(i + 1, depth, root.items[j], callback);
    }
  }
  if (i === depth) {
    callback(root);
  }
}
function map2(array, callback) {
  let i;
  if ("map" in array) {
    return array.map(callback);
  }
  const result = new Array(array.length);
  for (i in array) {
    result[i] = callback(array[i], i);
  }
  return result;
}
function isEmpty2(x) {
  return x !== x || "" === x || null === x || void 0 === x;
}
function isCount(aggregator) {
  return aggregator === aggregators.count;
}
function normalizeAggregate(aggregate) {
  const selector = compileGetter(aggregate.selector);
  const skipEmptyValues = "skipEmptyValues" in aggregate ? aggregate.skipEmptyValues : true;
  let {
    aggregator
  } = aggregate;
  if ("string" === typeof aggregator) {
    aggregator = aggregators[aggregator];
    if (!aggregator) {
      throw errors.Error("E4001", aggregate.aggregator);
    }
  }
  return {
    selector,
    aggregator,
    skipEmptyValues
  };
}
var AggregateCalculator = class {
  constructor(options) {
    this._data = options.data;
    this._groupLevel = options.groupLevel || 0;
    this._totalAggregates = map2(options.totalAggregates || [], normalizeAggregate);
    this._groupAggregates = map2(options.groupAggregates || [], normalizeAggregate);
    this._totals = [];
  }
  calculate() {
    if (this._totalAggregates.length) {
      this._calculateTotals(0, {
        items: this._data
      });
    }
    if (this._groupAggregates.length && this._groupLevel > 0) {
      this._calculateGroups({
        items: this._data
      });
    }
  }
  totalAggregates() {
    return this._totals;
  }
  _aggregate(aggregates, data17, container) {
    const length = data17.items ? data17.items.length : 0;
    for (let i = 0; i < aggregates.length; i++) {
      if (isCount(aggregates[i].aggregator)) {
        container[i] = (container[i] || 0) + length;
        continue;
      }
      for (let j = 0; j < length; j++) {
        this._accumulate(i, aggregates[i], container, data17.items[j]);
      }
    }
  }
  _calculateTotals(level, data17) {
    if (0 === level) {
      this._totals = this._seed(this._totalAggregates);
    }
    if (level === this._groupLevel) {
      this._aggregate(this._totalAggregates, data17, this._totals);
    } else {
      for (let i = 0; i < data17.items.length; i++) {
        this._calculateTotals(level + 1, data17.items[i]);
      }
    }
    if (0 === level) {
      this._totals = this._finalize(this._totalAggregates, this._totals);
    }
  }
  _calculateGroups(root) {
    const maxLevel = this._groupLevel;
    let currentLevel = maxLevel + 1;
    const seedFn = this._seed.bind(this, this._groupAggregates);
    const stepFn = this._aggregate.bind(this, this._groupAggregates);
    const finalizeFn = this._finalize.bind(this, this._groupAggregates);
    function aggregator(node) {
      node.aggregates = seedFn(currentLevel - 1);
      if (currentLevel === maxLevel) {
        stepFn(node, node.aggregates);
      } else {
        depthFirstSearch(currentLevel, maxLevel, node, ((innerNode) => {
          stepFn(innerNode, node.aggregates);
        }));
      }
      node.aggregates = finalizeFn(node.aggregates);
    }
    while (--currentLevel > 0) {
      depthFirstSearch(0, currentLevel, root, aggregator);
    }
  }
  _seed(aggregates, groupIndex) {
    return map2(aggregates, ((aggregate) => {
      const {
        aggregator
      } = aggregate;
      const seed = "seed" in aggregator ? isFunction(aggregator.seed) ? aggregator.seed(groupIndex) : aggregator.seed : NaN;
      return seed;
    }));
  }
  _accumulate(aggregateIndex, aggregate, results, item) {
    const value2 = aggregate.selector(item);
    const {
      aggregator
    } = aggregate;
    const {
      skipEmptyValues
    } = aggregate;
    if (skipEmptyValues && isEmpty2(value2)) {
      return;
    }
    if (results[aggregateIndex] !== results[aggregateIndex]) {
      results[aggregateIndex] = value2;
    } else {
      results[aggregateIndex] = aggregator.step(results[aggregateIndex], value2);
    }
  }
  _finalize(aggregates, results) {
    return map2(aggregates, ((aggregate, index) => {
      const fin = aggregate.aggregator.finalize;
      return fin ? fin(results[index]) : results[index];
    }));
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/summary/utils.js
function getSummaryCellIndex(column, prevColumn) {
  let isGroupRow3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;
  const cellIndex = column.index ?? -1;
  if (!isGroupRow3) {
    return cellIndex;
  }
  if ("groupExpand" === (null === prevColumn || void 0 === prevColumn ? void 0 : prevColumn.type) || "groupExpand" === column.type) {
    return (null === prevColumn || void 0 === prevColumn ? void 0 : prevColumn.index) ?? -1;
  }
  return !isDefined(column.groupIndex) ? cellIndex : -1;
}

// node_modules/devextreme/esm/__internal/grids/data_grid/summary/m_summary.js
var DATAGRID_CELL_DISABLED = "dx-cell-focus-disabled";
var renderSummaryCell = function(cell, options) {
  const $cell = renderer_default(cell);
  const {
    column
  } = options;
  const {
    summaryItems
  } = options;
  const $summaryItems = [];
  if (!column.command && summaryItems) {
    for (let i = 0; i < summaryItems.length; i++) {
      const summaryItem = summaryItems[i];
      const text = m_core_default.getSummaryText(summaryItem, options.summaryTexts);
      $summaryItems.push(renderer_default("<div>").css("textAlign", summaryItem.alignment || column.alignment).addClass("dx-datagrid-summary-item").addClass("dx-datagrid-text-content").addClass(summaryItem.cssClass).toggleClass("dx-datagrid-group-text-content", "group" === options.rowType).text(text).attr("aria-label", `${column.caption} ${text}`));
    }
    $cell.append($summaryItems);
  }
};
var getSummaryCellOptions = function(that, options) {
  const summaryTexts = that.option("summary.texts") || {};
  return {
    totalItem: options.row,
    summaryItems: options.row.summaryCells[options.columnIndex],
    summaryTexts
  };
};
var getGroupAggregates = function(data17) {
  return data17.summary || data17.aggregates || [];
};
var recalculateWhileEditing = function(that) {
  return that.option("summary.recalculateWhileEditing");
};
var forEachGroup = function(groups, groupCount, callback, path) {
  path = path || [];
  for (let i = 0; i < groups.length; i++) {
    path.push(groups[i].key);
    if (1 === groupCount) {
      callback(path, groups[i].items);
    } else {
      forEachGroup(groups[i].items, groupCount - 1, callback, path);
    }
    path.pop();
  }
};
var applyAddedData = function(data17, insertedData, groupLevel) {
  if (groupLevel) {
    return applyAddedData(data17, insertedData.map(((item) => ({
      items: [item]
    })), groupLevel - 1));
  }
  return data17.concat(insertedData);
};
var applyRemovedData = function(data17, removedData, groupLevel) {
  if (groupLevel) {
    return data17.map(((data18) => {
      const updatedData = {};
      const updatedItems = applyRemovedData(data18.items || [], removedData, groupLevel - 1);
      Object.defineProperty(updatedData, "aggregates", {
        get: () => data18.aggregates,
        set: (value2) => {
          data18.aggregates = value2;
        }
      });
      return extend(updatedData, data18, {
        items: updatedItems
      });
    }));
  }
  return data17.filter(((data18) => removedData.indexOf(data18) < 0));
};
var sortGroupsBySummaryCore = function(items, groups, sortByGroups) {
  if (!items || !groups.length) {
    return items;
  }
  const group = groups[0];
  const sorts = sortByGroups[0];
  let query;
  if (group && sorts && sorts.length) {
    query = m_query_default(items);
    each(sorts, (function(index) {
      if (0 === index) {
        query = query.sortBy(this.selector, this.desc);
      } else {
        query = query.thenBy(this.selector, this.desc);
      }
    }));
    query.enumerate().done(((sortedItems) => {
      items = sortedItems;
    }));
  }
  groups = groups.slice(1);
  sortByGroups = sortByGroups.slice(1);
  if (groups.length && sortByGroups.length) {
    each(items, (function() {
      this.items = sortGroupsBySummaryCore(this.items, groups, sortByGroups);
    }));
  }
  return items;
};
var sortGroupsBySummary = function(data17, group, summary) {
  const sortByGroups = summary && summary.sortByGroups && summary.sortByGroups();
  if (sortByGroups && sortByGroups.length) {
    return sortGroupsBySummaryCore(data17, group, sortByGroups);
  }
  return data17;
};
var calculateAggregates = function(that, summary, data17, groupLevel) {
  let calculator;
  if (recalculateWhileEditing(that)) {
    const editingController = that._editingController;
    if (editingController) {
      const insertedData = editingController.getInsertedData();
      if (insertedData.length) {
        data17 = applyAddedData(data17, insertedData, groupLevel);
      }
      const removedData = editingController.getRemovedData();
      if (removedData.length) {
        data17 = applyRemovedData(data17, removedData, groupLevel);
      }
    }
  }
  if (summary) {
    calculator = new AggregateCalculator({
      totalAggregates: summary.totalAggregates,
      groupAggregates: summary.groupAggregates,
      data: data17,
      groupLevel
    });
    calculator.calculate();
  }
  return calculator ? calculator.totalAggregates() : [];
};
var FooterView = class extends ColumnsView {
  _getRows() {
    return this._dataController.footerItems();
  }
  _getCellOptions(options) {
    return extend(super._getCellOptions(options), getSummaryCellOptions(this, options));
  }
  _renderCellContent($cell, options) {
    renderSummaryCell($cell, options);
    super._renderCellContent.apply(this, arguments);
  }
  _renderCore(change) {
    let needUpdateScrollLeft = false;
    const totalItem = this._dataController.footerItems()[0];
    if (!change || !change.columnIndices) {
      this.element().empty().addClass("dx-datagrid-total-footer").toggleClass("dx-datagrid-nowrap", !this.option("wordWrapEnabled"));
      needUpdateScrollLeft = true;
    }
    if (totalItem && totalItem.summaryCells && totalItem.summaryCells.length) {
      this._updateContent(this._renderTable({
        change
      }), change);
      needUpdateScrollLeft && this._updateScrollLeftPosition();
    }
    return super._renderCore(change);
  }
  _updateContent($newTable, change) {
    if (change && "update" === change.changeType && change.columnIndices) {
      return this.waitAsyncTemplates().done((() => {
        const $row = this.getTableElement().find(".dx-row");
        const $newRow = $newTable.find(".dx-row");
        this._updateCells($row, $newRow, change.columnIndices[0]);
      }));
    }
    return super._updateContent.apply(this, arguments);
  }
  _rowClick(e) {
    const item = this._dataController.footerItems()[e.rowIndex] || {};
    this.executeAction("onRowClick", extend({}, e, item));
  }
  _columnOptionChanged(e) {
    const {
      optionNames
    } = e;
    if (e.changeTypes.grouping) {
      return;
    }
    if (optionNames.width || optionNames.visibleWidth) {
      super._columnOptionChanged(e);
    }
  }
  _handleDataChanged(e) {
    const {
      changeType
    } = e;
    if ("update" === e.changeType && e.repaintChangesOnly) {
      if (!e.totalColumnIndices) {
        this.render();
      } else if (e.totalColumnIndices.length) {
        this.render(null, {
          changeType: "update",
          columnIndices: [e.totalColumnIndices]
        });
      }
    } else if ("refresh" === changeType || "append" === changeType || "prepend" === changeType) {
      this.render();
    }
  }
  _createRow(row) {
    const $row = super._createRow.apply(this, arguments);
    if ("totalFooter" === row.rowType) {
      $row.addClass("dx-footer-row");
      $row.addClass(DATAGRID_CELL_DISABLED);
      $row.attr("tabindex", 0);
    }
    return $row;
  }
  getHeight() {
    return this.getElementHeight();
  }
  isVisible() {
    return !!this._dataController.footerItems().length;
  }
};
var dataSourceAdapterExtender3 = (Base) => class extends Base {
  init() {
    super.init.apply(this, arguments);
    this._editingController = this.getController("editing");
    this._totalAggregates = [];
    this._summaryGetter = noop;
  }
  summaryGetter(summaryGetter) {
    if (!arguments.length) {
      return this._summaryGetter;
    }
    if (isFunction(summaryGetter)) {
      this._summaryGetter = summaryGetter;
    }
  }
  summary(summary) {
    if (!arguments.length) {
      return this._summaryGetter();
    }
    this._summaryGetter = function() {
      return summary;
    };
  }
  totalAggregates() {
    return this._totalAggregates;
  }
  isLastLevelGroupItemsPagingLocal() {
    const summary = this.summary();
    const sortByGroupsInfo = null === summary || void 0 === summary ? void 0 : summary.sortByGroups();
    return null === sortByGroupsInfo || void 0 === sortByGroupsInfo ? void 0 : sortByGroupsInfo.length;
  }
  sortLastLevelGroupItems(items, groups, paths) {
    const groupedItems = m_store_helper_default.multiLevelGroup(m_query_default(items), groups).toArray();
    let result = [];
    paths.forEach(((path) => {
      forEachGroup(groupedItems, groups.length, ((itemsPath, items2) => {
        if (path.toString() === itemsPath.toString()) {
          result = result.concat(items2);
        }
      }));
    }));
    return result;
  }
  _customizeRemoteOperations(options) {
    const summary = this.summary();
    if (summary) {
      if (options.remoteOperations.summary) {
        if (!options.isCustomLoading || options.storeLoadOptions.isLoadingAll) {
          if (options.storeLoadOptions.group) {
            if (options.remoteOperations.grouping) {
              options.storeLoadOptions.groupSummary = summary.groupAggregates;
            } else if (summary.groupAggregates.length) {
              options.remoteOperations.paging = false;
            }
          }
          options.storeLoadOptions.totalSummary = summary.totalAggregates;
        }
      } else if (summary.totalAggregates.length || summary.groupAggregates.length && options.storeLoadOptions.group) {
        options.remoteOperations.paging = false;
      }
    }
    super._customizeRemoteOperations.apply(this, arguments);
    const cachedExtra = options.cachedData.extra;
    if (null !== cachedExtra && void 0 !== cachedExtra && cachedExtra.summary && !options.isCustomLoading) {
      options.storeLoadOptions.totalSummary = void 0;
    }
  }
  _handleDataLoadedCore(options) {
    const groups = normalizeSortingInfo(options.storeLoadOptions.group || options.loadOptions.group || []);
    const remoteOperations = options.remoteOperations || {};
    const summary = this.summaryGetter()(remoteOperations);
    if (!options.isCustomLoading || options.storeLoadOptions.isLoadingAll) {
      if (remoteOperations.summary) {
        if (!remoteOperations.paging && groups.length && summary) {
          if (!remoteOperations.grouping) {
            calculateAggregates(this, {
              groupAggregates: summary.groupAggregates
            }, options.data, groups.length);
          }
          options.data = sortGroupsBySummary(options.data, groups, summary);
        }
      } else if (!remoteOperations.paging && summary) {
        var _options$cachedData;
        const operationTypes = options.operationTypes || {};
        const hasOperations = Object.keys(operationTypes).some(((type2) => operationTypes[type2]));
        if (!hasOperations || !(null !== (_options$cachedData = options.cachedData) && void 0 !== _options$cachedData && null !== (_options$cachedData = _options$cachedData.extra) && void 0 !== _options$cachedData && _options$cachedData.summary) || groups.length && summary.groupAggregates.length) {
          const totalAggregates = calculateAggregates(this, summary, options.data, groups.length);
          options.extra = isPlainObject(options.extra) ? options.extra : {};
          options.extra.summary = totalAggregates;
          if (options.cachedData) {
            options.cachedData.extra = options.extra;
          }
        }
        options.data = sortGroupsBySummary(options.data, groups, summary);
      }
    }
    if (!options.isCustomLoading) {
      this._totalAggregates = options.extra && options.extra.summary || this._totalAggregates;
    }
    super._handleDataLoadedCore(options);
  }
};
m_data_source_adapter_default.extend(dataSourceAdapterExtender3);
var data13 = (Base) => class extends Base {
  _isDataColumn(column) {
    return column && (!isDefined(column.groupIndex) || column.showWhenGrouped);
  }
  _isGroupFooterVisible() {
    const groupItems = this.option("summary.groupItems") || [];
    for (let i = 0; i < groupItems.length; i++) {
      const groupItem = groupItems[i];
      const column = this._columnsController.columnOption(groupItem.showInColumn || groupItem.column);
      if (groupItem.showInGroupFooter && this._isDataColumn(column)) {
        return true;
      }
    }
    return false;
  }
  _processGroupItems(items, groupCount, options) {
    const data17 = options && options.data;
    const result = super._processGroupItems.apply(this, arguments);
    if (options) {
      if (void 0 === options.isGroupFooterVisible) {
        options.isGroupFooterVisible = this._isGroupFooterVisible();
      }
      if (data17 && data17.items && options.isGroupFooterVisible && (options.collectContinuationItems || !data17.isContinuationOnNextPage)) {
        result.push({
          rowType: "groupFooter",
          key: options.path.slice(),
          data: data17,
          groupIndex: options.path.length - 1,
          values: []
        });
      }
    }
    return result;
  }
  _processGroupItem(groupItem, options) {
    const that = this;
    if (!options.summaryGroupItems) {
      options.summaryGroupItems = that.option("summary.groupItems") || [];
    }
    if ("group" === groupItem.rowType) {
      let groupColumnIndex = -1;
      let afterGroupColumnIndex = -1;
      each(options.visibleColumns, (function(visibleIndex) {
        const prevColumn = options.visibleColumns[visibleIndex - 1];
        if (groupItem.groupIndex === this.groupIndex) {
          groupColumnIndex = this.index;
        }
        if (visibleIndex > 0 && "expand" === prevColumn.command && "expand" !== this.command) {
          afterGroupColumnIndex = this.index;
        }
      }));
      groupItem.summaryCells = this._calculateSummaryCells(options.summaryGroupItems, getGroupAggregates(groupItem.data), options.visibleColumns, ((summaryItem, column) => {
        if (summaryItem.showInGroupFooter) {
          return -1;
        }
        if (summaryItem.alignByColumn && column && !isDefined(column.groupIndex) && column.index !== afterGroupColumnIndex) {
          return column.index;
        }
        return groupColumnIndex;
      }), true);
    }
    if ("groupFooter" === groupItem.rowType) {
      groupItem.summaryCells = this._calculateSummaryCells(options.summaryGroupItems, getGroupAggregates(groupItem.data), options.visibleColumns, ((summaryItem, column) => summaryItem.showInGroupFooter && that._isDataColumn(column) ? column.index : -1));
    }
    return groupItem;
  }
  _calculateSummaryCells(summaryItems, aggregates, visibleColumns, calculateTargetColumnIndex, isGroupRow3) {
    const that = this;
    const summaryCells = [];
    const summaryCellsByColumns = {};
    each(summaryItems, ((summaryIndex, summaryItem) => {
      const column = that._columnsController.columnOption(summaryItem.column);
      const showInColumn = summaryItem.showInColumn && that._columnsController.columnOption(summaryItem.showInColumn) || column;
      const columnIndex = calculateTargetColumnIndex(summaryItem, showInColumn);
      if (columnIndex >= 0) {
        if (!summaryCellsByColumns[columnIndex]) {
          summaryCellsByColumns[columnIndex] = [];
        }
        const aggregate = aggregates[summaryIndex];
        if (aggregate === aggregate) {
          let valueFormat;
          if (isDefined(summaryItem.valueFormat)) {
            valueFormat = summaryItem.valueFormat;
          } else if ("count" !== summaryItem.summaryType) {
            valueFormat = m_core_default.getFormatByDataType(column && column.dataType);
          }
          summaryCellsByColumns[columnIndex].push(extend({}, summaryItem, {
            value: isString(aggregate) && column && column.deserializeValue ? column.deserializeValue(aggregate) : aggregate,
            valueFormat,
            columnCaption: column && column.index !== columnIndex ? column.caption : void 0
          }));
        }
      }
    }));
    if (!isEmptyObject(summaryCellsByColumns)) {
      visibleColumns.forEach(((column, visibleIndex) => {
        const prevColumn = visibleColumns[visibleIndex - 1];
        const columnIndex = getSummaryCellIndex(column, prevColumn, isGroupRow3);
        summaryCells.push(summaryCellsByColumns[columnIndex] || []);
      }));
    }
    return summaryCells;
  }
  _getSummaryCells(summaryTotalItems, totalAggregates) {
    const that = this;
    const columnsController = that._columnsController;
    return that._calculateSummaryCells(summaryTotalItems, totalAggregates, columnsController.getVisibleColumns(), ((summaryItem, column) => that._isDataColumn(column) ? column.index : -1));
  }
  _updateItemsCore(change) {
    const that = this;
    let summaryCells;
    const dataSource = that._dataSource;
    const footerItems = that._footerItems;
    const oldSummaryCells = footerItems && footerItems[0] && footerItems[0].summaryCells;
    const summaryTotalItems = that.option("summary.totalItems");
    that._footerItems = [];
    if (dataSource && summaryTotalItems && summaryTotalItems.length) {
      const totalAggregates = dataSource.totalAggregates();
      summaryCells = that._getSummaryCells(summaryTotalItems, totalAggregates);
      if (change && change.repaintChangesOnly && oldSummaryCells) {
        change.totalColumnIndices = summaryCells.map(((summaryCell, index) => {
          if (JSON.stringify(summaryCell) !== JSON.stringify(oldSummaryCells[index])) {
            return index;
          }
          return -1;
        })).filter(((index) => index >= 0));
      }
      if (summaryCells.length) {
        that._footerItems.push({
          rowType: "totalFooter",
          summaryCells
        });
      }
    }
    super._updateItemsCore(change);
  }
  _prepareUnsavedDataSelector(selector) {
    if (recalculateWhileEditing(this)) {
      const editingController = this._editingController;
      if (editingController) {
        return function(data17) {
          data17 = editingController.getUpdatedData(data17);
          return selector(data17);
        };
      }
    }
    return selector;
  }
  _prepareAggregateSelector(selector, aggregator) {
    selector = this._prepareUnsavedDataSelector(selector);
    if ("avg" === aggregator || "sum" === aggregator) {
      return function(data17) {
        const value2 = selector(data17);
        return isDefined(value2) ? Number(value2) : value2;
      };
    }
    return selector;
  }
  _getAggregates(summaryItems, remoteOperations) {
    const that = this;
    let calculateCustomSummary = that.option("summary.calculateCustomSummary");
    const commonSkipEmptyValues = that.option("summary.skipEmptyValues");
    return map(summaryItems || [], ((summaryItem) => {
      const column = this._columnsController.columnOption(summaryItem.column);
      const calculateCellValue = column && column.calculateCellValue ? column.calculateCellValue.bind(column) : compileGetter(column ? column.dataField : summaryItem.column);
      let aggregator = summaryItem.summaryType || "count";
      const skipEmptyValues = isDefined(summaryItem.skipEmptyValues) ? summaryItem.skipEmptyValues : commonSkipEmptyValues;
      if (remoteOperations) {
        return {
          selector: summaryItem.column,
          summaryType: aggregator
        };
      }
      const selector = that._prepareAggregateSelector(calculateCellValue, aggregator);
      if ("custom" === aggregator) {
        if (!calculateCustomSummary) {
          ui_errors_default.log("E1026");
          calculateCustomSummary = function() {
          };
        }
        const options = {
          component: that.component,
          name: summaryItem.name
        };
        calculateCustomSummary(options);
        options.summaryProcess = "calculate";
        aggregator = {
          seed(groupIndex) {
            options.summaryProcess = "start";
            options.totalValue = void 0;
            options.groupIndex = groupIndex;
            delete options.value;
            calculateCustomSummary(options);
            return options.totalValue;
          },
          step(totalValue, value2) {
            options.summaryProcess = "calculate";
            options.totalValue = totalValue;
            options.value = value2;
            calculateCustomSummary(options);
            return options.totalValue;
          },
          finalize(totalValue) {
            options.summaryProcess = "finalize";
            options.totalValue = totalValue;
            delete options.value;
            calculateCustomSummary(options);
            return options.totalValue;
          }
        };
      }
      return {
        selector,
        aggregator,
        skipEmptyValues
      };
    }));
  }
  _addSortInfo(sortByGroups, groupColumn, selector, sortOrder) {
    if (groupColumn) {
      const {
        groupIndex
      } = groupColumn;
      sortOrder = sortOrder || groupColumn.sortOrder;
      if (isDefined(groupIndex)) {
        sortByGroups[groupIndex] = sortByGroups[groupIndex] || [];
        sortByGroups[groupIndex].push({
          selector,
          desc: "desc" === sortOrder
        });
      }
    }
  }
  _findSummaryItem(summaryItems, name) {
    let summaryItemIndex = -1;
    if (isDefined(name)) {
      each(summaryItems || [], (function(index) {
        if (this.name === name || index === name || this.summaryType === name || this.column === name || (function(summaryItem) {
          const {
            summaryType
          } = summaryItem;
          const {
            column
          } = summaryItem;
          return summaryType && column && `${summaryType}_${column}`;
        })(this) === name) {
          summaryItemIndex = index;
          return false;
        }
      }));
    }
    return summaryItemIndex;
  }
  _getSummarySortByGroups(sortByGroupSummaryInfo, groupSummaryItems) {
    const that = this;
    const columnsController = that._columnsController;
    const groupColumns = columnsController.getGroupColumns();
    const sortByGroups = [];
    if (!groupSummaryItems || !groupSummaryItems.length) {
      return;
    }
    each(sortByGroupSummaryInfo || [], (function() {
      const {
        sortOrder
      } = this;
      let {
        groupColumn
      } = this;
      const summaryItemIndex = that._findSummaryItem(groupSummaryItems, this.summaryItem);
      if (summaryItemIndex < 0) {
        return;
      }
      const selector = function(data17) {
        return getGroupAggregates(data17)[summaryItemIndex];
      };
      if (isDefined(groupColumn)) {
        groupColumn = columnsController.columnOption(groupColumn);
        that._addSortInfo(sortByGroups, groupColumn, selector, sortOrder);
      } else {
        each(groupColumns, ((groupIndex, groupColumn2) => {
          that._addSortInfo(sortByGroups, groupColumn2, selector, sortOrder);
        }));
      }
    }));
    return sortByGroups;
  }
  _createDataSourceAdapterCore(dataSource, remoteOperations) {
    const that = this;
    const dataSourceAdapter = super._createDataSourceAdapterCore(dataSource, remoteOperations);
    dataSourceAdapter.summaryGetter(((currentRemoteOperations) => that._getSummaryOptions(currentRemoteOperations || remoteOperations)));
    return dataSourceAdapter;
  }
  _getSummaryOptions(remoteOperations) {
    const that = this;
    const groupSummaryItems = that.option("summary.groupItems");
    const totalSummaryItems = that.option("summary.totalItems");
    const sortByGroupSummaryInfo = that.option("sortByGroupSummaryInfo");
    const groupAggregates = that._getAggregates(groupSummaryItems, remoteOperations && remoteOperations.grouping && remoteOperations.summary);
    const totalAggregates = that._getAggregates(totalSummaryItems, remoteOperations && remoteOperations.summary);
    const sortByGroups = function() {
      return that._getSummarySortByGroups(sortByGroupSummaryInfo, groupSummaryItems);
    };
    if (groupAggregates.length || totalAggregates.length) {
      return {
        groupAggregates,
        totalAggregates,
        sortByGroups
      };
    }
    return;
  }
  publicMethods() {
    const methods = super.publicMethods();
    methods.push("getTotalSummaryValue");
    return methods;
  }
  getTotalSummaryValue(summaryItemName) {
    const summaryItemIndex = this._findSummaryItem(this.option("summary.totalItems"), summaryItemName);
    const aggregates = this._dataSource.totalAggregates();
    if (aggregates.length && summaryItemIndex > -1) {
      return aggregates[summaryItemIndex];
    }
  }
  optionChanged(args) {
    if ("summary" === args.name || "sortByGroupSummaryInfo" === args.name) {
      args.name = "dataSource";
    }
    super.optionChanged(args);
  }
  init() {
    this._footerItems = [];
    super.init();
  }
  footerItems() {
    return this._footerItems;
  }
};
var editing3 = (Base) => class extends Base {
  _refreshSummary() {
    if (recalculateWhileEditing(this) && !this.isSaving()) {
      this._dataController.refresh({
        load: true,
        changesOnly: true
      });
    }
  }
  _addChange(params) {
    const result = super._addChange.apply(this, arguments);
    if (params.type) {
      this._refreshSummary();
    }
    return result;
  }
  _removeChange() {
    const result = super._removeChange.apply(this, arguments);
    this._refreshSummary();
    return result;
  }
  cancelEditData() {
    const result = super.cancelEditData.apply(this, arguments);
    this._refreshSummary();
    return result;
  }
};
var rowsView11 = (Base) => class extends Base {
  _createRow(row) {
    const $row = super._createRow.apply(this, arguments);
    row && $row.addClass("groupFooter" === row.rowType ? "dx-datagrid-group-footer" : "");
    return $row;
  }
  _renderCells($row, options) {
    super._renderCells.apply(this, arguments);
    if ("group" === options.row.rowType && options.row.summaryCells && options.row.summaryCells.length) {
      this._renderGroupSummaryCells($row, options);
    }
  }
  _hasAlignByColumnSummaryItems(columnIndex, options) {
    return !isDefined(options.columns[columnIndex].groupIndex) && options.row.summaryCells[columnIndex].length;
  }
  _getAlignByColumnCellCount(groupCellColSpan, options) {
    let alignByColumnCellCount = 0;
    for (let i = 1; i < groupCellColSpan; i++) {
      const columnIndex = options.row.summaryCells.length - i;
      alignByColumnCellCount = this._hasAlignByColumnSummaryItems(columnIndex, options) ? i : alignByColumnCellCount;
    }
    return alignByColumnCellCount;
  }
  _renderGroupSummaryCells($row, options) {
    const $groupCell = $row.children().last();
    const groupCellColSpan = Number($groupCell.attr("colSpan")) || 1;
    const alignByColumnCellCount = this._getAlignByColumnCellCount(groupCellColSpan, options);
    this._renderGroupSummaryCellsCore($groupCell, options, groupCellColSpan, alignByColumnCellCount);
  }
  _renderGroupSummaryCellsCore($groupCell, options, groupCellColSpan, alignByColumnCellCount) {
    if (alignByColumnCellCount > 0) {
      $groupCell.attr("colSpan", groupCellColSpan - alignByColumnCellCount);
      for (let i = 0; i < alignByColumnCellCount; i++) {
        const columnIndex = options.columns.length - alignByColumnCellCount + i;
        this._renderCell($groupCell.parent(), extend({
          column: options.columns[columnIndex],
          columnIndex: this._getSummaryCellIndex(columnIndex, options.columns)
        }, options));
      }
    }
  }
  _getSummaryCellIndex(columnIndex, columns7) {
    return columnIndex;
  }
  _getCellTemplate(options) {
    if (!options.column.command && !isDefined(options.column.groupIndex) && options.summaryItems && options.summaryItems.length) {
      return renderSummaryCell;
    }
    return super._getCellTemplate(options);
  }
  _getCellOptions(options) {
    const that = this;
    const parameters = super._getCellOptions(options);
    if (options.row.summaryCells) {
      return extend(parameters, getSummaryCellOptions(that, options));
    }
    return parameters;
  }
};
m_core_default.registerModule("summary", {
  defaultOptions: () => ({
    summary: {
      groupItems: void 0,
      totalItems: void 0,
      calculateCustomSummary: void 0,
      skipEmptyValues: true,
      recalculateWhileEditing: false,
      texts: {
        sum: message_default.format("dxDataGrid-summarySum"),
        sumOtherColumn: message_default.format("dxDataGrid-summarySumOtherColumn"),
        min: message_default.format("dxDataGrid-summaryMin"),
        minOtherColumn: message_default.format("dxDataGrid-summaryMinOtherColumn"),
        max: message_default.format("dxDataGrid-summaryMax"),
        maxOtherColumn: message_default.format("dxDataGrid-summaryMaxOtherColumn"),
        avg: message_default.format("dxDataGrid-summaryAvg"),
        avgOtherColumn: message_default.format("dxDataGrid-summaryAvgOtherColumn"),
        count: message_default.format("dxDataGrid-summaryCount")
      }
    },
    sortByGroupSummaryInfo: void 0
  }),
  views: {
    footerView: FooterView
  },
  extenders: {
    controllers: {
      data: data13,
      editing: editing3
    },
    views: {
      rowsView: rowsView11
    }
  }
});

// node_modules/devextreme/esm/__internal/grids/grid_core/sticky_columns/m_sticky_columns.js
var baseStickyColumns = (Base) => class extends Base {
  _addStickyColumnBorderLeftClass($cell, column, rowIndex) {
    let onlyWithinBandColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;
    let fixedPosition = arguments.length > 4 ? arguments[4] : void 0;
    const isFirstFixedCell = isFirstFixedColumn(this._columnsController, column, rowIndex, onlyWithinBandColumn, fixedPosition);
    if (isFirstFixedCell) {
      GridCoreStickyColumnsDom.addStickyColumnBorderLeftClass($cell, this.addWidgetPrefix.bind(this));
    }
  }
  _addStickyColumnBorderRightClass($cell, column, rowIndex) {
    let onlyWithinBandColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;
    let fixedPosition = arguments.length > 4 ? arguments[4] : void 0;
    const isLastFixedCell = isLastFixedColumn(this._columnsController, column, rowIndex, onlyWithinBandColumn, fixedPosition);
    if (isLastFixedCell) {
      GridCoreStickyColumnsDom.addStickyColumnBorderRightClass($cell, this.addWidgetPrefix.bind(this));
    }
  }
  updateBorderCellClasses($cell, column, rowIndex) {
    const columnsController = this._columnsController;
    const isRowsView = "rowsView" === this.name;
    const needToRemoveBorder = needToRemoveColumnBorder(columnsController, column, rowIndex, isRowsView);
    const isFirstColumn = null === columnsController || void 0 === columnsController ? void 0 : columnsController.isFirstColumn(column, rowIndex);
    GridCoreStickyColumnsDom.toggleColumnNoBorderClass($cell, needToRemoveBorder, this.addWidgetPrefix.bind(this));
    GridCoreStickyColumnsDom.toggleFirstHeaderClass($cell, isFirstColumn, this.addWidgetPrefix.bind(this));
  }
  _updateBorderClasses() {
    const isColumnHeadersView = "columnHeadersView" === this.name;
    const $rows = this._getRowElementsCore().not(`.${CLASSES6.detailRow}`).toArray();
    $rows.forEach(((row, index) => {
      const rowIndex = isColumnHeadersView ? index : null;
      const $cells = renderer_default(row).children("td").toArray();
      let columns7 = this.getColumns(rowIndex);
      columns7 = processFixedColumns(this._columnsController, columns7);
      $cells.forEach(((cell, cellIndex) => {
        const $cell = renderer_default(cell);
        const column = columns7[cellIndex];
        if (column.visibleWidth !== HIDDEN_COLUMNS_WIDTH) {
          this.updateBorderCellClasses($cell, column, rowIndex);
        }
      }));
    }));
  }
  _renderCore(options) {
    const deferred = super._renderCore(options);
    const $element = this.element();
    const hasStickyColumns = this.hasStickyColumns();
    GridCoreStickyColumnsDom.toggleStickyColumnsClass($element, hasStickyColumns, this.addWidgetPrefix.bind(this));
    if (hasStickyColumns) {
      return deferred.done((() => {
        this.setStickyOffsets();
      }));
    }
    return deferred;
  }
  _createCell(options) {
    const {
      column
    } = options;
    const {
      rowType
    } = options;
    const $cell = super._createCell(options);
    const hasStickyColumns = this.hasStickyColumns();
    const rowIndex = "header" === rowType ? options.rowIndex : null;
    const isSummary = "groupFooter" === rowType || "totalFooter" === rowType || "group" === rowType;
    const isExpandColumn = column.command && "expand" === column.command;
    if (hasStickyColumns && !needToDisableStickyColumn(this._columnsController, column)) {
      this.updateBorderCellClasses($cell, column, rowIndex);
      if (column.fixed) {
        const fixedPosition = getColumnFixedPosition(this._columnsController, column);
        GridCoreStickyColumnsDom.addStickyColumnClass($cell, fixedPosition, this.addWidgetPrefix.bind(this));
        if (!isSummary && !isExpandColumn) {
          switch (fixedPosition) {
            case StickyPosition.Right:
              this._addStickyColumnBorderLeftClass($cell, column, rowIndex, false, StickyPosition.Right);
              break;
            case StickyPosition.Sticky:
              this._addStickyColumnBorderLeftClass($cell, column, rowIndex, true);
              this._addStickyColumnBorderRightClass($cell, column, rowIndex, true);
              break;
            default:
              this._addStickyColumnBorderRightClass($cell, column, rowIndex, false, StickyPosition.Left);
          }
        }
      }
    }
    return $cell;
  }
  setStickyOffsets(rowIndex, offsets) {
    const columnsController = this._columnsController;
    const rtlEnabled = this.option("rtlEnabled");
    const showColumnHeaders = this.option("showColumnHeaders");
    let widths = this.getColumnWidths(void 0, rowIndex);
    let columns7 = this.getColumns(showColumnHeaders ? rowIndex : void 0);
    columns7 = processFixedColumns(this._columnsController, columns7);
    if (rtlEnabled) {
      columns7 = rtlEnabled ? [...columns7].reverse() : columns7;
      widths = rtlEnabled ? [...widths].reverse() : widths;
    }
    columns7.forEach(((column, columnIndex) => {
      if (column.fixed) {
        const visibleColumnIndex = rtlEnabled ? columns7.length - columnIndex - 1 : columnIndex;
        const offset = getStickyOffset(columnsController, columns7, widths, columnIndex, offsets);
        if (offsets) {
          offsets[column.index] = offset;
        }
        const styleProps = normalizeOffset(offset);
        this.setCellProperties(styleProps, visibleColumnIndex, rowIndex);
      }
    }));
  }
  setColumnWidths(options) {
    const hasStickyColumns = this.hasStickyColumns();
    const columnsResizerController = this.getController("columnsResizer");
    const isColumnResizing = null === columnsResizerController || void 0 === columnsResizerController ? void 0 : columnsResizerController.isResizing();
    super.setColumnWidths(options);
    if (hasStickyColumns && isColumnResizing) {
      this.setStickyOffsets();
    }
  }
  _resizeCore() {
    const hasStickyColumns = this.hasStickyColumns();
    const adaptiveColumns2 = this.getController("adaptiveColumns");
    const hidingColumnsQueue = null === adaptiveColumns2 || void 0 === adaptiveColumns2 ? void 0 : adaptiveColumns2.getHidingColumnsQueue();
    super._resizeCore.apply(this, arguments);
    if (hasStickyColumns) {
      this.setStickyOffsets();
      if (null !== hidingColumnsQueue && void 0 !== hidingColumnsQueue && hidingColumnsQueue.length) {
        this._updateBorderClasses();
      }
    }
  }
  hasStickyColumns() {
    var _this$_columnsControl;
    const stickyColumns = null === (_this$_columnsControl = this._columnsController) || void 0 === _this$_columnsControl ? void 0 : _this$_columnsControl.getStickyColumns();
    return true !== this.option("columnFixing.legacyMode") && !!stickyColumns.length;
  }
};
var columnHeadersView7 = (Base) => class extends baseStickyColumns(Base) {
  setStickyOffsets() {
    const offsets = {};
    const rows = this._getRows();
    for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
      var _rows$rowIndex;
      const isFilterRow = "filter" === (null === rows || void 0 === rows || null === (_rows$rowIndex = rows[rowIndex]) || void 0 === _rows$rowIndex ? void 0 : _rows$rowIndex.rowType);
      super.setStickyOffsets(rowIndex, isFilterRow ? void 0 : offsets);
    }
  }
  getContextMenuItems(options) {
    const {
      column
    } = options;
    const columnsController = this._columnsController;
    const columnFixingOptions = this.option("columnFixing");
    let items = super.getContextMenuItems(options);
    if (options.row && "header" === options.row.rowType) {
      if (true === columnFixingOptions.enabled && column && column.allowFixing) {
        const onItemClick = (params) => {
          switch (params.itemData.value) {
            case "none":
              this._columnsController.columnOption(column.index, "fixed", false);
              break;
            case "left":
              this._columnsController.columnOption(column.index, {
                fixed: true,
                fixedPosition: "left"
              });
              break;
            case "right":
              this._columnsController.columnOption(column.index, {
                fixed: true,
                fixedPosition: "right"
              });
              break;
            case "sticky":
              this._columnsController.columnOption(column.index, {
                fixed: true,
                fixedPosition: "sticky"
              });
          }
        };
        const fixedPositionItems = [{
          text: columnFixingOptions.texts.leftPosition,
          icon: columnFixingOptions.icons.leftPosition,
          value: "left",
          disabled: column.fixed && (!column.fixedPosition || "left" === column.fixedPosition),
          onItemClick
        }, {
          text: columnFixingOptions.texts.rightPosition,
          icon: columnFixingOptions.icons.rightPosition,
          value: "right",
          disabled: column.fixed && "right" === column.fixedPosition,
          onItemClick
        }];
        if (true !== this.option("columnFixing.legacyMode") && !columnsController.isVirtualMode()) {
          fixedPositionItems.push({
            text: columnFixingOptions.texts.stickyPosition,
            icon: columnFixingOptions.icons.stickyPosition,
            value: "sticky",
            disabled: column.fixed && column.fixedPosition === StickyPosition.Sticky,
            onItemClick
          });
        }
        items = items || [];
        items.push({
          text: columnFixingOptions.texts.fix,
          icon: columnFixingOptions.icons.fix,
          beginGroup: true,
          items: fixedPositionItems
        }, {
          text: columnFixingOptions.texts.unfix,
          icon: columnFixingOptions.icons.unfix,
          value: "none",
          disabled: !column.fixed,
          onItemClick
        });
      }
    }
    return items;
  }
};
var rowsView12 = (Base) => class extends baseStickyColumns(Base) {
  _getMasterDetailWidth() {
    const componentWidth = getWidth(this.component.$element()) ?? 0;
    const borderWidth = m_utils_default.getComponentBorderWidth(this, this._$element);
    return componentWidth - borderWidth - this.getScrollbarWidth();
  }
  _renderMasterDetailCell($row, row, options) {
    const $detailCell = super._renderMasterDetailCell($row, row, options);
    if (this.hasStickyColumns()) {
      const detailContainerSelector = `.${this.addWidgetPrefix(CLASSES6.detailContainer)}`;
      const $detailContainer = $detailCell.find(detailContainerSelector);
      $detailContainer.addClass(this.addWidgetPrefix(CLASSES3.stickyColumnLeft));
      setWidth($detailContainer, this._getMasterDetailWidth());
    }
    return $detailCell;
  }
  _updateMasterDetailWidths() {
    const $detailContainers = this._getRowElements().children(`.${CLASSES6.detailCell}`).children(`.${this.addWidgetPrefix(CLASSES6.detailContainer)}`);
    const width = this._getMasterDetailWidth();
    setWidth($detailContainers, `${width}px`);
  }
  setStickyOffsets(rowIndex, offsets) {
    super.setStickyOffsets(rowIndex, offsets);
    this.setStickyOffsetsForGroupCells();
  }
  setStickyOffsetsForGroupCells() {
    const groupColumns = this._columnsController.getGroupColumns();
    let columns7 = this.getColumns();
    let widths = this.getColumnWidths();
    const columnsCountBeforeGroups = this._getColumnsCountBeforeGroups(columns7);
    const rtlEnabled = this.option("rtlEnabled");
    if (rtlEnabled) {
      columns7 = rtlEnabled ? [...columns7].reverse() : columns7;
      widths = rtlEnabled ? [...widths].reverse() : widths;
    }
    const $tableElement = this.getTableElement();
    groupColumns.forEach(((column) => {
      const columnIndex = columnsCountBeforeGroups + column.groupIndex + 1;
      const visibleColumnIndex = rtlEnabled ? columns7.length - columnIndex - 1 : columnIndex;
      const offset = getStickyOffset(this._columnsController, columns7, widths, visibleColumnIndex);
      const styleProps = normalizeOffset(offset);
      const $cells = $tableElement.children().children(".dx-group-row").find(`.dx-group-cell[aria-colindex='${columnIndex + 1}']`);
      for (let i = 0; i < $cells.length; i += 1) {
        const cell = $cells.get(i);
        const container = renderer_default(cell).find(".dx-datagrid-group-row-container").get(0);
        Object.assign(cell.style, styleProps);
        Object.assign(container.style, styleProps);
      }
    }));
  }
  _resizeCore() {
    const hasStickyColumns = this.hasStickyColumns();
    super._resizeCore.apply(this, arguments);
    if (hasStickyColumns) {
      this._updateMasterDetailWidths();
    }
  }
  _renderCellContent($cell, options, renderOptions) {
    const hasStickyColumns = this.hasStickyColumns();
    const isGroupRowResult = isGroupRow(options);
    const isDetailRowResult = isDetailRow(options);
    const needWrapContent = isGroupRowResult || isDetailRowResult;
    if (!hasStickyColumns || !needWrapContent) {
      return super._renderCellContent($cell, options, renderOptions);
    }
    const $container = renderer_default("<div>").toggleClass(this.addWidgetPrefix(CLASSES3.groupRowContainer), isGroupRowResult).toggleClass(this.addWidgetPrefix(CLASSES6.detailContainer), isDetailRowResult).appendTo($cell);
    return super._renderCellContent($container, options, renderOptions);
  }
  _renderGroupSummaryCellsCore($groupCell, options, groupCellColSpan, alignByColumnCellCount) {
    super._renderGroupSummaryCellsCore($groupCell, options, groupCellColSpan, alignByColumnCellCount);
    const stickySummarySelector = `.${this.addWidgetPrefix(CLASSES3.stickyColumn)}`;
    if ($groupCell.parent().find(stickySummarySelector).length && GridCoreStickyColumnsDom.doesGroupCellEndInFirstColumn($groupCell)) {
      GridCoreStickyColumnsDom.addStickyColumnBorderRightClass($groupCell, this.addWidgetPrefix.bind(this));
    }
  }
  _handleScroll(e) {
    const hasStickyColumns = this.hasStickyColumns();
    super._handleScroll(e);
    if (hasStickyColumns) {
      const editorFactoryController = this.getController("editorFactory");
      const hasOverlayElements = editorFactoryController.hasOverlayElements();
      if (hasOverlayElements) {
        const $focusedElement = editorFactoryController.focus();
        editorFactoryController.focus($focusedElement);
      }
    }
  }
  _scrollToElement($element, offset) {
    let scrollOffset = offset;
    const scrollable = this.getScrollable();
    const hasStickyColumns = this.hasStickyColumns();
    if (hasStickyColumns && scrollable) {
      const isFixedCell2 = GridCoreStickyColumnsDom.isFixedCell($element, this.addWidgetPrefix.bind(this));
      if (!$element.is("td") || isFixedCell2) {
        return;
      }
      const $row = null === $element || void 0 === $element ? void 0 : $element.closest("tr");
      const $cells = null === $row || void 0 === $row ? void 0 : $row.children();
      scrollOffset = GridCoreStickyColumnsDom.getScrollPadding($cells, renderer_default(scrollable.container()), this.addWidgetPrefix.bind(this));
    }
    super._scrollToElement($element, scrollOffset);
  }
};
var footerView = (Base) => class extends baseStickyColumns(Base) {
};
var columnsResizer2 = (Base) => class extends Base {
  getSeparatorOffsetX($cell) {
    var _this$_columnHeadersV;
    const hasStickyColumns = null === (_this$_columnHeadersV = this._columnHeadersView) || void 0 === _this$_columnHeadersV ? void 0 : _this$_columnHeadersV.hasStickyColumns();
    if (hasStickyColumns) {
      const $container = renderer_default(this._columnHeadersView.getContent());
      const isFixedCellPinnedToRight2 = GridCoreStickyColumnsDom.isFixedCellPinnedToRight($cell, $container, this.addWidgetPrefix.bind(this));
      const isWidgetResizingMode = "widget" === this.option("columnResizingMode");
      if (isWidgetResizingMode && isFixedCellPinnedToRight2) {
        var _$cell$offset;
        return (null === (_$cell$offset = $cell.offset()) || void 0 === _$cell$offset ? void 0 : _$cell$offset.left) ?? 0;
      }
    }
    return super.getSeparatorOffsetX($cell);
  }
  _correctColumnIndexForPoint(point, correctionValue, columns7) {
    const rtlEnabled = this.option("rtlEnabled");
    const isWidgetResizingMode = "widget" === this.option("columnResizingMode");
    const columnIndex = Math.max(point.index - 1, 0);
    const column = columns7[columnIndex];
    const nextColumnIndex = this._getNextColumnIndex(columnIndex);
    const nextColumn = columns7[nextColumnIndex];
    if (isWidgetResizingMode && !isFixedEdge(point, column, nextColumn)) {
      const $container = renderer_default(this._columnHeadersView.getContent());
      const isFixedCellPinnedToRight2 = GridCoreStickyColumnsDom.isFixedCellPinnedToRight(renderer_default(point.item), $container, this.addWidgetPrefix.bind(this));
      if (isFixedCellPinnedToRight2) {
        point.columnIndex -= rtlEnabled ? 1 : 0;
        return;
      }
    }
    super._correctColumnIndexForPoint(point, correctionValue, columns7);
  }
  _needToInvertResizing($cell) {
    const result = super._needToInvertResizing($cell);
    const isWidgetResizingMode = "widget" === this.option("columnResizingMode");
    if (!result && isWidgetResizingMode) {
      const $container = renderer_default(this._columnHeadersView.getContent());
      return GridCoreStickyColumnsDom.isFixedCellPinnedToRight($cell, $container, this.addWidgetPrefix.bind(this));
    }
    return result;
  }
  _generatePointsByColumns() {
    var _this$_columnHeadersV2;
    const hasStickyColumns = null === (_this$_columnHeadersV2 = this._columnHeadersView) || void 0 === _this$_columnHeadersV2 ? void 0 : _this$_columnHeadersV2.hasStickyColumns();
    super._generatePointsByColumns(hasStickyColumns);
  }
  _pointCreated(point, cellsLength, columns7) {
    var _this$_columnHeadersV3;
    const hasStickyColumns = null === (_this$_columnHeadersV3 = this._columnHeadersView) || void 0 === _this$_columnHeadersV3 ? void 0 : _this$_columnHeadersV3.hasStickyColumns();
    const result = super._pointCreated(point, cellsLength, columns7);
    const needToCheckPoint = hasStickyColumns && cellsLength > 0;
    if (needToCheckPoint && !result) {
      const column = columns7[point.index - 1];
      const nextColumnIndex = this._getNextColumnIndex(point.index - 1);
      const nextColumn = columns7[nextColumnIndex];
      return GridCoreStickyColumnsDom.noNeedToCreateResizingPoint(this._columnHeadersView, {
        point,
        column,
        nextColumn
      }, this.addWidgetPrefix.bind(this));
    }
    return result;
  }
};
var draggingHeader = (Base) => class extends Base {
  _generatePointsByColumns(options) {
    var _this$_columnHeadersV4;
    const hasStickyColumns = null === (_this$_columnHeadersV4 = this._columnHeadersView) || void 0 === _this$_columnHeadersV4 ? void 0 : _this$_columnHeadersV4.hasStickyColumns();
    const {
      sourceLocation,
      sourceColumn,
      targetDraggingPanel
    } = options;
    const isDraggingBetweenHeaders = "headers" === sourceLocation && "headers" === (null === targetDraggingPanel || void 0 === targetDraggingPanel ? void 0 : targetDraggingPanel.getName());
    if (hasStickyColumns && isDraggingBetweenHeaders) {
      const columnFixedPosition = getColumnFixedPosition(this._columnsController, sourceColumn);
      switch (true) {
        case (sourceColumn.fixed && columnFixedPosition === StickyPosition.Left):
          options.columnElements = GridCoreStickyColumnsDom.getLeftFixedCells(options.columnElements, this.addWidgetPrefix.bind(this));
          options.startColumnIndex = options.columnElements.eq(0).index();
          break;
        case (sourceColumn.fixed && columnFixedPosition === StickyPosition.Right):
          options.columnElements = GridCoreStickyColumnsDom.getRightFixedCells(options.columnElements, this.addWidgetPrefix.bind(this));
          options.startColumnIndex = options.columnElements.eq(0).index();
          break;
        default:
          options.columnElements = GridCoreStickyColumnsDom.getNonFixedAndStickyCells(options.columnElements, this.addWidgetPrefix.bind(this));
          options.startColumnIndex = options.columnElements.eq(0).index();
      }
    }
    return super._generatePointsByColumns(options, hasStickyColumns);
  }
  _pointCreated(point, columns7, location, sourceColumn) {
    const hasStickyColumns = this._columnHeadersView.hasStickyColumns();
    const $cells = this._columnHeadersView.getColumnElements();
    const needToCheckPoint = hasStickyColumns && "headers" === location && (null === $cells || void 0 === $cells ? void 0 : $cells.length) && (!sourceColumn.fixed || sourceColumn.fixedPosition === StickyPosition.Sticky);
    const result = super._pointCreated(point, columns7, location, sourceColumn);
    if (needToCheckPoint && !result) {
      return GridCoreStickyColumnsDom.noNeedToCreateReorderingPoint(point, $cells, renderer_default(this._columnHeadersView.getContent()), this.addWidgetPrefix.bind(this));
    }
    return result;
  }
};
var editorFactory2 = (Base) => class extends Base {
  getOverlayContainerIfNeeded($cell) {
    const hasFixedColumns = this._rowsView.hasStickyColumns();
    const isFixedCell2 = GridCoreStickyColumnsDom.isFixedCell($cell, this.addWidgetPrefix.bind(this));
    if (hasFixedColumns && isFixedCell2) {
      return $cell.closest(`.${this.addWidgetPrefix(CLASSES3.stickyColumns)}`);
    }
    return;
  }
  updateFocusOverlaySize($element, position) {
    const hasFixedColumns = this._rowsView.hasStickyColumns();
    if (!hasFixedColumns) {
      super.updateFocusOverlaySize($element, position);
    }
  }
  getFocusOverlaySize($element) {
    const hasFixedColumns = this._rowsView.hasStickyColumns();
    if (hasFixedColumns) {
      const elementRect = getBoundingRect($element.get(0));
      const isLastCell2 = GridCoreStickyColumnsDom.isLastCell($element);
      const isFixedCell2 = GridCoreStickyColumnsDom.isFixedCell($element, this.addWidgetPrefix.bind(this));
      return {
        width: elementRect.right - elementRect.left + (isLastCell2 || isFixedCell2 ? 0 : 1),
        height: elementRect.bottom - elementRect.top
      };
    }
    return super.getFocusOverlaySize($element);
  }
  getValidationMessageContainer($cell) {
    return this.getOverlayContainerIfNeeded($cell) ?? super.getValidationMessageContainer($cell);
  }
  getRevertButtonContainer($cell) {
    return this.getOverlayContainerIfNeeded($cell) ?? super.getRevertButtonContainer($cell);
  }
  getFocusOverlayContainer($focusedElement) {
    return this.getOverlayContainerIfNeeded($focusedElement) ?? super.getFocusOverlayContainer($focusedElement);
  }
  overlayPositionedHandler(e, isOverlayVisible) {
    const columnHeaders = this.getView("columnHeadersView");
    const hasStickyColumns = columnHeaders.hasStickyColumns();
    super.overlayPositionedHandler(e, isOverlayVisible);
    if (hasStickyColumns) {
      const $cell = renderer_default(e.element).closest("td");
      if (!GridCoreStickyColumnsDom.isFixedCell($cell, this.addWidgetPrefix.bind(this))) {
        const $wrapper = e.component.$wrapper();
        const $overlayContent = e.component.$content();
        const isOutsideVisibleArea2 = GridCoreStickyColumnsDom.isOutsideVisibleArea($overlayContent, renderer_default(columnHeaders.getColumnElements()), renderer_default(columnHeaders.getContent()), this.addWidgetPrefix.bind(this));
        $wrapper.css("zIndex", isOutsideVisibleArea2 ? 1 : (null === this || void 0 === this ? void 0 : this.getOverlayBaseZIndex()) ?? 0);
      }
    }
  }
  updateFocusOverlay($element) {
    let isHideBorder = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;
    if (!isHideBorder) {
      const isFixedCell2 = GridCoreStickyColumnsDom.isFixedCell($element, this.addWidgetPrefix.bind(this));
      this._$focusOverlay.toggleClass(CLASSES3.focusedFixedElement, isFixedCell2);
      const isGroupElement = isGroupRow2($element);
      const isGroupFooterRowElement = isGroupFooterRow($element);
      const isAdaptiveElement = isAdaptiveItem($element);
      if (isFixedCell2 || isGroupElement || isGroupFooterRowElement || isAdaptiveElement) {
        this._$focusOverlay.toggleClass(CLASSES3.focusedFixedElement, true);
      }
    }
    super.updateFocusOverlay($element, isHideBorder);
  }
};
var resizing4 = (Base) => class extends Base {
  resize() {
    const result = super.resize();
    const hasStickyColumns = this._columnHeadersView.hasStickyColumns();
    if (hasStickyColumns && null !== this && void 0 !== this && this.hasResizeTimeout()) {
      this._rowsView.setStickyOffsets();
    }
    return result;
  }
};
var headersKeyboardNavigation2 = (Base) => class extends Base {
  getContainerBoundingRect($container) {
    var _this$_columnHeadersV5;
    const hasStickyColumns = null === (_this$_columnHeadersV5 = this._columnHeadersView) || void 0 === _this$_columnHeadersV5 ? void 0 : _this$_columnHeadersV5.hasStickyColumns();
    if (hasStickyColumns) {
      const $cells = renderer_default(this._columnHeadersView.getColumnElements());
      return GridCoreStickyColumnsDom.getNonFixedAreaBoundingRect($cells, $container, this.addWidgetPrefix.bind(this));
    }
    return super.getContainerBoundingRect($container);
  }
  tabKeyHandler(_ref) {
    var _this$_columnHeadersV6, _this$getView;
    let {
      originalEvent,
      shift
    } = _ref;
    const hasStickyColumns = null === (_this$_columnHeadersV6 = this._columnHeadersView) || void 0 === _this$_columnHeadersV6 ? void 0 : _this$_columnHeadersV6.hasStickyColumns();
    const scrollable = null === (_this$getView = this.getView("rowsView")) || void 0 === _this$getView ? void 0 : _this$getView.getScrollable();
    if (!hasStickyColumns || !scrollable) {
      return;
    }
    const $cell = renderer_default(originalEvent.target).closest("td");
    const $nextCell = GridCoreStickyColumnsDom.getNextHeaderCell($cell, shift ? "previous" : "next");
    const isFixedCell2 = GridCoreStickyColumnsDom.isFixedCell($nextCell, this.addWidgetPrefix.bind(this));
    if (isFixedCell2) {
      return;
    }
    const nextCellIsOutsideVisibleArea = $nextCell.length && this.isOutsideVisibleArea($nextCell, renderer_default(this._columnHeadersView.getContent()));
    if (nextCellIsOutsideVisibleArea) {
      this.scrollToColumn($nextCell);
    }
  }
};
var stickyColumnsModule = {
  extenders: {
    views: {
      columnHeadersView: columnHeadersView7,
      rowsView: rowsView12,
      footerView
    },
    controllers: {
      columnsResizer: columnsResizer2,
      draggingHeader,
      editorFactory: editorFactory2,
      resizing: resizing4,
      headersKeyboardNavigation: headersKeyboardNavigation2
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/sticky_columns.js
m_core_default.registerModule("stickyColumns", stickyColumnsModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/column_fixing/m_column_fixing.js
var DETAIL_ROW_CLASS2 = "dx-master-detail-row";
var getTransparentColumnIndex = function(fixedColumns) {
  let transparentColumnIndex = -1;
  each(fixedColumns, ((index, column) => {
    if ("transparent" === column.command) {
      transparentColumnIndex = index;
      return false;
    }
    return;
  }));
  return transparentColumnIndex;
};
var normalizeColumnWidths = function(fixedColumns, widths, fixedWidths) {
  let fixedColumnIndex = 0;
  if (fixedColumns && widths && fixedWidths) {
    for (let i = 0; i < fixedColumns.length; i++) {
      if ("transparent" === fixedColumns[i].command) {
        fixedColumnIndex += fixedColumns[i].colspan;
      } else {
        if (widths[fixedColumnIndex] < fixedWidths[i]) {
          widths[fixedColumnIndex] = fixedWidths[i];
        }
        fixedColumnIndex++;
      }
    }
  }
  return widths;
};
var baseFixedColumns = (Base) => class extends Base {
  init() {
    super.init();
    this._isFixedTableRendering = false;
    this._isFixedColumns = false;
  }
  _createCol(column) {
    return super._createCol(column).toggleClass("dx-col-fixed", !!(this._isFixedTableRendering && (column.fixed || column.command && "transparent" !== column.command)));
  }
  isIndicesArray(arr) {
    return Array.isArray(arr) && arr.length > 0;
  }
  _correctColumnIndicesForFixedColumns(fixedColumns, change) {
    var _change$items;
    const columnIndicesArray = null === change || void 0 === change ? void 0 : change.columnIndices;
    if (!this.isIndicesArray(columnIndicesArray)) {
      return;
    }
    const transparentColumnIndex = getTransparentColumnIndex(fixedColumns);
    const transparentColspan = fixedColumns[transparentColumnIndex].colspan;
    const transparentOffset = transparentColumnIndex + transparentColspan;
    const rowTypes = null === change || void 0 === change || null === (_change$items = change.items) || void 0 === _change$items ? void 0 : _change$items.map(((_ref) => {
      let {
        rowType
      } = _ref;
      return rowType;
    }));
    change.columnIndices = columnIndicesArray.map(((columnIndices, idx) => {
      if (!this.isIndicesArray(columnIndices)) {
        return columnIndices;
      }
      const isGroupRow3 = rowTypes && "group" === rowTypes[idx];
      if (isGroupRow3) {
        return [...columnIndices];
      }
      return columnIndices.reduce(((result, colIdx) => {
        switch (true) {
          case colIdx < transparentColumnIndex:
            result.push(colIdx);
            break;
          case colIdx >= transparentOffset:
            result.push(colIdx - transparentColspan + 1);
        }
        return result;
      }), []);
    }));
  }
  _partialUpdateFixedTable(fixedColumns, rows) {
    const fixedTableElement = this._fixedTableElement;
    const $rows = this._getRowElementsCore(fixedTableElement);
    const $colgroup = fixedTableElement.children("colgroup");
    $colgroup.replaceWith(this._createColGroup(fixedColumns));
    for (let i = 0; i < rows.length; i++) {
      this._partialUpdateFixedRow(renderer_default($rows[i]), fixedColumns, rows[i]);
    }
  }
  _partialUpdateFixedRow($row, fixedColumns, row) {
    const cellElements = $row.get(0).childNodes;
    const transparentColumnIndex = getTransparentColumnIndex(fixedColumns);
    const transparentColumn = fixedColumns[transparentColumnIndex];
    const columnIndexOffset = this._columnsController.getColumnIndexOffset();
    let groupCellOptions;
    let colIndex = columnIndexOffset + 1;
    let {
      colspan
    } = transparentColumn;
    if ($row.hasClass(DETAIL_ROW_CLASS2)) {
      var _this$_columnsControl;
      cellElements[0].setAttribute("colspan", null === (_this$_columnsControl = this._columnsController.getVisibleColumns()) || void 0 === _this$_columnsControl ? void 0 : _this$_columnsControl.length);
      return;
    }
    if ($row.hasClass("dx-group-row")) {
      groupCellOptions = this._getGroupCellOptions({
        row,
        columns: this._columnsController.getVisibleColumns()
      });
      const hasSummary = row.summaryCells.length > 0;
      if (hasSummary) {
        const alignByColumnCellCount = this._getAlignByColumnCellCount(groupCellOptions.colspan, {
          columns: this._columnsController.getVisibleColumns(),
          row,
          isFixed: true
        });
        colspan = groupCellOptions.colspan - alignByColumnCellCount;
      } else {
        colspan = groupCellOptions.colspan - Math.max(0, cellElements.length - (groupCellOptions.columnIndex + 2));
      }
    }
    for (let j = 0; j < cellElements.length; j++) {
      const needUpdateColspan = groupCellOptions ? j === groupCellOptions.columnIndex + 1 : j === transparentColumnIndex;
      cellElements[j].setAttribute("aria-colindex", colIndex);
      if (needUpdateColspan) {
        cellElements[j].setAttribute("colspan", colspan);
        colIndex += colspan;
      } else {
        colIndex++;
      }
    }
  }
  _renderTable(options) {
    let $fixedTable;
    const fixedColumns = this.getFixedColumns();
    this._isFixedColumns = this.isFixedColumns();
    const $table = super._renderTable(options);
    if (this._isFixedColumns) {
      var _change$items2;
      const change = null === options || void 0 === options ? void 0 : options.change;
      const $fixedDataRows = this._getRowElements(this._fixedTableElement);
      const needPartialUpdate = (null === change || void 0 === change ? void 0 : change.virtualColumnsScrolling) && $fixedDataRows.length === (null === change || void 0 === change || null === (_change$items2 = change.items) || void 0 === _change$items2 ? void 0 : _change$items2.length);
      this._isFixedTableRendering = true;
      if (needPartialUpdate && true !== this.option("scrolling.legacyMode")) {
        var _options$change;
        this._partialUpdateFixedTable(fixedColumns, null === options || void 0 === options || null === (_options$change = options.change) || void 0 === _options$change ? void 0 : _options$change.items);
        this._isFixedTableRendering = false;
      } else {
        const columnIndices = null === change || void 0 === change ? void 0 : change.columnIndices;
        this._correctColumnIndicesForFixedColumns(fixedColumns, change);
        $fixedTable = this._createTable(fixedColumns);
        this._renderRows($fixedTable, extend({}, options, {
          columns: fixedColumns
        }));
        this._updateContent($fixedTable, change, true);
        if (columnIndices) {
          change.columnIndices = columnIndices;
        }
        this._isFixedTableRendering = false;
      }
    } else {
      this._fixedTableElement && this._fixedTableElement.parent().remove();
      this._fixedTableElement = null;
    }
    return $table;
  }
  _renderRow($table, options) {
    let fixedCorrection;
    let {
      cells
    } = options.row;
    super._renderRow.apply(this, arguments);
    if (this._isFixedTableRendering && cells && cells.length) {
      fixedCorrection = 0;
      const fixedCells = options.row.cells || [];
      cells = cells.slice();
      options.row.cells = cells;
      for (let i = 0; i < fixedCells.length; i++) {
        if (fixedCells[i].column && "transparent" === fixedCells[i].column.command) {
          fixedCorrection = (fixedCells[i].column.colspan || 1) - 1;
          continue;
        }
        cells[i + fixedCorrection] = fixedCells[i];
      }
    }
  }
  _createCell(options) {
    const that = this;
    const {
      column
    } = options;
    const columnCommand = column && column.command;
    const {
      rowType
    } = options;
    const $cell = super._createCell.apply(that, arguments);
    let fixedColumns;
    let prevFixedColumn;
    let transparentColumnIndex;
    if (that._isFixedTableRendering || "filter" === rowType) {
      fixedColumns = that.getFixedColumns();
      transparentColumnIndex = getTransparentColumnIndex(fixedColumns);
      prevFixedColumn = fixedColumns[transparentColumnIndex - 1];
    }
    if (that._isFixedTableRendering) {
      if ("transparent" === columnCommand) {
        $cell.addClass("dx-pointer-events-none").toggleClass("dx-first-cell", 0 === transparentColumnIndex || prevFixedColumn && "expand" === prevFixedColumn.command).toggleClass("dx-last-cell", fixedColumns.length && transparentColumnIndex === fixedColumns.length - 1);
        if ("freeSpace" !== rowType) {
          m_utils_default.setEmptyText($cell);
        }
      }
    } else if ("filter" === rowType) {
      $cell.toggleClass("dx-first-cell", options.columnIndex === transparentColumnIndex);
    }
    const isRowAltStyle = that.option("rowAlternationEnabled") && options.isAltRow;
    const isSelectAllCell = "multiple" === that.option("selection.mode") && 0 === options.columnIndex && "header" === options.rowType;
    if (browser_default.mozilla && options.column.fixed && "group" !== options.rowType && !isRowAltStyle && !isSelectAllCell) {
      $cell.addClass("dx-col-fixed");
    }
    return $cell;
  }
  _wrapTableInScrollContainer($table, isFixedTableRendering) {
    const $scrollContainer = super._wrapTableInScrollContainer.apply(this, arguments);
    if (this._isFixedTableRendering || isFixedTableRendering) {
      $scrollContainer.addClass(this.addWidgetPrefix("content-fixed"));
    }
    return $scrollContainer;
  }
  _renderCellContent($cell, options) {
    let isEmptyCell;
    const {
      column
    } = options;
    const isFixedTableRendering = this._isFixedTableRendering;
    const isGroupCell = "group" === options.rowType && isDefined(column.groupIndex);
    if (isFixedTableRendering && isGroupCell && !column.command && !column.groupCellTemplate) {
      $cell.css("pointerEvents", "none");
    }
    if (!isFixedTableRendering && this._isFixedColumns) {
      isEmptyCell = column.fixed || column.command && false !== column.fixed;
      if (isGroupCell) {
        isEmptyCell = false;
        if (options.row.summaryCells && options.row.summaryCells.length) {
          var _this$_getAlignByColu;
          const columns7 = this._columnsController.getVisibleColumns();
          const alignByFixedColumnCellCount = (null === (_this$_getAlignByColu = this._getAlignByColumnCellCount) || void 0 === _this$_getAlignByColu ? void 0 : _this$_getAlignByColu.call(this, column.colspan, {
            columns: columns7,
            row: options.row,
            isFixed: true
          })) ?? 0;
          if (alignByFixedColumnCellCount > 0) {
            const transparentColumnIndex = getTransparentColumnIndex(this._columnsController.getFixedColumns());
            isEmptyCell = columns7.length - alignByFixedColumnCellCount < transparentColumnIndex;
          }
        }
      }
      if (isEmptyCell) {
        if (column.command && "buttons" !== column.type || "group" === options.rowType) {
          $cell.html("&nbsp;").addClass(column.cssClass);
          return;
        }
        $cell.addClass("dx-hidden-cell");
      }
    }
    if ("transparent" !== column.command) {
      super._renderCellContent.apply(this, arguments);
    }
  }
  getContent(isFixedTableRendering) {
    var _this$_fixedTableElem;
    return isFixedTableRendering ? null === (_this$_fixedTableElem = this._fixedTableElement) || void 0 === _this$_fixedTableElem ? void 0 : _this$_fixedTableElem.parent() : super.getContent.apply(this, arguments);
  }
  _getCellElementsCore(rowIndex) {
    const cellElements = super._getCellElementsCore.apply(this, arguments);
    const isGroupRow3 = null === cellElements || void 0 === cellElements ? void 0 : cellElements.parent().hasClass("dx-group-row");
    const headerRowIndex = "columnHeadersView" === this.name ? rowIndex : void 0;
    if (this._fixedTableElement && cellElements) {
      const fixedColumns = this.getFixedColumns(headerRowIndex);
      const fixedCellElements = this._getRowElements(this._fixedTableElement).eq(rowIndex).children("td");
      each(fixedCellElements, ((columnIndex, cell) => {
        if (isGroupRow3) {
          if (cellElements[columnIndex] && "hidden" !== cell.style.visibility) {
            cellElements[columnIndex] = cell;
          }
        } else {
          const fixedColumn = fixedColumns[columnIndex];
          if (fixedColumn) {
            if ("transparent" === fixedColumn.command) {
              if (fixedCellElements.eq(columnIndex).hasClass("dx-master-detail-cell")) {
                cellElements[columnIndex] = cell || cellElements[columnIndex];
              }
            } else {
              const fixedColumnIndex = this._columnsController.getVisibleIndexByColumn(fixedColumn, headerRowIndex);
              cellElements[fixedColumnIndex] = cell || cellElements[fixedColumnIndex];
            }
          }
        }
      }));
    }
    return cellElements;
  }
  getColumnWidths(fixedTableElement, rowIndex) {
    const result = super.getColumnWidths(fixedTableElement, rowIndex);
    const fixedColumns = this.getFixedColumns();
    const fixedWidths = this._fixedTableElement && result.length ? super.getColumnWidths(this._fixedTableElement) : void 0;
    return normalizeColumnWidths(fixedColumns, result, fixedWidths);
  }
  getTableElement(isFixedTableRendering) {
    isFixedTableRendering = this._isFixedTableRendering || isFixedTableRendering;
    const tableElement = isFixedTableRendering ? this._fixedTableElement : super.getTableElement();
    return tableElement;
  }
  setTableElement(tableElement, isFixedTableRendering) {
    if (this._isFixedTableRendering || isFixedTableRendering) {
      this._fixedTableElement = tableElement.addClass("dx-pointer-events-none");
    } else {
      super.setTableElement(tableElement);
    }
  }
  getColumns(rowIndex) {
    const $tableElement = this.getTableElement();
    if (this._isFixedTableRendering) {
      return this.getFixedColumns(rowIndex);
    }
    return super.getColumns(rowIndex, $tableElement);
  }
  getRowIndex($row) {
    const $fixedTable = this._fixedTableElement;
    if ($fixedTable && $fixedTable.find($row).length) {
      return this._getRowElements($fixedTable).index($row);
    }
    return super.getRowIndex($row);
  }
  getTableElements() {
    let result = super.getTableElements.apply(this, arguments);
    if (this._fixedTableElement) {
      result = renderer_default([result.get(0), this._fixedTableElement.get(0)]);
    }
    return result;
  }
  getFixedColumns(rowIndex) {
    return this._columnsController.getFixedColumns(rowIndex);
  }
  getFixedColumnsOffset() {
    let offset = {
      left: 0,
      right: 0
    };
    let $transparentColumn;
    if (this._fixedTableElement) {
      $transparentColumn = this.getTransparentColumnElement();
      const positionTransparentColumn = $transparentColumn.position();
      offset = {
        left: positionTransparentColumn.left,
        right: getOuterWidth(this.element(), true) - (getOuterWidth($transparentColumn, true) + positionTransparentColumn.left)
      };
    }
    return offset;
  }
  getTransparentColumnElement() {
    return this._fixedTableElement && this._fixedTableElement.find(".dx-pointer-events-none").first();
  }
  getFixedTableElement() {
    return this._fixedTableElement;
  }
  _resizeCore() {
    super._resizeCore();
    this.synchronizeRows();
  }
  setColumnWidths(options) {
    var _options$optionNames;
    const {
      widths
    } = options;
    const visibleColumns = this._columnsController.getVisibleColumns();
    const isColumnWidthsSynced = (null === widths || void 0 === widths ? void 0 : widths.length) && visibleColumns.some(((column) => isDefined(column.visibleWidth)));
    const isColumnWidthChanged = null === (_options$optionNames = options.optionNames) || void 0 === _options$optionNames ? void 0 : _options$optionNames.width;
    super.setColumnWidths(options);
    if (this._fixedTableElement) {
      const hasAutoWidth = null === widths || void 0 === widths ? void 0 : widths.some(((width) => "auto" === width || !isDefined(width)));
      const needVisibleColumns = hasAutoWidth && (!isColumnWidthsSynced || !this.isScrollbarVisible(true));
      const columns7 = needVisibleColumns ? visibleColumns : this.getFixedColumns();
      this.setFixedTableColumnWidths(columns7, widths);
    }
    const wordWrapEnabled = this.option("wordWrapEnabled");
    const needSynchronizeRows = isColumnWidthsSynced || isColumnWidthChanged && wordWrapEnabled;
    if (needSynchronizeRows) {
      this.synchronizeRows();
    }
  }
  setFixedTableColumnWidths(columns7, widths) {
    if (!this._fixedTableElement || !widths) {
      return;
    }
    const $cols = this._fixedTableElement.children("colgroup").children("col");
    $cols.toArray().forEach(((col) => col.removeAttribute("style")));
    let columnIndex = 0;
    columns7.forEach(((column) => {
      if (column.colspan) {
        columnIndex += column.colspan;
        return;
      }
      const colWidth = normalizeWidth(widths[columnIndex]);
      if (isDefined(colWidth)) {
        setWidth2($cols.eq(columnIndex), colWidth);
      }
      columnIndex += 1;
    }));
  }
  _getClientHeight(element) {
    const boundingClientRectElement = element.getBoundingClientRect && getBoundingRect(element);
    return boundingClientRectElement && boundingClientRectElement.height ? boundingClientRectElement.height : element.clientHeight;
  }
  synchronizeRows() {
    const rowHeights = [];
    const fixedRowHeights = [];
    let rowIndex;
    let $rowElements;
    let $fixedRowElements;
    let $contentElement;
    this.waitAsyncTemplates(true).done((() => {
      if (this._isFixedColumns && this._tableElement && this._fixedTableElement) {
        const heightTable = this._getClientHeight(this._tableElement.get(0));
        const heightFixedTable = this._getClientHeight(this._fixedTableElement.get(0));
        $rowElements = this._getRowElements(this._tableElement);
        $fixedRowElements = this._getRowElements(this._fixedTableElement);
        $contentElement = this._findContentElement();
        if (heightTable !== heightFixedTable) {
          $contentElement && $contentElement.css("height", heightTable);
          $rowElements.css("height", "");
          $fixedRowElements.css("height", "");
          for (rowIndex = 0; rowIndex < $rowElements.length; rowIndex++) {
            rowHeights.push(this._getClientHeight($rowElements.get(rowIndex)));
            fixedRowHeights.push(this._getClientHeight($fixedRowElements.get(rowIndex)));
          }
          for (rowIndex = 0; rowIndex < $rowElements.length; rowIndex++) {
            const rowHeight = rowHeights[rowIndex];
            const fixedRowHeight = fixedRowHeights[rowIndex];
            if (rowHeight > fixedRowHeight) {
              $fixedRowElements.eq(rowIndex).css("height", rowHeight);
            } else if (rowHeight < fixedRowHeight) {
              $rowElements.eq(rowIndex).css("height", fixedRowHeight);
            }
          }
          $contentElement && $contentElement.css("height", "");
        }
      }
    }));
  }
  setScrollerSpacing(width, hWidth) {
    const rtlEnabled = this.option("rtlEnabled");
    super.setScrollerSpacing(width);
    this.element().children(`.${this.addWidgetPrefix("content-fixed")}`).css({
      paddingLeft: rtlEnabled ? width : "",
      paddingRight: !rtlEnabled ? width : ""
    });
  }
  isFixedColumns() {
    const fixedColumns = this.getFixedColumns();
    const legacyMode = this.option("columnFixing.legacyMode");
    return true === legacyMode && !!fixedColumns.length;
  }
};
var columnHeadersView8 = (Base) => class extends baseFixedColumns(Base) {
  _getRowVisibleColumns(rowIndex) {
    if (this._isFixedTableRendering) {
      return this.getFixedColumns(rowIndex);
    }
    return super._getRowVisibleColumns(rowIndex);
  }
  getFixedColumnElements(rowIndex) {
    const that = this;
    if (!this._isFixedColumns) {
      return;
    }
    if (isDefined(rowIndex)) {
      return this._fixedTableElement && this._getRowElements(this._fixedTableElement).eq(rowIndex).children();
    }
    const columnElements = that.getColumnElements();
    const $transparentColumnElement = that.getTransparentColumnElement();
    if (columnElements && $transparentColumnElement && $transparentColumnElement.length) {
      var _$transparentColumnEl;
      const transparentColumnIndex = getTransparentColumnIndex(that.getFixedColumns());
      [].splice.apply(columnElements, [transparentColumnIndex, null === (_$transparentColumnEl = $transparentColumnElement.get(0)) || void 0 === _$transparentColumnEl ? void 0 : _$transparentColumnEl.colSpan, $transparentColumnElement.get(0)]);
    }
    return columnElements;
  }
  getColumnWidths(fixedTableElement, rowIndex) {
    const that = this;
    let fixedWidths;
    const result = super.getColumnWidths(fixedTableElement, rowIndex);
    const $fixedColumnElements = that.getFixedColumnElements();
    const fixedColumns = that.getFixedColumns();
    if (that._fixedTableElement) {
      if ($fixedColumnElements && $fixedColumnElements.length) {
        fixedWidths = that._getWidths($fixedColumnElements);
      } else {
        fixedWidths = super.getColumnWidths(that._fixedTableElement);
      }
    }
    return normalizeColumnWidths(fixedColumns, result, fixedWidths);
  }
};
var rowsView13 = (Base) => class extends baseFixedColumns(Base) {
  dispose() {
    super.dispose.apply(this, arguments);
    clearTimeout(this._fixedScrollTimeout);
  }
  optionChanged(args) {
    super.optionChanged(args);
    if ("hoverStateEnabled" === args.name && this._isFixedColumns) {
      args.value ? this._attachHoverEvents() : this._detachHoverEvents();
    }
  }
  _detachHoverEvents() {
    const element = this.element();
    if (this._fixedTableElement && this._tableElement) {
      m_events_engine_default.off(element, "mouseover mouseout", ".dx-data-row");
    }
  }
  _attachHoverEvents() {
    if (this._fixedTableElement && this._tableElement) {
      m_events_engine_default.on(this.element(), "mouseover mouseout", ".dx-data-row", this.createAction(((args) => {
        const {
          event
        } = args;
        const rowIndex = this.getRowIndex(renderer_default(event.target).closest(".dx-row"));
        const isHover = "mouseover" === event.type;
        if (rowIndex >= 0) {
          this._tableElement && this._getRowElements(this._tableElement).eq(rowIndex).toggleClass("dx-state-hover", isHover);
          this._fixedTableElement && this._getRowElements(this._fixedTableElement).eq(rowIndex).toggleClass("dx-state-hover", isHover);
        }
      })));
    }
  }
  _getScrollDelay() {
    var _this$_resizingContro;
    const hasResizeTimeout = null === (_this$_resizingContro = this._resizingController) || void 0 === _this$_resizingContro ? void 0 : _this$_resizingContro.hasResizeTimeout();
    if (hasResizeTimeout) {
      return this.option("scrolling.updateTimeout");
    }
    return browser_default.mozilla ? 60 : 0;
  }
  _findContentElement(isFixedTableRendering) {
    let $content;
    let scrollTop;
    const contentClass = this.addWidgetPrefix("content");
    const element = this.element();
    isFixedTableRendering = this._isFixedTableRendering || isFixedTableRendering;
    if (element && isFixedTableRendering) {
      $content = element.children(`.${contentClass}`);
      const scrollable = this.getScrollable();
      if (!$content.length && scrollable) {
        $content = renderer_default("<div>").addClass(contentClass);
        m_events_engine_default.on($content, "scroll", ((e) => {
          const {
            target
          } = e;
          const scrollDelay = this._getScrollDelay();
          clearTimeout(this._fixedScrollTimeout);
          this._fixedScrollTimeout = setTimeout((() => {
            scrollTop = renderer_default(target).scrollTop();
            scrollable.scrollTo({
              y: scrollTop
            });
          }), scrollDelay);
        }));
        m_events_engine_default.on($content, EVENT_NAME, ((e) => {
          const $nearestScrollable = renderer_default(e.target).closest(".dx-scrollable");
          let shouldScroll = false;
          if (scrollable && scrollable.$element().is($nearestScrollable)) {
            shouldScroll = true;
          } else {
            const nearestScrollableInstance = $nearestScrollable.length && ui_scrollable_default.getInstance($nearestScrollable.get(0));
            const nearestScrollableHasVerticalScrollbar = nearestScrollableInstance && nearestScrollableInstance.scrollHeight() - nearestScrollableInstance.clientHeight() > 0;
            shouldScroll = nearestScrollableInstance && !nearestScrollableHasVerticalScrollbar;
          }
          if (shouldScroll) {
            scrollTop = scrollable.scrollTop();
            scrollable.scrollTo({
              y: scrollTop - e.delta
            });
            const scrollableTop = scrollable.scrollTop() + scrollable.clientHeight();
            const scrollableHeight = scrollable.scrollHeight() + this.getScrollbarWidth();
            const isPreventDefault = scrollable.scrollTop() > 0 && scrollableTop < scrollableHeight;
            if (isPreventDefault) {
              return false;
            }
          }
          return;
        }));
        $content.appendTo(element);
      }
      return $content;
    }
    return super._findContentElement();
  }
  _updateScrollable() {
    super._updateScrollable();
    const scrollable = this.getScrollable();
    if (null !== scrollable && void 0 !== scrollable && scrollable._disposed) {
      return;
    }
    const scrollTop = scrollable && scrollable.scrollOffset().top;
    this._updateFixedTablePosition(scrollTop);
  }
  _renderContent(contentElement, tableElement, isFixedTableRendering) {
    if (this._isFixedTableRendering || isFixedTableRendering) {
      return contentElement.empty().addClass(`${this.addWidgetPrefix("content")} ${this.addWidgetPrefix("content-fixed")}`).append(tableElement);
    }
    return super._renderContent(contentElement, tableElement);
  }
  _getGroupCellOptions(options) {
    if (this._isFixedTableRendering) {
      return super._getGroupCellOptions(extend({}, options, {
        columns: this._columnsController.getVisibleColumns()
      }));
    }
    return super._getGroupCellOptions(options);
  }
  _renderGroupedCells($row, options) {
    return super._renderGroupedCells($row, extend({}, options, {
      columns: this._columnsController.getVisibleColumns()
    }));
  }
  _renderGroupSummaryCells($row, options) {
    if (this._isFixedTableRendering) {
      super._renderGroupSummaryCells($row, extend({}, options, {
        columns: this._columnsController.getVisibleColumns()
      }));
    } else {
      super._renderGroupSummaryCells($row, options);
    }
  }
  _hasAlignByColumnSummaryItems(columnIndex, options) {
    const result = super._hasAlignByColumnSummaryItems.apply(this, arguments);
    const column = options.columns[columnIndex];
    if (options.isFixed) {
      return column.fixed && (result || "right" === column.fixedPosition);
    }
    return result && (!this._isFixedColumns || !column.fixed);
  }
  _renderGroupSummaryCellsCore($groupCell, options, groupCellColSpan, alignByColumnCellCount) {
    let alignByFixedColumnCellCount;
    if (this._isFixedTableRendering) {
      options.isFixed = true;
      alignByFixedColumnCellCount = this._getAlignByColumnCellCount(groupCellColSpan, options);
      options.isFixed = false;
      const startColumnIndex = options.columns.length - alignByFixedColumnCellCount;
      options = extend({}, options, {
        columns: this.getFixedColumns()
      });
      const transparentColumnIndex = getTransparentColumnIndex(options.columns);
      if (startColumnIndex < transparentColumnIndex) {
        alignByFixedColumnCellCount -= options.columns[transparentColumnIndex].colspan - 1 || 0;
        groupCellColSpan -= options.columns[transparentColumnIndex].colspan - 1 || 0;
      } else if (alignByColumnCellCount > 0) {
        $groupCell.css("visibility", "hidden");
      }
      alignByColumnCellCount = alignByFixedColumnCellCount;
    }
    super._renderGroupSummaryCellsCore($groupCell, options, groupCellColSpan, alignByColumnCellCount);
  }
  _getSummaryCellIndex(columnIndex, columns7) {
    if (this._isFixedTableRendering) {
      const transparentColumnIndex = getTransparentColumnIndex(columns7);
      if (columnIndex > transparentColumnIndex) {
        columnIndex += columns7[transparentColumnIndex].colspan - 1;
      }
      return columnIndex;
    }
    return super._getSummaryCellIndex.apply(this, arguments);
  }
  _renderCore(change) {
    this._detachHoverEvents();
    const deferred = super._renderCore(change);
    const isFixedColumns = this._isFixedColumns;
    this.element().toggleClass("dx-fixed-columns", isFixedColumns);
    if (this.option("hoverStateEnabled") && isFixedColumns) {
      this._attachHoverEvents();
    }
    return deferred;
  }
  setAriaOwns(headerTableId, footerTableId, isFixed) {
    if (isFixed) {
      var _this$element;
      const contentFixedClass = this.addWidgetPrefix("content-fixed");
      const $contentFixedElement = null === (_this$element = this.element()) || void 0 === _this$element ? void 0 : _this$element.children(`.${contentFixedClass}`);
      const $fixedTableElement = this.getFixedTableElement();
      if ($contentFixedElement.length && null !== $fixedTableElement && void 0 !== $fixedTableElement && $fixedTableElement.length) {
        this.setAria("owns", `${headerTableId ?? ""} ${$fixedTableElement.attr("id") ?? ""} ${footerTableId ?? ""}`.trim(), $contentFixedElement);
      }
    } else {
      super.setAriaOwns.apply(this, arguments);
    }
  }
  toggleDraggableColumnClass(columnIndex, value2) {
    super.toggleDraggableColumnClass(columnIndex, value2);
    if (this.isFixedColumns()) {
      const $rows = this._getRowElements(this._fixedTableElement);
      this._toggleDraggableSourceColumnClass($rows, this.getFixedColumns(), columnIndex, value2);
    }
  }
  getCellIndex($cell) {
    const $fixedTable = this._fixedTableElement;
    let cellIndex = 0;
    if ($fixedTable && $cell.is("td") && $cell.closest($fixedTable).length) {
      const columns7 = this.getFixedColumns();
      each(columns7, ((index, column) => {
        if (index === $cell[0].cellIndex) {
          return false;
        }
        if (column.colspan) {
          cellIndex += column.colspan;
          return;
        }
        cellIndex++;
        return;
      }));
      return cellIndex;
    }
    return super.getCellIndex.apply(this, arguments);
  }
  _updateFixedTablePosition(scrollTop, needFocus) {
    if (this._fixedTableElement && this._tableElement) {
      let $focusedElement;
      this._fixedTableElement.parent().scrollTop(scrollTop);
      if (needFocus && this._editorFactoryController) {
        $focusedElement = this._editorFactoryController.focus();
        $focusedElement && this._editorFactoryController.focus($focusedElement);
      }
    }
  }
  setScrollerSpacing(vWidth, hWidth) {
    const that = this;
    const styles = {
      marginBottom: 0
    };
    const $fixedContent = that.element().children(`.${this.addWidgetPrefix("content-fixed")}`);
    if ($fixedContent.length && that._fixedTableElement) {
      $fixedContent.css(styles);
      that._fixedTableElement.css(styles);
      styles[that.option("rtlEnabled") ? "marginLeft" : "marginRight"] = vWidth;
      styles.marginBottom = hWidth;
      const useNativeScrolling = that._scrollable && that._scrollable.option("useNative");
      (useNativeScrolling ? $fixedContent : that._fixedTableElement).css(styles);
    }
  }
  _getElasticScrollTop(e) {
    let elasticScrollTop = 0;
    if (e.scrollOffset.top < 0) {
      elasticScrollTop = -e.scrollOffset.top;
    } else if (e.reachedBottom) {
      const $scrollableContent = renderer_default(e.component.content());
      const $scrollableContainer = renderer_default(e.component.container());
      const maxScrollTop = Math.max($scrollableContent.get(0).clientHeight - $scrollableContainer.get(0).clientHeight, 0);
      elasticScrollTop = Math.min(maxScrollTop - e.scrollOffset.top, 0);
    }
    return Math.floor(elasticScrollTop);
  }
  _applyElasticScrolling(e) {
    if (this._fixedTableElement) {
      const elasticScrollTop = this._getElasticScrollTop(e);
      if (0 !== Math.ceil(elasticScrollTop)) {
        move(this._fixedTableElement, {
          top: elasticScrollTop
        });
      } else {
        this._fixedTableElement.css("transform", "");
      }
    }
  }
  _handleScroll(e) {
    this._updateFixedTablePosition(e.scrollOffset.top, true);
    this._applyElasticScrolling(e);
    super._handleScroll(e);
  }
  _updateContentPosition(isRender) {
    super._updateContentPosition.apply(this, arguments);
    if (!isRender) {
      this._updateFixedTablePosition(this._scrollTop);
    }
  }
  _afterRowPrepared(e) {
    if (this._isFixedTableRendering) {
      return;
    }
    super._afterRowPrepared(e);
  }
  _scrollToElement($element, offset) {
    const scrollOffset = this.isFixedColumns() ? this.getFixedColumnsOffset() : offset;
    super._scrollToElement($element, scrollOffset);
  }
};
var footerView2 = (Base) => class extends baseFixedColumns(Base) {
};
var normalizeColumnIndicesByPoints = function(columns7, fixedColumns, pointsByColumns) {
  const transparentColumnIndex = getTransparentColumnIndex(fixedColumns);
  const correctIndex = columns7.length - fixedColumns.length;
  each(pointsByColumns, ((_, point) => {
    if (point.index > transparentColumnIndex) {
      point.columnIndex += correctIndex;
      point.index += correctIndex;
    }
  }));
  return pointsByColumns;
};
var draggingHeader2 = (Base) => class extends Base {
  _generatePointsByColumns(options, needToCheckPrevPoint) {
    const visibleColumns = options.columns;
    const {
      targetDraggingPanel
    } = options;
    if (targetDraggingPanel && "headers" === targetDraggingPanel.getName() && targetDraggingPanel.isFixedColumns()) {
      if (options.sourceColumn.fixed) {
        if (!options.rowIndex) {
          options.columnElements = targetDraggingPanel.getFixedColumnElements(0);
        }
        options.columns = targetDraggingPanel.getFixedColumns(options.rowIndex);
        const pointsByColumns = super._generatePointsByColumns(options, needToCheckPrevPoint);
        normalizeColumnIndicesByPoints(visibleColumns, options.columns, pointsByColumns);
        return pointsByColumns;
      }
    }
    return super._generatePointsByColumns(options, needToCheckPrevPoint);
  }
  _pointCreated(point, columns7, location, sourceColumn) {
    const result = super._pointCreated.apply(this, arguments);
    const targetColumn = columns7[point.columnIndex];
    const $transparentColumn = this._columnHeadersView.getTransparentColumnElement();
    if (!result && "headers" === location && $transparentColumn && $transparentColumn.length) {
      const boundingRect = getBoundingRect($transparentColumn.get(0));
      if (sourceColumn && sourceColumn.fixed) {
        return "right" === sourceColumn.fixedPosition ? point.x < boundingRect.right : point.x > boundingRect.left;
      }
      if (targetColumn && targetColumn.fixed && "right" !== targetColumn.fixedPosition) {
        return true;
      }
      return point.x < boundingRect.left || point.x > boundingRect.right;
    }
    return result;
  }
};
var columnsResizer3 = (Base) => class extends Base {
  _generatePointsByColumns(needToCheckPrevPoint) {
    const that = this;
    const columnsController = that._columnsController;
    const columns7 = columnsController && that._columnsController.getVisibleColumns();
    const fixedColumns = columnsController && that._columnsController.getFixedColumns();
    const transparentColumnIndex = getTransparentColumnIndex(fixedColumns);
    const correctIndex = columns7.length - fixedColumns.length;
    const cells = that._columnHeadersView.getFixedColumnElements();
    super._generatePointsByColumns(needToCheckPrevPoint);
    if (cells && cells.length > 0) {
      that._pointsByFixedColumns = m_utils_default.getPointsByColumns(cells, ((point) => {
        if (point.index > transparentColumnIndex) {
          point.columnIndex += correctIndex;
          point.index += correctIndex;
        }
        return that._pointCreated(point, columns7.length, columns7);
      }));
    }
  }
  _getTargetPoint(pointsByColumns, currentX, deltaX) {
    const $transparentColumn = this._columnHeadersView.getTransparentColumnElement();
    if ($transparentColumn && $transparentColumn.length) {
      const boundingRect = getBoundingRect($transparentColumn.get(0));
      if (currentX <= boundingRect.left || currentX >= boundingRect.right) {
        return super._getTargetPoint(this._pointsByFixedColumns, currentX, deltaX);
      }
    }
    return super._getTargetPoint(pointsByColumns, currentX, deltaX);
  }
};
var resizing5 = (Base) => class extends Base {
  _setAriaOwns() {
    var _this$_columnHeadersV, _this$_footerView, _this$_rowsView;
    super._setAriaOwns.apply(this, arguments);
    const headerFixedTable = null === (_this$_columnHeadersV = this._columnHeadersView) || void 0 === _this$_columnHeadersV ? void 0 : _this$_columnHeadersV.getFixedTableElement();
    const footerFixedTable = null === (_this$_footerView = this._footerView) || void 0 === _this$_footerView ? void 0 : _this$_footerView.getFixedTableElement();
    null === (_this$_rowsView = this._rowsView) || void 0 === _this$_rowsView || _this$_rowsView.setAriaOwns(null === headerFixedTable || void 0 === headerFixedTable ? void 0 : headerFixedTable.attr("id"), null === footerFixedTable || void 0 === footerFixedTable ? void 0 : footerFixedTable.attr("id"), true);
  }
};
var keyboardNavigation = (Base) => class extends Base {
  _toggleInertAttr(value2) {
    var _this$_rowsView2;
    const $fixedContent = null === (_this$_rowsView2 = this._rowsView) || void 0 === _this$_rowsView2 ? void 0 : _this$_rowsView2.getFixedContentElement();
    if (value2) {
      null === $fixedContent || void 0 === $fixedContent || $fixedContent.attr("inert", true);
    } else {
      null === $fixedContent || void 0 === $fixedContent || $fixedContent.removeAttr("inert");
    }
  }
};
var editorFactory3 = (Base) => class extends Base {
  getValidationMessageContainer($cell) {
    const isFixedColumns = this._rowsView.isFixedColumns();
    if (isFixedColumns) {
      return this._rowsView.element();
    }
    return super.getValidationMessageContainer($cell);
  }
};
var columnFixingModule = {
  defaultOptions: () => ({
    columnFixing: {
      enabled: false,
      legacyMode: false,
      texts: {
        fix: message_default.format("dxDataGrid-columnFixingFix"),
        unfix: message_default.format("dxDataGrid-columnFixingUnfix"),
        leftPosition: message_default.format("dxDataGrid-columnFixingLeftPosition"),
        rightPosition: message_default.format("dxDataGrid-columnFixingRightPosition"),
        stickyPosition: message_default.format("dxDataGrid-columnFixingStickyPosition")
      },
      icons: {
        fix: "fix-column",
        unfix: "unfix-column",
        leftPosition: "fix-column-left",
        rightPosition: "fix-column-right",
        stickyPosition: "stick-column"
      }
    }
  }),
  extenders: {
    views: {
      columnHeadersView: columnHeadersView8,
      rowsView: rowsView13,
      footerView: footerView2
    },
    controllers: {
      draggingHeader: draggingHeader2,
      columnsResizer: columnsResizer3,
      resizing: resizing5,
      keyboardNavigation,
      editorFactory: editorFactory3
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/column_fixing.js
m_core_default.registerModule("columnFixing", columnFixingModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/adaptivity/m_adaptivity.js
var ROWS_VIEW2 = "rowsView";
var FOOTER_VIEW = "footerView";
var COLUMN_VIEWS = ["columnHeadersView", ROWS_VIEW2, FOOTER_VIEW];
var ADAPTIVE_NAMESPACE = "dxDataGridAdaptivity";
var EXPAND_ARIA_NAME = "dxDataGrid-ariaAdaptiveExpand";
var COLLAPSE_ARIA_NAME = "dxDataGrid-ariaAdaptiveCollapse";
var LEGACY_SCROLLING_MODE5 = "scrolling.legacyMode";
function getColumnId(that, column) {
  return that._columnsController.getColumnId(column);
}
function getDataCellElements($row) {
  return $row.find("td:not(.dx-datagrid-hidden-column):not([class*='dx-command-'])");
}
function adaptiveCellTemplate(container, options) {
  let $adaptiveColumnButton;
  const $container = renderer_default(container);
  const adaptiveColumnsController = options.component.getController("adaptiveColumns");
  if ("data" === options.rowType) {
    $adaptiveColumnButton = renderer_default("<span>").addClass(adaptiveColumnsController.addWidgetPrefix("adaptive-more"));
    m_events_engine_default.on($adaptiveColumnButton, addNamespace(CLICK_EVENT_NAME, ADAPTIVE_NAMESPACE), adaptiveColumnsController.createAction((() => {
      adaptiveColumnsController.toggleExpandAdaptiveDetailRow(options.key);
    })));
    $adaptiveColumnButton.appendTo($container);
  } else {
    m_utils_default.setEmptyText($container);
  }
}
function focusCellHandler(e) {
  var _e$data;
  const $nextCell = null === (_e$data = e.data) || void 0 === _e$data ? void 0 : _e$data.$nextCell;
  m_events_engine_default.off($nextCell, "focus", focusCellHandler);
  m_events_engine_default.trigger($nextCell, "dxclick");
}
var AdaptiveColumnsController = class extends m_modules_default.ViewController {
  init() {
    this._columnsController = this.getController("columns");
    this._dataController = this.getController("data");
    this._editingController = this.getController("editing");
    this._keyboardNavigationController = this.getController("keyboardNavigation");
    this._rowsView = this.getView("rowsView");
    this._columnsController.addCommandColumn({
      type: "adaptive",
      command: "adaptive",
      visible: true,
      adaptiveHidden: true,
      cssClass: "dx-command-adaptive",
      alignment: "center",
      width: "auto",
      cellTemplate: adaptiveCellTemplate,
      fixedPosition: "right"
    });
    this._columnsController.columnsChanged.add((() => {
      const isAdaptiveVisible = !!this.updateHidingQueue(this._columnsController.getColumns()).length;
      this._columnsController.columnOption("command:adaptive", "adaptiveHidden", !isAdaptiveVisible, true);
    }));
    this._hidingColumnsQueue = [];
    this._hiddenColumns = [];
    this.createAction("onAdaptiveDetailRowPreparing");
    super.init();
  }
  optionChanged(args) {
    if ("columnHidingEnabled" === args.name) {
      this._columnsController.columnOption("command:adaptive", "adaptiveHidden", !args.value);
    }
    super.optionChanged(args);
  }
  publicMethods() {
    return ["isAdaptiveDetailRowExpanded", "expandAdaptiveDetailRow", "collapseAdaptiveDetailRow"];
  }
  _isRowEditMode() {
    const editMode = this._getEditMode();
    return "row" === editMode;
  }
  _isItemModified(item, cellOptions) {
    const columnIndex = this._columnsController.getVisibleIndex(item.column.index);
    const rowIndex = this._dataController.getRowIndexByKey(cellOptions.key);
    const row = this._dataController.items()[rowIndex + 1];
    return row && row.modifiedValues && isDefined(row.modifiedValues[columnIndex]);
  }
  _renderFormViewTemplate(item, cellOptions, $container) {
    const that = this;
    const {
      column
    } = item;
    const focusAction = that.createAction((() => {
      if (that._editingController.isEditing()) {
        m_events_engine_default.trigger($container, CLICK_EVENT_NAME);
      }
    }));
    const rowData = cellOptions.row.data;
    const value2 = column.calculateCellValue(rowData);
    const displayValue = m_utils_default.getDisplayValue(column, value2, rowData, cellOptions.rowType);
    const text = m_utils_default.formatValue(displayValue, column);
    const isCellOrBatchEditMode = this._editingController.isCellOrBatchEditMode();
    const rowsView18 = that._rowsView;
    if (column.allowEditing && this._keyboardNavigationController.isKeyboardEnabled()) {
      $container.attr("tabIndex", that.option("tabIndex"));
      if (isCellOrBatchEditMode) {
        m_events_engine_default.off($container, "focus", focusAction);
        m_events_engine_default.on($container, "focus", focusAction);
      }
    }
    if (column.cellTemplate) {
      const templateOptions = extend({}, cellOptions, {
        value: value2,
        displayValue,
        text,
        column
      });
      rowsView18.renderTemplate($container, column.cellTemplate, templateOptions, isElementInDom($container)).done((() => {
        rowsView18._cellPrepared($container, cellOptions);
      }));
    } else {
      const container = $container.get(0);
      if (column.encodeHtml) {
        container.textContent = text;
      } else {
        container.innerHTML = text;
      }
      $container.addClass("dx-adaptive-item-text");
      if (!isDefined(text) || "" === text) {
        $container.html("&nbsp;");
      }
      if (!that._isRowEditMode()) {
        if (that._isItemModified(item, cellOptions)) {
          $container.addClass("dx-item-modified");
        }
      }
      rowsView18._cellPrepared($container, cellOptions);
    }
  }
  _getTemplate(item, cellOptions, updateForm) {
    const that = this;
    const {
      column
    } = item;
    const editingController = this._editingController;
    return function(options, container) {
      const $container = renderer_default(container);
      const columnIndex = that._columnsController.getVisibleIndex(column.index);
      const templateOptions = extend({}, cellOptions);
      const renderFormTemplate = function() {
        const isItemEdited = that._isItemEdited(item);
        templateOptions.value = cellOptions.row.values[columnIndex];
        if (isItemEdited || column.showEditorAlways) {
          editingController.renderFormEditorTemplate(templateOptions, item, options, $container, !isItemEdited);
        } else {
          templateOptions.column = column;
          templateOptions.columnIndex = columnIndex;
          that._renderFormViewTemplate(item, templateOptions, $container);
        }
      };
      renderFormTemplate();
      if (templateOptions.watch) {
        const dispose = templateOptions.watch((() => ({
          isItemEdited: that._isItemEdited(item),
          value: cellOptions.row.values[columnIndex]
        })), (() => {
          $container.contents().remove();
          $container.removeClass("dx-adaptive-item-text");
          renderFormTemplate();
        }));
        m_events_engine_default.on($container, removeEvent, dispose);
      }
    };
  }
  _isVisibleColumnsValid(visibleColumns) {
    if (visibleColumns < 2) {
      return false;
    }
    if (visibleColumns.length - (function() {
      let result = 0;
      for (let j = 0; j < visibleColumns.length; j++) {
        const visibleColumn = visibleColumns[j];
        if (visibleColumn.command) {
          result++;
        }
      }
      return result;
    })() <= 1) {
      return false;
    }
    return true;
  }
  _calculatePercentWidths(widths, visibleColumns) {
    const that = this;
    let percentWidths = 0;
    visibleColumns.forEach(((item, index) => {
      if ("adaptiveHidden" !== widths[index]) {
        percentWidths += that._getItemPercentWidth(item);
      }
    }));
    return percentWidths;
  }
  _isPercentWidth(width) {
    return isString(width) && width.endsWith("%");
  }
  _isColumnHidden(column) {
    return this._hiddenColumns.filter(((hiddenColumn) => hiddenColumn.index === column.index)).length > 0;
  }
  _getAverageColumnsWidth(containerWidth, columns7, columnsCanFit) {
    const that = this;
    let fixedColumnsWidth = 0;
    let columnsWithoutFixedWidthCount = 0;
    columns7.forEach(((column) => {
      if (!that._isColumnHidden(column)) {
        const {
          width
        } = column;
        if (isDefined(width) && !isNaN(parseFloat(width))) {
          fixedColumnsWidth += that._isPercentWidth(width) ? that._calculatePercentWidth({
            visibleIndex: column.visibleIndex,
            columnsCount: columns7.length,
            columnsCanFit,
            bestFitWidth: column.bestFitWidth,
            columnWidth: width,
            containerWidth
          }) : parseFloat(width);
        } else {
          columnsWithoutFixedWidthCount++;
        }
      }
    }));
    return (containerWidth - fixedColumnsWidth) / columnsWithoutFixedWidthCount;
  }
  _calculateColumnWidth(column, containerWidth, contentColumns, columnsCanFit) {
    const columnId = getColumnId(this, column);
    const widthOption = this._columnsController.columnOption(columnId, "width");
    const bestFitWidth = this._columnsController.columnOption(columnId, "bestFitWidth");
    const columnsCount = contentColumns.length;
    let colWidth;
    if (widthOption && "auto" !== widthOption) {
      if (this._isPercentWidth(widthOption)) {
        colWidth = this._calculatePercentWidth({
          visibleIndex: column.visibleIndex,
          columnsCount,
          columnsCanFit,
          bestFitWidth,
          columnWidth: widthOption,
          containerWidth
        });
      } else {
        return parseFloat(widthOption);
      }
    } else {
      const columnAutoWidth = this.option("columnAutoWidth");
      colWidth = columnAutoWidth || !!column.command ? bestFitWidth : this._getAverageColumnsWidth(containerWidth, contentColumns, columnsCanFit);
    }
    return colWidth;
  }
  _calculatePercentWidth(options) {
    const columnFitted = options.visibleIndex < options.columnsCount - 1 && options.columnsCanFit;
    const partialWidth = options.containerWidth * parseFloat(options.columnWidth) / 100;
    const resultWidth = options.columnsCanFit && partialWidth < options.bestFitWidth ? options.bestFitWidth : partialWidth;
    return columnFitted ? options.containerWidth * parseFloat(options.columnWidth) / 100 : resultWidth;
  }
  _getNotTruncatedColumnWidth(column, containerWidth, contentColumns, columnsCanFit) {
    const columnId = getColumnId(this, column);
    const widthOption = this._columnsController.columnOption(columnId, "width");
    const bestFitWidth = this._columnsController.columnOption(columnId, "bestFitWidth");
    if (widthOption && "auto" !== widthOption && !this._isPercentWidth(widthOption)) {
      return parseFloat(widthOption);
    }
    const colWidth = this._calculateColumnWidth(column, containerWidth, contentColumns, columnsCanFit);
    return colWidth < bestFitWidth ? null : colWidth;
  }
  _getItemPercentWidth(item) {
    let result = 0;
    if (item.width && this._isPercentWidth(item.width)) {
      result = parseFloat(item.width);
    }
    return result;
  }
  _getCommandColumnsWidth() {
    const that = this;
    const columns7 = that._columnsController.getVisibleColumns();
    let colWidth = 0;
    each(columns7, ((index, column) => {
      if (column.index < 0 || column.command) {
        colWidth += that._columnsController.columnOption(getColumnId(that, column), "bestFitWidth") || 0;
      }
    }));
    return colWidth;
  }
  _isItemEdited(item) {
    if (this.isFormOrPopupEditMode()) {
      return false;
    }
    if (this._isRowEditMode()) {
      const editRowKey = this.option("editing.editRowKey");
      if (equalByValue(editRowKey, this._dataController.adaptiveExpandedKey())) {
        return true;
      }
    } else {
      const rowIndex = this._dataController.getRowIndexByKey(this._dataController.adaptiveExpandedKey()) + 1;
      const columnIndex = this._columnsController.getVisibleIndex(item.column.index);
      return this._editingController.isEditCell(rowIndex, columnIndex);
    }
    return;
  }
  _getFormItemsByHiddenColumns(hiddenColumns) {
    const items = [];
    each(hiddenColumns, ((_, column) => {
      items.push({
        column,
        name: column.name,
        dataField: column.dataField,
        visibleIndex: column.visibleIndex
      });
    }));
    return items;
  }
  _getAdaptiveColumnVisibleIndex(visibleColumns) {
    for (let i = 0; i < visibleColumns.length; i++) {
      const column = visibleColumns[i];
      if ("adaptive" === column.command) {
        return i;
      }
    }
    return;
  }
  _hideAdaptiveColumn(resultWidths, visibleColumns) {
    const visibleIndex = this._getAdaptiveColumnVisibleIndex(visibleColumns);
    if (isDefined(visibleIndex)) {
      resultWidths[visibleIndex] = "adaptiveHidden";
      this._hideVisibleColumn({
        isCommandColumn: true,
        visibleIndex
      });
    }
  }
  _showHiddenCellsInView(_ref) {
    let {
      $cells,
      isCommandColumn
    } = _ref;
    let cssClassNameToRemove = this.addWidgetPrefix("hidden-column");
    if (isCommandColumn) {
      cssClassNameToRemove = "dx-command-adaptive-hidden";
      $cells.attr({
        tabIndex: 0,
        "aria-hidden": null
      }).removeClass(cssClassNameToRemove);
    } else {
      $cells.removeClass(cssClassNameToRemove);
    }
  }
  _showHiddenColumns() {
    for (let i = 0; i < COLUMN_VIEWS.length; i++) {
      const view = this.getView(COLUMN_VIEWS[i]);
      if (view && view.isVisible() && view.element()) {
        const viewName2 = view.name;
        const $hiddenCommandCells = view.element().find(".dx-command-adaptive-hidden");
        this._showHiddenCellsInView({
          viewName: viewName2,
          $cells: $hiddenCommandCells,
          isCommandColumn: true
        });
        const $hiddenCells = view.element().find(`.${this.addWidgetPrefix("hidden-column")}`);
        this._showHiddenCellsInView({
          viewName: viewName2,
          $cells: $hiddenCells
        });
      }
    }
  }
  _isCellValid($cell) {
    return $cell && $cell.length && !$cell.hasClass("dx-master-detail-cell") && !$cell.hasClass("dx-group-cell");
  }
  _hideVisibleColumn(_ref2) {
    let {
      isCommandColumn,
      visibleIndex
    } = _ref2;
    const that = this;
    COLUMN_VIEWS.forEach(((viewName2) => {
      const view = that.getView(viewName2);
      view && that._hideVisibleColumnInView({
        view,
        isCommandColumn,
        visibleIndex
      });
    }));
  }
  _hideVisibleColumnInView(_ref3) {
    let {
      view,
      isCommandColumn,
      visibleIndex
    } = _ref3;
    const viewName2 = view.name;
    let $cellElement;
    const column = this._columnsController.getVisibleColumns()[visibleIndex];
    const editFormRowIndex = this._editingController && this._editingController.getEditFormRowIndex();
    if (view && view.isVisible() && column) {
      const rowsCount = view.getRowsCount();
      const $rowElements = view._getRowElements();
      for (let rowIndex = 0; rowIndex < rowsCount; rowIndex++) {
        const cancelClassAdding = rowIndex === editFormRowIndex && viewName2 === ROWS_VIEW2 && "popup" !== this.option("editing.mode");
        if (!cancelClassAdding) {
          const currentVisibleIndex = "columnHeadersView" === viewName2 ? this._columnsController.getVisibleIndex(column.index, rowIndex) : visibleIndex;
          if (currentVisibleIndex >= 0) {
            const $rowElement = $rowElements.eq(rowIndex);
            $cellElement = this._findCellElementInRow($rowElement, currentVisibleIndex);
            this._isCellValid($cellElement) && this._hideVisibleCellInView({
              viewName: viewName2,
              isCommandColumn,
              $cell: $cellElement
            });
          }
        }
      }
    }
  }
  _findCellElementInRow($rowElement, visibleColumnIndex) {
    const $rowCells = $rowElement.children();
    let visibleIndex = visibleColumnIndex;
    let cellIsInsideGroup = false;
    if ($rowElement.hasClass("dx-group-row")) {
      const $groupCell = $rowElement.find(".dx-group-cell");
      const colSpan = $groupCell.attr("colspan");
      if ($groupCell.length && isDefined(colSpan)) {
        const groupCellLength = parseInt(colSpan);
        const endGroupIndex = $groupCell.index() + groupCellLength - 1;
        if (visibleColumnIndex > endGroupIndex) {
          visibleIndex = visibleColumnIndex - groupCellLength + 1;
        } else {
          cellIsInsideGroup = true;
        }
      }
    }
    const $cellElement = !cellIsInsideGroup ? $rowCells.eq(visibleIndex) : void 0;
    return $cellElement;
  }
  _hideVisibleCellInView(_ref4) {
    let {
      $cell,
      isCommandColumn
    } = _ref4;
    const cssClassNameToAdd = isCommandColumn ? "dx-command-adaptive-hidden" : this.addWidgetPrefix("hidden-column");
    $cell.attr({
      tabIndex: -1,
      "aria-hidden": true
    }).addClass(cssClassNameToAdd);
  }
  _getEditMode() {
    return this._editingController.getEditMode();
  }
  isFormOrPopupEditMode() {
    const editMode = this._getEditMode();
    return "form" === editMode || "popup" === editMode;
  }
  hideRedundantColumns(resultWidths, visibleColumns, hiddenQueue) {
    const that = this;
    this._hiddenColumns = [];
    if (that._isVisibleColumnsValid(visibleColumns) && hiddenQueue.length) {
      let totalWidth = 0;
      const $rootElement = that.component.$element();
      let rootElementWidth = getWidth($rootElement) - that._getCommandColumnsWidth();
      const getVisibleContentColumns = (function() {
        return visibleColumns.filter(((item) => !item.command && 0 === this._hiddenColumns.filter(((i2) => i2.index === item.index)).length));
      }).bind(this);
      let visibleContentColumns = getVisibleContentColumns();
      const contentColumnsCount = visibleContentColumns.length;
      let i;
      let hasHiddenColumns;
      let needHideColumn;
      do {
        needHideColumn = false;
        totalWidth = 0;
        const percentWidths = that._calculatePercentWidths(resultWidths, visibleColumns);
        const columnsCanFit = percentWidths < 100 && 0 !== percentWidths;
        for (i = 0; i < visibleColumns.length; i++) {
          const visibleColumn = visibleColumns[i];
          let columnWidth = that._getNotTruncatedColumnWidth(visibleColumn, rootElementWidth, visibleContentColumns, columnsCanFit);
          const columnId = getColumnId(that, visibleColumn);
          const widthOption = that._columnsController.columnOption(columnId, "width");
          const minWidth = that._columnsController.columnOption(columnId, "minWidth");
          const columnBestFitWidth = that._columnsController.columnOption(columnId, "bestFitWidth");
          if ("adaptiveHidden" === resultWidths[i]) {
            hasHiddenColumns = true;
            continue;
          }
          if (!columnWidth && !visibleColumn.command && !visibleColumn.fixed) {
            needHideColumn = true;
            break;
          }
          if (!widthOption || "auto" === widthOption) {
            columnWidth = Math.max(columnBestFitWidth || 0, minWidth || 0);
          }
          if ("adaptive" !== visibleColumn.command || hasHiddenColumns) {
            totalWidth += columnWidth;
          }
        }
        needHideColumn = needHideColumn || totalWidth > getWidth($rootElement);
        if (needHideColumn) {
          const column = hiddenQueue.pop();
          const visibleIndex = that._columnsController.getVisibleIndex(column.index);
          rootElementWidth += that._calculateColumnWidth(column, rootElementWidth, visibleContentColumns, columnsCanFit);
          that._hideVisibleColumn({
            visibleIndex
          });
          resultWidths[visibleIndex] = "adaptiveHidden";
          this._hiddenColumns.push(column);
          visibleContentColumns = getVisibleContentColumns();
        }
      } while (needHideColumn && visibleContentColumns.length > 1 && hiddenQueue.length);
      if (contentColumnsCount === visibleContentColumns.length) {
        that._hideAdaptiveColumn(resultWidths, visibleColumns);
      }
    } else {
      that._hideAdaptiveColumn(resultWidths, visibleColumns);
    }
  }
  getAdaptiveDetailItems() {
    return this._$itemContents;
  }
  getItemContentByColumnIndex(visibleColumnIndex) {
    let $itemContent;
    for (let i = 0; i < this._$itemContents.length; i++) {
      $itemContent = this._$itemContents.eq(i);
      const item = $itemContent.data("dx-form-item");
      if (item && item.column && this._columnsController.getVisibleIndex(item.column.index) === visibleColumnIndex) {
        return $itemContent;
      }
    }
  }
  toggleExpandAdaptiveDetailRow(key, alwaysExpanded) {
    if (!(this.isFormOrPopupEditMode() && this._editingController.isEditing())) {
      this._dataController.toggleExpandAdaptiveDetailRow(key, alwaysExpanded);
    }
  }
  createFormByHiddenColumns(container, options) {
    const that = this;
    const $container = renderer_default(container);
    const userFormOptions = {
      items: that._getFormItemsByHiddenColumns(that._hiddenColumns),
      formID: `dx-${new guid_default()}`
    };
    const defaultFormOptions = isMaterial() ? {
      colCount: 2
    } : {};
    this.executeAction("onAdaptiveDetailRowPreparing", {
      formOptions: userFormOptions
    });
    that._$itemContents = null;
    that._form = that._createComponent(renderer_default("<div>").appendTo($container), form_default, extend(defaultFormOptions, userFormOptions, {
      customizeItem(item) {
        const column = item.column || that._columnsController.columnOption(item.name || item.dataField);
        if (column) {
          item.label = item.label || {};
          item.label.text = item.label.text || column.caption;
          item.column = column;
          item.template = that._getTemplate(item, options, that.updateForm.bind(that));
        }
        userFormOptions.customizeItem && userFormOptions.customizeItem.call(this, item);
      },
      onContentReady(e) {
        userFormOptions.onContentReady && userFormOptions.onContentReady.call(this, e);
        that._$itemContents = $container.find(".dx-field-item-content");
      }
    }));
  }
  hasAdaptiveDetailRowExpanded() {
    return isDefined(this._dataController.adaptiveExpandedKey());
  }
  updateForm(hiddenColumns) {
    if (this.hasAdaptiveDetailRowExpanded()) {
      if (this._form && isDefined(this._form._contentReadyAction)) {
        if (hiddenColumns && hiddenColumns.length) {
          this._form.option("items", this._getFormItemsByHiddenColumns(hiddenColumns));
        } else {
          this._form.repaint();
        }
      }
    }
  }
  updateHidingQueue(columns7) {
    const that = this;
    const hideableColumns = columns7.filter(((column) => column.visible && !column.type && !column.fixed && !(isDefined(column.groupIndex) && column.groupIndex >= 0)));
    let columnsHasHidingPriority;
    let i;
    that._hidingColumnsQueue = [];
    if (that.option("allowColumnResizing") && "widget" === that.option("columnResizingMode")) {
      return that._hidingColumnsQueue;
    }
    for (i = 0; i < hideableColumns.length; i++) {
      if (isDefined(hideableColumns[i].hidingPriority) && hideableColumns[i].hidingPriority >= 0) {
        columnsHasHidingPriority = true;
        that._hidingColumnsQueue[hideableColumns[i].hidingPriority] = hideableColumns[i];
      }
    }
    if (columnsHasHidingPriority) {
      that._hidingColumnsQueue.reverse();
    } else if (that.option("columnHidingEnabled")) {
      for (i = 0; i < hideableColumns.length; i++) {
        const visibleIndex = that._columnsController.getVisibleIndex(hideableColumns[i].index);
        that._hidingColumnsQueue[visibleIndex] = hideableColumns[i];
      }
    }
    that._hidingColumnsQueue = that._hidingColumnsQueue.filter(Object);
    return that._hidingColumnsQueue;
  }
  getHiddenColumns() {
    return this._hiddenColumns;
  }
  hasHiddenColumns() {
    return this._hiddenColumns.length > 0;
  }
  getHidingColumnsQueue() {
    return this._hidingColumnsQueue;
  }
  isAdaptiveDetailRowExpanded(key) {
    const dataController2 = this._dataController;
    return dataController2.adaptiveExpandedKey() && equalByValue(dataController2.adaptiveExpandedKey(), key);
  }
  expandAdaptiveDetailRow(key) {
    if (!this.hasAdaptiveDetailRowExpanded()) {
      this.toggleExpandAdaptiveDetailRow(key);
    }
  }
  collapseAdaptiveDetailRow() {
    if (this.hasAdaptiveDetailRowExpanded()) {
      this.toggleExpandAdaptiveDetailRow();
    }
  }
  updateCommandAdaptiveAriaLabel(key, label) {
    const rowIndex = this._dataController.getRowIndexByKey(key);
    if (-1 === rowIndex) {
      return;
    }
    const $row = renderer_default(this.component.getRowElement(rowIndex));
    this.setCommandAdaptiveAriaLabel($row, label);
  }
  setCommandAdaptiveAriaLabel($row, labelName) {
    const $adaptiveCommand = $row.find(".dx-command-adaptive");
    $adaptiveCommand.attr("aria-label", message_default.format(labelName));
  }
};
var keyboardNavigation2 = (Base) => class extends Base {
  _isCellValid($cell, isClick) {
    return super._isCellValid($cell, isClick) && !$cell.hasClass(this.addWidgetPrefix("hidden-column")) && !$cell.hasClass("dx-command-adaptive-hidden");
  }
  _processNextCellInMasterDetail($nextCell, $cell) {
    super._processNextCellInMasterDetail($nextCell, $cell);
    const isCellOrBatchMode = this._editingController.isCellOrBatchEditMode();
    const isEditing = this._editingController.isEditing();
    if (isEditing && $nextCell && isCellOrBatchMode && !this._isInsideEditForm($nextCell)) {
      m_events_engine_default.off($nextCell, "focus", focusCellHandler);
      m_events_engine_default.on($nextCell, "focus", {
        $nextCell
      }, focusCellHandler);
      m_events_engine_default.trigger($cell, "focus");
    }
  }
  isFocusableColumn(column) {
    return super.isFocusableColumn(column) && "adaptiveHidden" !== column.visibleWidth;
  }
  _isCellElement($cell) {
    return super._isCellElement($cell) || $cell.hasClass("dx-adaptive-item-text");
  }
};
var rowsView14 = (Base) => class extends Base {
  _getCellTemplate(options) {
    const that = this;
    const {
      column
    } = options;
    if ("detailAdaptive" === options.rowType && "detail" === column.command) {
      return function(container, options2) {
        that._adaptiveColumnsController.createFormByHiddenColumns(renderer_default(container), options2);
      };
    }
    return super._getCellTemplate(options);
  }
  _createRow(row) {
    const $row = super._createRow.apply(this, arguments);
    if (row && "detailAdaptive" === row.rowType && row.key === this._dataController.adaptiveExpandedKey()) {
      $row.addClass("dx-adaptive-detail-row");
    }
    return $row;
  }
  _renderCells($row, options) {
    super._renderCells($row, options);
    const adaptiveColumnsController = this._adaptiveColumnsController;
    const hidingColumnsQueueLength = adaptiveColumnsController.getHidingColumnsQueue().length;
    const hiddenColumnsLength = adaptiveColumnsController.getHiddenColumns().length;
    if (hidingColumnsQueueLength && !hiddenColumnsLength) {
      getDataCellElements($row).last().addClass("dx-last-data-cell");
    }
    if ("data" === options.row.rowType) {
      adaptiveColumnsController.setCommandAdaptiveAriaLabel($row, EXPAND_ARIA_NAME);
    }
  }
  _getColumnIndexByElementCore($element) {
    const $itemContent = $element.closest(".dx-field-item-content");
    if ($itemContent.length && $itemContent.closest(this.component.$element()).length) {
      const formItem = $itemContent.length ? $itemContent.first().data("dx-form-item") : null;
      return formItem && formItem.column && this._columnsController.getVisibleIndex(formItem.column.index);
    }
    return super._getColumnIndexByElementCore($element);
  }
  _cellPrepared($cell, options) {
    super._cellPrepared.apply(this, arguments);
    if ("detailAdaptive" !== options.row.rowType && "adaptiveHidden" === options.column.visibleWidth) {
      $cell.addClass(this.addWidgetPrefix("hidden-column"));
    }
  }
  getCell(cellPosition, rows) {
    const item = this._dataController.items()[null === cellPosition || void 0 === cellPosition ? void 0 : cellPosition.rowIndex];
    if ("detailAdaptive" === (null === item || void 0 === item ? void 0 : item.rowType)) {
      const $adaptiveDetailItems = this._adaptiveColumnsController.getAdaptiveDetailItems();
      return super.getCell(cellPosition, rows, $adaptiveDetailItems);
    }
    return super.getCell.apply(this, arguments);
  }
  _getCellElement(rowIndex, columnIdentifier) {
    const item = this._dataController.items()[rowIndex];
    if (item && "detailAdaptive" === item.rowType) {
      return this._adaptiveColumnsController.getItemContentByColumnIndex(columnIdentifier);
    }
    return super._getCellElement.apply(this, arguments);
  }
  getContextMenuItems(options) {
    var _super$getContextMenu;
    if (options.row && "detailAdaptive" === options.row.rowType) {
      const view = this._columnHeadersView;
      const formItem = renderer_default(options.targetElement).closest(".dx-field-item-label").next().data("dx-form-item");
      options.column = formItem ? formItem.column : options.column;
      return view.getContextMenuItems && view.getContextMenuItems(options);
    }
    return null === (_super$getContextMenu = super.getContextMenuItems) || void 0 === _super$getContextMenu ? void 0 : _super$getContextMenu.call(this, options);
  }
  isClickableElement($target) {
    var _super$isClickableEle;
    const isClickable = (null === (_super$isClickableEle = super.isClickableElement) || void 0 === _super$isClickableEle ? void 0 : _super$isClickableEle.call(this, $target)) ?? false;
    return isClickable || !!$target.closest(".dx-command-adaptive").length;
  }
};
var exportExtender = (Base) => class extends Base {
  _updateColumnWidth(column, width) {
    super._updateColumnWidth(column, "adaptiveHidden" === column.visibleWidth ? column.bestFitWidth : width);
  }
};
var columnsResizer4 = (Base) => class extends Base {
  _pointCreated(point, cellsLength, columns7) {
    const result = super._pointCreated(point, cellsLength, columns7);
    const currentColumn = columns7[point.columnIndex] || {};
    const nextColumnIndex = this._getNextColumnIndex(point.columnIndex);
    const nextColumn = columns7[nextColumnIndex] || {};
    const hasHiddenColumnsOnly = nextColumnIndex !== point.columnIndex + 1 && nextColumn.command;
    const hasAdaptiveHiddenWidth = "adaptiveHidden" === currentColumn.visibleWidth || hasHiddenColumnsOnly;
    return result || hasAdaptiveHiddenWidth;
  }
  _getNextColumnIndex(currentColumnIndex) {
    const visibleColumns = this._columnsController.getVisibleColumns();
    let index = super._getNextColumnIndex(currentColumnIndex);
    while (visibleColumns[index] && "adaptiveHidden" === visibleColumns[index].visibleWidth) {
      index++;
    }
    return index;
  }
};
var draggingHeader3 = (Base) => class extends Base {
  _pointCreated(point, columns7, location, sourceColumn) {
    const result = super._pointCreated(point, columns7, location, sourceColumn);
    const column = columns7[point.columnIndex - 1] || {};
    const hasAdaptiveHiddenWidth = "adaptiveHidden" === column.visibleWidth;
    return result || hasAdaptiveHiddenWidth;
  }
};
var editing4 = (Base) => class extends Base {
  _isRowEditMode() {
    return "row" === this.getEditMode();
  }
  _getFormEditItemTemplate(cellOptions, column) {
    if ("row" !== this.getEditMode() && "detailAdaptive" === cellOptions.rowType) {
      cellOptions.columnIndex = this._columnsController.getVisibleIndex(column.index);
      return this.getColumnTemplate(cellOptions);
    }
    return super._getFormEditItemTemplate(cellOptions, column);
  }
  _closeEditItem($targetElement) {
    const $itemContents = $targetElement.closest(".dx-field-item-content");
    const rowIndex = this._dataController.getRowIndexByKey(this._dataController.adaptiveExpandedKey()) + 1;
    const formItem = $itemContents.length ? $itemContents.first().data("dx-form-item") : null;
    const columnIndex = formItem && formItem.column && this._columnsController.getVisibleIndex(formItem.column.index);
    if (!this.isEditCell(rowIndex, columnIndex)) {
      super._closeEditItem($targetElement);
    }
  }
  _beforeUpdateItems(rowIndices, rowIndex) {
    if (!this._adaptiveColumnsController.isFormOrPopupEditMode() && this._adaptiveColumnsController.hasHiddenColumns()) {
      const items = this._dataController.items();
      const item = items[rowIndex];
      const oldExpandRowIndex = m_utils_default.getIndexByKey(this._dataController.adaptiveExpandedKey(), items);
      this._isForceRowAdaptiveExpand = !this._adaptiveColumnsController.hasAdaptiveDetailRowExpanded();
      if (oldExpandRowIndex >= 0) {
        rowIndices.push(oldExpandRowIndex + 1);
      }
      rowIndices.push(rowIndex + 1);
      this._dataController.adaptiveExpandedKey(item.key);
    }
  }
  _afterInsertRow(key) {
    super._afterInsertRow.apply(this, arguments);
    if (this._adaptiveColumnsController.hasHiddenColumns()) {
      this._adaptiveColumnsController.toggleExpandAdaptiveDetailRow(key, this.isRowEditMode());
      this._isForceRowAdaptiveExpand = true;
    }
  }
  _collapseAdaptiveDetailRow() {
    if (this._isRowEditMode() && this._isForceRowAdaptiveExpand) {
      this._adaptiveColumnsController.collapseAdaptiveDetailRow();
      this._isForceRowAdaptiveExpand = false;
    }
  }
  _cancelEditAdaptiveDetailRow() {
    if (this._adaptiveColumnsController.hasHiddenColumns()) {
      this._collapseAdaptiveDetailRow();
    }
  }
  _afterSaveEditData() {
    super._afterSaveEditData.apply(this, arguments);
    const deferred = new Deferred();
    if (this._isRowEditMode() && this._adaptiveColumnsController.hasHiddenColumns()) {
      when(this._validatingController.validate(true)).done(((isValid) => {
        if (isValid) {
          this._cancelEditAdaptiveDetailRow();
        }
        deferred.resolve();
      }));
    } else {
      deferred.resolve();
    }
    return deferred.promise();
  }
  _beforeCancelEditData() {
    super._beforeCancelEditData();
    this._cancelEditAdaptiveDetailRow();
  }
  _getRowIndicesForCascadeUpdating(row) {
    const rowIndices = super._getRowIndicesForCascadeUpdating.apply(this, arguments);
    if (this._adaptiveColumnsController.isAdaptiveDetailRowExpanded(row.key)) {
      rowIndices.push("detailAdaptive" === row.rowType ? row.rowIndex - 1 : row.rowIndex + 1);
    }
    return rowIndices;
  }
  _beforeCloseEditCellInBatchMode(rowIndices) {
    const expandedKey = this._dataController._adaptiveExpandedKey;
    if (expandedKey) {
      const rowIndex = m_utils_default.getIndexByKey(expandedKey, this._dataController.items());
      if (rowIndex > -1) {
        rowIndices.unshift(rowIndex);
      }
    }
  }
  editRow(rowIndex) {
    if (this._adaptiveColumnsController.isFormOrPopupEditMode()) {
      this._adaptiveColumnsController.collapseAdaptiveDetailRow();
    }
    return super.editRow(rowIndex);
  }
  deleteRow(rowIndex) {
    const rowKey = this._dataController.getKeyByRowIndex(rowIndex);
    if ("batch" === this.getEditMode() && this._adaptiveColumnsController.isAdaptiveDetailRowExpanded(rowKey)) {
      this._adaptiveColumnsController.collapseAdaptiveDetailRow();
    }
    super.deleteRow(rowIndex);
  }
};
var data14 = (Base) => class extends Base {
  init() {
    super.init();
    this._adaptiveExpandedKey = void 0;
  }
  _processItems(items, change) {
    const {
      changeType
    } = change;
    items = super._processItems.apply(this, arguments);
    if ("loadingAll" === changeType || !isDefined(this._adaptiveExpandedKey)) {
      return items;
    }
    const expandRowIndex = m_utils_default.getIndexByKey(this._adaptiveExpandedKey, items);
    const newMode = false === this.option(LEGACY_SCROLLING_MODE5);
    if (expandRowIndex >= 0) {
      const item = items[expandRowIndex];
      items.splice(expandRowIndex + 1, 0, {
        visible: true,
        rowType: "detailAdaptive",
        key: item.key,
        data: item.data,
        node: item.node,
        modifiedValues: item.modifiedValues,
        isNewRow: item.isNewRow,
        values: item.values
      });
    } else if ("refresh" === changeType && !(newMode && change.repaintChangesOnly)) {
      this._adaptiveExpandedKey = void 0;
    }
    return items;
  }
  _getRowIndicesForExpand(key) {
    const rowIndices = super._getRowIndicesForExpand.apply(this, arguments);
    if (this._adaptiveColumnsController.isAdaptiveDetailRowExpanded(key)) {
      const lastRowIndex = rowIndices[rowIndices.length - 1];
      rowIndices.push(lastRowIndex + 1);
    }
    return rowIndices;
  }
  adaptiveExpandedKey(value2) {
    if (isDefined(value2)) {
      this._adaptiveExpandedKey = value2;
    } else {
      return this._adaptiveExpandedKey;
    }
  }
  toggleExpandAdaptiveDetailRow(key, alwaysExpanded) {
    let oldExpandLoadedRowIndex = m_utils_default.getIndexByKey(this._adaptiveExpandedKey, this._items);
    let newExpandLoadedRowIndex = m_utils_default.getIndexByKey(key, this._items);
    if (oldExpandLoadedRowIndex >= 0 && oldExpandLoadedRowIndex === newExpandLoadedRowIndex && !alwaysExpanded) {
      key = void 0;
      newExpandLoadedRowIndex = -1;
    }
    const oldKey = this._adaptiveExpandedKey;
    this._adaptiveExpandedKey = key;
    if (oldExpandLoadedRowIndex >= 0) {
      oldExpandLoadedRowIndex++;
    }
    if (newExpandLoadedRowIndex >= 0) {
      newExpandLoadedRowIndex++;
    }
    const rowIndexDelta = this.getRowIndexDelta();
    this.updateItems({
      allowInvisibleRowIndices: true,
      changeType: "update",
      rowIndices: [oldExpandLoadedRowIndex - rowIndexDelta, newExpandLoadedRowIndex - rowIndexDelta]
    });
    this._adaptiveColumnsController.updateCommandAdaptiveAriaLabel(key, COLLAPSE_ARIA_NAME);
    this._adaptiveColumnsController.updateCommandAdaptiveAriaLabel(oldKey, EXPAND_ARIA_NAME);
  }
};
var editorFactory4 = (Base) => class extends Base {
  _needHideBorder($element) {
    return super._needHideBorder($element) || (null === $element || void 0 === $element ? void 0 : $element.hasClass("dx-field-item-content")) && (null === $element || void 0 === $element ? void 0 : $element.find(".dx-checkbox").length);
  }
  _getFocusCellSelector() {
    return `${super._getFocusCellSelector()}, .dx-adaptive-detail-row .dx-field-item > .dx-field-item-content`;
  }
  _getRevertTooltipsSelector() {
    return `${super._getRevertTooltipsSelector()}, .dx-field-item-content .${this.addWidgetPrefix("revert-tooltip")}`;
  }
};
var columns4 = (Base) => class extends Base {
  _isColumnVisible(column) {
    return super._isColumnVisible(column) && !column.adaptiveHidden;
  }
  getVisibleDataColumnsByBandColumn(bandColumnIndex) {
    return super.getVisibleDataColumnsByBandColumn(bandColumnIndex).filter(((column) => "adaptiveHidden" !== column.visibleWidth));
  }
};
var resizing6 = (Base) => class extends Base {
  dispose() {
    super.dispose.apply(this, arguments);
    clearTimeout(this._updateScrollableTimeoutID);
  }
  _needBestFit() {
    return super._needBestFit() || !!this._adaptiveColumnsController.getHidingColumnsQueue().length;
  }
  _correctColumnWidths(resultWidths, visibleColumns) {
    const adaptiveController = this._adaptiveColumnsController;
    const oldHiddenColumns = adaptiveController.getHiddenColumns();
    const hidingColumnsQueue = adaptiveController.updateHidingQueue(this._columnsController.getColumns());
    adaptiveController.hideRedundantColumns(resultWidths, visibleColumns, hidingColumnsQueue);
    const hiddenColumns = adaptiveController.getHiddenColumns();
    if (adaptiveController.hasAdaptiveDetailRowExpanded()) {
      if (oldHiddenColumns.length !== hiddenColumns.length) {
        adaptiveController.updateForm(hiddenColumns);
      }
    }
    !hiddenColumns.length && adaptiveController.collapseAdaptiveDetailRow();
    return super._correctColumnWidths.apply(this, arguments);
  }
  _toggleBestFitMode(isBestFit) {
    isBestFit && this._adaptiveColumnsController._showHiddenColumns();
    super._toggleBestFitMode(isBestFit);
  }
  _needStretch() {
    const adaptiveColumnsController = this._adaptiveColumnsController;
    return super._needStretch.apply(this, arguments) || adaptiveColumnsController.getHidingColumnsQueue().length || adaptiveColumnsController.hasHiddenColumns();
  }
};
var headersKeyboardNavigation3 = (Base) => class extends Base {
  getColumnVisibleIndexCorrection(visibleIndex, rowIndex, direction) {
    let indexCorrection = super.getColumnVisibleIndexCorrection(visibleIndex, rowIndex, direction);
    let visibleColumns = this._columnsController.getVisibleColumns(rowIndex);
    visibleColumns = "next" === direction ? visibleColumns.slice(visibleIndex + 1) : visibleColumns.slice(0, visibleIndex).reverse();
    while ("adaptiveHidden" === (null === (_visibleColumns = visibleColumns) || void 0 === _visibleColumns || null === (_visibleColumns = _visibleColumns.shift()) || void 0 === _visibleColumns ? void 0 : _visibleColumns.visibleWidth)) {
      var _visibleColumns;
      indexCorrection += "next" === direction ? 1 : -1;
    }
    return indexCorrection;
  }
  getFocusableColumns(rowIndex, bandColumnId) {
    return super.getFocusableColumns(rowIndex, bandColumnId).filter(((col) => "adaptiveHidden" !== col.visibleWidth));
  }
  getDraggableColumns(column, rowIndex) {
    return super.getDraggableColumns(column, rowIndex).filter(((col) => "adaptiveHidden" !== col.visibleWidth));
  }
};
var adaptivityModule = {
  defaultOptions: () => ({
    columnHidingEnabled: false,
    onAdaptiveDetailRowPreparing: null
  }),
  controllers: {
    adaptiveColumns: AdaptiveColumnsController
  },
  extenders: {
    views: {
      rowsView: rowsView14
    },
    controllers: {
      export: exportExtender,
      columnsResizer: columnsResizer4,
      draggingHeader: draggingHeader3,
      editing: editing4,
      resizing: resizing6,
      data: data14,
      editorFactory: editorFactory4,
      columns: columns4,
      keyboardNavigation: keyboardNavigation2,
      headersKeyboardNavigation: headersKeyboardNavigation3
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/adaptivity.js
m_core_default.registerModule("adaptivity", adaptivityModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/virtual_columns/m_virtual_columns_core.js
function foreachColumnInfo(info, callback, rowIndex, offsets, columnCount, lastProcessedIndexes) {
  rowIndex = rowIndex || 0;
  offsets = offsets || [];
  lastProcessedIndexes = lastProcessedIndexes || [];
  offsets[rowIndex] = offsets[rowIndex] || 0;
  const row = info[rowIndex];
  const startIndex = lastProcessedIndexes[rowIndex] + 1 || 0;
  let processedColumnCount = 0;
  let colIndex;
  if (!row) {
    return;
  }
  for (colIndex = startIndex; colIndex < row.length; colIndex++) {
    const cell = row[colIndex];
    const visibleIndex = colIndex + offsets[rowIndex];
    const colspan = cell.colspan || 1;
    foreachColumnInfo(info, callback, rowIndex + (cell.rowspan || 1), offsets, colspan, lastProcessedIndexes);
    offsets[rowIndex] += colspan - 1;
    processedColumnCount += colspan;
    if (cell.rowspan) {
      for (let i = rowIndex + 1; i < rowIndex + cell.rowspan; i++) {
        offsets[i] = offsets[i] || 0;
        offsets[i] += cell.colspan || 1;
      }
    }
    if (false === callback(cell, visibleIndex, rowIndex, colIndex)) {
      break;
    }
    if (void 0 !== columnCount && processedColumnCount >= columnCount) {
      break;
    }
  }
  lastProcessedIndexes[rowIndex] = colIndex;
}
function createColumnsInfo(info, startIndex, endIndex) {
  const newInfo = [];
  foreachColumnInfo(info, ((columnInfo, visibleIndex, rowIndex) => {
    let cell = columnInfo;
    let colspan;
    const cellColspan = cell.colspan || 1;
    const isVisible2 = visibleIndex + cellColspan - 1 >= startIndex && visibleIndex < endIndex;
    newInfo[rowIndex] = newInfo[rowIndex] || [];
    if (isVisible2) {
      if (visibleIndex < startIndex) {
        colspan = cellColspan - (startIndex - visibleIndex);
        visibleIndex = startIndex;
      } else {
        colspan = cellColspan;
      }
      if (visibleIndex + colspan > endIndex) {
        colspan = endIndex - visibleIndex;
      }
      if (colspan !== cellColspan) {
        cell = extend({}, cell, {
          colspan
        });
      }
      newInfo[rowIndex].push(cell);
    } else if (visibleIndex > endIndex) {
      return false;
    }
    return;
  }));
  for (let i = 0; i < newInfo.length; i++) {
    newInfo[i] = newInfo[i] || [];
  }
  return newInfo;
}

// node_modules/devextreme/esm/__internal/grids/grid_core/virtual_columns/m_virtual_columns.js
var baseView = (Base) => class extends Base {
  _needToSetCellWidths() {
    let result = super._needToSetCellWidths();
    if (!result && this._columnsController.isVirtualMode()) {
      const columns7 = this._columnsController.getColumns();
      result = columns7.some(((column) => "auto" === column.width));
    }
    return result;
  }
};
var rowsView15 = (Base) => class extends baseView(Base) {
  _resizeCore() {
    super._resizeCore.apply(this, arguments);
    this._columnsController.resize();
  }
  _handleScroll(e) {
    const scrollable = this.getScrollable();
    let {
      left
    } = e.scrollOffset;
    this._scrollLeft = left;
    super._handleScroll.apply(this, arguments);
    if (this.option("rtlEnabled") && scrollable) {
      left = getWidth(scrollable.$content()) - getWidth(scrollable.$element()) - left;
    }
    this._columnsController.setScrollPosition(left, e.event);
  }
  _renderCore(e) {
    if (null !== e && void 0 !== e && e.virtualColumnsScrolling) {
      var _this$_columnsControl, _this$_scrollable;
      const $contentElement = this._findContentElement();
      const fixedColumns = null === (_this$_columnsControl = this._columnsController) || void 0 === _this$_columnsControl ? void 0 : _this$_columnsControl.getFixedColumns();
      const useNativeScrolling = null === (_this$_scrollable = this._scrollable) || void 0 === _this$_scrollable ? void 0 : _this$_scrollable.option("useNative");
      const legacyMode = this.option("columnFixing.legacyMode");
      if (null !== fixedColumns && void 0 !== fixedColumns && fixedColumns.length) {
        if (legacyMode && !useNativeScrolling) {
          $contentElement.css({
            minHeight: m_utils_default.getContentHeightLimit(browser_default)
          });
        } else {
          $contentElement.css({
            minHeight: getHeight($contentElement)
          });
        }
        const resizeCompletedHandler = () => {
          this.resizeCompleted.remove(resizeCompletedHandler);
          $contentElement.css({
            minHeight: ""
          });
        };
        this.resizeCompleted.add(resizeCompletedHandler);
      }
    }
    return super._renderCore.apply(this, arguments);
  }
};
var columnHeadersView9 = (Base) => class extends baseView(Base) {
  _renderCore() {
    const deferred = super._renderCore.apply(this, arguments);
    if (this._columnsController.isVirtualMode()) {
      this._updateScrollLeftPosition();
    }
    return deferred;
  }
};
var getWidths = function(columns7) {
  return columns7.map(((column) => column.visibleWidth || parseFloat(column.width) || 50));
};
var columns5 = (Base) => class extends Base {
  init() {
    super.init.apply(this, arguments);
    this._resizingController = this.getController("resizing");
    this._beginPageIndex = null;
    this._endPageIndex = null;
    this._position ?? (this._position = 0);
    this._virtualVisibleColumns = {};
  }
  dispose() {
    clearTimeout(this._changedTimeout);
    super.dispose.apply(this, arguments);
  }
  resetColumnsCache() {
    super.resetColumnsCache();
    this._virtualVisibleColumns = {};
  }
  getBeginPageIndex(position) {
    const visibleColumns = this.getVisibleColumns(void 0, true);
    const widths = getWidths(visibleColumns);
    let currentPosition = 0;
    for (let index = 0; index < widths.length; index++) {
      if (currentPosition >= position) {
        return Math.floor(index / this.getColumnPageSize());
      }
      currentPosition += widths[index];
    }
    return 0;
  }
  getTotalWidth() {
    const width = this.option("width");
    if ("number" === typeof width) {
      return width;
    }
    return this._resizingController._lastWidth || getOuterWidth(this.component.$element());
  }
  getEndPageIndex(position) {
    const visibleColumns = this.getVisibleColumns(void 0, true);
    const widths = getWidths(visibleColumns);
    let currentPosition = 0;
    position += this.getTotalWidth();
    for (let index = 0; index < widths.length; index++) {
      if (currentPosition >= position) {
        return Math.ceil(index / this.getColumnPageSize());
      }
      currentPosition += widths[index];
    }
    return Math.ceil(widths.length / this.getColumnPageSize());
  }
  getColumnPageSize() {
    return this.option("scrolling.columnPageSize");
  }
  _fireColumnsChanged(event) {
    const date = /* @__PURE__ */ new Date();
    this.columnsChanged.fire({
      optionNames: {
        all: true,
        length: 1
      },
      changeTypes: {
        columns: true,
        virtualColumnsScrolling: true,
        length: 2,
        event
      }
    });
    this._renderTime = /* @__PURE__ */ new Date() - date;
  }
  getScrollingTimeout() {
    const renderingThreshold = this.option("scrolling.columnRenderingThreshold");
    const renderAsync = this.option("scrolling.renderAsync");
    let scrollingTimeout = 0;
    if (!isDefined(renderAsync) && this._renderTime > renderingThreshold || renderAsync) {
      scrollingTimeout = this.option("scrolling.timeout");
    }
    return scrollingTimeout;
  }
  setScrollPosition(position, event) {
    const scrollingTimeout = this.getScrollingTimeout();
    if (scrollingTimeout > 0) {
      clearTimeout(this._changedTimeout);
      this._changedTimeout = setTimeout((() => {
        this._setScrollPositionCore(position, event);
      }), scrollingTimeout);
    } else {
      this._setScrollPositionCore(position, event);
    }
  }
  resize() {
    this._setScrollPositionCore(this._position);
  }
  _setScrollPositionCore(position, event) {
    const needColumnsChanged = this.isNeedToRenderVirtualColumns(position);
    if (needColumnsChanged) {
      this._position = position;
      this._beginPageIndex = this.getBeginPageIndex(position);
      this._endPageIndex = this.getEndPageIndex(position);
      this._fireColumnsChanged(event);
    }
  }
  isNeedToRenderVirtualColumns(scrollPosition) {
    if (this.isVirtualMode()) {
      if (scrollPosition < this._position) {
        return this._beginPageIndex > this.getBeginPageIndex(scrollPosition);
      }
      return this._endPageIndex < this.getEndPageIndex(scrollPosition);
    }
    return false;
  }
  getFixedColumns(rowIndex, isBase) {
    const fixedColumns = super.getFixedColumns(rowIndex);
    if (this.isVirtualMode() && !isBase && fixedColumns.length) {
      const transparentColumnIndex = fixedColumns.map(((c) => c.command)).indexOf("transparent");
      fixedColumns[transparentColumnIndex].colspan = this.getVisibleColumns().length - super.getFixedColumns().length + 1;
      return fixedColumns;
    }
    return fixedColumns;
  }
  _compileVisibleColumns(rowIndex, isBase) {
    var _this$_columns;
    if (isBase || !this.isVirtualMode() || !this._shouldReturnVisibleColumns()) {
      return super._compileVisibleColumns(rowIndex);
    }
    if (null !== (_this$_columns = this._columns) && void 0 !== _this$_columns && _this$_columns.length && !isDefined(this._beginPageIndex) && !isDefined(this._endPageIndex)) {
      this._beginPageIndex = this.getBeginPageIndex(this._position);
      this._endPageIndex = this.getEndPageIndex(this._position);
    }
    const beginPageIndex = this._beginPageIndex;
    const endPageIndex = this._endPageIndex;
    const visibleColumnsHash = `${rowIndex}-${beginPageIndex}-${endPageIndex}`;
    if (this._virtualVisibleColumns[visibleColumnsHash]) {
      return this._virtualVisibleColumns[visibleColumnsHash];
    }
    let visibleColumns = super._compileVisibleColumns();
    const rowCount = this.getRowCount();
    const pageSize = this.getColumnPageSize();
    let startIndex = beginPageIndex * pageSize;
    let endIndex = endPageIndex * pageSize;
    const fixedColumns = this.getFixedColumns(void 0, true);
    const transparentColumnIndex = fixedColumns.map(((c) => c.command)).indexOf("transparent");
    const beginFixedColumnCount = fixedColumns.length ? transparentColumnIndex : 0;
    let beginFixedColumns = visibleColumns.slice(0, beginFixedColumnCount);
    const beginColumns = visibleColumns.slice(beginFixedColumnCount, startIndex);
    const beginWidth = getWidths(beginColumns).reduce(((a, b) => a + b), 0);
    if (!beginWidth) {
      startIndex = 0;
    }
    const endFixedColumnCount = fixedColumns.length ? fixedColumns.length - transparentColumnIndex - 1 : 0;
    let endFixedColumns = visibleColumns.slice(visibleColumns.length - endFixedColumnCount);
    const endColumns = visibleColumns.slice(endIndex, visibleColumns.length - endFixedColumnCount);
    const endWidth = getWidths(endColumns).reduce(((a, b) => a + b), 0);
    if (!endWidth) {
      endIndex = visibleColumns.length;
    }
    if (rowCount > 1 && "number" === typeof rowIndex) {
      const columnsInfo = [];
      for (let i = 0; i <= rowCount; i++) {
        columnsInfo.push(super._compileVisibleColumns(i));
      }
      beginFixedColumns = createColumnsInfo(columnsInfo, 0, beginFixedColumns.length)[rowIndex] || [];
      endFixedColumns = createColumnsInfo(columnsInfo, visibleColumns.length - endFixedColumns.length, visibleColumns.length)[rowIndex] || [];
      visibleColumns = createColumnsInfo(columnsInfo, startIndex, endIndex)[rowIndex] || [];
    } else {
      visibleColumns = visibleColumns.slice(startIndex, endIndex);
    }
    if (beginWidth) {
      visibleColumns.unshift({
        command: "virtual",
        type: "virtual",
        width: beginWidth
      });
      visibleColumns = beginFixedColumns.concat(visibleColumns);
    }
    if (endWidth) {
      visibleColumns.push({
        command: "virtual",
        type: "virtual",
        width: endWidth
      });
      visibleColumns = visibleColumns.concat(endFixedColumns);
    }
    this._virtualVisibleColumns[visibleColumnsHash] = visibleColumns;
    return visibleColumns;
  }
  getColumnIndexOffset() {
    let offset = 0;
    if (this._beginPageIndex > 0) {
      const fixedColumns = this.getFixedColumns();
      const transparentColumnIndex = fixedColumns.map(((c) => c.command)).indexOf("transparent");
      const leftFixedColumnCount = transparentColumnIndex >= 0 ? transparentColumnIndex : 0;
      offset = this._beginPageIndex * this.getColumnPageSize() - leftFixedColumnCount - 1;
    }
    return offset > 0 ? offset : 0;
  }
  isVirtualMode() {
    return hasWindow() && "virtual" === this.option("scrolling.columnRenderingMode");
  }
};
var virtualColumnsModule = {
  defaultOptions: () => ({
    scrolling: {
      columnRenderingMode: "standard",
      columnPageSize: 5,
      columnRenderingThreshold: 300
    }
  }),
  extenders: {
    controllers: {
      columns: columns5
    },
    views: {
      columnHeadersView: columnHeadersView9,
      rowsView: rowsView15
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/virtual_columns.js
m_core_default.registerModule("virtualColumns", virtualColumnsModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/m_export.js
function prepareItems(items, emptyCell) {
  const defaultSetter = (value2) => !value2 ? 1 : value2;
  const resultItems = [];
  const cols = (items[0] || []).reduce(((sum, item2) => sum + defaultSetter(item2.colspan)), 0);
  const getItem = /* @__PURE__ */ ((items2) => {
    let rowIndex2 = 0;
    let cellIndex = 0;
    return () => {
      const row = items2[rowIndex2] || [];
      const item2 = row[cellIndex++];
      if (cellIndex >= row.length) {
        rowIndex2++;
        cellIndex = 0;
      }
      if (item2) {
        item2.colspan = defaultSetter(item2.colspan);
        item2.rowspan = defaultSetter(item2.rowspan);
      }
      return item2;
    };
  })(items);
  const addItem2 = (rowIndex2, cellIndex, item2) => {
    const row = resultItems[rowIndex2] = resultItems[rowIndex2] || [];
    row[cellIndex] = item2;
    if (item2.colspan > 1 || item2.rowspan > 1) {
      const clone = ((item3) => extend({}, item3, emptyCell))(item2);
      for (let c = 1; c < item2.colspan; c++) {
        addItem2(rowIndex2, cellIndex + c, clone);
      }
      for (let r = 1; r < item2.rowspan; r++) {
        for (let c = 0; c < item2.colspan; c++) {
          addItem2(rowIndex2 + r, cellIndex + c, clone);
        }
      }
    }
  };
  let item = getItem();
  let rowIndex = 0;
  while (item) {
    for (let cellIndex = 0; cellIndex < cols; cellIndex++) {
      if (!item) {
        break;
      }
      if (resultItems[rowIndex] && resultItems[rowIndex][cellIndex]) {
        continue;
      }
      addItem2(rowIndex, cellIndex, item);
      cellIndex += item.colspan - 1;
      item = getItem();
    }
    rowIndex++;
  }
  return resultItems;
}

// node_modules/devextreme/esm/__internal/grids/data_grid/export/m_export.js
var DataProvider = class {
  constructor(exportController, initialColumnWidthsByColumnIndex, selectedRowsOnly) {
    this._exportController = exportController;
    this._initialColumnWidthsByColumnIndex = initialColumnWidthsByColumnIndex;
    this._selectedRowsOnly = selectedRowsOnly;
  }
  _getGroupValue(item) {
    const {
      key,
      data: data17,
      rowType,
      groupIndex,
      summaryCells
    } = item;
    const groupColumn = this._options.groupColumns[groupIndex];
    const value2 = m_core_default.getDisplayValue(groupColumn, groupColumn.deserializeValue ? groupColumn.deserializeValue(key[groupIndex]) : key[groupIndex], data17, rowType);
    let result = `${groupColumn.caption}: ${m_core_default.formatValue(value2, groupColumn)}`;
    if (summaryCells && summaryCells[0] && summaryCells[0].length) {
      result += ` ${m_core_default.getGroupRowSummaryText(summaryCells[0], this._options.summaryTexts)}`;
    }
    return result;
  }
  _correctCellIndex(cellIndex) {
    return cellIndex;
  }
  _initOptions() {
    const exportController = this._exportController;
    const groupColumns = exportController._columnsController.getGroupColumns();
    this._options = {
      columns: exportController._getColumns(this._initialColumnWidthsByColumnIndex),
      groupColumns,
      items: this._selectedRowsOnly || exportController._selectionOnly ? exportController._getSelectedItems() : exportController._getAllItems(),
      isHeadersVisible: exportController.option("showColumnHeaders"),
      summaryTexts: exportController.option("summary.texts"),
      rtlEnabled: exportController.option("rtlEnabled")
    };
  }
  getHeaderStyles() {
    return [{
      bold: true,
      alignment: "center"
    }, {
      bold: true,
      alignment: "left"
    }, {
      bold: true,
      alignment: "right"
    }];
  }
  getGroupRowStyle() {
    return {
      bold: true,
      alignment: getDefaultAlignment(this._options.rtlEnabled)
    };
  }
  getColumnStyles() {
    const columnStyles = [];
    this.getColumns().forEach(((column) => {
      columnStyles.push({
        alignment: column.alignment || "left",
        format: column.format,
        dataType: column.dataType
      });
    }));
    return columnStyles;
  }
  getStyles() {
    return [...this.getHeaderStyles(), ...this.getColumnStyles(), this.getGroupRowStyle()];
  }
  _getTotalCellStyleId(cellIndex) {
    var _this$getColumns$cell;
    const alignment = (null === (_this$getColumns$cell = this.getColumns()[cellIndex]) || void 0 === _this$getColumns$cell ? void 0 : _this$getColumns$cell.alignment) || "right";
    return this.getHeaderStyles().map(((style) => style.alignment)).indexOf(alignment);
  }
  getStyleId(rowIndex, cellIndex) {
    if (rowIndex < this.getHeaderRowCount()) {
      return 0;
    }
    if (this.isTotalCell(rowIndex - this.getHeaderRowCount(), cellIndex)) {
      return this._getTotalCellStyleId(cellIndex);
    }
    if (this.isGroupRow(rowIndex - this.getHeaderRowCount())) {
      return this.getHeaderStyles().length + this.getColumns().length;
    }
    return cellIndex + this.getHeaderStyles().length;
  }
  getColumns(getColumnsByAllRows) {
    const {
      columns: columns7
    } = this._options;
    return getColumnsByAllRows ? columns7 : columns7[columns7.length - 1];
  }
  getColumnsWidths() {
    const columns7 = this.getColumns();
    return isDefined(columns7) ? columns7.map(((c) => c.width)) : void 0;
  }
  getRowsCount() {
    return this._options.items.length + this.getHeaderRowCount();
  }
  getHeaderRowCount() {
    if (this.isHeadersVisible()) {
      return this._options.columns.length - 1;
    }
    return 0;
  }
  isGroupRow(rowIndex) {
    return rowIndex < this._options.items.length && "group" === this._options.items[rowIndex].rowType;
  }
  getGroupLevel(rowIndex) {
    const item = this._options.items[rowIndex - this.getHeaderRowCount()];
    const groupIndex = item && item.groupIndex;
    if (item && "totalFooter" === item.rowType) {
      return 0;
    }
    return isDefined(groupIndex) ? groupIndex : this._options.groupColumns.length;
  }
  getCellType(rowIndex, cellIndex) {
    const columns7 = this.getColumns();
    if (rowIndex < this.getHeaderRowCount()) {
      return "string";
    }
    rowIndex -= this.getHeaderRowCount();
    if (cellIndex < columns7.length) {
      const item = this._options.items.length && this._options.items[rowIndex];
      const column = columns7[cellIndex];
      if (item && "data" === item.rowType) {
        if (isFinite(item.values[this._correctCellIndex(cellIndex)]) && !isDefined(column.customizeText)) {
          return isDefined(column.lookup) ? column.lookup.dataType : column.dataType;
        }
      }
      return "string";
    }
  }
  ready() {
    this._initOptions();
    const options = this._options;
    return when(options.items).done(((items) => {
      options.items = items;
    })).fail((() => {
      options.items = [];
    }));
  }
  _convertFromGridGroupSummaryItems(gridGroupSummaryItems) {
    if (isDefined(gridGroupSummaryItems) && gridGroupSummaryItems.length > 0) {
      return gridGroupSummaryItems.map(((item) => ({
        value: item.value,
        name: item.name
      })));
    }
  }
  getCellData(rowIndex, cellIndex, isExcelJS) {
    let value2;
    let column;
    const result = {
      cellSourceData: {},
      value: value2
    };
    const columns7 = this.getColumns();
    const correctedCellIndex = this._correctCellIndex(cellIndex);
    if (rowIndex < this.getHeaderRowCount()) {
      const columnsRow = this.getColumns(true)[rowIndex];
      column = columnsRow[cellIndex];
      result.cellSourceData.rowType = "header";
      result.cellSourceData.column = column && column.gridColumn;
      result.value = column && column.caption;
    } else {
      rowIndex -= this.getHeaderRowCount();
      const item = this._options.items.length && this._options.items[rowIndex];
      if (item) {
        const itemValues = item.values;
        result.cellSourceData.rowType = item.rowType;
        result.cellSourceData.column = columns7[cellIndex] && columns7[cellIndex].gridColumn;
        switch (item.rowType) {
          case "groupFooter":
          case "totalFooter":
            if (correctedCellIndex < itemValues.length) {
              value2 = itemValues[correctedCellIndex];
              if (isDefined(value2)) {
                result.cellSourceData.value = value2.value;
                result.cellSourceData.totalSummaryItemName = value2.name;
                result.value = m_core_default.getSummaryText(value2, this._options.summaryTexts);
              } else {
                result.cellSourceData.value = void 0;
              }
            }
            break;
          case "group":
            result.cellSourceData.groupIndex = item.groupIndex;
            if (cellIndex < 1) {
              result.cellSourceData.column = this._options.groupColumns[item.groupIndex];
              result.cellSourceData.value = item.key[item.groupIndex];
              result.cellSourceData.groupSummaryItems = this._convertFromGridGroupSummaryItems(item.summaryCells[0]);
              result.value = this._getGroupValue(item);
            } else {
              const summaryItems = item.values[correctedCellIndex];
              if (Array.isArray(summaryItems)) {
                result.cellSourceData.groupSummaryItems = this._convertFromGridGroupSummaryItems(summaryItems);
                value2 = "";
                for (let i = 0; i < summaryItems.length; i++) {
                  value2 += (i > 0 ? isExcelJS ? "\n" : " \n " : "") + m_core_default.getSummaryText(summaryItems[i], this._options.summaryTexts);
                }
                result.value = value2;
              } else {
                result.cellSourceData.value = void 0;
              }
            }
            break;
          default:
            column = columns7[cellIndex];
            if (column) {
              const value3 = itemValues[correctedCellIndex];
              const displayValue = m_core_default.getDisplayValue(column, value3, item.data, item.rowType);
              if (!isFinite(displayValue) || isDefined(column.customizeText)) {
                if (isExcelJS && isDefined(column.customizeText) && column.customizeText === this._exportController._columnsController.getCustomizeTextByDataType("boolean")) {
                  result.value = displayValue;
                } else {
                  result.value = m_core_default.formatValue(displayValue, column);
                }
              } else {
                result.value = displayValue;
              }
              result.cellSourceData.value = value3;
            }
            result.cellSourceData.data = item.data;
        }
      }
    }
    return result;
  }
  isHeadersVisible() {
    return this._options.isHeadersVisible;
  }
  isTotalCell(rowIndex, cellIndex) {
    const {
      items
    } = this._options;
    const item = items[rowIndex];
    const correctCellIndex = this._correctCellIndex(cellIndex);
    const isSummaryAlignByColumn = item.summaryCells && item.summaryCells[correctCellIndex] && item.summaryCells[correctCellIndex].length > 0 && item.summaryCells[correctCellIndex][0].alignByColumn;
    return item && "groupFooter" === item.rowType || "totalFooter" === item.rowType || isSummaryAlignByColumn;
  }
  getCellMerging(rowIndex, cellIndex) {
    const {
      columns: columns7
    } = this._options;
    const column = columns7[rowIndex] && columns7[rowIndex][cellIndex];
    return column ? {
      colspan: (column.exportColspan || 1) - 1,
      rowspan: (column.rowspan || 1) - 1
    } : {
      colspan: 0,
      rowspan: 0
    };
  }
  getFrozenArea() {
    return {
      x: 0,
      y: this.getHeaderRowCount()
    };
  }
};
var ExportController = class extends m_core_default.ViewController {
  init() {
    this.throwWarningIfNoOnExportingEvent();
    this._columnsController = this.getController("columns");
    this._dataController = this.getController("data");
    this._selectionController = this.getController("selection");
    this._rowsView = this.getView("rowsView");
    this._headersView = this.getView("columnHeadersView");
    this.createAction("onExporting", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _getEmptyCell() {
    return {
      caption: "",
      colspan: 1,
      rowspan: 1
    };
  }
  _updateColumnWidth(column, width) {
    column.width = width;
  }
  _getColumns(initialColumnWidthsByColumnIndex) {
    let result = [];
    let i;
    let columns7;
    const columnsController = this._columnsController;
    const rowCount = columnsController.getRowCount();
    for (i = 0; i <= rowCount; i++) {
      const currentHeaderRow = [];
      columns7 = columnsController.getVisibleColumns(i, true);
      let columnWidthsByColumnIndex;
      if (i === rowCount) {
        if (this._updateLockCount) {
          columnWidthsByColumnIndex = initialColumnWidthsByColumnIndex;
        } else {
          const columnWidths = this._getColumnWidths(this._headersView, this._rowsView);
          if (columnWidths && columnWidths.length) {
            columnWidthsByColumnIndex = {};
            for (let i2 = 0; i2 < columns7.length; i2++) {
              columnWidthsByColumnIndex[columns7[i2].index] = columnWidths[i2];
            }
          }
        }
      }
      for (let j = 0; j < columns7.length; j++) {
        const column = extend({}, columns7[j], {
          dataType: "datetime" === columns7[j].dataType ? "date" : columns7[j].dataType,
          gridColumn: columns7[j]
        });
        if (this._needColumnExporting(column)) {
          const currentColspan = this._calculateExportColspan(column);
          if (isDefined(currentColspan)) {
            column.exportColspan = currentColspan;
          }
          if (columnWidthsByColumnIndex) {
            this._updateColumnWidth(column, columnWidthsByColumnIndex[column.index]);
          }
          currentHeaderRow.push(column);
        }
      }
      result.push(currentHeaderRow);
    }
    columns7 = result[rowCount];
    result = prepareItems(result.slice(0, -1), this._getEmptyCell());
    result.push(columns7);
    return result;
  }
  _calculateExportColspan(column) {
    if (!column.isBand) {
      return;
    }
    const childColumns = this._columnsController.getChildrenByBandColumn(column.index, true);
    if (!isDefined(childColumns)) {
      return;
    }
    return childColumns.reduce(((result, childColumn) => {
      if (this._needColumnExporting(childColumn)) {
        return result + (this._calculateExportColspan(childColumn) || 1);
      }
      return result;
    }), 0);
  }
  _needColumnExporting(column) {
    return !column.command && (column.allowExporting || void 0 === column.allowExporting);
  }
  _getFooterSummaryItems(summaryCells, isTotal) {
    const result = [];
    let estimatedItemsCount = 1;
    let i = 0;
    do {
      const values = [];
      for (let j = 0; j < summaryCells.length; j++) {
        const summaryCell = summaryCells[j];
        const itemsLength = summaryCell.length;
        if (estimatedItemsCount < itemsLength) {
          estimatedItemsCount = itemsLength;
        }
        values.push(summaryCell[i]);
      }
      result.push({
        values,
        rowType: isTotal ? "totalFooter" : "groupFooter"
      });
    } while (i++ < estimatedItemsCount - 1);
    return result;
  }
  _hasSummaryGroupFooters() {
    const groupItems = this.option("summary.groupItems");
    if (isDefined(groupItems)) {
      for (let i = 0; i < groupItems.length; i++) {
        if (groupItems[i].showInGroupFooter) {
          return true;
        }
      }
    }
    return false;
  }
  _getItemsWithSummaryGroupFooters(sourceItems) {
    let result = [];
    let beforeGroupFooterItems = [];
    let groupFooterItems = [];
    for (let i = 0; i < sourceItems.length; i++) {
      const item = sourceItems[i];
      if ("groupFooter" === item.rowType) {
        groupFooterItems = this._getFooterSummaryItems(item.summaryCells);
        result = result.concat(beforeGroupFooterItems, groupFooterItems);
        beforeGroupFooterItems = [];
      } else {
        beforeGroupFooterItems.push(item);
      }
    }
    return result.length ? result : beforeGroupFooterItems;
  }
  _updateGroupValuesWithSummaryByColumn(sourceItems) {
    let summaryValues = [];
    for (let i = 0; i < sourceItems.length; i++) {
      const item = sourceItems[i];
      const {
        summaryCells
      } = item;
      if ("group" === item.rowType && summaryCells && summaryCells.length > 1) {
        const groupColumnCount = item.values.length;
        for (let j = 1; j < summaryCells.length; j++) {
          for (let k = 0; k < summaryCells[j].length; k++) {
            const summaryItem = summaryCells[j][k];
            if (summaryItem && summaryItem.alignByColumn) {
              if (!Array.isArray(summaryValues[j - groupColumnCount])) {
                summaryValues[j - groupColumnCount] = [];
              }
              summaryValues[j - groupColumnCount].push(summaryItem);
            }
          }
        }
        if (summaryValues.length > 0) {
          item.values.push(...summaryValues);
          summaryValues = [];
        }
      }
    }
  }
  _processUnExportedItems(items) {
    const columns7 = this._columnsController.getVisibleColumns(null, true);
    const groupColumns = this._columnsController.getGroupColumns();
    let values;
    let summaryCells;
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      let isCommand = false;
      values = [];
      summaryCells = [];
      for (let j = 0; j < columns7.length; j++) {
        const column = columns7[j];
        isCommand || (isCommand = ["detailExpand", "buttons"].includes(column.type));
        if (this._needColumnExporting(column)) {
          if (item.values) {
            if ("group" === item.rowType && !values.length) {
              values.push(item.key[item.groupIndex]);
            } else {
              values.push(item.values[j]);
            }
          }
          if (item.summaryCells) {
            if ("group" === item.rowType && !summaryCells.length) {
              const index = j - groupColumns.length + item.groupIndex;
              summaryCells.push(item.summaryCells[isCommand ? index : index + 1]);
            } else {
              summaryCells.push(item.summaryCells[j]);
            }
          }
        }
      }
      if (values.length) {
        item.values = values;
      }
      if (summaryCells.length) {
        item.summaryCells = summaryCells;
      }
    }
  }
  _getAllItems(data17) {
    let skipFilter = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;
    const that = this;
    const d = new Deferred();
    const footerItems = this._dataController.footerItems();
    const totalItem = footerItems.length && footerItems[0];
    const summaryTotalItems = that.option("summary.totalItems");
    let summaryCells;
    when(data17).done(((data18) => {
      this._dataController.loadAll(data18, skipFilter).done(((sourceItems, totalAggregates) => {
        that._updateGroupValuesWithSummaryByColumn(sourceItems);
        if (that._hasSummaryGroupFooters()) {
          sourceItems = that._getItemsWithSummaryGroupFooters(sourceItems);
        }
        summaryCells = totalItem && totalItem.summaryCells;
        if (isDefined(totalAggregates) && summaryTotalItems) {
          summaryCells = that._getSummaryCells(summaryTotalItems, totalAggregates);
        }
        const summaryItems = totalItem && that._getFooterSummaryItems(summaryCells, true);
        if (summaryItems) {
          sourceItems = sourceItems.concat(summaryItems);
        }
        that._processUnExportedItems(sourceItems);
        d.resolve(sourceItems);
      })).fail(d.reject);
    })).fail(d.reject);
    return d;
  }
  _getSummaryCells(summaryTotalItems, totalAggregates) {
    return this._dataController._calculateSummaryCells(summaryTotalItems, totalAggregates, this._columnsController.getVisibleColumns(null, true), ((summaryItem, column) => this._dataController._isDataColumn(column) ? column.index : -1));
  }
  _getSelectedItems() {
    if (this.needLoadItemsOnExportingSelectedItems()) {
      return this._getAllItems(this._selectionController.loadSelectedItemsWithFilter(), true);
    }
    return this._getAllItems(this._selectionController.getSelectedRowsData());
  }
  _getColumnWidths(headersView, rowsView18) {
    return headersView && headersView.isVisible() ? headersView.getColumnWidths() : rowsView18.getColumnWidths();
  }
  throwWarningIfNoOnExportingEvent() {
    var _this$component$hasAc, _this$component;
    const hasOnExporting = null === (_this$component$hasAc = (_this$component = this.component).hasActionSubscription) || void 0 === _this$component$hasAc ? void 0 : _this$component$hasAc.call(_this$component, "onExporting");
    if (this.option("export.enabled") && !hasOnExporting) {
      ui_errors_default.log("W1024");
    }
  }
  callbackNames() {
    return ["selectionOnlyChanged"];
  }
  getDataProvider(selectedRowsOnly) {
    const columnWidths = this._getColumnWidths(this._headersView, this._rowsView);
    let initialColumnWidthsByColumnIndex;
    if (columnWidths && columnWidths.length) {
      initialColumnWidthsByColumnIndex = {};
      const columnsLastRowVisibleColumns = this._columnsController.getVisibleColumns(this._columnsController.getRowCount(), true);
      for (let i = 0; i < columnsLastRowVisibleColumns.length; i++) {
        initialColumnWidthsByColumnIndex[columnsLastRowVisibleColumns[i].index] = columnWidths[i];
      }
    }
    return new DataProvider(this, initialColumnWidthsByColumnIndex, selectedRowsOnly);
  }
  exportTo(selectedRowsOnly, format2) {
    this._selectionOnly = selectedRowsOnly;
    const onExporting = this.getAction("onExporting");
    const eventArgs = {
      rtlEnabled: this.option("rtlEnabled"),
      selectedRowsOnly: !!selectedRowsOnly,
      format: format2,
      fileName: "DataGrid",
      cancel: false
    };
    isFunction(onExporting) && onExporting(eventArgs);
  }
  publicMethods() {
    return ["getDataProvider"];
  }
  selectionOnly(value2) {
    if (isDefined(value2)) {
      this._isSelectedRows = value2;
      this.selectionOnlyChanged.fire();
    } else {
      return this._isSelectedRows;
    }
  }
  optionChanged(args) {
    super.optionChanged(args);
    if ("export" === args.name) {
      this.throwWarningIfNoOnExportingEvent();
    }
  }
  needLoadItemsOnExportingSelectedItems() {
    return this.option("loadItemsOnExportingSelectedItems") ?? this._dataController._dataSource.remoteOperations().filtering;
  }
};
var editing5 = (Base) => class extends Base {
  callbackNames() {
    const callbackList = super.callbackNames();
    return isDefined(callbackList) ? callbackList.push("editingButtonsUpdated") : ["editingButtonsUpdated"];
  }
  _updateEditButtons() {
    super._updateEditButtons();
    this.editingButtonsUpdated.fire();
  }
};
var headerPanel7 = (Base) => class extends Base {
  _getToolbarItems() {
    const items = super._getToolbarItems();
    const exportButton = this._getExportToolbarButton();
    if (exportButton) {
      items.push(exportButton);
      this._correctItemsPosition(items);
    }
    return items;
  }
  _getExportToolbarButton() {
    const items = this._getExportToolbarItems();
    if (0 === items.length) {
      return null;
    }
    const disabled = this._needDisableExportButton();
    const toolbarButtonOptions = {
      name: "exportButton",
      location: "after",
      locateInMenu: "auto",
      sortIndex: 30,
      options: {
        items
      },
      disabled
    };
    if (1 === items.length) {
      const widgetOptions = _extends({}, items[0], {
        hint: items[0].text,
        elementAttr: {
          class: "dx-datagrid-export-button"
        }
      });
      toolbarButtonOptions.widget = "dxButton";
      toolbarButtonOptions.showText = "inMenu";
      toolbarButtonOptions.options = widgetOptions;
    } else {
      const widgetOptions = {
        icon: "export",
        displayExpr: "text",
        items,
        hint: this.option("export.texts.exportTo"),
        elementAttr: {
          class: "dx-datagrid-export-button"
        },
        dropDownOptions: {
          width: "auto",
          _wrapperClassExternal: "dx-datagrid-export-menu"
        }
      };
      toolbarButtonOptions.options = widgetOptions;
      toolbarButtonOptions.widget = "dxDropDownButton";
      toolbarButtonOptions.menuItemTemplate = (_data, _index, container) => {
        this._createComponent(renderer_default(container), list_edit_search_default, {
          items
        });
      };
    }
    return toolbarButtonOptions;
  }
  _getExportToolbarItems() {
    const exportOptions = this.option("export");
    const texts = this.option("export.texts");
    const formats = this.option("export.formats") ?? [];
    if (!exportOptions.enabled) {
      return [];
    }
    const items = [];
    formats.forEach(((formatType) => {
      let formatName = formatType.toUpperCase();
      let exportAllIcon = "export";
      if ("xlsx" === formatType) {
        formatName = "Excel";
        exportAllIcon = "xlsxfile";
      }
      if ("pdf" === formatType) {
        exportAllIcon = "pdffile";
      }
      items.push({
        text: format(texts.exportAll, formatName),
        icon: exportAllIcon,
        onClick: () => {
          this._exportController.exportTo(false, formatType);
        }
      });
      if (exportOptions.allowExportSelectedData) {
        items.push({
          text: format(texts.exportSelectedRows, formatName),
          icon: "exportselected",
          onClick: () => {
            this._exportController.exportTo(true, formatType);
          }
        });
      }
    }));
    return items;
  }
  _correctItemsPosition(items) {
    items.sort(((itemA, itemB) => itemA.sortIndex - itemB.sortIndex));
  }
  _isExportButtonVisible() {
    return this.option("export.enabled");
  }
  optionChanged(args) {
    super.optionChanged(args);
    if ("export" === args.name) {
      args.handled = true;
      this._invalidate();
    }
  }
  _needDisableExportButton() {
    const isDataColumnsInvisible = !this._columnsController.hasVisibleDataColumns();
    const hasUnsavedChanges = this._editingController.hasChanges();
    return isDataColumnsInvisible || hasUnsavedChanges;
  }
  _columnOptionChanged(e) {
    super._columnOptionChanged(e);
    const isColumnLocationChanged = m_core_default.checkChanges(e.optionNames, ["groupIndex", "visible", "all"]);
    if (isColumnLocationChanged) {
      const disabled = this._needDisableExportButton();
      this.setToolbarItemDisabled("exportButton", disabled);
    }
  }
  init() {
    super.init();
    this._exportController = this.getController("export");
    this._editingController.editingButtonsUpdated.add((() => {
      const disabled = this._needDisableExportButton();
      this.setToolbarItemDisabled("exportButton", disabled);
    }));
  }
};
m_core_default.registerModule("export", {
  defaultOptions: () => ({
    export: {
      enabled: false,
      fileName: "DataGrid",
      formats: ["xlsx"],
      allowExportSelectedData: false,
      texts: {
        exportTo: message_default.format("dxDataGrid-exportTo"),
        exportAll: message_default.format("dxDataGrid-exportAll"),
        exportSelectedRows: message_default.format("dxDataGrid-exportSelectedRows")
      }
    }
  }),
  controllers: {
    export: ExportController
  },
  extenders: {
    controllers: {
      editing: editing5
    },
    views: {
      headerPanel: headerPanel7
    }
  }
});

// node_modules/devextreme/esm/__internal/grids/grid_core/focus/m_focus_utils.js
var getSortFilterValue = (sortInfo, rowData, _ref) => {
  let {
    isRemoteFiltering,
    dateSerializationFormat,
    getSelector
  } = _ref;
  const {
    selector
  } = sortInfo;
  const getter = isFunction(selector) ? selector : getSelector(selector);
  const rawValue = getter ? getter(rowData) : rowData[selector];
  const safeValue = isRemoteFiltering && isDate(rawValue) ? date_serialization_default.serializeDate(rawValue, dateSerializationFormat) : rawValue;
  return {
    getter,
    rawValue,
    safeValue
  };
};
var UiGridCoreFocusUtils = {
  getSortFilterValue
};

// node_modules/devextreme/esm/__internal/grids/grid_core/focus/m_focus.js
var FOCUSED_ROW_SELECTOR = ".dx-row.dx-row-focused";
var FocusController = class extends m_modules_default.ViewController {
  getKeyboardController() {
    return this.getController("keyboardNavigation");
  }
  getDataController() {
    return this.getController("data");
  }
  init() {
    this.component._optionsByReference.focusedRowKey = true;
  }
  optionChanged(args) {
    const {
      name,
      value: value2,
      previousValue
    } = args;
    switch (name) {
      case "focusedRowIndex":
        this._focusRowByIndex(value2);
        this.getKeyboardController()._fireFocusedRowChanged();
        args.handled = true;
        break;
      case "focusedRowKey":
        if (Array.isArray(value2) && JSON.stringify(value2) === JSON.stringify(previousValue)) {
          return;
        }
        this._focusRowByKey(value2).done((() => {
          this.getKeyboardController()._fireFocusedRowChanged();
        }));
        args.handled = true;
        break;
      case "focusedColumnIndex":
      case "focusedRowEnabled":
      case "autoNavigateToFocusedRow":
        args.handled = true;
        break;
      default:
        super.optionChanged(args);
    }
  }
  publicMethods() {
    return ["navigateToRow", "isRowFocused"];
  }
  isAutoNavigateToFocusedRow() {
    return "infinite" !== this.option("scrolling.mode") && this.option("autoNavigateToFocusedRow");
  }
  _focusRowByIndex(index, operationTypes) {
    if (!this.option("focusedRowEnabled")) {
      return;
    }
    const currentIndex = void 0 !== index ? index : this.option("focusedRowIndex");
    if (currentIndex < 0) {
      if (this.isAutoNavigateToFocusedRow()) {
        this._resetFocusedRow();
      }
    } else {
      this._focusRowByIndexCore(currentIndex, operationTypes);
    }
  }
  _focusRowByIndexCore(index, operationTypes) {
    const pageSize = this.getDataController().pageSize();
    const setKeyByIndex = () => {
      if (this._isValidFocusedRowIndex(index)) {
        let rowIndex = index - this.getDataController().getRowIndexOffset(true);
        if (!operationTypes || operationTypes.paging && !operationTypes.filtering) {
          const lastItemIndex = this.getDataController()._getLastItemIndex();
          rowIndex = Math.min(rowIndex, lastItemIndex);
        }
        const focusedRowKey = this.getDataController().getKeyByRowIndex(rowIndex, true);
        if (isDefined(focusedRowKey) && !this.isRowFocused(focusedRowKey)) {
          this.option("focusedRowKey", focusedRowKey);
        }
      }
    };
    if (pageSize >= 0) {
      if (!this._isLocalRowIndex(index)) {
        const pageIndex = Math.floor(index / this.getDataController().pageSize());
        when(this.getDataController().pageIndex(pageIndex), this.getDataController().waitReady()).done((() => {
          setKeyByIndex();
        }));
      } else {
        setKeyByIndex();
      }
    }
  }
  _isLocalRowIndex(index) {
    const isVirtualScrolling = this.getKeyboardController()._isVirtualScrolling();
    if (isVirtualScrolling) {
      const pageIndex = Math.floor(index / this.getDataController().pageSize());
      const virtualItems = this.getDataController().virtualItemsCount();
      const virtualItemsBegin = virtualItems ? virtualItems.begin : -1;
      const visibleRowsCount = this.getDataController().getVisibleRows().length + this.getDataController().getRowIndexOffset();
      const visiblePagesCount = Math.ceil(visibleRowsCount / this.getDataController().pageSize());
      return virtualItemsBegin <= index && visiblePagesCount > pageIndex;
    }
    return true;
  }
  _setFocusedRowKeyByIndex(index) {
    if (this._isValidFocusedRowIndex(index)) {
      const rowIndex = Math.min(index - this.getDataController().getRowIndexOffset(), this.getDataController().items().length - 1);
      const focusedRowKey = this.getDataController().getKeyByRowIndex(rowIndex);
      if (isDefined(focusedRowKey) && !this.isRowFocused(focusedRowKey)) {
        this.option("focusedRowKey", focusedRowKey);
      }
    }
  }
  _focusRowByKey(key) {
    if (!isDefined(key)) {
      this._resetFocusedRow();
      return Deferred().resolve();
    }
    return this._navigateToRow(key, true);
  }
  _resetFocusedRow() {
    const focusedRowKey = this.option("focusedRowKey");
    const isFocusedRowKeyDefined = isDefined(focusedRowKey);
    if (!isFocusedRowKeyDefined && this.option("focusedRowIndex") < 0) {
      return;
    }
    if (isFocusedRowKeyDefined) {
      this.option("focusedRowKey", null);
    }
    this.getKeyboardController().setFocusedRowIndex(-1);
    this.option("focusedRowIndex", -1);
    this.getDataController().updateItems({
      changeType: "updateFocusedRow",
      focusedRowKey: null
    });
    this.getKeyboardController()._fireFocusedRowChanged();
  }
  _isValidFocusedRowIndex(rowIndex) {
    const row = this.getDataController().getVisibleRows()[rowIndex];
    return !row || "data" === row.rowType || "group" === row.rowType;
  }
  navigateToRow(key) {
    if (!this.isAutoNavigateToFocusedRow()) {
      this.option("focusedRowIndex", -1);
    }
    return this._navigateToRow(key, false);
  }
  _navigateToRow(key, needFocusRow) {
    const that = this;
    const isAutoNavigate = that.isAutoNavigateToFocusedRow();
    const d = new Deferred();
    const rowsView18 = this.getView("rowsView");
    if (void 0 === key || !this.getDataController().dataSource()) {
      return d.reject().promise();
    }
    const rowIndexByKey = that.getFocusedRowIndexByKey(key);
    if (!isAutoNavigate && needFocusRow || rowIndexByKey >= 0) {
      that._navigateTo(key, d, needFocusRow);
    } else {
      this.getDataController().getPageIndexByKey(key).done(((pageIndex) => {
        if (pageIndex < 0) {
          d.resolve(-1);
          return;
        }
        if (pageIndex === this.getDataController().pageIndex()) {
          this.getDataController().reload().done((() => {
            if (that.isRowFocused(key) && this.getDataController().getRowIndexByKey(key) >= 0) {
              d.resolve(that.getFocusedRowIndexByKey(key));
            } else {
              that._navigateTo(key, d, needFocusRow);
            }
          })).fail(d.reject);
        } else {
          this.getDataController().pageIndex(pageIndex).done((() => {
            rowsView18.waitAsyncTemplates(true).done((() => {
              that._navigateTo(key, d, needFocusRow);
            }));
          })).fail(d.reject);
        }
      })).fail(d.reject);
    }
    return d.promise();
  }
  _navigateTo(key, deferred, needFocusRow) {
    const visibleRowIndex = this.getDataController().getRowIndexByKey(key);
    const isVirtualRowRenderingMode = m_utils_default.isVirtualRowRendering(this);
    const isAutoNavigate = this.isAutoNavigateToFocusedRow();
    if (isAutoNavigate && isVirtualRowRenderingMode && visibleRowIndex < 0) {
      this._navigateToVirtualRow(key, deferred, needFocusRow);
    } else {
      this._navigateToVisibleRow(key, deferred, needFocusRow);
    }
  }
  _navigateToVisibleRow(key, deferred, needFocusRow) {
    if (needFocusRow) {
      this._triggerUpdateFocusedRow(key, deferred);
    } else {
      const focusedRowIndex = this.getFocusedRowIndexByKey(key);
      this.getView("rowsView").scrollToRowElement(key, deferred).done((() => {
        deferred.resolve(focusedRowIndex);
      }));
    }
  }
  _navigateToVirtualRow(key, deferred, needFocusRow) {
    const rowsScrollController = this.getDataController()._rowsScrollController;
    const rowIndex = m_utils_default.getIndexByKey(key, this.getDataController().items(true));
    const scrollable = this.getView("rowsView").getScrollable();
    if (rowsScrollController && scrollable && rowIndex >= 0) {
      const focusedRowIndex = rowIndex + this.getDataController().getRowIndexOffset(true);
      const offset = rowsScrollController.getItemOffset(focusedRowIndex);
      const triggerUpdateFocusedRow = () => {
        if (this.getDataController().totalCount() && !this.getDataController().items().length) {
          return;
        }
        this.component.off("contentReady", triggerUpdateFocusedRow);
        if (needFocusRow) {
          this._triggerUpdateFocusedRow(key, deferred);
        } else {
          deferred.resolve(focusedRowIndex);
        }
      };
      this.component.on("contentReady", triggerUpdateFocusedRow);
      this.getView("rowsView").scrollTopPosition(offset);
    } else {
      deferred.resolve(-1);
    }
  }
  _triggerUpdateFocusedRow(key, deferred) {
    const focusedRowIndex = this.getFocusedRowIndexByKey(key);
    if (this._isValidFocusedRowIndex(focusedRowIndex)) {
      let d;
      if (this.option("focusedRowEnabled")) {
        this.getDataController().updateItems({
          changeType: "updateFocusedRow",
          focusedRowKey: key
        });
      } else {
        d = this.getView("rowsView").scrollToRowElement(key);
      }
      when(d).done((() => {
        this.getKeyboardController().setFocusedRowIndex(focusedRowIndex);
        deferred && deferred.resolve(focusedRowIndex);
      }));
    } else {
      deferred && deferred.resolve(-1);
    }
  }
  getFocusedRowIndexByKey(key) {
    const loadedRowIndex = this.getDataController().getRowIndexByKey(key, true);
    return loadedRowIndex >= 0 ? loadedRowIndex + this.getDataController().getRowIndexOffset(true) : -1;
  }
  _focusRowByKeyOrIndex() {
    const focusedRowKey = this.option("focusedRowKey");
    let currentFocusedRowIndex = this.option("focusedRowIndex");
    if (isDefined(focusedRowKey)) {
      const visibleRowIndex = this.getDataController().getRowIndexByKey(focusedRowKey);
      if (visibleRowIndex >= 0) {
        if (this.getKeyboardController()._isVirtualScrolling()) {
          currentFocusedRowIndex = visibleRowIndex + this.getDataController().getRowIndexOffset();
        }
        this.getKeyboardController().setFocusedRowIndex(currentFocusedRowIndex);
        this._triggerUpdateFocusedRow(focusedRowKey);
      } else {
        this._navigateToRow(focusedRowKey, true).done(((focusedRowIndex) => {
          if (currentFocusedRowIndex >= 0 && focusedRowIndex < 0) {
            this._focusRowByIndex();
          } else if (currentFocusedRowIndex < 0 && focusedRowIndex >= 0) {
            this.getKeyboardController().setFocusedRowIndex(focusedRowIndex);
          }
        }));
      }
    } else if (currentFocusedRowIndex >= 0) {
      this._focusRowByIndex(currentFocusedRowIndex);
    }
  }
  isRowFocused(key) {
    const focusedRowKey = this.option("focusedRowKey");
    if (isDefined(focusedRowKey)) {
      return equalByValue(key, this.option("focusedRowKey"));
    }
    return;
  }
  updateFocusedRow(e) {
    const that = this;
    const focusedRowIndex = that.getDataController().getRowIndexByKey(e.focusedRowKey);
    const rowsView18 = that.getView("rowsView");
    let $tableElement;
    let $mainRow;
    each(rowsView18.getTableElements(), ((index, element) => {
      const isMainTable = 0 === index;
      $tableElement = renderer_default(element);
      that._clearPreviousFocusedRow($tableElement, focusedRowIndex);
      const $row = that._prepareFocusedRow({
        changedItem: that.getDataController().getVisibleRows()[focusedRowIndex],
        $tableElement,
        focusedRowIndex
      });
      if (isMainTable) {
        $mainRow = $row;
      }
    }));
    if (!e.preventScroll && $mainRow) {
      rowsView18.scrollToElementVertically($mainRow);
    }
  }
  _clearPreviousFocusedRow($tableElement, focusedRowIndex) {
    const $prevRowFocusedElement = $tableElement.find(FOCUSED_ROW_SELECTOR).filter(((_, focusedRow) => {
      const $focusedRowTable = renderer_default(focusedRow).closest(`.${this.addWidgetPrefix("table")}`);
      return $tableElement.is($focusedRowTable);
    }));
    $prevRowFocusedElement.removeClass("dx-row-focused").removeClass("dx-cell-focus-disabled").removeAttr("tabindex");
    $prevRowFocusedElement.children("td").removeAttr("tabindex");
    if (0 !== focusedRowIndex) {
      const $firstRow = renderer_default(this.getView("rowsView").getRowElement(0));
      $firstRow.removeClass("dx-cell-focus-disabled").removeAttr("tabIndex");
    }
  }
  _prepareFocusedRow(options) {
    let $row;
    const {
      changedItem
    } = options;
    if (changedItem && ("data" === changedItem.rowType || "group" === changedItem.rowType)) {
      const {
        focusedRowIndex
      } = options;
      const {
        $tableElement
      } = options;
      const tabIndex = this.option("tabindex") || 0;
      const rowsView18 = this.getView("rowsView");
      $row = renderer_default(rowsView18._getRowElements($tableElement).eq(focusedRowIndex));
      $row.addClass("dx-row-focused").attr("tabindex", tabIndex);
    }
    return $row;
  }
};
var keyboardNavigation3 = (Base) => class extends Base {
  init() {
    const rowIndex = this.option("focusedRowIndex");
    const columnIndex = this.option("focusedColumnIndex");
    this.createAction("onFocusedRowChanging", {
      excludeValidators: ["disabled", "readOnly"]
    });
    this.createAction("onFocusedRowChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
    this.createAction("onFocusedCellChanging", {
      excludeValidators: ["disabled", "readOnly"]
    });
    this.createAction("onFocusedCellChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
    super.init();
    this.setRowFocusType();
    this._focusedCellPosition = {};
    if (isDefined(rowIndex) && rowIndex >= 0) {
      this._focusedCellPosition.rowIndex = rowIndex;
    }
    if (isDefined(columnIndex) && columnIndex >= 0) {
      this._focusedCellPosition.columnIndex = columnIndex;
    }
  }
  setFocusedRowIndex(rowIndex) {
    super.setFocusedRowIndex(rowIndex);
    this.option("focusedRowIndex", rowIndex);
  }
  setFocusedColumnIndex(columnIndex) {
    super.setFocusedColumnIndex(columnIndex);
    this.option("focusedColumnIndex", columnIndex);
  }
  _escapeKeyHandler(eventArgs, isEditing) {
    if (isEditing || !this.option("focusedRowEnabled")) {
      return super._escapeKeyHandler(eventArgs, isEditing);
    }
    if (this.isCellFocusType()) {
      this.setRowFocusType();
      this._focus(this._getCellElementFromTarget(eventArgs.originalEvent.target), true);
      return true;
    }
    return false;
  }
  _updateFocusedCellPosition($cell, direction) {
    const position = super._updateFocusedCellPosition($cell, direction);
    if (position && position.columnIndex >= 0) {
      this._fireFocusedCellChanged($cell);
    }
    return position;
  }
};
var editorFactory5 = (Base) => class extends Base {
  renderFocusOverlay($element, isHideBorder) {
    var _this$_keyboardNaviga;
    const focusedRowEnabled = this.option("focusedRowEnabled");
    if (!focusedRowEnabled || !(null !== (_this$_keyboardNaviga = this._keyboardNavigationController) && void 0 !== _this$_keyboardNaviga && _this$_keyboardNaviga.isRowFocusType()) || this._editingController.isEditing() || this._columnHeadersView.isFilterRowCell($element)) {
      super.renderFocusOverlay($element, isHideBorder);
    } else if (focusedRowEnabled) {
      const isRowElement = "row" === this._keyboardNavigationController._getElementType($element);
      if (isRowElement && !$element.hasClass("dx-row-focused")) {
        const $cell = this._keyboardNavigationController.getFirstValidCellInRow($element);
        this._keyboardNavigationController.focus($cell);
      }
    }
  }
};
var columns6 = (Base) => class extends Base {
  getSortDataSourceParameters(_, sortByKey) {
    let result = super.getSortDataSourceParameters.apply(this, arguments);
    const dataSource = this._dataController._dataSource;
    const store = this._dataController.store();
    let key = store && store.key();
    const remoteOperations = dataSource && dataSource.remoteOperations() || {};
    const isLocalOperations = Object.keys(remoteOperations).every(((operationName) => !remoteOperations[operationName]));
    if (key && (this.option("focusedRowEnabled") && false !== this._focusController.isAutoNavigateToFocusedRow() || sortByKey)) {
      key = Array.isArray(key) ? key : [key];
      const notSortedKeys = key.filter(((key2) => !this.columnOption(key2, "sortOrder")));
      if (notSortedKeys.length) {
        result = result || [];
        if (isLocalOperations) {
          result.push({
            selector: dataSource.getDataIndexGetter(),
            desc: false
          });
        } else {
          notSortedKeys.forEach(((notSortedKey) => result.push({
            selector: notSortedKey,
            desc: false
          })));
        }
      }
    }
    return result;
  }
};
var data15 = (Base) => class extends Base {
  constructor() {
    super(...arguments);
    this._isDataPushed = false;
  }
  _applyChange(change) {
    if (change && "updateFocusedRow" === change.changeType) {
      return;
    }
    return super._applyChange.apply(this, arguments);
  }
  _fireChanged(e) {
    super._fireChanged(e);
    const forceUpdateFocusedRow = this._isDataPushed;
    this._isDataPushed = false;
    if (this.option("focusedRowEnabled") && this._dataSource) {
      const isPartialUpdate = "update" === e.changeType && e.repaintChangesOnly;
      const isPartialUpdateWithDeleting = isPartialUpdate && e.changeTypes && e.changeTypes.indexOf("remove") >= 0;
      if (forceUpdateFocusedRow && this.isEmpty()) {
        this._focusController._resetFocusedRow();
      } else if ("refresh" === e.changeType && e.items.length || isPartialUpdateWithDeleting) {
        this._updatePageIndexes();
        this._updateFocusedRowIfNeeded(e, forceUpdateFocusedRow);
      } else if ("append" === e.changeType || "prepend" === e.changeType) {
        this._updatePageIndexes();
      } else if (isPartialUpdate) {
        this._updateFocusedRowIfNeeded(e, forceUpdateFocusedRow);
      }
    }
  }
  _handleDataPushed(changes) {
    super._handleDataPushed(changes);
    const focusedRowKey = this.option("focusedRowKey");
    this._isDataPushed = isDefined(focusedRowKey) && !!changes.length;
  }
  _updatePageIndexes() {
    const prevRenderingPageIndex = this._lastRenderingPageIndex || 0;
    const renderingPageIndex = this._rowsScrollController ? this._rowsScrollController.pageIndex() : 0;
    this._lastRenderingPageIndex = renderingPageIndex;
    this._isPagingByRendering = renderingPageIndex !== prevRenderingPageIndex;
  }
  isPagingByRendering() {
    return this._isPagingByRendering;
  }
  _updateFocusedRowIfNeeded(e) {
    let forceUpdate = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;
    const operationTypes = e.operationTypes || {};
    const {
      reload,
      fullReload,
      pageIndex,
      paging
    } = operationTypes;
    const isVirtualScrolling = this._keyboardNavigationController._isVirtualScrolling();
    const pagingWithoutVirtualScrolling = paging && !isVirtualScrolling;
    const focusedRowKey = this.option("focusedRowKey");
    const isAutoNavigate = this._focusController.isAutoNavigateToFocusedRow();
    const isReload = reload && false === pageIndex;
    const rowIndexByKey = this.getRowIndexByKey(focusedRowKey);
    switch (true) {
      case forceUpdate:
        this._focusController._focusRowByKeyOrIndex();
        break;
      case (isReload && !fullReload && isDefined(focusedRowKey)):
        this._focusController._navigateToRow(focusedRowKey, true).done(((focusedRowIndex) => {
          if (focusedRowIndex < 0) {
            this._focusController._focusRowByIndex(void 0, operationTypes);
          }
        }));
        break;
      case (pagingWithoutVirtualScrolling && isAutoNavigate): {
        const focusedRowIndex = this.option("focusedRowIndex");
        const isValidRowIndexByKey = rowIndexByKey >= 0;
        const isValidFocusedRowIndex = focusedRowIndex >= 0;
        const isSameRowIndex = focusedRowIndex === rowIndexByKey;
        if (isValidFocusedRowIndex && (isSameRowIndex || !isValidRowIndexByKey)) {
          this._focusController._focusRowByIndex(focusedRowIndex, operationTypes);
        }
        break;
      }
      case (pagingWithoutVirtualScrolling && !isAutoNavigate && rowIndexByKey < 0):
        this.option("focusedRowIndex", -1);
        break;
      case operationTypes.fullReload:
        this._focusController._focusRowByKeyOrIndex();
    }
  }
  getPageIndexByKey(key) {
    const that = this;
    const d = new Deferred();
    that.getGlobalRowIndexByKey(key).done(((globalIndex) => {
      d.resolve(globalIndex >= 0 ? Math.floor(globalIndex / that.pageSize()) : -1);
    })).fail(d.reject);
    return d.promise();
  }
  getGlobalRowIndexByKey(key) {
    if (this._dataSource.group()) {
      return this._calculateGlobalRowIndexByGroupedData(key);
    }
    return this._calculateGlobalRowIndexByFlatData(key);
  }
  _calculateGlobalRowIndexByFlatData(key, groupFilter, useGroup) {
    const that = this;
    const deferred = new Deferred();
    const dataSource = that._dataSource;
    if (Array.isArray(key) || isNewRowTempKey(key)) {
      return deferred.resolve(-1).promise();
    }
    let filter = that._generateFilterByKey(key);
    dataSource.load({
      filter: that._concatWithCombinedFilter(filter),
      skip: 0,
      take: 1
    }).done(((data17) => {
      if (data17.length > 0) {
        filter = that._generateOperationFilterByKey(key, data17[0], useGroup);
        dataSource.load({
          filter: that._concatWithCombinedFilter(filter, groupFilter),
          skip: 0,
          take: 1,
          requireTotalCount: true
        }).done(((_, extra) => {
          deferred.resolve(extra.totalCount);
        }));
      } else {
        deferred.resolve(-1);
      }
    }));
    return deferred.promise();
  }
  _concatWithCombinedFilter(filter, groupFilter) {
    const combinedFilter = this.getCombinedFilter();
    return m_utils_default.combineFilters([filter, combinedFilter, groupFilter]);
  }
  _generateBooleanFilter(selector, value2, sortInfo) {
    const {
      desc
    } = sortInfo;
    switch (true) {
      case (false === value2 && desc):
        return [selector, "=", true];
      case (false === value2 && !desc):
        return [selector, "=", null];
      case (true === value2 && !desc):
      case (!isBoolean(value2) && desc):
        return [selector, "<>", value2];
      default:
        return;
    }
  }
  _generateOperationFilterByKey(key, rowData, useGroup) {
    const that = this;
    const dateSerializationFormat = that.option("dateSerializationFormat");
    const isRemoteFiltering = that._dataSource.remoteOperations().filtering;
    const isRemoteSorting = that._dataSource.remoteOperations().sorting;
    let filter = that._generateFilterByKey(key, "<");
    let sort = that._columnsController.getSortDataSourceParameters(!isRemoteFiltering, true);
    if (useGroup) {
      const group = that._columnsController.getGroupDataSourceParameters(!isRemoteFiltering);
      if (group) {
        sort = sort ? group.concat(sort) : group;
      }
    }
    if (sort) {
      sort.slice().reverse().forEach(((sortInfo) => {
        const {
          selector,
          desc,
          compare
        } = sortInfo;
        const {
          getter,
          rawValue,
          safeValue
        } = UiGridCoreFocusUtils.getSortFilterValue(sortInfo, rowData, {
          isRemoteFiltering,
          dateSerializationFormat,
          getSelector: (selector2) => that._columnsController.columnOption(selector2, "selector")
        });
        filter = [
          [selector, "=", safeValue],
          "and",
          filter
        ];
        if (null === rawValue || isBoolean(rawValue)) {
          const booleanFilter = that._generateBooleanFilter(selector, safeValue, desc);
          if (booleanFilter) {
            filter = [booleanFilter, "or", filter];
          }
        } else {
          const filterOperation = desc ? ">" : "<";
          let sortFilter;
          if (compare && !isRemoteSorting) {
            sortFilter = (data17) => {
              if ("<" === filterOperation) {
                return compare(rawValue, getter(data17)) >= 1;
              }
              return compare(rawValue, getter(data17)) <= -1;
            };
          } else {
            sortFilter = [selector, filterOperation, safeValue];
            if (!desc) {
              sortFilter = [sortFilter, "or", [selector, "=", null]];
            }
          }
          filter = [sortFilter, "or", filter];
        }
      }));
    }
    return filter;
  }
  _generateFilterByKey(key, operation) {
    const dataSourceKey = this._dataSource.key();
    let filter = [];
    if (!operation) {
      operation = "=";
    }
    if (Array.isArray(dataSourceKey)) {
      for (let i = 0; i < dataSourceKey.length; ++i) {
        const keyPart = key[dataSourceKey[i]];
        if (keyPart) {
          if (filter.length > 0) {
            filter.push("and");
          }
          filter.push([dataSourceKey[i], operation, keyPart]);
        }
      }
    } else {
      filter = [dataSourceKey, operation, key];
    }
    return filter;
  }
  _getLastItemIndex() {
    return this.items(true).length - 1;
  }
};
var editing6 = (Base) => class extends Base {
  _deleteRowCore(rowIndex) {
    const deferred = super._deleteRowCore.apply(this, arguments);
    const rowKey = this._dataController.getKeyByRowIndex(rowIndex);
    deferred.done((() => {
      const rowIndex2 = this._dataController.getRowIndexByKey(rowKey);
      const visibleRows = this._dataController.getVisibleRows();
      if (-1 === rowIndex2 && !visibleRows.length) {
        this._focusController._resetFocusedRow();
      }
    }));
  }
};
var rowsView16 = (Base) => class extends Base {
  _createRow(row) {
    const $row = super._createRow.apply(this, arguments);
    if (this.option("focusedRowEnabled") && row) {
      if (this._focusController.isRowFocused(row.key)) {
        $row.addClass("dx-row-focused");
      }
    }
    return $row;
  }
  _checkRowKeys(options) {
    super._checkRowKeys.apply(this, arguments);
    if (this.option("focusedRowEnabled") && this.option("dataSource")) {
      const store = this._dataController.store();
      if (store && !store.key()) {
        this._dataController.fireError("E1042", "Row focusing");
      }
    }
  }
  _update(change) {
    if ("updateFocusedRow" === change.changeType) {
      if (this.option("focusedRowEnabled")) {
        this._focusController.updateFocusedRow(change);
      }
    } else {
      super._update(change);
    }
  }
  updateFocusElementTabIndex($cellElements, preventScroll) {
    if (this.option("focusedRowEnabled")) {
      this._setFocusedRowElementTabIndex(preventScroll);
    } else {
      super.updateFocusElementTabIndex($cellElements);
    }
  }
  _setFocusedRowElementTabIndex(preventScroll) {
    const focusedRowKey = this.option("focusedRowKey");
    const tabIndex = this.option("tabIndex") ?? 0;
    const columnsController = this._columnsController;
    let rowIndex = this._dataController.getRowIndexByKey(focusedRowKey);
    let columnIndex = this.option("focusedColumnIndex");
    const $row = this._findRowElementForTabIndex();
    const dataSource = this._dataController.dataSource();
    const operationTypes = null === dataSource || void 0 === dataSource ? void 0 : dataSource.operationTypes();
    const isPaging = !operationTypes || operationTypes.paging;
    if (!isDefined(this._scrollToFocusOnResize)) {
      this._scrollToFocusOnResize = () => {
        this.scrollToElementVertically(this._findRowElementForTabIndex());
        this.resizeCompleted.remove(this._scrollToFocusOnResize);
      };
    }
    $row.attr("tabIndex", tabIndex);
    const rowIndexFromOption = this.option("focusedRowIndex") - this._dataController.getRowIndexOffset(true);
    if (!isPaging && rowIndex < 0 && rowIndexFromOption >= 0) {
      this._focusController.updateFocusedRow({
        focusedRowKey,
        preventScroll
      });
    }
    if (rowIndex >= 0 && !preventScroll) {
      if (columnIndex < 0) {
        columnIndex = 0;
      }
      rowIndex += this._dataController.getRowIndexOffset();
      columnIndex += columnsController.getColumnIndexOffset();
      this._keyboardNavigationController.setFocusedCellPosition(rowIndex, columnIndex);
      if (this._focusController.isAutoNavigateToFocusedRow()) {
        if (!isPaging && !this._dataController.isPagingByRendering()) {
          this.resizeCompleted.remove(this._scrollToFocusOnResize);
          this.resizeCompleted.add(this._scrollToFocusOnResize);
        }
      }
    }
  }
  _findRowElementForTabIndex() {
    const focusedRowKey = this.option("focusedRowKey");
    const rowIndex = this._dataController.getRowIndexByKey(focusedRowKey);
    return renderer_default(this.getRowElement(rowIndex >= 0 ? rowIndex : 0));
  }
  scrollToRowElement(key) {
    const rowIndex = this._dataController.getRowIndexByKey(key);
    const $row = renderer_default(this.getRow(rowIndex));
    return this.scrollToElementVertically($row);
  }
  scrollToElementVertically($row) {
    const scrollable = this.getScrollable();
    if (scrollable && $row.length) {
      const position = scrollable.getScrollElementPosition($row, "vertical");
      return this.scrollTopPosition(position);
    }
    return new Deferred().resolve();
  }
  scrollTopPosition(scrollTop) {
    const d = new Deferred();
    const scrollable = this.getScrollable();
    if (scrollable) {
      const currentScrollTop = scrollable.scrollTop();
      const scrollHandler = () => {
        scrollable.off("scroll", scrollHandler);
        d.resolve();
      };
      if (scrollTop !== currentScrollTop) {
        scrollable.on("scroll", scrollHandler);
        this._dataController.resetFilterApplying();
        scrollable.scrollTo({
          top: scrollTop
        });
        return d.promise();
      }
    }
    return d.resolve();
  }
};
var focusModule = {
  defaultOptions: () => ({
    focusedRowEnabled: false,
    autoNavigateToFocusedRow: true,
    focusedRowKey: null,
    focusedRowIndex: -1,
    focusedColumnIndex: -1
  }),
  controllers: {
    focus: FocusController
  },
  extenders: {
    controllers: {
      keyboardNavigation: keyboardNavigation3,
      editorFactory: editorFactory5,
      columns: columns6,
      data: data15,
      editing: editing6
    },
    views: {
      rowsView: rowsView16
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/focus/m_focus.js
var MAX_SAFE_INTEGER2 = Number.MAX_SAFE_INTEGER || 9007199254740991;
var data16 = (Base) => class extends focusModule.extenders.controllers.data(Base) {
  changeRowExpand(path, isRowClick) {
    if (this.option("focusedRowEnabled") && Array.isArray(path) && this.isRowExpanded(path)) {
      if ((!isRowClick || !this._keyboardNavigationController.isKeyboardEnabled()) && this._isFocusedRowInsideGroup(path)) {
        this.option("focusedRowKey", path);
      }
    }
    return super.changeRowExpand(path, isRowClick);
  }
  _isFocusedRowInsideGroup(path) {
    const focusedRowKey = this.option("focusedRowKey");
    const rowIndex = this.getRowIndexByKey(focusedRowKey);
    const focusedRow = rowIndex >= 0 && this.getVisibleRows()[rowIndex];
    const groups = this._columnsController.getGroupDataSourceParameters(true);
    if (focusedRow) {
      for (let i = 0; i < path.length; ++i) {
        const getter = compileGetter(groups[i] && groups[i].selector);
        if (getter(focusedRow.data) !== path[i]) {
          return false;
        }
      }
    }
    return true;
  }
  _getGroupPath(groupItems, groupCount) {
    const groupPath = [];
    let groupItem = groupItems[0];
    while (groupItem && groupPath.length < groupCount) {
      var _groupItem$items;
      groupPath.push(groupItem.key);
      groupItem = null === (_groupItem$items = groupItem.items) || void 0 === _groupItem$items ? void 0 : _groupItem$items[0];
    }
    return groupPath;
  }
  _expandGroupByPath(that, groupPath, level) {
    const d = new Deferred();
    level++;
    that.expandRow(groupPath.slice(0, level)).done((() => {
      if (level === groupPath.length) {
        d.resolve();
      } else {
        that._expandGroupByPath(that, groupPath, level).done(d.resolve).fail(d.reject);
      }
    })).fail(d.reject);
    return d.promise();
  }
  _calculateGlobalRowIndexByGroupedData(key) {
    const that = this;
    const dataSource = that._dataSource;
    const filter = that._generateFilterByKey(key);
    const deferred = new Deferred();
    const isGroupKey = Array.isArray(key);
    const group = dataSource.group();
    if (isGroupKey) {
      return deferred.resolve(-1).promise();
    }
    if (!dataSource._grouping._updatePagingOptions) {
      that._calculateGlobalRowIndexByFlatData(key, null, true).done(deferred.resolve).fail(deferred.reject);
      return deferred;
    }
    dataSource.load({
      filter: that._concatWithCombinedFilter(filter),
      group
    }).done(((data17) => {
      const hasData = isDefined(data17) && data17.length > 0;
      if (!hasData) {
        return deferred.resolve(-1).promise();
      }
      const groupPath = that._getGroupPath(data17, group.length);
      that._expandGroupByPath(that, groupPath, 0).done((() => {
        that._calculateExpandedRowGlobalIndex(deferred, key, groupPath, group);
      })).fail(deferred.reject);
    })).fail(deferred.reject);
    return deferred.promise();
  }
  _calculateExpandedRowGlobalIndex(deferred, key, groupPath, group) {
    const groupFilter = createGroupFilter(groupPath, {
      group
    });
    const dataSource = this._dataSource;
    const scrollingMode = this.option("scrolling.mode");
    const isVirtualScrolling = "virtual" === scrollingMode || "infinite" === scrollingMode;
    const pageSize = dataSource.pageSize();
    let groupOffset;
    dataSource._grouping._updatePagingOptions({
      skip: 0,
      take: MAX_SAFE_INTEGER2
    }, ((groupInfo, totalOffset) => {
      if (equalByValue(groupInfo.path, groupPath)) {
        groupOffset = totalOffset;
      }
    }));
    this._calculateGlobalRowIndexByFlatData(key, groupFilter).done(((dataOffset) => {
      let count;
      let groupContinuationCount;
      if (dataOffset < 0) {
        deferred.resolve(-1);
        return;
      }
      const currentPageOffset = groupOffset % pageSize || pageSize;
      count = currentPageOffset + dataOffset - groupPath.length;
      if (isVirtualScrolling) {
        groupContinuationCount = 0;
      } else {
        groupContinuationCount = Math.floor(count / (pageSize - groupPath.length)) * groupPath.length;
      }
      count = groupOffset + dataOffset + groupContinuationCount;
      deferred.resolve(count);
    })).fail(deferred.reject);
  }
};
m_core_default.registerModule("focus", _extends({}, focusModule, {
  extenders: _extends({}, focusModule.extenders, {
    controllers: _extends({}, focusModule.extenders.controllers, {
      data: data16
    })
  })
}));

// node_modules/devextreme/esm/ui/sortable.js
var sortable_default = m_sortable_default;

// node_modules/devextreme/esm/__internal/grids/grid_core/row_dragging/const.js
var ATTRIBUTES2 = {
  dragCell: "dx-drag-cell"
};
var CLASSES7 = {
  cellFocusDisabled: "dx-cell-focus-disabled",
  handleIcon: "drag-icon",
  commandDrag: "dx-command-drag",
  sortableWithoutHandle: "dx-sortable-without-handle",
  rowsView: "rowsview",
  dragView: "dragview"
};

// node_modules/devextreme/esm/__internal/grids/grid_core/row_dragging/dom.js
var createHandleTemplateFunc = (addWidgetPrefix) => (container, options) => {
  const $container = renderer_default(container);
  if ("data" === options.rowType) {
    $container.addClass(CLASSES7.cellFocusDisabled);
    return renderer_default("<span>").addClass(addWidgetPrefix(CLASSES7.handleIcon));
  }
  m_utils_default.setEmptyText($container);
  return;
};
var GridCoreRowDraggingDom = {
  createHandleTemplateFunc
};

// node_modules/devextreme/esm/__internal/grids/grid_core/row_dragging/m_row_dragging.js
var rowsView17 = (Base) => class extends Base {
  init() {
    super.init.apply(this, arguments);
    this._updateHandleColumn();
  }
  optionChanged(args) {
    if ("rowDragging" === args.name) {
      this._updateHandleColumn();
      this._invalidate(true, true);
      args.handled = true;
    }
    super.optionChanged.apply(this, arguments);
  }
  _allowReordering() {
    const rowDragging = this.option("rowDragging");
    return !!(rowDragging && (rowDragging.allowReordering || rowDragging.allowDropInsideItem || rowDragging.group));
  }
  _updateHandleColumn() {
    const rowDragging = this.option("rowDragging");
    const allowReordering2 = this._allowReordering();
    const columnsController = this._columnsController;
    const isHandleColumnVisible = allowReordering2 && rowDragging.showDragIcons;
    null === columnsController || void 0 === columnsController || columnsController.addCommandColumn({
      type: "drag",
      command: "drag",
      visibleIndex: -2,
      alignment: "center",
      elementAttr: [{
        name: ATTRIBUTES2.dragCell,
        value: ""
      }],
      cssClass: CLASSES7.commandDrag,
      width: "auto",
      cellTemplate: this._getHandleTemplate(),
      visible: isHandleColumnVisible
    });
    null === columnsController || void 0 === columnsController || columnsController.columnOption("type:drag", "visible", isHandleColumnVisible);
  }
  _renderContent() {
    const rowDragging = this.option("rowDragging");
    const allowReordering2 = this._allowReordering();
    const $content = super._renderContent.apply(this, arguments);
    const isFixedTableRendering = this._isFixedTableRendering;
    const currentSortableName = isFixedTableRendering ? "_sortableFixed" : "_sortable";
    const anotherSortableName = isFixedTableRendering ? "_sortable" : "_sortableFixed";
    const togglePointerEventsStyle = (toggle) => {
      var _this$sortableFixedNa;
      null === (_this$sortableFixedNa = this._sortableFixed) || void 0 === _this$sortableFixedNa || _this$sortableFixedNa.$element().css("pointerEvents", toggle ? "auto" : "");
    };
    const rowSelector = ".dx-row:not(.dx-freespace-row):not(.dx-virtual-row):not(.dx-header-row):not(.dx-footer-row)";
    const filter = this.option("dataRowTemplate") ? `> table > tbody${rowSelector}` : `> table > tbody > ${rowSelector}`;
    if ((allowReordering2 || this[currentSortableName]) && $content.length) {
      this[currentSortableName] = this._createComponent($content, sortable_default, extend({
        component: this.component,
        contentTemplate: null,
        filter,
        cursorOffset: (options) => {
          const {
            event
          } = options;
          const rowsViewOffset = renderer_default(this.element()).offset();
          return {
            x: event.pageX - rowsViewOffset.left
          };
        },
        onDraggableElementShown: (e) => {
          if (rowDragging.dragTemplate) {
            return;
          }
          const $dragElement = renderer_default(e.dragElement);
          const gridInstance = $dragElement.children(".dx-widget").data(this.component.NAME);
          this._synchronizeScrollLeftPosition(gridInstance);
        },
        dragTemplate: this._getDraggableRowTemplate(),
        handle: rowDragging.showDragIcons && `.${CLASSES7.commandDrag}`,
        dropFeedbackMode: "indicate"
      }, rowDragging, {
        onDragStart: (e) => {
          var _this$getController, _rowDragging$onDragSt;
          null === (_this$getController = this.getController("keyboardNavigation")) || void 0 === _this$getController || _this$getController._resetFocusedCell();
          const row = e.component.getVisibleRows()[e.fromIndex];
          e.itemData = null === row || void 0 === row ? void 0 : row.data;
          const isDataRow2 = row && "data" === row.rowType;
          e.cancel = !allowReordering2 || !isDataRow2;
          null === (_rowDragging$onDragSt = rowDragging.onDragStart) || void 0 === _rowDragging$onDragSt || _rowDragging$onDragSt.call(rowDragging, e);
        },
        onDragEnter: (e) => {
          if (e.fromComponent !== e.toComponent) {
            togglePointerEventsStyle(true);
          }
        },
        onDragLeave: () => {
          togglePointerEventsStyle(false);
        },
        onDragEnd: (e) => {
          var _rowDragging$onDragEn;
          togglePointerEventsStyle(false);
          null === (_rowDragging$onDragEn = rowDragging.onDragEnd) || void 0 === _rowDragging$onDragEn || _rowDragging$onDragEn.call(rowDragging, e);
        },
        onAdd: (e) => {
          var _rowDragging$onAdd;
          togglePointerEventsStyle(false);
          null === (_rowDragging$onAdd = rowDragging.onAdd) || void 0 === _rowDragging$onAdd || _rowDragging$onAdd.call(rowDragging, e);
        },
        dropFeedbackMode: rowDragging.dropFeedbackMode,
        onOptionChanged: (e) => {
          const hasFixedSortable = this._sortableFixed;
          if (hasFixedSortable) {
            if ("fromIndex" === e.name || "toIndex" === e.name) {
              this[anotherSortableName].option(e.name, e.value);
            }
          }
        }
      }));
      $content.toggleClass("dx-scrollable-container", isFixedTableRendering);
      $content.toggleClass(CLASSES7.sortableWithoutHandle, allowReordering2 && !rowDragging.showDragIcons);
    }
    return $content;
  }
  _renderCore(e) {
    super._renderCore.apply(this, arguments);
    if (e && "update" === e.changeType && e.repaintChangesOnly && m_utils_default.isVirtualRowRendering(this)) {
      deferUpdate((() => {
        this._updateSortable();
      }));
    }
  }
  _updateSortable() {
    const offset = this._dataController.getRowIndexOffset();
    const offsetDiff = offset - this._previousOffset;
    [this._sortable, this._sortableFixed].forEach(((sortable) => {
      const toIndex = null === sortable || void 0 === sortable ? void 0 : sortable.option("toIndex");
      if (isDefined(toIndex) && isDefined(this._previousOffset)) {
        null === sortable || void 0 === sortable || sortable.option("toIndex", toIndex - offsetDiff);
      }
      null === sortable || void 0 === sortable || sortable.option("offset", offset);
      null === sortable || void 0 === sortable || sortable.update();
    }));
    this._previousOffset = offset;
  }
  _resizeCore() {
    super._resizeCore.apply(this, arguments);
    this._updateSortable();
  }
  _getDraggableGridOptions(options) {
    const gridOptions = this.option();
    const columns7 = this.getColumns();
    const $rowElement = renderer_default(this.getRowElement(options.rowIndex));
    return {
      dataSource: [{
        id: 1,
        parentId: 0
      }],
      showBorders: true,
      showColumnHeaders: false,
      scrolling: {
        useNative: false,
        showScrollbar: "never"
      },
      pager: {
        visible: false
      },
      loadingTimeout: null,
      columnFixing: gridOptions.columnFixing,
      columnAutoWidth: gridOptions.columnAutoWidth,
      showColumnLines: gridOptions.showColumnLines,
      columns: columns7.map(((column) => ({
        width: column.width || column.visibleWidth,
        fixed: column.fixed,
        fixedPosition: column.fixedPosition
      }))),
      isDragging: true,
      onRowPrepared: (e) => {
        const rowsView18 = e.component.getView("rowsView");
        renderer_default(e.rowElement).replaceWith($rowElement.eq(rowsView18._isFixedTableRendering ? 1 : 0).clone());
      }
    };
  }
  _synchronizeScrollLeftPosition(gridInstance) {
    const scrollable = null === gridInstance || void 0 === gridInstance ? void 0 : gridInstance.getScrollable();
    null === scrollable || void 0 === scrollable || scrollable.scrollTo({
      x: this._scrollLeft
    });
  }
  _getDraggableRowTemplate() {
    return (options) => {
      const $rootElement = this.component.$element();
      const $dataGridContainer = renderer_default("<div>");
      setWidth($dataGridContainer, getWidth($rootElement));
      const items = this._dataController.items();
      const row = items && items[options.fromIndex];
      const gridOptions = this._getDraggableGridOptions(row);
      this._createComponent($dataGridContainer, this.component.NAME, gridOptions);
      $dataGridContainer.find(".dx-gridbase-container").children(`:not(.${this.addWidgetPrefix(CLASSES7.rowsView)})`).hide();
      $dataGridContainer.addClass(this.addWidgetPrefix(CLASSES7.dragView));
      return $dataGridContainer;
    };
  }
  _getHandleTemplate() {
    return GridCoreRowDraggingDom.createHandleTemplateFunc(((string) => this.addWidgetPrefix(string)));
  }
};
var rowDraggingModule = {
  defaultOptions: () => ({
    rowDragging: {
      showDragIcons: true,
      dropFeedbackMode: "indicate",
      allowReordering: false,
      allowDropInsideItem: false
    }
  }),
  extenders: {
    views: {
      rowsView: rowsView17
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/row_dragging.js
m_core_default.registerModule("rowDragging", rowDraggingModule);

// node_modules/devextreme/esm/__internal/grids/data_grid/m_widget.js
var m_widget_default = m_widget_base_default;

// node_modules/devextreme/esm/ui/data_grid.js
var data_grid_default = m_widget_default;

// node_modules/devextreme-angular/fesm2022/devextreme-angular-ui-data-grid-nested.mjs
var _c0 = ["*"];
var DxoDataGridAnimationComponent = class _DxoDataGridAnimationComponent extends NestedOption {
  get hide() {
    return this._getOption("hide");
  }
  set hide(value2) {
    this._setOption("hide", value2);
  }
  get show() {
    return this._getOption("show");
  }
  set show(value2) {
    this._setOption("show", value2);
  }
  get _optionPath() {
    return "animation";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridAnimationComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridAnimationComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridAnimationComponent,
    selectors: [["dxo-data-grid-animation"]],
    inputs: {
      hide: "hide",
      show: "show"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridAnimationComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridAnimationComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-animation",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    hide: [{
      type: Input
    }],
    show: [{
      type: Input
    }]
  });
})();
var DxoDataGridAnimationModule = class _DxoDataGridAnimationModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridAnimationModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridAnimationModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridAnimationModule,
    imports: [DxoDataGridAnimationComponent],
    exports: [DxoDataGridAnimationComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridAnimationComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridAnimationModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridAnimationComponent],
      exports: [DxoDataGridAnimationComponent]
    }]
  }], null, null);
})();
var DxiDataGridAsyncRuleComponent = class _DxiDataGridAsyncRuleComponent extends CollectionNestedOption {
  get ignoreEmptyValue() {
    return this._getOption("ignoreEmptyValue");
  }
  set ignoreEmptyValue(value2) {
    this._setOption("ignoreEmptyValue", value2);
  }
  get message() {
    return this._getOption("message");
  }
  set message(value2) {
    this._setOption("message", value2);
  }
  get reevaluate() {
    return this._getOption("reevaluate");
  }
  set reevaluate(value2) {
    this._setOption("reevaluate", value2);
  }
  get type() {
    return this._getOption("type");
  }
  set type(value2) {
    this._setOption("type", value2);
  }
  get validationCallback() {
    return this._getOption("validationCallback");
  }
  set validationCallback(value2) {
    this._setOption("validationCallback", value2);
  }
  get _optionPath() {
    return "validationRules";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
    this.type = "async";
  }
  ngOnDestroy() {
    this._deleteRemovedOptions(this._fullOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxiDataGridAsyncRuleComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridAsyncRuleComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxiDataGridAsyncRuleComponent,
    selectors: [["dxi-data-grid-async-rule"]],
    inputs: {
      ignoreEmptyValue: "ignoreEmptyValue",
      message: "message",
      reevaluate: "reevaluate",
      type: "type",
      validationCallback: "validationCallback"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost, {
      provide: PROPERTY_TOKEN_validationRules,
      useExisting: _DxiDataGridAsyncRuleComponent
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxiDataGridAsyncRuleComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridAsyncRuleComponent, [{
    type: Component,
    args: [{
      selector: "dxi-data-grid-async-rule",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost, {
        provide: PROPERTY_TOKEN_validationRules,
        useExisting: DxiDataGridAsyncRuleComponent
      }]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    ignoreEmptyValue: [{
      type: Input
    }],
    message: [{
      type: Input
    }],
    reevaluate: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    validationCallback: [{
      type: Input
    }]
  });
})();
var DxiDataGridAsyncRuleModule = class _DxiDataGridAsyncRuleModule {
  /** @nocollapse */
  static ɵfac = function DxiDataGridAsyncRuleModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridAsyncRuleModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxiDataGridAsyncRuleModule,
    imports: [DxiDataGridAsyncRuleComponent],
    exports: [DxiDataGridAsyncRuleComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxiDataGridAsyncRuleComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridAsyncRuleModule, [{
    type: NgModule,
    args: [{
      imports: [DxiDataGridAsyncRuleComponent],
      exports: [DxiDataGridAsyncRuleComponent]
    }]
  }], null, null);
})();
var DxoDataGridAtComponent = class _DxoDataGridAtComponent extends NestedOption {
  get x() {
    return this._getOption("x");
  }
  set x(value2) {
    this._setOption("x", value2);
  }
  get y() {
    return this._getOption("y");
  }
  set y(value2) {
    this._setOption("y", value2);
  }
  get _optionPath() {
    return "at";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridAtComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridAtComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridAtComponent,
    selectors: [["dxo-data-grid-at"]],
    inputs: {
      x: "x",
      y: "y"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridAtComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridAtComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-at",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    x: [{
      type: Input
    }],
    y: [{
      type: Input
    }]
  });
})();
var DxoDataGridAtModule = class _DxoDataGridAtModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridAtModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridAtModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridAtModule,
    imports: [DxoDataGridAtComponent],
    exports: [DxoDataGridAtComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridAtComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridAtModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridAtComponent],
      exports: [DxoDataGridAtComponent]
    }]
  }], null, null);
})();
var DxoDataGridBoundaryOffsetComponent = class _DxoDataGridBoundaryOffsetComponent extends NestedOption {
  get x() {
    return this._getOption("x");
  }
  set x(value2) {
    this._setOption("x", value2);
  }
  get y() {
    return this._getOption("y");
  }
  set y(value2) {
    this._setOption("y", value2);
  }
  get _optionPath() {
    return "boundaryOffset";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridBoundaryOffsetComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridBoundaryOffsetComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridBoundaryOffsetComponent,
    selectors: [["dxo-data-grid-boundary-offset"]],
    inputs: {
      x: "x",
      y: "y"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridBoundaryOffsetComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridBoundaryOffsetComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-boundary-offset",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    x: [{
      type: Input
    }],
    y: [{
      type: Input
    }]
  });
})();
var DxoDataGridBoundaryOffsetModule = class _DxoDataGridBoundaryOffsetModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridBoundaryOffsetModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridBoundaryOffsetModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridBoundaryOffsetModule,
    imports: [DxoDataGridBoundaryOffsetComponent],
    exports: [DxoDataGridBoundaryOffsetComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridBoundaryOffsetComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridBoundaryOffsetModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridBoundaryOffsetComponent],
      exports: [DxoDataGridBoundaryOffsetComponent]
    }]
  }], null, null);
})();
var DxiDataGridButtonComponent = class _DxiDataGridButtonComponent extends CollectionNestedOption {
  renderer;
  document;
  element;
  get cssClass() {
    return this._getOption("cssClass");
  }
  set cssClass(value2) {
    this._setOption("cssClass", value2);
  }
  get disabled() {
    return this._getOption("disabled");
  }
  set disabled(value2) {
    this._setOption("disabled", value2);
  }
  get hint() {
    return this._getOption("hint");
  }
  set hint(value2) {
    this._setOption("hint", value2);
  }
  get icon() {
    return this._getOption("icon");
  }
  set icon(value2) {
    this._setOption("icon", value2);
  }
  get name() {
    return this._getOption("name");
  }
  set name(value2) {
    this._setOption("name", value2);
  }
  get onClick() {
    return this._getOption("onClick");
  }
  set onClick(value2) {
    this._setOption("onClick", value2);
  }
  get template() {
    return this._getOption("template");
  }
  set template(value2) {
    this._setOption("template", value2);
  }
  get text() {
    return this._getOption("text");
  }
  set text(value2) {
    this._setOption("text", value2);
  }
  get visible() {
    return this._getOption("visible");
  }
  set visible(value2) {
    this._setOption("visible", value2);
  }
  get _optionPath() {
    return "buttons";
  }
  constructor(parentOptionHost, optionHost, renderer, document, templateHost, element) {
    super();
    this.renderer = renderer;
    this.document = document;
    this.element = element;
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
    templateHost.setHost(this);
  }
  setTemplate(template) {
    this.template = template;
  }
  ngAfterViewInit() {
    extractTemplate(this, this.element, this.renderer, this.document);
  }
  ngOnDestroy() {
    this._deleteRemovedOptions(this._fullOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxiDataGridButtonComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridButtonComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(DOCUMENT), ɵɵdirectiveInject(DxTemplateHost, 1), ɵɵdirectiveInject(ElementRef));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxiDataGridButtonComponent,
    selectors: [["dxi-data-grid-button"]],
    inputs: {
      cssClass: "cssClass",
      disabled: "disabled",
      hint: "hint",
      icon: "icon",
      name: "name",
      onClick: "onClick",
      template: "template",
      text: "text",
      visible: "visible"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost, DxTemplateHost, {
      provide: PROPERTY_TOKEN_buttons,
      useExisting: _DxiDataGridButtonComponent
    }]), ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function DxiDataGridButtonComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    dependencies: [DxIntegrationModule],
    styles: ["[_nghost-%COMP%]{display:block}"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridButtonComponent, [{
    type: Component,
    args: [{
      selector: "dxi-data-grid-button",
      standalone: true,
      template: "<ng-content></ng-content>",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost, DxTemplateHost, {
        provide: PROPERTY_TOKEN_buttons,
        useExisting: DxiDataGridButtonComponent
      }],
      styles: [":host{display:block}\n"]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }, {
    type: Renderer2
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: DxTemplateHost,
    decorators: [{
      type: Host
    }]
  }, {
    type: ElementRef
  }], {
    cssClass: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    hint: [{
      type: Input
    }],
    icon: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    onClick: [{
      type: Input
    }],
    template: [{
      type: Input
    }],
    text: [{
      type: Input
    }],
    visible: [{
      type: Input
    }]
  });
})();
var DxiDataGridButtonModule = class _DxiDataGridButtonModule {
  /** @nocollapse */
  static ɵfac = function DxiDataGridButtonModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridButtonModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxiDataGridButtonModule,
    imports: [DxiDataGridButtonComponent],
    exports: [DxiDataGridButtonComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxiDataGridButtonComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridButtonModule, [{
    type: NgModule,
    args: [{
      imports: [DxiDataGridButtonComponent],
      exports: [DxiDataGridButtonComponent]
    }]
  }], null, null);
})();
var DxiDataGridChangeComponent = class _DxiDataGridChangeComponent extends CollectionNestedOption {
  get data() {
    return this._getOption("data");
  }
  set data(value2) {
    this._setOption("data", value2);
  }
  get insertAfterKey() {
    return this._getOption("insertAfterKey");
  }
  set insertAfterKey(value2) {
    this._setOption("insertAfterKey", value2);
  }
  get insertBeforeKey() {
    return this._getOption("insertBeforeKey");
  }
  set insertBeforeKey(value2) {
    this._setOption("insertBeforeKey", value2);
  }
  get key() {
    return this._getOption("key");
  }
  set key(value2) {
    this._setOption("key", value2);
  }
  get type() {
    return this._getOption("type");
  }
  set type(value2) {
    this._setOption("type", value2);
  }
  get _optionPath() {
    return "changes";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnDestroy() {
    this._deleteRemovedOptions(this._fullOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxiDataGridChangeComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridChangeComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxiDataGridChangeComponent,
    selectors: [["dxi-data-grid-change"]],
    inputs: {
      data: "data",
      insertAfterKey: "insertAfterKey",
      insertBeforeKey: "insertBeforeKey",
      key: "key",
      type: "type"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost, {
      provide: PROPERTY_TOKEN_changes,
      useExisting: _DxiDataGridChangeComponent
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxiDataGridChangeComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridChangeComponent, [{
    type: Component,
    args: [{
      selector: "dxi-data-grid-change",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost, {
        provide: PROPERTY_TOKEN_changes,
        useExisting: DxiDataGridChangeComponent
      }]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    data: [{
      type: Input
    }],
    insertAfterKey: [{
      type: Input
    }],
    insertBeforeKey: [{
      type: Input
    }],
    key: [{
      type: Input
    }],
    type: [{
      type: Input
    }]
  });
})();
var DxiDataGridChangeModule = class _DxiDataGridChangeModule {
  /** @nocollapse */
  static ɵfac = function DxiDataGridChangeModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridChangeModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxiDataGridChangeModule,
    imports: [DxiDataGridChangeComponent],
    exports: [DxiDataGridChangeComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxiDataGridChangeComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridChangeModule, [{
    type: NgModule,
    args: [{
      imports: [DxiDataGridChangeComponent],
      exports: [DxiDataGridChangeComponent]
    }]
  }], null, null);
})();
var DxoDataGridColCountByScreenComponent = class _DxoDataGridColCountByScreenComponent extends NestedOption {
  get lg() {
    return this._getOption("lg");
  }
  set lg(value2) {
    this._setOption("lg", value2);
  }
  get md() {
    return this._getOption("md");
  }
  set md(value2) {
    this._setOption("md", value2);
  }
  get sm() {
    return this._getOption("sm");
  }
  set sm(value2) {
    this._setOption("sm", value2);
  }
  get xs() {
    return this._getOption("xs");
  }
  set xs(value2) {
    this._setOption("xs", value2);
  }
  get _optionPath() {
    return "colCountByScreen";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridColCountByScreenComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridColCountByScreenComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridColCountByScreenComponent,
    selectors: [["dxo-data-grid-col-count-by-screen"]],
    inputs: {
      lg: "lg",
      md: "md",
      sm: "sm",
      xs: "xs"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridColCountByScreenComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridColCountByScreenComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-col-count-by-screen",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    lg: [{
      type: Input
    }],
    md: [{
      type: Input
    }],
    sm: [{
      type: Input
    }],
    xs: [{
      type: Input
    }]
  });
})();
var DxoDataGridColCountByScreenModule = class _DxoDataGridColCountByScreenModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridColCountByScreenModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridColCountByScreenModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridColCountByScreenModule,
    imports: [DxoDataGridColCountByScreenComponent],
    exports: [DxoDataGridColCountByScreenComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridColCountByScreenComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridColCountByScreenModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridColCountByScreenComponent],
      exports: [DxoDataGridColCountByScreenComponent]
    }]
  }], null, null);
})();
var DxoDataGridCollisionComponent = class _DxoDataGridCollisionComponent extends NestedOption {
  get x() {
    return this._getOption("x");
  }
  set x(value2) {
    this._setOption("x", value2);
  }
  get y() {
    return this._getOption("y");
  }
  set y(value2) {
    this._setOption("y", value2);
  }
  get _optionPath() {
    return "collision";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridCollisionComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridCollisionComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridCollisionComponent,
    selectors: [["dxo-data-grid-collision"]],
    inputs: {
      x: "x",
      y: "y"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridCollisionComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridCollisionComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-collision",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    x: [{
      type: Input
    }],
    y: [{
      type: Input
    }]
  });
})();
var DxoDataGridCollisionModule = class _DxoDataGridCollisionModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridCollisionModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridCollisionModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridCollisionModule,
    imports: [DxoDataGridCollisionComponent],
    exports: [DxoDataGridCollisionComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridCollisionComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridCollisionModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridCollisionComponent],
      exports: [DxoDataGridCollisionComponent]
    }]
  }], null, null);
})();
var DxoDataGridColumnChooserSearchComponent = class _DxoDataGridColumnChooserSearchComponent extends NestedOption {
  get editorOptions() {
    return this._getOption("editorOptions");
  }
  set editorOptions(value2) {
    this._setOption("editorOptions", value2);
  }
  get enabled() {
    return this._getOption("enabled");
  }
  set enabled(value2) {
    this._setOption("enabled", value2);
  }
  get timeout() {
    return this._getOption("timeout");
  }
  set timeout(value2) {
    this._setOption("timeout", value2);
  }
  get _optionPath() {
    return "search";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridColumnChooserSearchComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridColumnChooserSearchComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridColumnChooserSearchComponent,
    selectors: [["dxo-data-grid-column-chooser-search"]],
    inputs: {
      editorOptions: "editorOptions",
      enabled: "enabled",
      timeout: "timeout"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridColumnChooserSearchComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridColumnChooserSearchComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-column-chooser-search",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    editorOptions: [{
      type: Input
    }],
    enabled: [{
      type: Input
    }],
    timeout: [{
      type: Input
    }]
  });
})();
var DxoDataGridColumnChooserSearchModule = class _DxoDataGridColumnChooserSearchModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridColumnChooserSearchModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridColumnChooserSearchModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridColumnChooserSearchModule,
    imports: [DxoDataGridColumnChooserSearchComponent],
    exports: [DxoDataGridColumnChooserSearchComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridColumnChooserSearchComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridColumnChooserSearchModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridColumnChooserSearchComponent],
      exports: [DxoDataGridColumnChooserSearchComponent]
    }]
  }], null, null);
})();
var DxoDataGridColumnChooserSelectionComponent = class _DxoDataGridColumnChooserSelectionComponent extends NestedOption {
  get allowSelectAll() {
    return this._getOption("allowSelectAll");
  }
  set allowSelectAll(value2) {
    this._setOption("allowSelectAll", value2);
  }
  get recursive() {
    return this._getOption("recursive");
  }
  set recursive(value2) {
    this._setOption("recursive", value2);
  }
  get selectByClick() {
    return this._getOption("selectByClick");
  }
  set selectByClick(value2) {
    this._setOption("selectByClick", value2);
  }
  get _optionPath() {
    return "selection";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridColumnChooserSelectionComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridColumnChooserSelectionComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridColumnChooserSelectionComponent,
    selectors: [["dxo-data-grid-column-chooser-selection"]],
    inputs: {
      allowSelectAll: "allowSelectAll",
      recursive: "recursive",
      selectByClick: "selectByClick"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridColumnChooserSelectionComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridColumnChooserSelectionComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-column-chooser-selection",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    allowSelectAll: [{
      type: Input
    }],
    recursive: [{
      type: Input
    }],
    selectByClick: [{
      type: Input
    }]
  });
})();
var DxoDataGridColumnChooserSelectionModule = class _DxoDataGridColumnChooserSelectionModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridColumnChooserSelectionModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridColumnChooserSelectionModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridColumnChooserSelectionModule,
    imports: [DxoDataGridColumnChooserSelectionComponent],
    exports: [DxoDataGridColumnChooserSelectionComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridColumnChooserSelectionComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridColumnChooserSelectionModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridColumnChooserSelectionComponent],
      exports: [DxoDataGridColumnChooserSelectionComponent]
    }]
  }], null, null);
})();
var DxoDataGridColumnChooserComponent = class _DxoDataGridColumnChooserComponent extends NestedOption {
  get allowSearch() {
    return this._getOption("allowSearch");
  }
  set allowSearch(value2) {
    this._setOption("allowSearch", value2);
  }
  get container() {
    return this._getOption("container");
  }
  set container(value2) {
    this._setOption("container", value2);
  }
  get emptyPanelText() {
    return this._getOption("emptyPanelText");
  }
  set emptyPanelText(value2) {
    this._setOption("emptyPanelText", value2);
  }
  get enabled() {
    return this._getOption("enabled");
  }
  set enabled(value2) {
    this._setOption("enabled", value2);
  }
  get height() {
    return this._getOption("height");
  }
  set height(value2) {
    this._setOption("height", value2);
  }
  get mode() {
    return this._getOption("mode");
  }
  set mode(value2) {
    this._setOption("mode", value2);
  }
  get position() {
    return this._getOption("position");
  }
  set position(value2) {
    this._setOption("position", value2);
  }
  get search() {
    return this._getOption("search");
  }
  set search(value2) {
    this._setOption("search", value2);
  }
  get searchTimeout() {
    return this._getOption("searchTimeout");
  }
  set searchTimeout(value2) {
    this._setOption("searchTimeout", value2);
  }
  get selection() {
    return this._getOption("selection");
  }
  set selection(value2) {
    this._setOption("selection", value2);
  }
  get sortOrder() {
    return this._getOption("sortOrder");
  }
  set sortOrder(value2) {
    this._setOption("sortOrder", value2);
  }
  get title() {
    return this._getOption("title");
  }
  set title(value2) {
    this._setOption("title", value2);
  }
  get width() {
    return this._getOption("width");
  }
  set width(value2) {
    this._setOption("width", value2);
  }
  get _optionPath() {
    return "columnChooser";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridColumnChooserComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridColumnChooserComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridColumnChooserComponent,
    selectors: [["dxo-data-grid-column-chooser"]],
    inputs: {
      allowSearch: "allowSearch",
      container: "container",
      emptyPanelText: "emptyPanelText",
      enabled: "enabled",
      height: "height",
      mode: "mode",
      position: "position",
      search: "search",
      searchTimeout: "searchTimeout",
      selection: "selection",
      sortOrder: "sortOrder",
      title: "title",
      width: "width"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridColumnChooserComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridColumnChooserComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-column-chooser",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    allowSearch: [{
      type: Input
    }],
    container: [{
      type: Input
    }],
    emptyPanelText: [{
      type: Input
    }],
    enabled: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    mode: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    search: [{
      type: Input
    }],
    searchTimeout: [{
      type: Input
    }],
    selection: [{
      type: Input
    }],
    sortOrder: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    width: [{
      type: Input
    }]
  });
})();
var DxoDataGridColumnChooserModule = class _DxoDataGridColumnChooserModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridColumnChooserModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridColumnChooserModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridColumnChooserModule,
    imports: [DxoDataGridColumnChooserComponent],
    exports: [DxoDataGridColumnChooserComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridColumnChooserComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridColumnChooserModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridColumnChooserComponent],
      exports: [DxoDataGridColumnChooserComponent]
    }]
  }], null, null);
})();
var DxiDataGridColumnComponent = class _DxiDataGridColumnComponent extends CollectionNestedOption {
  set _validationRulesContentChildren(value2) {
    this.setChildren("validationRules", value2);
  }
  set _buttonsContentChildren(value2) {
    this.setChildren("buttons", value2);
  }
  set _columnsContentChildren(value2) {
    this.setChildren("columns", value2);
  }
  get alignment() {
    return this._getOption("alignment");
  }
  set alignment(value2) {
    this._setOption("alignment", value2);
  }
  get allowEditing() {
    return this._getOption("allowEditing");
  }
  set allowEditing(value2) {
    this._setOption("allowEditing", value2);
  }
  get allowExporting() {
    return this._getOption("allowExporting");
  }
  set allowExporting(value2) {
    this._setOption("allowExporting", value2);
  }
  get allowFiltering() {
    return this._getOption("allowFiltering");
  }
  set allowFiltering(value2) {
    this._setOption("allowFiltering", value2);
  }
  get allowFixing() {
    return this._getOption("allowFixing");
  }
  set allowFixing(value2) {
    this._setOption("allowFixing", value2);
  }
  get allowGrouping() {
    return this._getOption("allowGrouping");
  }
  set allowGrouping(value2) {
    this._setOption("allowGrouping", value2);
  }
  get allowHeaderFiltering() {
    return this._getOption("allowHeaderFiltering");
  }
  set allowHeaderFiltering(value2) {
    this._setOption("allowHeaderFiltering", value2);
  }
  get allowHiding() {
    return this._getOption("allowHiding");
  }
  set allowHiding(value2) {
    this._setOption("allowHiding", value2);
  }
  get allowReordering() {
    return this._getOption("allowReordering");
  }
  set allowReordering(value2) {
    this._setOption("allowReordering", value2);
  }
  get allowResizing() {
    return this._getOption("allowResizing");
  }
  set allowResizing(value2) {
    this._setOption("allowResizing", value2);
  }
  get allowSearch() {
    return this._getOption("allowSearch");
  }
  set allowSearch(value2) {
    this._setOption("allowSearch", value2);
  }
  get allowSorting() {
    return this._getOption("allowSorting");
  }
  set allowSorting(value2) {
    this._setOption("allowSorting", value2);
  }
  get autoExpandGroup() {
    return this._getOption("autoExpandGroup");
  }
  set autoExpandGroup(value2) {
    this._setOption("autoExpandGroup", value2);
  }
  get buttons() {
    return this._getOption("buttons");
  }
  set buttons(value2) {
    this._setOption("buttons", value2);
  }
  get calculateCellValue() {
    return this._getOption("calculateCellValue");
  }
  set calculateCellValue(value2) {
    this._setOption("calculateCellValue", value2);
  }
  get calculateDisplayValue() {
    return this._getOption("calculateDisplayValue");
  }
  set calculateDisplayValue(value2) {
    this._setOption("calculateDisplayValue", value2);
  }
  get calculateFilterExpression() {
    return this._getOption("calculateFilterExpression");
  }
  set calculateFilterExpression(value2) {
    this._setOption("calculateFilterExpression", value2);
  }
  get calculateGroupValue() {
    return this._getOption("calculateGroupValue");
  }
  set calculateGroupValue(value2) {
    this._setOption("calculateGroupValue", value2);
  }
  get calculateSortValue() {
    return this._getOption("calculateSortValue");
  }
  set calculateSortValue(value2) {
    this._setOption("calculateSortValue", value2);
  }
  get caption() {
    return this._getOption("caption");
  }
  set caption(value2) {
    this._setOption("caption", value2);
  }
  get cellTemplate() {
    return this._getOption("cellTemplate");
  }
  set cellTemplate(value2) {
    this._setOption("cellTemplate", value2);
  }
  get columns() {
    return this._getOption("columns");
  }
  set columns(value2) {
    this._setOption("columns", value2);
  }
  get cssClass() {
    return this._getOption("cssClass");
  }
  set cssClass(value2) {
    this._setOption("cssClass", value2);
  }
  get customizeText() {
    return this._getOption("customizeText");
  }
  set customizeText(value2) {
    this._setOption("customizeText", value2);
  }
  get dataField() {
    return this._getOption("dataField");
  }
  set dataField(value2) {
    this._setOption("dataField", value2);
  }
  get dataType() {
    return this._getOption("dataType");
  }
  set dataType(value2) {
    this._setOption("dataType", value2);
  }
  get editCellTemplate() {
    return this._getOption("editCellTemplate");
  }
  set editCellTemplate(value2) {
    this._setOption("editCellTemplate", value2);
  }
  get editorOptions() {
    return this._getOption("editorOptions");
  }
  set editorOptions(value2) {
    this._setOption("editorOptions", value2);
  }
  get encodeHtml() {
    return this._getOption("encodeHtml");
  }
  set encodeHtml(value2) {
    this._setOption("encodeHtml", value2);
  }
  get falseText() {
    return this._getOption("falseText");
  }
  set falseText(value2) {
    this._setOption("falseText", value2);
  }
  get filterOperations() {
    return this._getOption("filterOperations");
  }
  set filterOperations(value2) {
    this._setOption("filterOperations", value2);
  }
  get filterType() {
    return this._getOption("filterType");
  }
  set filterType(value2) {
    this._setOption("filterType", value2);
  }
  get filterValue() {
    return this._getOption("filterValue");
  }
  set filterValue(value2) {
    this._setOption("filterValue", value2);
  }
  get filterValues() {
    return this._getOption("filterValues");
  }
  set filterValues(value2) {
    this._setOption("filterValues", value2);
  }
  get fixed() {
    return this._getOption("fixed");
  }
  set fixed(value2) {
    this._setOption("fixed", value2);
  }
  get fixedPosition() {
    return this._getOption("fixedPosition");
  }
  set fixedPosition(value2) {
    this._setOption("fixedPosition", value2);
  }
  get format() {
    return this._getOption("format");
  }
  set format(value2) {
    this._setOption("format", value2);
  }
  get formItem() {
    return this._getOption("formItem");
  }
  set formItem(value2) {
    this._setOption("formItem", value2);
  }
  get groupCellTemplate() {
    return this._getOption("groupCellTemplate");
  }
  set groupCellTemplate(value2) {
    this._setOption("groupCellTemplate", value2);
  }
  get groupIndex() {
    return this._getOption("groupIndex");
  }
  set groupIndex(value2) {
    this._setOption("groupIndex", value2);
  }
  get headerCellTemplate() {
    return this._getOption("headerCellTemplate");
  }
  set headerCellTemplate(value2) {
    this._setOption("headerCellTemplate", value2);
  }
  get headerFilter() {
    return this._getOption("headerFilter");
  }
  set headerFilter(value2) {
    this._setOption("headerFilter", value2);
  }
  get hidingPriority() {
    return this._getOption("hidingPriority");
  }
  set hidingPriority(value2) {
    this._setOption("hidingPriority", value2);
  }
  get isBand() {
    return this._getOption("isBand");
  }
  set isBand(value2) {
    this._setOption("isBand", value2);
  }
  get lookup() {
    return this._getOption("lookup");
  }
  set lookup(value2) {
    this._setOption("lookup", value2);
  }
  get minWidth() {
    return this._getOption("minWidth");
  }
  set minWidth(value2) {
    this._setOption("minWidth", value2);
  }
  get name() {
    return this._getOption("name");
  }
  set name(value2) {
    this._setOption("name", value2);
  }
  get ownerBand() {
    return this._getOption("ownerBand");
  }
  set ownerBand(value2) {
    this._setOption("ownerBand", value2);
  }
  get renderAsync() {
    return this._getOption("renderAsync");
  }
  set renderAsync(value2) {
    this._setOption("renderAsync", value2);
  }
  get selectedFilterOperation() {
    return this._getOption("selectedFilterOperation");
  }
  set selectedFilterOperation(value2) {
    this._setOption("selectedFilterOperation", value2);
  }
  get setCellValue() {
    return this._getOption("setCellValue");
  }
  set setCellValue(value2) {
    this._setOption("setCellValue", value2);
  }
  get showEditorAlways() {
    return this._getOption("showEditorAlways");
  }
  set showEditorAlways(value2) {
    this._setOption("showEditorAlways", value2);
  }
  get showInColumnChooser() {
    return this._getOption("showInColumnChooser");
  }
  set showInColumnChooser(value2) {
    this._setOption("showInColumnChooser", value2);
  }
  get showWhenGrouped() {
    return this._getOption("showWhenGrouped");
  }
  set showWhenGrouped(value2) {
    this._setOption("showWhenGrouped", value2);
  }
  get sortIndex() {
    return this._getOption("sortIndex");
  }
  set sortIndex(value2) {
    this._setOption("sortIndex", value2);
  }
  get sortingMethod() {
    return this._getOption("sortingMethod");
  }
  set sortingMethod(value2) {
    this._setOption("sortingMethod", value2);
  }
  get sortOrder() {
    return this._getOption("sortOrder");
  }
  set sortOrder(value2) {
    this._setOption("sortOrder", value2);
  }
  get trueText() {
    return this._getOption("trueText");
  }
  set trueText(value2) {
    this._setOption("trueText", value2);
  }
  get type() {
    return this._getOption("type");
  }
  set type(value2) {
    this._setOption("type", value2);
  }
  get validationRules() {
    return this._getOption("validationRules");
  }
  set validationRules(value2) {
    this._setOption("validationRules", value2);
  }
  get visible() {
    return this._getOption("visible");
  }
  set visible(value2) {
    this._setOption("visible", value2);
  }
  get visibleIndex() {
    return this._getOption("visibleIndex");
  }
  set visibleIndex(value2) {
    this._setOption("visibleIndex", value2);
  }
  get width() {
    return this._getOption("width");
  }
  set width(value2) {
    this._setOption("width", value2);
  }
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  filterValueChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  filterValuesChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  groupIndexChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  selectedFilterOperationChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  sortIndexChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  sortOrderChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  visibleChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  visibleIndexChange;
  get _optionPath() {
    return "columns";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    this._createEventEmitters([{
      emit: "filterValueChange"
    }, {
      emit: "filterValuesChange"
    }, {
      emit: "groupIndexChange"
    }, {
      emit: "selectedFilterOperationChange"
    }, {
      emit: "sortIndexChange"
    }, {
      emit: "sortOrderChange"
    }, {
      emit: "visibleChange"
    }, {
      emit: "visibleIndexChange"
    }]);
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnDestroy() {
    this._deleteRemovedOptions(this._fullOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxiDataGridColumnComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridColumnComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxiDataGridColumnComponent,
    selectors: [["dxi-data-grid-column"]],
    contentQueries: function DxiDataGridColumnComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, PROPERTY_TOKEN_validationRules, 4);
        ɵɵcontentQuery(dirIndex, PROPERTY_TOKEN_buttons, 4);
        ɵɵcontentQuery(dirIndex, PROPERTY_TOKEN_columns, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._validationRulesContentChildren = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._buttonsContentChildren = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._columnsContentChildren = _t);
      }
    },
    inputs: {
      alignment: "alignment",
      allowEditing: "allowEditing",
      allowExporting: "allowExporting",
      allowFiltering: "allowFiltering",
      allowFixing: "allowFixing",
      allowGrouping: "allowGrouping",
      allowHeaderFiltering: "allowHeaderFiltering",
      allowHiding: "allowHiding",
      allowReordering: "allowReordering",
      allowResizing: "allowResizing",
      allowSearch: "allowSearch",
      allowSorting: "allowSorting",
      autoExpandGroup: "autoExpandGroup",
      buttons: "buttons",
      calculateCellValue: "calculateCellValue",
      calculateDisplayValue: "calculateDisplayValue",
      calculateFilterExpression: "calculateFilterExpression",
      calculateGroupValue: "calculateGroupValue",
      calculateSortValue: "calculateSortValue",
      caption: "caption",
      cellTemplate: "cellTemplate",
      columns: "columns",
      cssClass: "cssClass",
      customizeText: "customizeText",
      dataField: "dataField",
      dataType: "dataType",
      editCellTemplate: "editCellTemplate",
      editorOptions: "editorOptions",
      encodeHtml: "encodeHtml",
      falseText: "falseText",
      filterOperations: "filterOperations",
      filterType: "filterType",
      filterValue: "filterValue",
      filterValues: "filterValues",
      fixed: "fixed",
      fixedPosition: "fixedPosition",
      format: "format",
      formItem: "formItem",
      groupCellTemplate: "groupCellTemplate",
      groupIndex: "groupIndex",
      headerCellTemplate: "headerCellTemplate",
      headerFilter: "headerFilter",
      hidingPriority: "hidingPriority",
      isBand: "isBand",
      lookup: "lookup",
      minWidth: "minWidth",
      name: "name",
      ownerBand: "ownerBand",
      renderAsync: "renderAsync",
      selectedFilterOperation: "selectedFilterOperation",
      setCellValue: "setCellValue",
      showEditorAlways: "showEditorAlways",
      showInColumnChooser: "showInColumnChooser",
      showWhenGrouped: "showWhenGrouped",
      sortIndex: "sortIndex",
      sortingMethod: "sortingMethod",
      sortOrder: "sortOrder",
      trueText: "trueText",
      type: "type",
      validationRules: "validationRules",
      visible: "visible",
      visibleIndex: "visibleIndex",
      width: "width"
    },
    outputs: {
      filterValueChange: "filterValueChange",
      filterValuesChange: "filterValuesChange",
      groupIndexChange: "groupIndexChange",
      selectedFilterOperationChange: "selectedFilterOperationChange",
      sortIndexChange: "sortIndexChange",
      sortOrderChange: "sortOrderChange",
      visibleChange: "visibleChange",
      visibleIndexChange: "visibleIndexChange"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost, {
      provide: PROPERTY_TOKEN_columns,
      useExisting: _DxiDataGridColumnComponent
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxiDataGridColumnComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridColumnComponent, [{
    type: Component,
    args: [{
      selector: "dxi-data-grid-column",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost, {
        provide: PROPERTY_TOKEN_columns,
        useExisting: DxiDataGridColumnComponent
      }]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    _validationRulesContentChildren: [{
      type: ContentChildren,
      args: [PROPERTY_TOKEN_validationRules]
    }],
    _buttonsContentChildren: [{
      type: ContentChildren,
      args: [PROPERTY_TOKEN_buttons]
    }],
    _columnsContentChildren: [{
      type: ContentChildren,
      args: [PROPERTY_TOKEN_columns]
    }],
    alignment: [{
      type: Input
    }],
    allowEditing: [{
      type: Input
    }],
    allowExporting: [{
      type: Input
    }],
    allowFiltering: [{
      type: Input
    }],
    allowFixing: [{
      type: Input
    }],
    allowGrouping: [{
      type: Input
    }],
    allowHeaderFiltering: [{
      type: Input
    }],
    allowHiding: [{
      type: Input
    }],
    allowReordering: [{
      type: Input
    }],
    allowResizing: [{
      type: Input
    }],
    allowSearch: [{
      type: Input
    }],
    allowSorting: [{
      type: Input
    }],
    autoExpandGroup: [{
      type: Input
    }],
    buttons: [{
      type: Input
    }],
    calculateCellValue: [{
      type: Input
    }],
    calculateDisplayValue: [{
      type: Input
    }],
    calculateFilterExpression: [{
      type: Input
    }],
    calculateGroupValue: [{
      type: Input
    }],
    calculateSortValue: [{
      type: Input
    }],
    caption: [{
      type: Input
    }],
    cellTemplate: [{
      type: Input
    }],
    columns: [{
      type: Input
    }],
    cssClass: [{
      type: Input
    }],
    customizeText: [{
      type: Input
    }],
    dataField: [{
      type: Input
    }],
    dataType: [{
      type: Input
    }],
    editCellTemplate: [{
      type: Input
    }],
    editorOptions: [{
      type: Input
    }],
    encodeHtml: [{
      type: Input
    }],
    falseText: [{
      type: Input
    }],
    filterOperations: [{
      type: Input
    }],
    filterType: [{
      type: Input
    }],
    filterValue: [{
      type: Input
    }],
    filterValues: [{
      type: Input
    }],
    fixed: [{
      type: Input
    }],
    fixedPosition: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    formItem: [{
      type: Input
    }],
    groupCellTemplate: [{
      type: Input
    }],
    groupIndex: [{
      type: Input
    }],
    headerCellTemplate: [{
      type: Input
    }],
    headerFilter: [{
      type: Input
    }],
    hidingPriority: [{
      type: Input
    }],
    isBand: [{
      type: Input
    }],
    lookup: [{
      type: Input
    }],
    minWidth: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    ownerBand: [{
      type: Input
    }],
    renderAsync: [{
      type: Input
    }],
    selectedFilterOperation: [{
      type: Input
    }],
    setCellValue: [{
      type: Input
    }],
    showEditorAlways: [{
      type: Input
    }],
    showInColumnChooser: [{
      type: Input
    }],
    showWhenGrouped: [{
      type: Input
    }],
    sortIndex: [{
      type: Input
    }],
    sortingMethod: [{
      type: Input
    }],
    sortOrder: [{
      type: Input
    }],
    trueText: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    validationRules: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    visibleIndex: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    filterValueChange: [{
      type: Output
    }],
    filterValuesChange: [{
      type: Output
    }],
    groupIndexChange: [{
      type: Output
    }],
    selectedFilterOperationChange: [{
      type: Output
    }],
    sortIndexChange: [{
      type: Output
    }],
    sortOrderChange: [{
      type: Output
    }],
    visibleChange: [{
      type: Output
    }],
    visibleIndexChange: [{
      type: Output
    }]
  });
})();
var DxiDataGridColumnModule = class _DxiDataGridColumnModule {
  /** @nocollapse */
  static ɵfac = function DxiDataGridColumnModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridColumnModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxiDataGridColumnModule,
    imports: [DxiDataGridColumnComponent],
    exports: [DxiDataGridColumnComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxiDataGridColumnComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridColumnModule, [{
    type: NgModule,
    args: [{
      imports: [DxiDataGridColumnComponent],
      exports: [DxiDataGridColumnComponent]
    }]
  }], null, null);
})();
var DxoDataGridColumnFixingTextsComponent = class _DxoDataGridColumnFixingTextsComponent extends NestedOption {
  get fix() {
    return this._getOption("fix");
  }
  set fix(value2) {
    this._setOption("fix", value2);
  }
  get leftPosition() {
    return this._getOption("leftPosition");
  }
  set leftPosition(value2) {
    this._setOption("leftPosition", value2);
  }
  get rightPosition() {
    return this._getOption("rightPosition");
  }
  set rightPosition(value2) {
    this._setOption("rightPosition", value2);
  }
  get stickyPosition() {
    return this._getOption("stickyPosition");
  }
  set stickyPosition(value2) {
    this._setOption("stickyPosition", value2);
  }
  get unfix() {
    return this._getOption("unfix");
  }
  set unfix(value2) {
    this._setOption("unfix", value2);
  }
  get _optionPath() {
    return "texts";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridColumnFixingTextsComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridColumnFixingTextsComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridColumnFixingTextsComponent,
    selectors: [["dxo-data-grid-column-fixing-texts"]],
    inputs: {
      fix: "fix",
      leftPosition: "leftPosition",
      rightPosition: "rightPosition",
      stickyPosition: "stickyPosition",
      unfix: "unfix"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridColumnFixingTextsComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridColumnFixingTextsComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-column-fixing-texts",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    fix: [{
      type: Input
    }],
    leftPosition: [{
      type: Input
    }],
    rightPosition: [{
      type: Input
    }],
    stickyPosition: [{
      type: Input
    }],
    unfix: [{
      type: Input
    }]
  });
})();
var DxoDataGridColumnFixingTextsModule = class _DxoDataGridColumnFixingTextsModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridColumnFixingTextsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridColumnFixingTextsModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridColumnFixingTextsModule,
    imports: [DxoDataGridColumnFixingTextsComponent],
    exports: [DxoDataGridColumnFixingTextsComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridColumnFixingTextsComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridColumnFixingTextsModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridColumnFixingTextsComponent],
      exports: [DxoDataGridColumnFixingTextsComponent]
    }]
  }], null, null);
})();
var DxoDataGridColumnFixingComponent = class _DxoDataGridColumnFixingComponent extends NestedOption {
  get enabled() {
    return this._getOption("enabled");
  }
  set enabled(value2) {
    this._setOption("enabled", value2);
  }
  get icons() {
    return this._getOption("icons");
  }
  set icons(value2) {
    this._setOption("icons", value2);
  }
  get texts() {
    return this._getOption("texts");
  }
  set texts(value2) {
    this._setOption("texts", value2);
  }
  get _optionPath() {
    return "columnFixing";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridColumnFixingComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridColumnFixingComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridColumnFixingComponent,
    selectors: [["dxo-data-grid-column-fixing"]],
    inputs: {
      enabled: "enabled",
      icons: "icons",
      texts: "texts"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridColumnFixingComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridColumnFixingComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-column-fixing",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    enabled: [{
      type: Input
    }],
    icons: [{
      type: Input
    }],
    texts: [{
      type: Input
    }]
  });
})();
var DxoDataGridColumnFixingModule = class _DxoDataGridColumnFixingModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridColumnFixingModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridColumnFixingModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridColumnFixingModule,
    imports: [DxoDataGridColumnFixingComponent],
    exports: [DxoDataGridColumnFixingComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridColumnFixingComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridColumnFixingModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridColumnFixingComponent],
      exports: [DxoDataGridColumnFixingComponent]
    }]
  }], null, null);
})();
var DxoDataGridColumnHeaderFilterSearchComponent = class _DxoDataGridColumnHeaderFilterSearchComponent extends NestedOption {
  get editorOptions() {
    return this._getOption("editorOptions");
  }
  set editorOptions(value2) {
    this._setOption("editorOptions", value2);
  }
  get enabled() {
    return this._getOption("enabled");
  }
  set enabled(value2) {
    this._setOption("enabled", value2);
  }
  get mode() {
    return this._getOption("mode");
  }
  set mode(value2) {
    this._setOption("mode", value2);
  }
  get searchExpr() {
    return this._getOption("searchExpr");
  }
  set searchExpr(value2) {
    this._setOption("searchExpr", value2);
  }
  get timeout() {
    return this._getOption("timeout");
  }
  set timeout(value2) {
    this._setOption("timeout", value2);
  }
  get _optionPath() {
    return "search";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridColumnHeaderFilterSearchComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridColumnHeaderFilterSearchComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridColumnHeaderFilterSearchComponent,
    selectors: [["dxo-data-grid-column-header-filter-search"]],
    inputs: {
      editorOptions: "editorOptions",
      enabled: "enabled",
      mode: "mode",
      searchExpr: "searchExpr",
      timeout: "timeout"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridColumnHeaderFilterSearchComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridColumnHeaderFilterSearchComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-column-header-filter-search",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    editorOptions: [{
      type: Input
    }],
    enabled: [{
      type: Input
    }],
    mode: [{
      type: Input
    }],
    searchExpr: [{
      type: Input
    }],
    timeout: [{
      type: Input
    }]
  });
})();
var DxoDataGridColumnHeaderFilterSearchModule = class _DxoDataGridColumnHeaderFilterSearchModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridColumnHeaderFilterSearchModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridColumnHeaderFilterSearchModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridColumnHeaderFilterSearchModule,
    imports: [DxoDataGridColumnHeaderFilterSearchComponent],
    exports: [DxoDataGridColumnHeaderFilterSearchComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridColumnHeaderFilterSearchComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridColumnHeaderFilterSearchModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridColumnHeaderFilterSearchComponent],
      exports: [DxoDataGridColumnHeaderFilterSearchComponent]
    }]
  }], null, null);
})();
var DxoDataGridColumnHeaderFilterComponent = class _DxoDataGridColumnHeaderFilterComponent extends NestedOption {
  get allowSearch() {
    return this._getOption("allowSearch");
  }
  set allowSearch(value2) {
    this._setOption("allowSearch", value2);
  }
  get allowSelectAll() {
    return this._getOption("allowSelectAll");
  }
  set allowSelectAll(value2) {
    this._setOption("allowSelectAll", value2);
  }
  get dataSource() {
    return this._getOption("dataSource");
  }
  set dataSource(value2) {
    this._setOption("dataSource", value2);
  }
  get groupInterval() {
    return this._getOption("groupInterval");
  }
  set groupInterval(value2) {
    this._setOption("groupInterval", value2);
  }
  get height() {
    return this._getOption("height");
  }
  set height(value2) {
    this._setOption("height", value2);
  }
  get search() {
    return this._getOption("search");
  }
  set search(value2) {
    this._setOption("search", value2);
  }
  get searchMode() {
    return this._getOption("searchMode");
  }
  set searchMode(value2) {
    this._setOption("searchMode", value2);
  }
  get width() {
    return this._getOption("width");
  }
  set width(value2) {
    this._setOption("width", value2);
  }
  get _optionPath() {
    return "headerFilter";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridColumnHeaderFilterComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridColumnHeaderFilterComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridColumnHeaderFilterComponent,
    selectors: [["dxo-data-grid-column-header-filter"]],
    inputs: {
      allowSearch: "allowSearch",
      allowSelectAll: "allowSelectAll",
      dataSource: "dataSource",
      groupInterval: "groupInterval",
      height: "height",
      search: "search",
      searchMode: "searchMode",
      width: "width"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridColumnHeaderFilterComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridColumnHeaderFilterComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-column-header-filter",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    allowSearch: [{
      type: Input
    }],
    allowSelectAll: [{
      type: Input
    }],
    dataSource: [{
      type: Input
    }],
    groupInterval: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    search: [{
      type: Input
    }],
    searchMode: [{
      type: Input
    }],
    width: [{
      type: Input
    }]
  });
})();
var DxoDataGridColumnHeaderFilterModule = class _DxoDataGridColumnHeaderFilterModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridColumnHeaderFilterModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridColumnHeaderFilterModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridColumnHeaderFilterModule,
    imports: [DxoDataGridColumnHeaderFilterComponent],
    exports: [DxoDataGridColumnHeaderFilterComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridColumnHeaderFilterComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridColumnHeaderFilterModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridColumnHeaderFilterComponent],
      exports: [DxoDataGridColumnHeaderFilterComponent]
    }]
  }], null, null);
})();
var DxoDataGridColumnLookupComponent = class _DxoDataGridColumnLookupComponent extends NestedOption {
  get allowClearing() {
    return this._getOption("allowClearing");
  }
  set allowClearing(value2) {
    this._setOption("allowClearing", value2);
  }
  get calculateCellValue() {
    return this._getOption("calculateCellValue");
  }
  set calculateCellValue(value2) {
    this._setOption("calculateCellValue", value2);
  }
  get dataSource() {
    return this._getOption("dataSource");
  }
  set dataSource(value2) {
    this._setOption("dataSource", value2);
  }
  get displayExpr() {
    return this._getOption("displayExpr");
  }
  set displayExpr(value2) {
    this._setOption("displayExpr", value2);
  }
  get valueExpr() {
    return this._getOption("valueExpr");
  }
  set valueExpr(value2) {
    this._setOption("valueExpr", value2);
  }
  get _optionPath() {
    return "lookup";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridColumnLookupComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridColumnLookupComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridColumnLookupComponent,
    selectors: [["dxo-data-grid-column-lookup"]],
    inputs: {
      allowClearing: "allowClearing",
      calculateCellValue: "calculateCellValue",
      dataSource: "dataSource",
      displayExpr: "displayExpr",
      valueExpr: "valueExpr"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridColumnLookupComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridColumnLookupComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-column-lookup",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    allowClearing: [{
      type: Input
    }],
    calculateCellValue: [{
      type: Input
    }],
    dataSource: [{
      type: Input
    }],
    displayExpr: [{
      type: Input
    }],
    valueExpr: [{
      type: Input
    }]
  });
})();
var DxoDataGridColumnLookupModule = class _DxoDataGridColumnLookupModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridColumnLookupModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridColumnLookupModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridColumnLookupModule,
    imports: [DxoDataGridColumnLookupComponent],
    exports: [DxoDataGridColumnLookupComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridColumnLookupComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridColumnLookupModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridColumnLookupComponent],
      exports: [DxoDataGridColumnLookupComponent]
    }]
  }], null, null);
})();
var DxiDataGridCompareRuleComponent = class _DxiDataGridCompareRuleComponent extends CollectionNestedOption {
  get comparisonTarget() {
    return this._getOption("comparisonTarget");
  }
  set comparisonTarget(value2) {
    this._setOption("comparisonTarget", value2);
  }
  get comparisonType() {
    return this._getOption("comparisonType");
  }
  set comparisonType(value2) {
    this._setOption("comparisonType", value2);
  }
  get ignoreEmptyValue() {
    return this._getOption("ignoreEmptyValue");
  }
  set ignoreEmptyValue(value2) {
    this._setOption("ignoreEmptyValue", value2);
  }
  get message() {
    return this._getOption("message");
  }
  set message(value2) {
    this._setOption("message", value2);
  }
  get type() {
    return this._getOption("type");
  }
  set type(value2) {
    this._setOption("type", value2);
  }
  get _optionPath() {
    return "validationRules";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
    this.type = "compare";
  }
  ngOnDestroy() {
    this._deleteRemovedOptions(this._fullOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxiDataGridCompareRuleComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridCompareRuleComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxiDataGridCompareRuleComponent,
    selectors: [["dxi-data-grid-compare-rule"]],
    inputs: {
      comparisonTarget: "comparisonTarget",
      comparisonType: "comparisonType",
      ignoreEmptyValue: "ignoreEmptyValue",
      message: "message",
      type: "type"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost, {
      provide: PROPERTY_TOKEN_validationRules,
      useExisting: _DxiDataGridCompareRuleComponent
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxiDataGridCompareRuleComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridCompareRuleComponent, [{
    type: Component,
    args: [{
      selector: "dxi-data-grid-compare-rule",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost, {
        provide: PROPERTY_TOKEN_validationRules,
        useExisting: DxiDataGridCompareRuleComponent
      }]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    comparisonTarget: [{
      type: Input
    }],
    comparisonType: [{
      type: Input
    }],
    ignoreEmptyValue: [{
      type: Input
    }],
    message: [{
      type: Input
    }],
    type: [{
      type: Input
    }]
  });
})();
var DxiDataGridCompareRuleModule = class _DxiDataGridCompareRuleModule {
  /** @nocollapse */
  static ɵfac = function DxiDataGridCompareRuleModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridCompareRuleModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxiDataGridCompareRuleModule,
    imports: [DxiDataGridCompareRuleComponent],
    exports: [DxiDataGridCompareRuleComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxiDataGridCompareRuleComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridCompareRuleModule, [{
    type: NgModule,
    args: [{
      imports: [DxiDataGridCompareRuleComponent],
      exports: [DxiDataGridCompareRuleComponent]
    }]
  }], null, null);
})();
var DxoDataGridCursorOffsetComponent = class _DxoDataGridCursorOffsetComponent extends NestedOption {
  get x() {
    return this._getOption("x");
  }
  set x(value2) {
    this._setOption("x", value2);
  }
  get y() {
    return this._getOption("y");
  }
  set y(value2) {
    this._setOption("y", value2);
  }
  get _optionPath() {
    return "cursorOffset";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridCursorOffsetComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridCursorOffsetComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridCursorOffsetComponent,
    selectors: [["dxo-data-grid-cursor-offset"]],
    inputs: {
      x: "x",
      y: "y"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridCursorOffsetComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridCursorOffsetComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-cursor-offset",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    x: [{
      type: Input
    }],
    y: [{
      type: Input
    }]
  });
})();
var DxoDataGridCursorOffsetModule = class _DxoDataGridCursorOffsetModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridCursorOffsetModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridCursorOffsetModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridCursorOffsetModule,
    imports: [DxoDataGridCursorOffsetComponent],
    exports: [DxoDataGridCursorOffsetComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridCursorOffsetComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridCursorOffsetModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridCursorOffsetComponent],
      exports: [DxoDataGridCursorOffsetComponent]
    }]
  }], null, null);
})();
var DxiDataGridCustomOperationComponent = class _DxiDataGridCustomOperationComponent extends CollectionNestedOption {
  get calculateFilterExpression() {
    return this._getOption("calculateFilterExpression");
  }
  set calculateFilterExpression(value2) {
    this._setOption("calculateFilterExpression", value2);
  }
  get caption() {
    return this._getOption("caption");
  }
  set caption(value2) {
    this._setOption("caption", value2);
  }
  get customizeText() {
    return this._getOption("customizeText");
  }
  set customizeText(value2) {
    this._setOption("customizeText", value2);
  }
  get dataTypes() {
    return this._getOption("dataTypes");
  }
  set dataTypes(value2) {
    this._setOption("dataTypes", value2);
  }
  get editorTemplate() {
    return this._getOption("editorTemplate");
  }
  set editorTemplate(value2) {
    this._setOption("editorTemplate", value2);
  }
  get hasValue() {
    return this._getOption("hasValue");
  }
  set hasValue(value2) {
    this._setOption("hasValue", value2);
  }
  get icon() {
    return this._getOption("icon");
  }
  set icon(value2) {
    this._setOption("icon", value2);
  }
  get name() {
    return this._getOption("name");
  }
  set name(value2) {
    this._setOption("name", value2);
  }
  get _optionPath() {
    return "customOperations";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnDestroy() {
    this._deleteRemovedOptions(this._fullOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxiDataGridCustomOperationComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridCustomOperationComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxiDataGridCustomOperationComponent,
    selectors: [["dxi-data-grid-custom-operation"]],
    inputs: {
      calculateFilterExpression: "calculateFilterExpression",
      caption: "caption",
      customizeText: "customizeText",
      dataTypes: "dataTypes",
      editorTemplate: "editorTemplate",
      hasValue: "hasValue",
      icon: "icon",
      name: "name"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost, {
      provide: PROPERTY_TOKEN_customOperations,
      useExisting: _DxiDataGridCustomOperationComponent
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxiDataGridCustomOperationComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridCustomOperationComponent, [{
    type: Component,
    args: [{
      selector: "dxi-data-grid-custom-operation",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost, {
        provide: PROPERTY_TOKEN_customOperations,
        useExisting: DxiDataGridCustomOperationComponent
      }]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    calculateFilterExpression: [{
      type: Input
    }],
    caption: [{
      type: Input
    }],
    customizeText: [{
      type: Input
    }],
    dataTypes: [{
      type: Input
    }],
    editorTemplate: [{
      type: Input
    }],
    hasValue: [{
      type: Input
    }],
    icon: [{
      type: Input
    }],
    name: [{
      type: Input
    }]
  });
})();
var DxiDataGridCustomOperationModule = class _DxiDataGridCustomOperationModule {
  /** @nocollapse */
  static ɵfac = function DxiDataGridCustomOperationModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridCustomOperationModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxiDataGridCustomOperationModule,
    imports: [DxiDataGridCustomOperationComponent],
    exports: [DxiDataGridCustomOperationComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxiDataGridCustomOperationComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridCustomOperationModule, [{
    type: NgModule,
    args: [{
      imports: [DxiDataGridCustomOperationComponent],
      exports: [DxiDataGridCustomOperationComponent]
    }]
  }], null, null);
})();
var DxiDataGridCustomRuleComponent = class _DxiDataGridCustomRuleComponent extends CollectionNestedOption {
  get ignoreEmptyValue() {
    return this._getOption("ignoreEmptyValue");
  }
  set ignoreEmptyValue(value2) {
    this._setOption("ignoreEmptyValue", value2);
  }
  get message() {
    return this._getOption("message");
  }
  set message(value2) {
    this._setOption("message", value2);
  }
  get reevaluate() {
    return this._getOption("reevaluate");
  }
  set reevaluate(value2) {
    this._setOption("reevaluate", value2);
  }
  get type() {
    return this._getOption("type");
  }
  set type(value2) {
    this._setOption("type", value2);
  }
  get validationCallback() {
    return this._getOption("validationCallback");
  }
  set validationCallback(value2) {
    this._setOption("validationCallback", value2);
  }
  get _optionPath() {
    return "validationRules";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
    this.type = "custom";
  }
  ngOnDestroy() {
    this._deleteRemovedOptions(this._fullOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxiDataGridCustomRuleComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridCustomRuleComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxiDataGridCustomRuleComponent,
    selectors: [["dxi-data-grid-custom-rule"]],
    inputs: {
      ignoreEmptyValue: "ignoreEmptyValue",
      message: "message",
      reevaluate: "reevaluate",
      type: "type",
      validationCallback: "validationCallback"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost, {
      provide: PROPERTY_TOKEN_validationRules,
      useExisting: _DxiDataGridCustomRuleComponent
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxiDataGridCustomRuleComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridCustomRuleComponent, [{
    type: Component,
    args: [{
      selector: "dxi-data-grid-custom-rule",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost, {
        provide: PROPERTY_TOKEN_validationRules,
        useExisting: DxiDataGridCustomRuleComponent
      }]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    ignoreEmptyValue: [{
      type: Input
    }],
    message: [{
      type: Input
    }],
    reevaluate: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    validationCallback: [{
      type: Input
    }]
  });
})();
var DxiDataGridCustomRuleModule = class _DxiDataGridCustomRuleModule {
  /** @nocollapse */
  static ɵfac = function DxiDataGridCustomRuleModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridCustomRuleModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxiDataGridCustomRuleModule,
    imports: [DxiDataGridCustomRuleComponent],
    exports: [DxiDataGridCustomRuleComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxiDataGridCustomRuleComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridCustomRuleModule, [{
    type: NgModule,
    args: [{
      imports: [DxiDataGridCustomRuleComponent],
      exports: [DxiDataGridCustomRuleComponent]
    }]
  }], null, null);
})();
var DxoDataGridDataGridHeaderFilterSearchComponent = class _DxoDataGridDataGridHeaderFilterSearchComponent extends NestedOption {
  get editorOptions() {
    return this._getOption("editorOptions");
  }
  set editorOptions(value2) {
    this._setOption("editorOptions", value2);
  }
  get enabled() {
    return this._getOption("enabled");
  }
  set enabled(value2) {
    this._setOption("enabled", value2);
  }
  get mode() {
    return this._getOption("mode");
  }
  set mode(value2) {
    this._setOption("mode", value2);
  }
  get timeout() {
    return this._getOption("timeout");
  }
  set timeout(value2) {
    this._setOption("timeout", value2);
  }
  get _optionPath() {
    return "search";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridDataGridHeaderFilterSearchComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridDataGridHeaderFilterSearchComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridDataGridHeaderFilterSearchComponent,
    selectors: [["dxo-data-grid-data-grid-header-filter-search"]],
    inputs: {
      editorOptions: "editorOptions",
      enabled: "enabled",
      mode: "mode",
      timeout: "timeout"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridDataGridHeaderFilterSearchComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridDataGridHeaderFilterSearchComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-data-grid-header-filter-search",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    editorOptions: [{
      type: Input
    }],
    enabled: [{
      type: Input
    }],
    mode: [{
      type: Input
    }],
    timeout: [{
      type: Input
    }]
  });
})();
var DxoDataGridDataGridHeaderFilterSearchModule = class _DxoDataGridDataGridHeaderFilterSearchModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridDataGridHeaderFilterSearchModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridDataGridHeaderFilterSearchModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridDataGridHeaderFilterSearchModule,
    imports: [DxoDataGridDataGridHeaderFilterSearchComponent],
    exports: [DxoDataGridDataGridHeaderFilterSearchComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridDataGridHeaderFilterSearchComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridDataGridHeaderFilterSearchModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridDataGridHeaderFilterSearchComponent],
      exports: [DxoDataGridDataGridHeaderFilterSearchComponent]
    }]
  }], null, null);
})();
var DxoDataGridDataGridHeaderFilterTextsComponent = class _DxoDataGridDataGridHeaderFilterTextsComponent extends NestedOption {
  get cancel() {
    return this._getOption("cancel");
  }
  set cancel(value2) {
    this._setOption("cancel", value2);
  }
  get emptyValue() {
    return this._getOption("emptyValue");
  }
  set emptyValue(value2) {
    this._setOption("emptyValue", value2);
  }
  get ok() {
    return this._getOption("ok");
  }
  set ok(value2) {
    this._setOption("ok", value2);
  }
  get _optionPath() {
    return "texts";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridDataGridHeaderFilterTextsComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridDataGridHeaderFilterTextsComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridDataGridHeaderFilterTextsComponent,
    selectors: [["dxo-data-grid-data-grid-header-filter-texts"]],
    inputs: {
      cancel: "cancel",
      emptyValue: "emptyValue",
      ok: "ok"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridDataGridHeaderFilterTextsComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridDataGridHeaderFilterTextsComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-data-grid-header-filter-texts",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    cancel: [{
      type: Input
    }],
    emptyValue: [{
      type: Input
    }],
    ok: [{
      type: Input
    }]
  });
})();
var DxoDataGridDataGridHeaderFilterTextsModule = class _DxoDataGridDataGridHeaderFilterTextsModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridDataGridHeaderFilterTextsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridDataGridHeaderFilterTextsModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridDataGridHeaderFilterTextsModule,
    imports: [DxoDataGridDataGridHeaderFilterTextsComponent],
    exports: [DxoDataGridDataGridHeaderFilterTextsComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridDataGridHeaderFilterTextsComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridDataGridHeaderFilterTextsModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridDataGridHeaderFilterTextsComponent],
      exports: [DxoDataGridDataGridHeaderFilterTextsComponent]
    }]
  }], null, null);
})();
var DxoDataGridDataGridHeaderFilterComponent = class _DxoDataGridDataGridHeaderFilterComponent extends NestedOption {
  get allowSearch() {
    return this._getOption("allowSearch");
  }
  set allowSearch(value2) {
    this._setOption("allowSearch", value2);
  }
  get allowSelectAll() {
    return this._getOption("allowSelectAll");
  }
  set allowSelectAll(value2) {
    this._setOption("allowSelectAll", value2);
  }
  get height() {
    return this._getOption("height");
  }
  set height(value2) {
    this._setOption("height", value2);
  }
  get search() {
    return this._getOption("search");
  }
  set search(value2) {
    this._setOption("search", value2);
  }
  get searchTimeout() {
    return this._getOption("searchTimeout");
  }
  set searchTimeout(value2) {
    this._setOption("searchTimeout", value2);
  }
  get texts() {
    return this._getOption("texts");
  }
  set texts(value2) {
    this._setOption("texts", value2);
  }
  get visible() {
    return this._getOption("visible");
  }
  set visible(value2) {
    this._setOption("visible", value2);
  }
  get width() {
    return this._getOption("width");
  }
  set width(value2) {
    this._setOption("width", value2);
  }
  get _optionPath() {
    return "headerFilter";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridDataGridHeaderFilterComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridDataGridHeaderFilterComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridDataGridHeaderFilterComponent,
    selectors: [["dxo-data-grid-data-grid-header-filter"]],
    inputs: {
      allowSearch: "allowSearch",
      allowSelectAll: "allowSelectAll",
      height: "height",
      search: "search",
      searchTimeout: "searchTimeout",
      texts: "texts",
      visible: "visible",
      width: "width"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridDataGridHeaderFilterComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridDataGridHeaderFilterComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-data-grid-header-filter",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    allowSearch: [{
      type: Input
    }],
    allowSelectAll: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    search: [{
      type: Input
    }],
    searchTimeout: [{
      type: Input
    }],
    texts: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    width: [{
      type: Input
    }]
  });
})();
var DxoDataGridDataGridHeaderFilterModule = class _DxoDataGridDataGridHeaderFilterModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridDataGridHeaderFilterModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridDataGridHeaderFilterModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridDataGridHeaderFilterModule,
    imports: [DxoDataGridDataGridHeaderFilterComponent],
    exports: [DxoDataGridDataGridHeaderFilterComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridDataGridHeaderFilterComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridDataGridHeaderFilterModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridDataGridHeaderFilterComponent],
      exports: [DxoDataGridDataGridHeaderFilterComponent]
    }]
  }], null, null);
})();
var DxoDataGridDataGridSelectionComponent = class _DxoDataGridDataGridSelectionComponent extends NestedOption {
  get allowSelectAll() {
    return this._getOption("allowSelectAll");
  }
  set allowSelectAll(value2) {
    this._setOption("allowSelectAll", value2);
  }
  get deferred() {
    return this._getOption("deferred");
  }
  set deferred(value2) {
    this._setOption("deferred", value2);
  }
  get mode() {
    return this._getOption("mode");
  }
  set mode(value2) {
    this._setOption("mode", value2);
  }
  get selectAllMode() {
    return this._getOption("selectAllMode");
  }
  set selectAllMode(value2) {
    this._setOption("selectAllMode", value2);
  }
  get sensitivity() {
    return this._getOption("sensitivity");
  }
  set sensitivity(value2) {
    this._setOption("sensitivity", value2);
  }
  get showCheckBoxesMode() {
    return this._getOption("showCheckBoxesMode");
  }
  set showCheckBoxesMode(value2) {
    this._setOption("showCheckBoxesMode", value2);
  }
  get _optionPath() {
    return "selection";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridDataGridSelectionComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridDataGridSelectionComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridDataGridSelectionComponent,
    selectors: [["dxo-data-grid-data-grid-selection"]],
    inputs: {
      allowSelectAll: "allowSelectAll",
      deferred: "deferred",
      mode: "mode",
      selectAllMode: "selectAllMode",
      sensitivity: "sensitivity",
      showCheckBoxesMode: "showCheckBoxesMode"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridDataGridSelectionComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridDataGridSelectionComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-data-grid-selection",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    allowSelectAll: [{
      type: Input
    }],
    deferred: [{
      type: Input
    }],
    mode: [{
      type: Input
    }],
    selectAllMode: [{
      type: Input
    }],
    sensitivity: [{
      type: Input
    }],
    showCheckBoxesMode: [{
      type: Input
    }]
  });
})();
var DxoDataGridDataGridSelectionModule = class _DxoDataGridDataGridSelectionModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridDataGridSelectionModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridDataGridSelectionModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridDataGridSelectionModule,
    imports: [DxoDataGridDataGridSelectionComponent],
    exports: [DxoDataGridDataGridSelectionComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridDataGridSelectionComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridDataGridSelectionModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridDataGridSelectionComponent],
      exports: [DxoDataGridDataGridSelectionComponent]
    }]
  }], null, null);
})();
var DxoDataGridEditingTextsComponent = class _DxoDataGridEditingTextsComponent extends NestedOption {
  get addRow() {
    return this._getOption("addRow");
  }
  set addRow(value2) {
    this._setOption("addRow", value2);
  }
  get cancelAllChanges() {
    return this._getOption("cancelAllChanges");
  }
  set cancelAllChanges(value2) {
    this._setOption("cancelAllChanges", value2);
  }
  get cancelRowChanges() {
    return this._getOption("cancelRowChanges");
  }
  set cancelRowChanges(value2) {
    this._setOption("cancelRowChanges", value2);
  }
  get confirmDeleteMessage() {
    return this._getOption("confirmDeleteMessage");
  }
  set confirmDeleteMessage(value2) {
    this._setOption("confirmDeleteMessage", value2);
  }
  get confirmDeleteTitle() {
    return this._getOption("confirmDeleteTitle");
  }
  set confirmDeleteTitle(value2) {
    this._setOption("confirmDeleteTitle", value2);
  }
  get deleteRow() {
    return this._getOption("deleteRow");
  }
  set deleteRow(value2) {
    this._setOption("deleteRow", value2);
  }
  get editRow() {
    return this._getOption("editRow");
  }
  set editRow(value2) {
    this._setOption("editRow", value2);
  }
  get saveAllChanges() {
    return this._getOption("saveAllChanges");
  }
  set saveAllChanges(value2) {
    this._setOption("saveAllChanges", value2);
  }
  get saveRowChanges() {
    return this._getOption("saveRowChanges");
  }
  set saveRowChanges(value2) {
    this._setOption("saveRowChanges", value2);
  }
  get undeleteRow() {
    return this._getOption("undeleteRow");
  }
  set undeleteRow(value2) {
    this._setOption("undeleteRow", value2);
  }
  get validationCancelChanges() {
    return this._getOption("validationCancelChanges");
  }
  set validationCancelChanges(value2) {
    this._setOption("validationCancelChanges", value2);
  }
  get _optionPath() {
    return "texts";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridEditingTextsComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridEditingTextsComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridEditingTextsComponent,
    selectors: [["dxo-data-grid-editing-texts"]],
    inputs: {
      addRow: "addRow",
      cancelAllChanges: "cancelAllChanges",
      cancelRowChanges: "cancelRowChanges",
      confirmDeleteMessage: "confirmDeleteMessage",
      confirmDeleteTitle: "confirmDeleteTitle",
      deleteRow: "deleteRow",
      editRow: "editRow",
      saveAllChanges: "saveAllChanges",
      saveRowChanges: "saveRowChanges",
      undeleteRow: "undeleteRow",
      validationCancelChanges: "validationCancelChanges"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridEditingTextsComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridEditingTextsComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-editing-texts",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    addRow: [{
      type: Input
    }],
    cancelAllChanges: [{
      type: Input
    }],
    cancelRowChanges: [{
      type: Input
    }],
    confirmDeleteMessage: [{
      type: Input
    }],
    confirmDeleteTitle: [{
      type: Input
    }],
    deleteRow: [{
      type: Input
    }],
    editRow: [{
      type: Input
    }],
    saveAllChanges: [{
      type: Input
    }],
    saveRowChanges: [{
      type: Input
    }],
    undeleteRow: [{
      type: Input
    }],
    validationCancelChanges: [{
      type: Input
    }]
  });
})();
var DxoDataGridEditingTextsModule = class _DxoDataGridEditingTextsModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridEditingTextsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridEditingTextsModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridEditingTextsModule,
    imports: [DxoDataGridEditingTextsComponent],
    exports: [DxoDataGridEditingTextsComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridEditingTextsComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridEditingTextsModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridEditingTextsComponent],
      exports: [DxoDataGridEditingTextsComponent]
    }]
  }], null, null);
})();
var DxoDataGridEditingComponent = class _DxoDataGridEditingComponent extends NestedOption {
  set _changesContentChildren(value2) {
    this.setChildren("changes", value2);
  }
  get allowAdding() {
    return this._getOption("allowAdding");
  }
  set allowAdding(value2) {
    this._setOption("allowAdding", value2);
  }
  get allowDeleting() {
    return this._getOption("allowDeleting");
  }
  set allowDeleting(value2) {
    this._setOption("allowDeleting", value2);
  }
  get allowUpdating() {
    return this._getOption("allowUpdating");
  }
  set allowUpdating(value2) {
    this._setOption("allowUpdating", value2);
  }
  get changes() {
    return this._getOption("changes");
  }
  set changes(value2) {
    this._setOption("changes", value2);
  }
  get confirmDelete() {
    return this._getOption("confirmDelete");
  }
  set confirmDelete(value2) {
    this._setOption("confirmDelete", value2);
  }
  get editColumnName() {
    return this._getOption("editColumnName");
  }
  set editColumnName(value2) {
    this._setOption("editColumnName", value2);
  }
  get editRowKey() {
    return this._getOption("editRowKey");
  }
  set editRowKey(value2) {
    this._setOption("editRowKey", value2);
  }
  get form() {
    return this._getOption("form");
  }
  set form(value2) {
    this._setOption("form", value2);
  }
  get mode() {
    return this._getOption("mode");
  }
  set mode(value2) {
    this._setOption("mode", value2);
  }
  get newRowPosition() {
    return this._getOption("newRowPosition");
  }
  set newRowPosition(value2) {
    this._setOption("newRowPosition", value2);
  }
  get popup() {
    return this._getOption("popup");
  }
  set popup(value2) {
    this._setOption("popup", value2);
  }
  get refreshMode() {
    return this._getOption("refreshMode");
  }
  set refreshMode(value2) {
    this._setOption("refreshMode", value2);
  }
  get selectTextOnEditStart() {
    return this._getOption("selectTextOnEditStart");
  }
  set selectTextOnEditStart(value2) {
    this._setOption("selectTextOnEditStart", value2);
  }
  get startEditAction() {
    return this._getOption("startEditAction");
  }
  set startEditAction(value2) {
    this._setOption("startEditAction", value2);
  }
  get texts() {
    return this._getOption("texts");
  }
  set texts(value2) {
    this._setOption("texts", value2);
  }
  get useIcons() {
    return this._getOption("useIcons");
  }
  set useIcons(value2) {
    this._setOption("useIcons", value2);
  }
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  changesChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  editColumnNameChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  editRowKeyChange;
  get _optionPath() {
    return "editing";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    this._createEventEmitters([{
      emit: "changesChange"
    }, {
      emit: "editColumnNameChange"
    }, {
      emit: "editRowKeyChange"
    }]);
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridEditingComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridEditingComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridEditingComponent,
    selectors: [["dxo-data-grid-editing"]],
    contentQueries: function DxoDataGridEditingComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, PROPERTY_TOKEN_changes, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._changesContentChildren = _t);
      }
    },
    inputs: {
      allowAdding: "allowAdding",
      allowDeleting: "allowDeleting",
      allowUpdating: "allowUpdating",
      changes: "changes",
      confirmDelete: "confirmDelete",
      editColumnName: "editColumnName",
      editRowKey: "editRowKey",
      form: "form",
      mode: "mode",
      newRowPosition: "newRowPosition",
      popup: "popup",
      refreshMode: "refreshMode",
      selectTextOnEditStart: "selectTextOnEditStart",
      startEditAction: "startEditAction",
      texts: "texts",
      useIcons: "useIcons"
    },
    outputs: {
      changesChange: "changesChange",
      editColumnNameChange: "editColumnNameChange",
      editRowKeyChange: "editRowKeyChange"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridEditingComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridEditingComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-editing",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    _changesContentChildren: [{
      type: ContentChildren,
      args: [PROPERTY_TOKEN_changes]
    }],
    allowAdding: [{
      type: Input
    }],
    allowDeleting: [{
      type: Input
    }],
    allowUpdating: [{
      type: Input
    }],
    changes: [{
      type: Input
    }],
    confirmDelete: [{
      type: Input
    }],
    editColumnName: [{
      type: Input
    }],
    editRowKey: [{
      type: Input
    }],
    form: [{
      type: Input
    }],
    mode: [{
      type: Input
    }],
    newRowPosition: [{
      type: Input
    }],
    popup: [{
      type: Input
    }],
    refreshMode: [{
      type: Input
    }],
    selectTextOnEditStart: [{
      type: Input
    }],
    startEditAction: [{
      type: Input
    }],
    texts: [{
      type: Input
    }],
    useIcons: [{
      type: Input
    }],
    changesChange: [{
      type: Output
    }],
    editColumnNameChange: [{
      type: Output
    }],
    editRowKeyChange: [{
      type: Output
    }]
  });
})();
var DxoDataGridEditingModule = class _DxoDataGridEditingModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridEditingModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridEditingModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridEditingModule,
    imports: [DxoDataGridEditingComponent],
    exports: [DxoDataGridEditingComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridEditingComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridEditingModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridEditingComponent],
      exports: [DxoDataGridEditingComponent]
    }]
  }], null, null);
})();
var DxiDataGridEmailRuleComponent = class _DxiDataGridEmailRuleComponent extends CollectionNestedOption {
  get ignoreEmptyValue() {
    return this._getOption("ignoreEmptyValue");
  }
  set ignoreEmptyValue(value2) {
    this._setOption("ignoreEmptyValue", value2);
  }
  get message() {
    return this._getOption("message");
  }
  set message(value2) {
    this._setOption("message", value2);
  }
  get type() {
    return this._getOption("type");
  }
  set type(value2) {
    this._setOption("type", value2);
  }
  get _optionPath() {
    return "validationRules";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
    this.type = "email";
  }
  ngOnDestroy() {
    this._deleteRemovedOptions(this._fullOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxiDataGridEmailRuleComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridEmailRuleComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxiDataGridEmailRuleComponent,
    selectors: [["dxi-data-grid-email-rule"]],
    inputs: {
      ignoreEmptyValue: "ignoreEmptyValue",
      message: "message",
      type: "type"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost, {
      provide: PROPERTY_TOKEN_validationRules,
      useExisting: _DxiDataGridEmailRuleComponent
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxiDataGridEmailRuleComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridEmailRuleComponent, [{
    type: Component,
    args: [{
      selector: "dxi-data-grid-email-rule",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost, {
        provide: PROPERTY_TOKEN_validationRules,
        useExisting: DxiDataGridEmailRuleComponent
      }]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    ignoreEmptyValue: [{
      type: Input
    }],
    message: [{
      type: Input
    }],
    type: [{
      type: Input
    }]
  });
})();
var DxiDataGridEmailRuleModule = class _DxiDataGridEmailRuleModule {
  /** @nocollapse */
  static ɵfac = function DxiDataGridEmailRuleModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridEmailRuleModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxiDataGridEmailRuleModule,
    imports: [DxiDataGridEmailRuleComponent],
    exports: [DxiDataGridEmailRuleComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxiDataGridEmailRuleComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridEmailRuleModule, [{
    type: NgModule,
    args: [{
      imports: [DxiDataGridEmailRuleComponent],
      exports: [DxiDataGridEmailRuleComponent]
    }]
  }], null, null);
})();
var DxoDataGridExportTextsComponent = class _DxoDataGridExportTextsComponent extends NestedOption {
  get exportAll() {
    return this._getOption("exportAll");
  }
  set exportAll(value2) {
    this._setOption("exportAll", value2);
  }
  get exportSelectedRows() {
    return this._getOption("exportSelectedRows");
  }
  set exportSelectedRows(value2) {
    this._setOption("exportSelectedRows", value2);
  }
  get exportTo() {
    return this._getOption("exportTo");
  }
  set exportTo(value2) {
    this._setOption("exportTo", value2);
  }
  get _optionPath() {
    return "texts";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridExportTextsComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridExportTextsComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridExportTextsComponent,
    selectors: [["dxo-data-grid-export-texts"]],
    inputs: {
      exportAll: "exportAll",
      exportSelectedRows: "exportSelectedRows",
      exportTo: "exportTo"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridExportTextsComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridExportTextsComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-export-texts",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    exportAll: [{
      type: Input
    }],
    exportSelectedRows: [{
      type: Input
    }],
    exportTo: [{
      type: Input
    }]
  });
})();
var DxoDataGridExportTextsModule = class _DxoDataGridExportTextsModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridExportTextsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridExportTextsModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridExportTextsModule,
    imports: [DxoDataGridExportTextsComponent],
    exports: [DxoDataGridExportTextsComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridExportTextsComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridExportTextsModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridExportTextsComponent],
      exports: [DxoDataGridExportTextsComponent]
    }]
  }], null, null);
})();
var DxoDataGridExportComponent = class _DxoDataGridExportComponent extends NestedOption {
  get allowExportSelectedData() {
    return this._getOption("allowExportSelectedData");
  }
  set allowExportSelectedData(value2) {
    this._setOption("allowExportSelectedData", value2);
  }
  get enabled() {
    return this._getOption("enabled");
  }
  set enabled(value2) {
    this._setOption("enabled", value2);
  }
  get formats() {
    return this._getOption("formats");
  }
  set formats(value2) {
    this._setOption("formats", value2);
  }
  get texts() {
    return this._getOption("texts");
  }
  set texts(value2) {
    this._setOption("texts", value2);
  }
  get _optionPath() {
    return "export";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridExportComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridExportComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridExportComponent,
    selectors: [["dxo-data-grid-export"]],
    inputs: {
      allowExportSelectedData: "allowExportSelectedData",
      enabled: "enabled",
      formats: "formats",
      texts: "texts"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridExportComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridExportComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-export",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    allowExportSelectedData: [{
      type: Input
    }],
    enabled: [{
      type: Input
    }],
    formats: [{
      type: Input
    }],
    texts: [{
      type: Input
    }]
  });
})();
var DxoDataGridExportModule = class _DxoDataGridExportModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridExportModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridExportModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridExportModule,
    imports: [DxoDataGridExportComponent],
    exports: [DxoDataGridExportComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridExportComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridExportModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridExportComponent],
      exports: [DxoDataGridExportComponent]
    }]
  }], null, null);
})();
var DxiDataGridFieldComponent = class _DxiDataGridFieldComponent extends CollectionNestedOption {
  get calculateFilterExpression() {
    return this._getOption("calculateFilterExpression");
  }
  set calculateFilterExpression(value2) {
    this._setOption("calculateFilterExpression", value2);
  }
  get caption() {
    return this._getOption("caption");
  }
  set caption(value2) {
    this._setOption("caption", value2);
  }
  get customizeText() {
    return this._getOption("customizeText");
  }
  set customizeText(value2) {
    this._setOption("customizeText", value2);
  }
  get dataField() {
    return this._getOption("dataField");
  }
  set dataField(value2) {
    this._setOption("dataField", value2);
  }
  get dataType() {
    return this._getOption("dataType");
  }
  set dataType(value2) {
    this._setOption("dataType", value2);
  }
  get editorOptions() {
    return this._getOption("editorOptions");
  }
  set editorOptions(value2) {
    this._setOption("editorOptions", value2);
  }
  get editorTemplate() {
    return this._getOption("editorTemplate");
  }
  set editorTemplate(value2) {
    this._setOption("editorTemplate", value2);
  }
  get falseText() {
    return this._getOption("falseText");
  }
  set falseText(value2) {
    this._setOption("falseText", value2);
  }
  get filterOperations() {
    return this._getOption("filterOperations");
  }
  set filterOperations(value2) {
    this._setOption("filterOperations", value2);
  }
  get format() {
    return this._getOption("format");
  }
  set format(value2) {
    this._setOption("format", value2);
  }
  get lookup() {
    return this._getOption("lookup");
  }
  set lookup(value2) {
    this._setOption("lookup", value2);
  }
  get name() {
    return this._getOption("name");
  }
  set name(value2) {
    this._setOption("name", value2);
  }
  get trueText() {
    return this._getOption("trueText");
  }
  set trueText(value2) {
    this._setOption("trueText", value2);
  }
  get _optionPath() {
    return "fields";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnDestroy() {
    this._deleteRemovedOptions(this._fullOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxiDataGridFieldComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridFieldComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxiDataGridFieldComponent,
    selectors: [["dxi-data-grid-field"]],
    inputs: {
      calculateFilterExpression: "calculateFilterExpression",
      caption: "caption",
      customizeText: "customizeText",
      dataField: "dataField",
      dataType: "dataType",
      editorOptions: "editorOptions",
      editorTemplate: "editorTemplate",
      falseText: "falseText",
      filterOperations: "filterOperations",
      format: "format",
      lookup: "lookup",
      name: "name",
      trueText: "trueText"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost, {
      provide: PROPERTY_TOKEN_fields,
      useExisting: _DxiDataGridFieldComponent
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxiDataGridFieldComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridFieldComponent, [{
    type: Component,
    args: [{
      selector: "dxi-data-grid-field",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost, {
        provide: PROPERTY_TOKEN_fields,
        useExisting: DxiDataGridFieldComponent
      }]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    calculateFilterExpression: [{
      type: Input
    }],
    caption: [{
      type: Input
    }],
    customizeText: [{
      type: Input
    }],
    dataField: [{
      type: Input
    }],
    dataType: [{
      type: Input
    }],
    editorOptions: [{
      type: Input
    }],
    editorTemplate: [{
      type: Input
    }],
    falseText: [{
      type: Input
    }],
    filterOperations: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    lookup: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    trueText: [{
      type: Input
    }]
  });
})();
var DxiDataGridFieldModule = class _DxiDataGridFieldModule {
  /** @nocollapse */
  static ɵfac = function DxiDataGridFieldModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridFieldModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxiDataGridFieldModule,
    imports: [DxiDataGridFieldComponent],
    exports: [DxiDataGridFieldComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxiDataGridFieldComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridFieldModule, [{
    type: NgModule,
    args: [{
      imports: [DxiDataGridFieldComponent],
      exports: [DxiDataGridFieldComponent]
    }]
  }], null, null);
})();
var DxoDataGridFieldLookupComponent = class _DxoDataGridFieldLookupComponent extends NestedOption {
  get allowClearing() {
    return this._getOption("allowClearing");
  }
  set allowClearing(value2) {
    this._setOption("allowClearing", value2);
  }
  get dataSource() {
    return this._getOption("dataSource");
  }
  set dataSource(value2) {
    this._setOption("dataSource", value2);
  }
  get displayExpr() {
    return this._getOption("displayExpr");
  }
  set displayExpr(value2) {
    this._setOption("displayExpr", value2);
  }
  get valueExpr() {
    return this._getOption("valueExpr");
  }
  set valueExpr(value2) {
    this._setOption("valueExpr", value2);
  }
  get _optionPath() {
    return "lookup";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridFieldLookupComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridFieldLookupComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridFieldLookupComponent,
    selectors: [["dxo-data-grid-field-lookup"]],
    inputs: {
      allowClearing: "allowClearing",
      dataSource: "dataSource",
      displayExpr: "displayExpr",
      valueExpr: "valueExpr"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridFieldLookupComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridFieldLookupComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-field-lookup",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    allowClearing: [{
      type: Input
    }],
    dataSource: [{
      type: Input
    }],
    displayExpr: [{
      type: Input
    }],
    valueExpr: [{
      type: Input
    }]
  });
})();
var DxoDataGridFieldLookupModule = class _DxoDataGridFieldLookupModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridFieldLookupModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridFieldLookupModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridFieldLookupModule,
    imports: [DxoDataGridFieldLookupComponent],
    exports: [DxoDataGridFieldLookupComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridFieldLookupComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridFieldLookupModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridFieldLookupComponent],
      exports: [DxoDataGridFieldLookupComponent]
    }]
  }], null, null);
})();
var DxoDataGridFilterBuilderPopupComponent = class _DxoDataGridFilterBuilderPopupComponent extends NestedOption {
  set _toolbarItemsContentChildren(value2) {
    this.setChildren("toolbarItems", value2);
  }
  get accessKey() {
    return this._getOption("accessKey");
  }
  set accessKey(value2) {
    this._setOption("accessKey", value2);
  }
  get animation() {
    return this._getOption("animation");
  }
  set animation(value2) {
    this._setOption("animation", value2);
  }
  get container() {
    return this._getOption("container");
  }
  set container(value2) {
    this._setOption("container", value2);
  }
  get contentTemplate() {
    return this._getOption("contentTemplate");
  }
  set contentTemplate(value2) {
    this._setOption("contentTemplate", value2);
  }
  get deferRendering() {
    return this._getOption("deferRendering");
  }
  set deferRendering(value2) {
    this._setOption("deferRendering", value2);
  }
  get disabled() {
    return this._getOption("disabled");
  }
  set disabled(value2) {
    this._setOption("disabled", value2);
  }
  get dragAndResizeArea() {
    return this._getOption("dragAndResizeArea");
  }
  set dragAndResizeArea(value2) {
    this._setOption("dragAndResizeArea", value2);
  }
  get dragEnabled() {
    return this._getOption("dragEnabled");
  }
  set dragEnabled(value2) {
    this._setOption("dragEnabled", value2);
  }
  get dragOutsideBoundary() {
    return this._getOption("dragOutsideBoundary");
  }
  set dragOutsideBoundary(value2) {
    this._setOption("dragOutsideBoundary", value2);
  }
  get enableBodyScroll() {
    return this._getOption("enableBodyScroll");
  }
  set enableBodyScroll(value2) {
    this._setOption("enableBodyScroll", value2);
  }
  get focusStateEnabled() {
    return this._getOption("focusStateEnabled");
  }
  set focusStateEnabled(value2) {
    this._setOption("focusStateEnabled", value2);
  }
  get fullScreen() {
    return this._getOption("fullScreen");
  }
  set fullScreen(value2) {
    this._setOption("fullScreen", value2);
  }
  get height() {
    return this._getOption("height");
  }
  set height(value2) {
    this._setOption("height", value2);
  }
  get hideOnOutsideClick() {
    return this._getOption("hideOnOutsideClick");
  }
  set hideOnOutsideClick(value2) {
    this._setOption("hideOnOutsideClick", value2);
  }
  get hideOnParentScroll() {
    return this._getOption("hideOnParentScroll");
  }
  set hideOnParentScroll(value2) {
    this._setOption("hideOnParentScroll", value2);
  }
  get hint() {
    return this._getOption("hint");
  }
  set hint(value2) {
    this._setOption("hint", value2);
  }
  get hoverStateEnabled() {
    return this._getOption("hoverStateEnabled");
  }
  set hoverStateEnabled(value2) {
    this._setOption("hoverStateEnabled", value2);
  }
  get maxHeight() {
    return this._getOption("maxHeight");
  }
  set maxHeight(value2) {
    this._setOption("maxHeight", value2);
  }
  get maxWidth() {
    return this._getOption("maxWidth");
  }
  set maxWidth(value2) {
    this._setOption("maxWidth", value2);
  }
  get minHeight() {
    return this._getOption("minHeight");
  }
  set minHeight(value2) {
    this._setOption("minHeight", value2);
  }
  get minWidth() {
    return this._getOption("minWidth");
  }
  set minWidth(value2) {
    this._setOption("minWidth", value2);
  }
  get onContentReady() {
    return this._getOption("onContentReady");
  }
  set onContentReady(value2) {
    this._setOption("onContentReady", value2);
  }
  get onDisposing() {
    return this._getOption("onDisposing");
  }
  set onDisposing(value2) {
    this._setOption("onDisposing", value2);
  }
  get onHidden() {
    return this._getOption("onHidden");
  }
  set onHidden(value2) {
    this._setOption("onHidden", value2);
  }
  get onHiding() {
    return this._getOption("onHiding");
  }
  set onHiding(value2) {
    this._setOption("onHiding", value2);
  }
  get onInitialized() {
    return this._getOption("onInitialized");
  }
  set onInitialized(value2) {
    this._setOption("onInitialized", value2);
  }
  get onOptionChanged() {
    return this._getOption("onOptionChanged");
  }
  set onOptionChanged(value2) {
    this._setOption("onOptionChanged", value2);
  }
  get onResize() {
    return this._getOption("onResize");
  }
  set onResize(value2) {
    this._setOption("onResize", value2);
  }
  get onResizeEnd() {
    return this._getOption("onResizeEnd");
  }
  set onResizeEnd(value2) {
    this._setOption("onResizeEnd", value2);
  }
  get onResizeStart() {
    return this._getOption("onResizeStart");
  }
  set onResizeStart(value2) {
    this._setOption("onResizeStart", value2);
  }
  get onShowing() {
    return this._getOption("onShowing");
  }
  set onShowing(value2) {
    this._setOption("onShowing", value2);
  }
  get onShown() {
    return this._getOption("onShown");
  }
  set onShown(value2) {
    this._setOption("onShown", value2);
  }
  get onTitleRendered() {
    return this._getOption("onTitleRendered");
  }
  set onTitleRendered(value2) {
    this._setOption("onTitleRendered", value2);
  }
  get position() {
    return this._getOption("position");
  }
  set position(value2) {
    this._setOption("position", value2);
  }
  get resizeEnabled() {
    return this._getOption("resizeEnabled");
  }
  set resizeEnabled(value2) {
    this._setOption("resizeEnabled", value2);
  }
  get restorePosition() {
    return this._getOption("restorePosition");
  }
  set restorePosition(value2) {
    this._setOption("restorePosition", value2);
  }
  get rtlEnabled() {
    return this._getOption("rtlEnabled");
  }
  set rtlEnabled(value2) {
    this._setOption("rtlEnabled", value2);
  }
  get shading() {
    return this._getOption("shading");
  }
  set shading(value2) {
    this._setOption("shading", value2);
  }
  get shadingColor() {
    return this._getOption("shadingColor");
  }
  set shadingColor(value2) {
    this._setOption("shadingColor", value2);
  }
  get showCloseButton() {
    return this._getOption("showCloseButton");
  }
  set showCloseButton(value2) {
    this._setOption("showCloseButton", value2);
  }
  get showTitle() {
    return this._getOption("showTitle");
  }
  set showTitle(value2) {
    this._setOption("showTitle", value2);
  }
  get tabIndex() {
    return this._getOption("tabIndex");
  }
  set tabIndex(value2) {
    this._setOption("tabIndex", value2);
  }
  get title() {
    return this._getOption("title");
  }
  set title(value2) {
    this._setOption("title", value2);
  }
  get titleTemplate() {
    return this._getOption("titleTemplate");
  }
  set titleTemplate(value2) {
    this._setOption("titleTemplate", value2);
  }
  get toolbarItems() {
    return this._getOption("toolbarItems");
  }
  set toolbarItems(value2) {
    this._setOption("toolbarItems", value2);
  }
  get visible() {
    return this._getOption("visible");
  }
  set visible(value2) {
    this._setOption("visible", value2);
  }
  get width() {
    return this._getOption("width");
  }
  set width(value2) {
    this._setOption("width", value2);
  }
  get wrapperAttr() {
    return this._getOption("wrapperAttr");
  }
  set wrapperAttr(value2) {
    this._setOption("wrapperAttr", value2);
  }
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  heightChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  positionChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  visibleChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  widthChange;
  get _optionPath() {
    return "filterBuilderPopup";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    this._createEventEmitters([{
      emit: "heightChange"
    }, {
      emit: "positionChange"
    }, {
      emit: "visibleChange"
    }, {
      emit: "widthChange"
    }]);
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridFilterBuilderPopupComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridFilterBuilderPopupComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridFilterBuilderPopupComponent,
    selectors: [["dxo-data-grid-filter-builder-popup"]],
    contentQueries: function DxoDataGridFilterBuilderPopupComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, PROPERTY_TOKEN_toolbarItems, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._toolbarItemsContentChildren = _t);
      }
    },
    inputs: {
      accessKey: "accessKey",
      animation: "animation",
      container: "container",
      contentTemplate: "contentTemplate",
      deferRendering: "deferRendering",
      disabled: "disabled",
      dragAndResizeArea: "dragAndResizeArea",
      dragEnabled: "dragEnabled",
      dragOutsideBoundary: "dragOutsideBoundary",
      enableBodyScroll: "enableBodyScroll",
      focusStateEnabled: "focusStateEnabled",
      fullScreen: "fullScreen",
      height: "height",
      hideOnOutsideClick: "hideOnOutsideClick",
      hideOnParentScroll: "hideOnParentScroll",
      hint: "hint",
      hoverStateEnabled: "hoverStateEnabled",
      maxHeight: "maxHeight",
      maxWidth: "maxWidth",
      minHeight: "minHeight",
      minWidth: "minWidth",
      onContentReady: "onContentReady",
      onDisposing: "onDisposing",
      onHidden: "onHidden",
      onHiding: "onHiding",
      onInitialized: "onInitialized",
      onOptionChanged: "onOptionChanged",
      onResize: "onResize",
      onResizeEnd: "onResizeEnd",
      onResizeStart: "onResizeStart",
      onShowing: "onShowing",
      onShown: "onShown",
      onTitleRendered: "onTitleRendered",
      position: "position",
      resizeEnabled: "resizeEnabled",
      restorePosition: "restorePosition",
      rtlEnabled: "rtlEnabled",
      shading: "shading",
      shadingColor: "shadingColor",
      showCloseButton: "showCloseButton",
      showTitle: "showTitle",
      tabIndex: "tabIndex",
      title: "title",
      titleTemplate: "titleTemplate",
      toolbarItems: "toolbarItems",
      visible: "visible",
      width: "width",
      wrapperAttr: "wrapperAttr"
    },
    outputs: {
      heightChange: "heightChange",
      positionChange: "positionChange",
      visibleChange: "visibleChange",
      widthChange: "widthChange"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridFilterBuilderPopupComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridFilterBuilderPopupComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-filter-builder-popup",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    _toolbarItemsContentChildren: [{
      type: ContentChildren,
      args: [PROPERTY_TOKEN_toolbarItems]
    }],
    accessKey: [{
      type: Input
    }],
    animation: [{
      type: Input
    }],
    container: [{
      type: Input
    }],
    contentTemplate: [{
      type: Input
    }],
    deferRendering: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    dragAndResizeArea: [{
      type: Input
    }],
    dragEnabled: [{
      type: Input
    }],
    dragOutsideBoundary: [{
      type: Input
    }],
    enableBodyScroll: [{
      type: Input
    }],
    focusStateEnabled: [{
      type: Input
    }],
    fullScreen: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    hideOnOutsideClick: [{
      type: Input
    }],
    hideOnParentScroll: [{
      type: Input
    }],
    hint: [{
      type: Input
    }],
    hoverStateEnabled: [{
      type: Input
    }],
    maxHeight: [{
      type: Input
    }],
    maxWidth: [{
      type: Input
    }],
    minHeight: [{
      type: Input
    }],
    minWidth: [{
      type: Input
    }],
    onContentReady: [{
      type: Input
    }],
    onDisposing: [{
      type: Input
    }],
    onHidden: [{
      type: Input
    }],
    onHiding: [{
      type: Input
    }],
    onInitialized: [{
      type: Input
    }],
    onOptionChanged: [{
      type: Input
    }],
    onResize: [{
      type: Input
    }],
    onResizeEnd: [{
      type: Input
    }],
    onResizeStart: [{
      type: Input
    }],
    onShowing: [{
      type: Input
    }],
    onShown: [{
      type: Input
    }],
    onTitleRendered: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    resizeEnabled: [{
      type: Input
    }],
    restorePosition: [{
      type: Input
    }],
    rtlEnabled: [{
      type: Input
    }],
    shading: [{
      type: Input
    }],
    shadingColor: [{
      type: Input
    }],
    showCloseButton: [{
      type: Input
    }],
    showTitle: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    titleTemplate: [{
      type: Input
    }],
    toolbarItems: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    wrapperAttr: [{
      type: Input
    }],
    heightChange: [{
      type: Output
    }],
    positionChange: [{
      type: Output
    }],
    visibleChange: [{
      type: Output
    }],
    widthChange: [{
      type: Output
    }]
  });
})();
var DxoDataGridFilterBuilderPopupModule = class _DxoDataGridFilterBuilderPopupModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridFilterBuilderPopupModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridFilterBuilderPopupModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridFilterBuilderPopupModule,
    imports: [DxoDataGridFilterBuilderPopupComponent],
    exports: [DxoDataGridFilterBuilderPopupComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridFilterBuilderPopupComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridFilterBuilderPopupModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridFilterBuilderPopupComponent],
      exports: [DxoDataGridFilterBuilderPopupComponent]
    }]
  }], null, null);
})();
var DxoDataGridFilterBuilderComponent = class _DxoDataGridFilterBuilderComponent extends NestedOption {
  set _customOperationsContentChildren(value2) {
    this.setChildren("customOperations", value2);
  }
  set _fieldsContentChildren(value2) {
    this.setChildren("fields", value2);
  }
  get accessKey() {
    return this._getOption("accessKey");
  }
  set accessKey(value2) {
    this._setOption("accessKey", value2);
  }
  get activeStateEnabled() {
    return this._getOption("activeStateEnabled");
  }
  set activeStateEnabled(value2) {
    this._setOption("activeStateEnabled", value2);
  }
  get allowHierarchicalFields() {
    return this._getOption("allowHierarchicalFields");
  }
  set allowHierarchicalFields(value2) {
    this._setOption("allowHierarchicalFields", value2);
  }
  get customOperations() {
    return this._getOption("customOperations");
  }
  set customOperations(value2) {
    this._setOption("customOperations", value2);
  }
  get disabled() {
    return this._getOption("disabled");
  }
  set disabled(value2) {
    this._setOption("disabled", value2);
  }
  get elementAttr() {
    return this._getOption("elementAttr");
  }
  set elementAttr(value2) {
    this._setOption("elementAttr", value2);
  }
  get fields() {
    return this._getOption("fields");
  }
  set fields(value2) {
    this._setOption("fields", value2);
  }
  get filterOperationDescriptions() {
    return this._getOption("filterOperationDescriptions");
  }
  set filterOperationDescriptions(value2) {
    this._setOption("filterOperationDescriptions", value2);
  }
  get focusStateEnabled() {
    return this._getOption("focusStateEnabled");
  }
  set focusStateEnabled(value2) {
    this._setOption("focusStateEnabled", value2);
  }
  get groupOperationDescriptions() {
    return this._getOption("groupOperationDescriptions");
  }
  set groupOperationDescriptions(value2) {
    this._setOption("groupOperationDescriptions", value2);
  }
  get groupOperations() {
    return this._getOption("groupOperations");
  }
  set groupOperations(value2) {
    this._setOption("groupOperations", value2);
  }
  get height() {
    return this._getOption("height");
  }
  set height(value2) {
    this._setOption("height", value2);
  }
  get hint() {
    return this._getOption("hint");
  }
  set hint(value2) {
    this._setOption("hint", value2);
  }
  get hoverStateEnabled() {
    return this._getOption("hoverStateEnabled");
  }
  set hoverStateEnabled(value2) {
    this._setOption("hoverStateEnabled", value2);
  }
  get maxGroupLevel() {
    return this._getOption("maxGroupLevel");
  }
  set maxGroupLevel(value2) {
    this._setOption("maxGroupLevel", value2);
  }
  get onContentReady() {
    return this._getOption("onContentReady");
  }
  set onContentReady(value2) {
    this._setOption("onContentReady", value2);
  }
  get onDisposing() {
    return this._getOption("onDisposing");
  }
  set onDisposing(value2) {
    this._setOption("onDisposing", value2);
  }
  get onEditorPrepared() {
    return this._getOption("onEditorPrepared");
  }
  set onEditorPrepared(value2) {
    this._setOption("onEditorPrepared", value2);
  }
  get onEditorPreparing() {
    return this._getOption("onEditorPreparing");
  }
  set onEditorPreparing(value2) {
    this._setOption("onEditorPreparing", value2);
  }
  get onInitialized() {
    return this._getOption("onInitialized");
  }
  set onInitialized(value2) {
    this._setOption("onInitialized", value2);
  }
  get onOptionChanged() {
    return this._getOption("onOptionChanged");
  }
  set onOptionChanged(value2) {
    this._setOption("onOptionChanged", value2);
  }
  get onValueChanged() {
    return this._getOption("onValueChanged");
  }
  set onValueChanged(value2) {
    this._setOption("onValueChanged", value2);
  }
  get rtlEnabled() {
    return this._getOption("rtlEnabled");
  }
  set rtlEnabled(value2) {
    this._setOption("rtlEnabled", value2);
  }
  get tabIndex() {
    return this._getOption("tabIndex");
  }
  set tabIndex(value2) {
    this._setOption("tabIndex", value2);
  }
  get value() {
    return this._getOption("value");
  }
  set value(value2) {
    this._setOption("value", value2);
  }
  get visible() {
    return this._getOption("visible");
  }
  set visible(value2) {
    this._setOption("visible", value2);
  }
  get width() {
    return this._getOption("width");
  }
  set width(value2) {
    this._setOption("width", value2);
  }
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  valueChange;
  get _optionPath() {
    return "filterBuilder";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    this._createEventEmitters([{
      emit: "valueChange"
    }]);
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridFilterBuilderComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridFilterBuilderComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridFilterBuilderComponent,
    selectors: [["dxo-data-grid-filter-builder"]],
    contentQueries: function DxoDataGridFilterBuilderComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, PROPERTY_TOKEN_customOperations, 4);
        ɵɵcontentQuery(dirIndex, PROPERTY_TOKEN_fields, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._customOperationsContentChildren = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._fieldsContentChildren = _t);
      }
    },
    inputs: {
      accessKey: "accessKey",
      activeStateEnabled: "activeStateEnabled",
      allowHierarchicalFields: "allowHierarchicalFields",
      customOperations: "customOperations",
      disabled: "disabled",
      elementAttr: "elementAttr",
      fields: "fields",
      filterOperationDescriptions: "filterOperationDescriptions",
      focusStateEnabled: "focusStateEnabled",
      groupOperationDescriptions: "groupOperationDescriptions",
      groupOperations: "groupOperations",
      height: "height",
      hint: "hint",
      hoverStateEnabled: "hoverStateEnabled",
      maxGroupLevel: "maxGroupLevel",
      onContentReady: "onContentReady",
      onDisposing: "onDisposing",
      onEditorPrepared: "onEditorPrepared",
      onEditorPreparing: "onEditorPreparing",
      onInitialized: "onInitialized",
      onOptionChanged: "onOptionChanged",
      onValueChanged: "onValueChanged",
      rtlEnabled: "rtlEnabled",
      tabIndex: "tabIndex",
      value: "value",
      visible: "visible",
      width: "width"
    },
    outputs: {
      valueChange: "valueChange"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridFilterBuilderComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridFilterBuilderComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-filter-builder",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    _customOperationsContentChildren: [{
      type: ContentChildren,
      args: [PROPERTY_TOKEN_customOperations]
    }],
    _fieldsContentChildren: [{
      type: ContentChildren,
      args: [PROPERTY_TOKEN_fields]
    }],
    accessKey: [{
      type: Input
    }],
    activeStateEnabled: [{
      type: Input
    }],
    allowHierarchicalFields: [{
      type: Input
    }],
    customOperations: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    elementAttr: [{
      type: Input
    }],
    fields: [{
      type: Input
    }],
    filterOperationDescriptions: [{
      type: Input
    }],
    focusStateEnabled: [{
      type: Input
    }],
    groupOperationDescriptions: [{
      type: Input
    }],
    groupOperations: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    hint: [{
      type: Input
    }],
    hoverStateEnabled: [{
      type: Input
    }],
    maxGroupLevel: [{
      type: Input
    }],
    onContentReady: [{
      type: Input
    }],
    onDisposing: [{
      type: Input
    }],
    onEditorPrepared: [{
      type: Input
    }],
    onEditorPreparing: [{
      type: Input
    }],
    onInitialized: [{
      type: Input
    }],
    onOptionChanged: [{
      type: Input
    }],
    onValueChanged: [{
      type: Input
    }],
    rtlEnabled: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }]
  });
})();
var DxoDataGridFilterBuilderModule = class _DxoDataGridFilterBuilderModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridFilterBuilderModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridFilterBuilderModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridFilterBuilderModule,
    imports: [DxoDataGridFilterBuilderComponent],
    exports: [DxoDataGridFilterBuilderComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridFilterBuilderComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridFilterBuilderModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridFilterBuilderComponent],
      exports: [DxoDataGridFilterBuilderComponent]
    }]
  }], null, null);
})();
var DxoDataGridFilterOperationDescriptionsComponent = class _DxoDataGridFilterOperationDescriptionsComponent extends NestedOption {
  get between() {
    return this._getOption("between");
  }
  set between(value2) {
    this._setOption("between", value2);
  }
  get contains() {
    return this._getOption("contains");
  }
  set contains(value2) {
    this._setOption("contains", value2);
  }
  get endsWith() {
    return this._getOption("endsWith");
  }
  set endsWith(value2) {
    this._setOption("endsWith", value2);
  }
  get equal() {
    return this._getOption("equal");
  }
  set equal(value2) {
    this._setOption("equal", value2);
  }
  get greaterThan() {
    return this._getOption("greaterThan");
  }
  set greaterThan(value2) {
    this._setOption("greaterThan", value2);
  }
  get greaterThanOrEqual() {
    return this._getOption("greaterThanOrEqual");
  }
  set greaterThanOrEqual(value2) {
    this._setOption("greaterThanOrEqual", value2);
  }
  get isBlank() {
    return this._getOption("isBlank");
  }
  set isBlank(value2) {
    this._setOption("isBlank", value2);
  }
  get isNotBlank() {
    return this._getOption("isNotBlank");
  }
  set isNotBlank(value2) {
    this._setOption("isNotBlank", value2);
  }
  get lessThan() {
    return this._getOption("lessThan");
  }
  set lessThan(value2) {
    this._setOption("lessThan", value2);
  }
  get lessThanOrEqual() {
    return this._getOption("lessThanOrEqual");
  }
  set lessThanOrEqual(value2) {
    this._setOption("lessThanOrEqual", value2);
  }
  get notContains() {
    return this._getOption("notContains");
  }
  set notContains(value2) {
    this._setOption("notContains", value2);
  }
  get notEqual() {
    return this._getOption("notEqual");
  }
  set notEqual(value2) {
    this._setOption("notEqual", value2);
  }
  get startsWith() {
    return this._getOption("startsWith");
  }
  set startsWith(value2) {
    this._setOption("startsWith", value2);
  }
  get _optionPath() {
    return "filterOperationDescriptions";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridFilterOperationDescriptionsComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridFilterOperationDescriptionsComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridFilterOperationDescriptionsComponent,
    selectors: [["dxo-data-grid-filter-operation-descriptions"]],
    inputs: {
      between: "between",
      contains: "contains",
      endsWith: "endsWith",
      equal: "equal",
      greaterThan: "greaterThan",
      greaterThanOrEqual: "greaterThanOrEqual",
      isBlank: "isBlank",
      isNotBlank: "isNotBlank",
      lessThan: "lessThan",
      lessThanOrEqual: "lessThanOrEqual",
      notContains: "notContains",
      notEqual: "notEqual",
      startsWith: "startsWith"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridFilterOperationDescriptionsComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridFilterOperationDescriptionsComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-filter-operation-descriptions",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    between: [{
      type: Input
    }],
    contains: [{
      type: Input
    }],
    endsWith: [{
      type: Input
    }],
    equal: [{
      type: Input
    }],
    greaterThan: [{
      type: Input
    }],
    greaterThanOrEqual: [{
      type: Input
    }],
    isBlank: [{
      type: Input
    }],
    isNotBlank: [{
      type: Input
    }],
    lessThan: [{
      type: Input
    }],
    lessThanOrEqual: [{
      type: Input
    }],
    notContains: [{
      type: Input
    }],
    notEqual: [{
      type: Input
    }],
    startsWith: [{
      type: Input
    }]
  });
})();
var DxoDataGridFilterOperationDescriptionsModule = class _DxoDataGridFilterOperationDescriptionsModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridFilterOperationDescriptionsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridFilterOperationDescriptionsModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridFilterOperationDescriptionsModule,
    imports: [DxoDataGridFilterOperationDescriptionsComponent],
    exports: [DxoDataGridFilterOperationDescriptionsComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridFilterOperationDescriptionsComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridFilterOperationDescriptionsModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridFilterOperationDescriptionsComponent],
      exports: [DxoDataGridFilterOperationDescriptionsComponent]
    }]
  }], null, null);
})();
var DxoDataGridFilterPanelTextsComponent = class _DxoDataGridFilterPanelTextsComponent extends NestedOption {
  get clearFilter() {
    return this._getOption("clearFilter");
  }
  set clearFilter(value2) {
    this._setOption("clearFilter", value2);
  }
  get createFilter() {
    return this._getOption("createFilter");
  }
  set createFilter(value2) {
    this._setOption("createFilter", value2);
  }
  get filterEnabledHint() {
    return this._getOption("filterEnabledHint");
  }
  set filterEnabledHint(value2) {
    this._setOption("filterEnabledHint", value2);
  }
  get _optionPath() {
    return "texts";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridFilterPanelTextsComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridFilterPanelTextsComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridFilterPanelTextsComponent,
    selectors: [["dxo-data-grid-filter-panel-texts"]],
    inputs: {
      clearFilter: "clearFilter",
      createFilter: "createFilter",
      filterEnabledHint: "filterEnabledHint"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridFilterPanelTextsComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridFilterPanelTextsComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-filter-panel-texts",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    clearFilter: [{
      type: Input
    }],
    createFilter: [{
      type: Input
    }],
    filterEnabledHint: [{
      type: Input
    }]
  });
})();
var DxoDataGridFilterPanelTextsModule = class _DxoDataGridFilterPanelTextsModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridFilterPanelTextsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridFilterPanelTextsModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridFilterPanelTextsModule,
    imports: [DxoDataGridFilterPanelTextsComponent],
    exports: [DxoDataGridFilterPanelTextsComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridFilterPanelTextsComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridFilterPanelTextsModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridFilterPanelTextsComponent],
      exports: [DxoDataGridFilterPanelTextsComponent]
    }]
  }], null, null);
})();
var DxoDataGridFilterPanelComponent = class _DxoDataGridFilterPanelComponent extends NestedOption {
  get customizeText() {
    return this._getOption("customizeText");
  }
  set customizeText(value2) {
    this._setOption("customizeText", value2);
  }
  get filterEnabled() {
    return this._getOption("filterEnabled");
  }
  set filterEnabled(value2) {
    this._setOption("filterEnabled", value2);
  }
  get texts() {
    return this._getOption("texts");
  }
  set texts(value2) {
    this._setOption("texts", value2);
  }
  get visible() {
    return this._getOption("visible");
  }
  set visible(value2) {
    this._setOption("visible", value2);
  }
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  filterEnabledChange;
  get _optionPath() {
    return "filterPanel";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    this._createEventEmitters([{
      emit: "filterEnabledChange"
    }]);
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridFilterPanelComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridFilterPanelComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridFilterPanelComponent,
    selectors: [["dxo-data-grid-filter-panel"]],
    inputs: {
      customizeText: "customizeText",
      filterEnabled: "filterEnabled",
      texts: "texts",
      visible: "visible"
    },
    outputs: {
      filterEnabledChange: "filterEnabledChange"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridFilterPanelComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridFilterPanelComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-filter-panel",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    customizeText: [{
      type: Input
    }],
    filterEnabled: [{
      type: Input
    }],
    texts: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    filterEnabledChange: [{
      type: Output
    }]
  });
})();
var DxoDataGridFilterPanelModule = class _DxoDataGridFilterPanelModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridFilterPanelModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridFilterPanelModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridFilterPanelModule,
    imports: [DxoDataGridFilterPanelComponent],
    exports: [DxoDataGridFilterPanelComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridFilterPanelComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridFilterPanelModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridFilterPanelComponent],
      exports: [DxoDataGridFilterPanelComponent]
    }]
  }], null, null);
})();
var DxoDataGridFilterRowComponent = class _DxoDataGridFilterRowComponent extends NestedOption {
  get applyFilter() {
    return this._getOption("applyFilter");
  }
  set applyFilter(value2) {
    this._setOption("applyFilter", value2);
  }
  get applyFilterText() {
    return this._getOption("applyFilterText");
  }
  set applyFilterText(value2) {
    this._setOption("applyFilterText", value2);
  }
  get betweenEndText() {
    return this._getOption("betweenEndText");
  }
  set betweenEndText(value2) {
    this._setOption("betweenEndText", value2);
  }
  get betweenStartText() {
    return this._getOption("betweenStartText");
  }
  set betweenStartText(value2) {
    this._setOption("betweenStartText", value2);
  }
  get operationDescriptions() {
    return this._getOption("operationDescriptions");
  }
  set operationDescriptions(value2) {
    this._setOption("operationDescriptions", value2);
  }
  get resetOperationText() {
    return this._getOption("resetOperationText");
  }
  set resetOperationText(value2) {
    this._setOption("resetOperationText", value2);
  }
  get showAllText() {
    return this._getOption("showAllText");
  }
  set showAllText(value2) {
    this._setOption("showAllText", value2);
  }
  get showOperationChooser() {
    return this._getOption("showOperationChooser");
  }
  set showOperationChooser(value2) {
    this._setOption("showOperationChooser", value2);
  }
  get visible() {
    return this._getOption("visible");
  }
  set visible(value2) {
    this._setOption("visible", value2);
  }
  get _optionPath() {
    return "filterRow";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridFilterRowComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridFilterRowComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridFilterRowComponent,
    selectors: [["dxo-data-grid-filter-row"]],
    inputs: {
      applyFilter: "applyFilter",
      applyFilterText: "applyFilterText",
      betweenEndText: "betweenEndText",
      betweenStartText: "betweenStartText",
      operationDescriptions: "operationDescriptions",
      resetOperationText: "resetOperationText",
      showAllText: "showAllText",
      showOperationChooser: "showOperationChooser",
      visible: "visible"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridFilterRowComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridFilterRowComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-filter-row",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    applyFilter: [{
      type: Input
    }],
    applyFilterText: [{
      type: Input
    }],
    betweenEndText: [{
      type: Input
    }],
    betweenStartText: [{
      type: Input
    }],
    operationDescriptions: [{
      type: Input
    }],
    resetOperationText: [{
      type: Input
    }],
    showAllText: [{
      type: Input
    }],
    showOperationChooser: [{
      type: Input
    }],
    visible: [{
      type: Input
    }]
  });
})();
var DxoDataGridFilterRowModule = class _DxoDataGridFilterRowModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridFilterRowModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridFilterRowModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridFilterRowModule,
    imports: [DxoDataGridFilterRowComponent],
    exports: [DxoDataGridFilterRowComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridFilterRowComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridFilterRowModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridFilterRowComponent],
      exports: [DxoDataGridFilterRowComponent]
    }]
  }], null, null);
})();
var DxoDataGridFormItemComponent = class _DxoDataGridFormItemComponent extends NestedOption {
  renderer;
  document;
  element;
  set _validationRulesContentChildren(value2) {
    this.setChildren("validationRules", value2);
  }
  get colSpan() {
    return this._getOption("colSpan");
  }
  set colSpan(value2) {
    this._setOption("colSpan", value2);
  }
  get cssClass() {
    return this._getOption("cssClass");
  }
  set cssClass(value2) {
    this._setOption("cssClass", value2);
  }
  get dataField() {
    return this._getOption("dataField");
  }
  set dataField(value2) {
    this._setOption("dataField", value2);
  }
  get editorOptions() {
    return this._getOption("editorOptions");
  }
  set editorOptions(value2) {
    this._setOption("editorOptions", value2);
  }
  get editorType() {
    return this._getOption("editorType");
  }
  set editorType(value2) {
    this._setOption("editorType", value2);
  }
  get helpText() {
    return this._getOption("helpText");
  }
  set helpText(value2) {
    this._setOption("helpText", value2);
  }
  get isRequired() {
    return this._getOption("isRequired");
  }
  set isRequired(value2) {
    this._setOption("isRequired", value2);
  }
  get itemType() {
    return this._getOption("itemType");
  }
  set itemType(value2) {
    this._setOption("itemType", value2);
  }
  get label() {
    return this._getOption("label");
  }
  set label(value2) {
    this._setOption("label", value2);
  }
  get name() {
    return this._getOption("name");
  }
  set name(value2) {
    this._setOption("name", value2);
  }
  get template() {
    return this._getOption("template");
  }
  set template(value2) {
    this._setOption("template", value2);
  }
  get validationRules() {
    return this._getOption("validationRules");
  }
  set validationRules(value2) {
    this._setOption("validationRules", value2);
  }
  get visible() {
    return this._getOption("visible");
  }
  set visible(value2) {
    this._setOption("visible", value2);
  }
  get visibleIndex() {
    return this._getOption("visibleIndex");
  }
  set visibleIndex(value2) {
    this._setOption("visibleIndex", value2);
  }
  get _optionPath() {
    return "formItem";
  }
  constructor(parentOptionHost, optionHost, renderer, document, templateHost, element) {
    super();
    this.renderer = renderer;
    this.document = document;
    this.element = element;
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
    templateHost.setHost(this);
  }
  setTemplate(template) {
    this.template = template;
  }
  ngAfterViewInit() {
    extractTemplate(this, this.element, this.renderer, this.document);
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridFormItemComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridFormItemComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(DOCUMENT), ɵɵdirectiveInject(DxTemplateHost, 1), ɵɵdirectiveInject(ElementRef));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridFormItemComponent,
    selectors: [["dxo-data-grid-form-item"]],
    contentQueries: function DxoDataGridFormItemComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, PROPERTY_TOKEN_validationRules, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._validationRulesContentChildren = _t);
      }
    },
    inputs: {
      colSpan: "colSpan",
      cssClass: "cssClass",
      dataField: "dataField",
      editorOptions: "editorOptions",
      editorType: "editorType",
      helpText: "helpText",
      isRequired: "isRequired",
      itemType: "itemType",
      label: "label",
      name: "name",
      template: "template",
      validationRules: "validationRules",
      visible: "visible",
      visibleIndex: "visibleIndex"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost, DxTemplateHost]), ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function DxoDataGridFormItemComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    dependencies: [DxIntegrationModule],
    styles: ["[_nghost-%COMP%]{display:block}"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridFormItemComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-form-item",
      standalone: true,
      template: "<ng-content></ng-content>",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost, DxTemplateHost],
      styles: [":host{display:block}\n"]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }, {
    type: Renderer2
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: DxTemplateHost,
    decorators: [{
      type: Host
    }]
  }, {
    type: ElementRef
  }], {
    _validationRulesContentChildren: [{
      type: ContentChildren,
      args: [PROPERTY_TOKEN_validationRules]
    }],
    colSpan: [{
      type: Input
    }],
    cssClass: [{
      type: Input
    }],
    dataField: [{
      type: Input
    }],
    editorOptions: [{
      type: Input
    }],
    editorType: [{
      type: Input
    }],
    helpText: [{
      type: Input
    }],
    isRequired: [{
      type: Input
    }],
    itemType: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    template: [{
      type: Input
    }],
    validationRules: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    visibleIndex: [{
      type: Input
    }]
  });
})();
var DxoDataGridFormItemModule = class _DxoDataGridFormItemModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridFormItemModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridFormItemModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridFormItemModule,
    imports: [DxoDataGridFormItemComponent],
    exports: [DxoDataGridFormItemComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridFormItemComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridFormItemModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridFormItemComponent],
      exports: [DxoDataGridFormItemComponent]
    }]
  }], null, null);
})();
var DxoDataGridFormComponent = class _DxoDataGridFormComponent extends NestedOption {
  get accessKey() {
    return this._getOption("accessKey");
  }
  set accessKey(value2) {
    this._setOption("accessKey", value2);
  }
  get activeStateEnabled() {
    return this._getOption("activeStateEnabled");
  }
  set activeStateEnabled(value2) {
    this._setOption("activeStateEnabled", value2);
  }
  get alignItemLabels() {
    return this._getOption("alignItemLabels");
  }
  set alignItemLabels(value2) {
    this._setOption("alignItemLabels", value2);
  }
  get alignItemLabelsInAllGroups() {
    return this._getOption("alignItemLabelsInAllGroups");
  }
  set alignItemLabelsInAllGroups(value2) {
    this._setOption("alignItemLabelsInAllGroups", value2);
  }
  get colCount() {
    return this._getOption("colCount");
  }
  set colCount(value2) {
    this._setOption("colCount", value2);
  }
  get colCountByScreen() {
    return this._getOption("colCountByScreen");
  }
  set colCountByScreen(value2) {
    this._setOption("colCountByScreen", value2);
  }
  get customizeItem() {
    return this._getOption("customizeItem");
  }
  set customizeItem(value2) {
    this._setOption("customizeItem", value2);
  }
  get disabled() {
    return this._getOption("disabled");
  }
  set disabled(value2) {
    this._setOption("disabled", value2);
  }
  get elementAttr() {
    return this._getOption("elementAttr");
  }
  set elementAttr(value2) {
    this._setOption("elementAttr", value2);
  }
  get focusStateEnabled() {
    return this._getOption("focusStateEnabled");
  }
  set focusStateEnabled(value2) {
    this._setOption("focusStateEnabled", value2);
  }
  get formData() {
    return this._getOption("formData");
  }
  set formData(value2) {
    this._setOption("formData", value2);
  }
  get height() {
    return this._getOption("height");
  }
  set height(value2) {
    this._setOption("height", value2);
  }
  get hint() {
    return this._getOption("hint");
  }
  set hint(value2) {
    this._setOption("hint", value2);
  }
  get hoverStateEnabled() {
    return this._getOption("hoverStateEnabled");
  }
  set hoverStateEnabled(value2) {
    this._setOption("hoverStateEnabled", value2);
  }
  get isDirty() {
    return this._getOption("isDirty");
  }
  set isDirty(value2) {
    this._setOption("isDirty", value2);
  }
  get items() {
    return this._getOption("items");
  }
  set items(value2) {
    this._setOption("items", value2);
  }
  get labelLocation() {
    return this._getOption("labelLocation");
  }
  set labelLocation(value2) {
    this._setOption("labelLocation", value2);
  }
  get labelMode() {
    return this._getOption("labelMode");
  }
  set labelMode(value2) {
    this._setOption("labelMode", value2);
  }
  get minColWidth() {
    return this._getOption("minColWidth");
  }
  set minColWidth(value2) {
    this._setOption("minColWidth", value2);
  }
  get onContentReady() {
    return this._getOption("onContentReady");
  }
  set onContentReady(value2) {
    this._setOption("onContentReady", value2);
  }
  get onDisposing() {
    return this._getOption("onDisposing");
  }
  set onDisposing(value2) {
    this._setOption("onDisposing", value2);
  }
  get onEditorEnterKey() {
    return this._getOption("onEditorEnterKey");
  }
  set onEditorEnterKey(value2) {
    this._setOption("onEditorEnterKey", value2);
  }
  get onFieldDataChanged() {
    return this._getOption("onFieldDataChanged");
  }
  set onFieldDataChanged(value2) {
    this._setOption("onFieldDataChanged", value2);
  }
  get onInitialized() {
    return this._getOption("onInitialized");
  }
  set onInitialized(value2) {
    this._setOption("onInitialized", value2);
  }
  get onOptionChanged() {
    return this._getOption("onOptionChanged");
  }
  set onOptionChanged(value2) {
    this._setOption("onOptionChanged", value2);
  }
  get optionalMark() {
    return this._getOption("optionalMark");
  }
  set optionalMark(value2) {
    this._setOption("optionalMark", value2);
  }
  get readOnly() {
    return this._getOption("readOnly");
  }
  set readOnly(value2) {
    this._setOption("readOnly", value2);
  }
  get requiredMark() {
    return this._getOption("requiredMark");
  }
  set requiredMark(value2) {
    this._setOption("requiredMark", value2);
  }
  get requiredMessage() {
    return this._getOption("requiredMessage");
  }
  set requiredMessage(value2) {
    this._setOption("requiredMessage", value2);
  }
  get rtlEnabled() {
    return this._getOption("rtlEnabled");
  }
  set rtlEnabled(value2) {
    this._setOption("rtlEnabled", value2);
  }
  get screenByWidth() {
    return this._getOption("screenByWidth");
  }
  set screenByWidth(value2) {
    this._setOption("screenByWidth", value2);
  }
  get scrollingEnabled() {
    return this._getOption("scrollingEnabled");
  }
  set scrollingEnabled(value2) {
    this._setOption("scrollingEnabled", value2);
  }
  get showColonAfterLabel() {
    return this._getOption("showColonAfterLabel");
  }
  set showColonAfterLabel(value2) {
    this._setOption("showColonAfterLabel", value2);
  }
  get showOptionalMark() {
    return this._getOption("showOptionalMark");
  }
  set showOptionalMark(value2) {
    this._setOption("showOptionalMark", value2);
  }
  get showRequiredMark() {
    return this._getOption("showRequiredMark");
  }
  set showRequiredMark(value2) {
    this._setOption("showRequiredMark", value2);
  }
  get showValidationSummary() {
    return this._getOption("showValidationSummary");
  }
  set showValidationSummary(value2) {
    this._setOption("showValidationSummary", value2);
  }
  get tabIndex() {
    return this._getOption("tabIndex");
  }
  set tabIndex(value2) {
    this._setOption("tabIndex", value2);
  }
  get validationGroup() {
    return this._getOption("validationGroup");
  }
  set validationGroup(value2) {
    this._setOption("validationGroup", value2);
  }
  get visible() {
    return this._getOption("visible");
  }
  set visible(value2) {
    this._setOption("visible", value2);
  }
  get width() {
    return this._getOption("width");
  }
  set width(value2) {
    this._setOption("width", value2);
  }
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  formDataChange;
  get _optionPath() {
    return "form";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    this._createEventEmitters([{
      emit: "formDataChange"
    }]);
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridFormComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridFormComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridFormComponent,
    selectors: [["dxo-data-grid-form"]],
    inputs: {
      accessKey: "accessKey",
      activeStateEnabled: "activeStateEnabled",
      alignItemLabels: "alignItemLabels",
      alignItemLabelsInAllGroups: "alignItemLabelsInAllGroups",
      colCount: "colCount",
      colCountByScreen: "colCountByScreen",
      customizeItem: "customizeItem",
      disabled: "disabled",
      elementAttr: "elementAttr",
      focusStateEnabled: "focusStateEnabled",
      formData: "formData",
      height: "height",
      hint: "hint",
      hoverStateEnabled: "hoverStateEnabled",
      isDirty: "isDirty",
      items: "items",
      labelLocation: "labelLocation",
      labelMode: "labelMode",
      minColWidth: "minColWidth",
      onContentReady: "onContentReady",
      onDisposing: "onDisposing",
      onEditorEnterKey: "onEditorEnterKey",
      onFieldDataChanged: "onFieldDataChanged",
      onInitialized: "onInitialized",
      onOptionChanged: "onOptionChanged",
      optionalMark: "optionalMark",
      readOnly: "readOnly",
      requiredMark: "requiredMark",
      requiredMessage: "requiredMessage",
      rtlEnabled: "rtlEnabled",
      screenByWidth: "screenByWidth",
      scrollingEnabled: "scrollingEnabled",
      showColonAfterLabel: "showColonAfterLabel",
      showOptionalMark: "showOptionalMark",
      showRequiredMark: "showRequiredMark",
      showValidationSummary: "showValidationSummary",
      tabIndex: "tabIndex",
      validationGroup: "validationGroup",
      visible: "visible",
      width: "width"
    },
    outputs: {
      formDataChange: "formDataChange"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridFormComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridFormComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-form",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    accessKey: [{
      type: Input
    }],
    activeStateEnabled: [{
      type: Input
    }],
    alignItemLabels: [{
      type: Input
    }],
    alignItemLabelsInAllGroups: [{
      type: Input
    }],
    colCount: [{
      type: Input
    }],
    colCountByScreen: [{
      type: Input
    }],
    customizeItem: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    elementAttr: [{
      type: Input
    }],
    focusStateEnabled: [{
      type: Input
    }],
    formData: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    hint: [{
      type: Input
    }],
    hoverStateEnabled: [{
      type: Input
    }],
    isDirty: [{
      type: Input
    }],
    items: [{
      type: Input
    }],
    labelLocation: [{
      type: Input
    }],
    labelMode: [{
      type: Input
    }],
    minColWidth: [{
      type: Input
    }],
    onContentReady: [{
      type: Input
    }],
    onDisposing: [{
      type: Input
    }],
    onEditorEnterKey: [{
      type: Input
    }],
    onFieldDataChanged: [{
      type: Input
    }],
    onInitialized: [{
      type: Input
    }],
    onOptionChanged: [{
      type: Input
    }],
    optionalMark: [{
      type: Input
    }],
    readOnly: [{
      type: Input
    }],
    requiredMark: [{
      type: Input
    }],
    requiredMessage: [{
      type: Input
    }],
    rtlEnabled: [{
      type: Input
    }],
    screenByWidth: [{
      type: Input
    }],
    scrollingEnabled: [{
      type: Input
    }],
    showColonAfterLabel: [{
      type: Input
    }],
    showOptionalMark: [{
      type: Input
    }],
    showRequiredMark: [{
      type: Input
    }],
    showValidationSummary: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    validationGroup: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    formDataChange: [{
      type: Output
    }]
  });
})();
var DxoDataGridFormModule = class _DxoDataGridFormModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridFormModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridFormModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridFormModule,
    imports: [DxoDataGridFormComponent],
    exports: [DxoDataGridFormComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridFormComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridFormModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridFormComponent],
      exports: [DxoDataGridFormComponent]
    }]
  }], null, null);
})();
var DxoDataGridFormatComponent = class _DxoDataGridFormatComponent extends NestedOption {
  get currency() {
    return this._getOption("currency");
  }
  set currency(value2) {
    this._setOption("currency", value2);
  }
  get formatter() {
    return this._getOption("formatter");
  }
  set formatter(value2) {
    this._setOption("formatter", value2);
  }
  get parser() {
    return this._getOption("parser");
  }
  set parser(value2) {
    this._setOption("parser", value2);
  }
  get precision() {
    return this._getOption("precision");
  }
  set precision(value2) {
    this._setOption("precision", value2);
  }
  get type() {
    return this._getOption("type");
  }
  set type(value2) {
    this._setOption("type", value2);
  }
  get useCurrencyAccountingStyle() {
    return this._getOption("useCurrencyAccountingStyle");
  }
  set useCurrencyAccountingStyle(value2) {
    this._setOption("useCurrencyAccountingStyle", value2);
  }
  get _optionPath() {
    return "format";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridFormatComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridFormatComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridFormatComponent,
    selectors: [["dxo-data-grid-format"]],
    inputs: {
      currency: "currency",
      formatter: "formatter",
      parser: "parser",
      precision: "precision",
      type: "type",
      useCurrencyAccountingStyle: "useCurrencyAccountingStyle"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridFormatComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridFormatComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-format",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    currency: [{
      type: Input
    }],
    formatter: [{
      type: Input
    }],
    parser: [{
      type: Input
    }],
    precision: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    useCurrencyAccountingStyle: [{
      type: Input
    }]
  });
})();
var DxoDataGridFormatModule = class _DxoDataGridFormatModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridFormatModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridFormatModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridFormatModule,
    imports: [DxoDataGridFormatComponent],
    exports: [DxoDataGridFormatComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridFormatComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridFormatModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridFormatComponent],
      exports: [DxoDataGridFormatComponent]
    }]
  }], null, null);
})();
var DxoDataGridFromComponent = class _DxoDataGridFromComponent extends NestedOption {
  get left() {
    return this._getOption("left");
  }
  set left(value2) {
    this._setOption("left", value2);
  }
  get opacity() {
    return this._getOption("opacity");
  }
  set opacity(value2) {
    this._setOption("opacity", value2);
  }
  get position() {
    return this._getOption("position");
  }
  set position(value2) {
    this._setOption("position", value2);
  }
  get scale() {
    return this._getOption("scale");
  }
  set scale(value2) {
    this._setOption("scale", value2);
  }
  get top() {
    return this._getOption("top");
  }
  set top(value2) {
    this._setOption("top", value2);
  }
  get _optionPath() {
    return "from";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridFromComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridFromComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridFromComponent,
    selectors: [["dxo-data-grid-from"]],
    inputs: {
      left: "left",
      opacity: "opacity",
      position: "position",
      scale: "scale",
      top: "top"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridFromComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridFromComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-from",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    left: [{
      type: Input
    }],
    opacity: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    scale: [{
      type: Input
    }],
    top: [{
      type: Input
    }]
  });
})();
var DxoDataGridFromModule = class _DxoDataGridFromModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridFromModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridFromModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridFromModule,
    imports: [DxoDataGridFromComponent],
    exports: [DxoDataGridFromComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridFromComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridFromModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridFromComponent],
      exports: [DxoDataGridFromComponent]
    }]
  }], null, null);
})();
var DxiDataGridGroupItemComponent = class _DxiDataGridGroupItemComponent extends CollectionNestedOption {
  get alignByColumn() {
    return this._getOption("alignByColumn");
  }
  set alignByColumn(value2) {
    this._setOption("alignByColumn", value2);
  }
  get column() {
    return this._getOption("column");
  }
  set column(value2) {
    this._setOption("column", value2);
  }
  get customizeText() {
    return this._getOption("customizeText");
  }
  set customizeText(value2) {
    this._setOption("customizeText", value2);
  }
  get displayFormat() {
    return this._getOption("displayFormat");
  }
  set displayFormat(value2) {
    this._setOption("displayFormat", value2);
  }
  get name() {
    return this._getOption("name");
  }
  set name(value2) {
    this._setOption("name", value2);
  }
  get showInColumn() {
    return this._getOption("showInColumn");
  }
  set showInColumn(value2) {
    this._setOption("showInColumn", value2);
  }
  get showInGroupFooter() {
    return this._getOption("showInGroupFooter");
  }
  set showInGroupFooter(value2) {
    this._setOption("showInGroupFooter", value2);
  }
  get skipEmptyValues() {
    return this._getOption("skipEmptyValues");
  }
  set skipEmptyValues(value2) {
    this._setOption("skipEmptyValues", value2);
  }
  get summaryType() {
    return this._getOption("summaryType");
  }
  set summaryType(value2) {
    this._setOption("summaryType", value2);
  }
  get valueFormat() {
    return this._getOption("valueFormat");
  }
  set valueFormat(value2) {
    this._setOption("valueFormat", value2);
  }
  get _optionPath() {
    return "groupItems";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnDestroy() {
    this._deleteRemovedOptions(this._fullOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxiDataGridGroupItemComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridGroupItemComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxiDataGridGroupItemComponent,
    selectors: [["dxi-data-grid-group-item"]],
    inputs: {
      alignByColumn: "alignByColumn",
      column: "column",
      customizeText: "customizeText",
      displayFormat: "displayFormat",
      name: "name",
      showInColumn: "showInColumn",
      showInGroupFooter: "showInGroupFooter",
      skipEmptyValues: "skipEmptyValues",
      summaryType: "summaryType",
      valueFormat: "valueFormat"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost, {
      provide: PROPERTY_TOKEN_groupItems,
      useExisting: _DxiDataGridGroupItemComponent
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxiDataGridGroupItemComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridGroupItemComponent, [{
    type: Component,
    args: [{
      selector: "dxi-data-grid-group-item",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost, {
        provide: PROPERTY_TOKEN_groupItems,
        useExisting: DxiDataGridGroupItemComponent
      }]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    alignByColumn: [{
      type: Input
    }],
    column: [{
      type: Input
    }],
    customizeText: [{
      type: Input
    }],
    displayFormat: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    showInColumn: [{
      type: Input
    }],
    showInGroupFooter: [{
      type: Input
    }],
    skipEmptyValues: [{
      type: Input
    }],
    summaryType: [{
      type: Input
    }],
    valueFormat: [{
      type: Input
    }]
  });
})();
var DxiDataGridGroupItemModule = class _DxiDataGridGroupItemModule {
  /** @nocollapse */
  static ɵfac = function DxiDataGridGroupItemModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridGroupItemModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxiDataGridGroupItemModule,
    imports: [DxiDataGridGroupItemComponent],
    exports: [DxiDataGridGroupItemComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxiDataGridGroupItemComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridGroupItemModule, [{
    type: NgModule,
    args: [{
      imports: [DxiDataGridGroupItemComponent],
      exports: [DxiDataGridGroupItemComponent]
    }]
  }], null, null);
})();
var DxoDataGridGroupOperationDescriptionsComponent = class _DxoDataGridGroupOperationDescriptionsComponent extends NestedOption {
  get and() {
    return this._getOption("and");
  }
  set and(value2) {
    this._setOption("and", value2);
  }
  get notAnd() {
    return this._getOption("notAnd");
  }
  set notAnd(value2) {
    this._setOption("notAnd", value2);
  }
  get notOr() {
    return this._getOption("notOr");
  }
  set notOr(value2) {
    this._setOption("notOr", value2);
  }
  get or() {
    return this._getOption("or");
  }
  set or(value2) {
    this._setOption("or", value2);
  }
  get _optionPath() {
    return "groupOperationDescriptions";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridGroupOperationDescriptionsComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridGroupOperationDescriptionsComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridGroupOperationDescriptionsComponent,
    selectors: [["dxo-data-grid-group-operation-descriptions"]],
    inputs: {
      and: "and",
      notAnd: "notAnd",
      notOr: "notOr",
      or: "or"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridGroupOperationDescriptionsComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridGroupOperationDescriptionsComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-group-operation-descriptions",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    and: [{
      type: Input
    }],
    notAnd: [{
      type: Input
    }],
    notOr: [{
      type: Input
    }],
    or: [{
      type: Input
    }]
  });
})();
var DxoDataGridGroupOperationDescriptionsModule = class _DxoDataGridGroupOperationDescriptionsModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridGroupOperationDescriptionsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridGroupOperationDescriptionsModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridGroupOperationDescriptionsModule,
    imports: [DxoDataGridGroupOperationDescriptionsComponent],
    exports: [DxoDataGridGroupOperationDescriptionsComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridGroupOperationDescriptionsComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridGroupOperationDescriptionsModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridGroupOperationDescriptionsComponent],
      exports: [DxoDataGridGroupOperationDescriptionsComponent]
    }]
  }], null, null);
})();
var DxoDataGridGroupPanelComponent = class _DxoDataGridGroupPanelComponent extends NestedOption {
  get allowColumnDragging() {
    return this._getOption("allowColumnDragging");
  }
  set allowColumnDragging(value2) {
    this._setOption("allowColumnDragging", value2);
  }
  get emptyPanelText() {
    return this._getOption("emptyPanelText");
  }
  set emptyPanelText(value2) {
    this._setOption("emptyPanelText", value2);
  }
  get visible() {
    return this._getOption("visible");
  }
  set visible(value2) {
    this._setOption("visible", value2);
  }
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  visibleChange;
  get _optionPath() {
    return "groupPanel";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    this._createEventEmitters([{
      emit: "visibleChange"
    }]);
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridGroupPanelComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridGroupPanelComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridGroupPanelComponent,
    selectors: [["dxo-data-grid-group-panel"]],
    inputs: {
      allowColumnDragging: "allowColumnDragging",
      emptyPanelText: "emptyPanelText",
      visible: "visible"
    },
    outputs: {
      visibleChange: "visibleChange"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridGroupPanelComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridGroupPanelComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-group-panel",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    allowColumnDragging: [{
      type: Input
    }],
    emptyPanelText: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    visibleChange: [{
      type: Output
    }]
  });
})();
var DxoDataGridGroupPanelModule = class _DxoDataGridGroupPanelModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridGroupPanelModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridGroupPanelModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridGroupPanelModule,
    imports: [DxoDataGridGroupPanelComponent],
    exports: [DxoDataGridGroupPanelComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridGroupPanelComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridGroupPanelModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridGroupPanelComponent],
      exports: [DxoDataGridGroupPanelComponent]
    }]
  }], null, null);
})();
var DxoDataGridGroupingTextsComponent = class _DxoDataGridGroupingTextsComponent extends NestedOption {
  get groupByThisColumn() {
    return this._getOption("groupByThisColumn");
  }
  set groupByThisColumn(value2) {
    this._setOption("groupByThisColumn", value2);
  }
  get groupContinuedMessage() {
    return this._getOption("groupContinuedMessage");
  }
  set groupContinuedMessage(value2) {
    this._setOption("groupContinuedMessage", value2);
  }
  get groupContinuesMessage() {
    return this._getOption("groupContinuesMessage");
  }
  set groupContinuesMessage(value2) {
    this._setOption("groupContinuesMessage", value2);
  }
  get ungroup() {
    return this._getOption("ungroup");
  }
  set ungroup(value2) {
    this._setOption("ungroup", value2);
  }
  get ungroupAll() {
    return this._getOption("ungroupAll");
  }
  set ungroupAll(value2) {
    this._setOption("ungroupAll", value2);
  }
  get _optionPath() {
    return "texts";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridGroupingTextsComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridGroupingTextsComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridGroupingTextsComponent,
    selectors: [["dxo-data-grid-grouping-texts"]],
    inputs: {
      groupByThisColumn: "groupByThisColumn",
      groupContinuedMessage: "groupContinuedMessage",
      groupContinuesMessage: "groupContinuesMessage",
      ungroup: "ungroup",
      ungroupAll: "ungroupAll"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridGroupingTextsComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridGroupingTextsComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-grouping-texts",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    groupByThisColumn: [{
      type: Input
    }],
    groupContinuedMessage: [{
      type: Input
    }],
    groupContinuesMessage: [{
      type: Input
    }],
    ungroup: [{
      type: Input
    }],
    ungroupAll: [{
      type: Input
    }]
  });
})();
var DxoDataGridGroupingTextsModule = class _DxoDataGridGroupingTextsModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridGroupingTextsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridGroupingTextsModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridGroupingTextsModule,
    imports: [DxoDataGridGroupingTextsComponent],
    exports: [DxoDataGridGroupingTextsComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridGroupingTextsComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridGroupingTextsModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridGroupingTextsComponent],
      exports: [DxoDataGridGroupingTextsComponent]
    }]
  }], null, null);
})();
var DxoDataGridGroupingComponent = class _DxoDataGridGroupingComponent extends NestedOption {
  get allowCollapsing() {
    return this._getOption("allowCollapsing");
  }
  set allowCollapsing(value2) {
    this._setOption("allowCollapsing", value2);
  }
  get autoExpandAll() {
    return this._getOption("autoExpandAll");
  }
  set autoExpandAll(value2) {
    this._setOption("autoExpandAll", value2);
  }
  get contextMenuEnabled() {
    return this._getOption("contextMenuEnabled");
  }
  set contextMenuEnabled(value2) {
    this._setOption("contextMenuEnabled", value2);
  }
  get expandMode() {
    return this._getOption("expandMode");
  }
  set expandMode(value2) {
    this._setOption("expandMode", value2);
  }
  get texts() {
    return this._getOption("texts");
  }
  set texts(value2) {
    this._setOption("texts", value2);
  }
  get _optionPath() {
    return "grouping";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridGroupingComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridGroupingComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridGroupingComponent,
    selectors: [["dxo-data-grid-grouping"]],
    inputs: {
      allowCollapsing: "allowCollapsing",
      autoExpandAll: "autoExpandAll",
      contextMenuEnabled: "contextMenuEnabled",
      expandMode: "expandMode",
      texts: "texts"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridGroupingComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridGroupingComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-grouping",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    allowCollapsing: [{
      type: Input
    }],
    autoExpandAll: [{
      type: Input
    }],
    contextMenuEnabled: [{
      type: Input
    }],
    expandMode: [{
      type: Input
    }],
    texts: [{
      type: Input
    }]
  });
})();
var DxoDataGridGroupingModule = class _DxoDataGridGroupingModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridGroupingModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridGroupingModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridGroupingModule,
    imports: [DxoDataGridGroupingComponent],
    exports: [DxoDataGridGroupingComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridGroupingComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridGroupingModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridGroupingComponent],
      exports: [DxoDataGridGroupingComponent]
    }]
  }], null, null);
})();
var DxoDataGridHeaderFilterComponent = class _DxoDataGridHeaderFilterComponent extends NestedOption {
  get allowSearch() {
    return this._getOption("allowSearch");
  }
  set allowSearch(value2) {
    this._setOption("allowSearch", value2);
  }
  get allowSelectAll() {
    return this._getOption("allowSelectAll");
  }
  set allowSelectAll(value2) {
    this._setOption("allowSelectAll", value2);
  }
  get dataSource() {
    return this._getOption("dataSource");
  }
  set dataSource(value2) {
    this._setOption("dataSource", value2);
  }
  get groupInterval() {
    return this._getOption("groupInterval");
  }
  set groupInterval(value2) {
    this._setOption("groupInterval", value2);
  }
  get height() {
    return this._getOption("height");
  }
  set height(value2) {
    this._setOption("height", value2);
  }
  get search() {
    return this._getOption("search");
  }
  set search(value2) {
    this._setOption("search", value2);
  }
  get searchMode() {
    return this._getOption("searchMode");
  }
  set searchMode(value2) {
    this._setOption("searchMode", value2);
  }
  get width() {
    return this._getOption("width");
  }
  set width(value2) {
    this._setOption("width", value2);
  }
  get searchTimeout() {
    return this._getOption("searchTimeout");
  }
  set searchTimeout(value2) {
    this._setOption("searchTimeout", value2);
  }
  get texts() {
    return this._getOption("texts");
  }
  set texts(value2) {
    this._setOption("texts", value2);
  }
  get visible() {
    return this._getOption("visible");
  }
  set visible(value2) {
    this._setOption("visible", value2);
  }
  get _optionPath() {
    return "headerFilter";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridHeaderFilterComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridHeaderFilterComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridHeaderFilterComponent,
    selectors: [["dxo-data-grid-header-filter"]],
    inputs: {
      allowSearch: "allowSearch",
      allowSelectAll: "allowSelectAll",
      dataSource: "dataSource",
      groupInterval: "groupInterval",
      height: "height",
      search: "search",
      searchMode: "searchMode",
      width: "width",
      searchTimeout: "searchTimeout",
      texts: "texts",
      visible: "visible"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridHeaderFilterComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridHeaderFilterComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-header-filter",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    allowSearch: [{
      type: Input
    }],
    allowSelectAll: [{
      type: Input
    }],
    dataSource: [{
      type: Input
    }],
    groupInterval: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    search: [{
      type: Input
    }],
    searchMode: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    searchTimeout: [{
      type: Input
    }],
    texts: [{
      type: Input
    }],
    visible: [{
      type: Input
    }]
  });
})();
var DxoDataGridHeaderFilterModule = class _DxoDataGridHeaderFilterModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridHeaderFilterModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridHeaderFilterModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridHeaderFilterModule,
    imports: [DxoDataGridHeaderFilterComponent],
    exports: [DxoDataGridHeaderFilterComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridHeaderFilterComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridHeaderFilterModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridHeaderFilterComponent],
      exports: [DxoDataGridHeaderFilterComponent]
    }]
  }], null, null);
})();
var DxoDataGridHideComponent = class _DxoDataGridHideComponent extends NestedOption {
  get complete() {
    return this._getOption("complete");
  }
  set complete(value2) {
    this._setOption("complete", value2);
  }
  get delay() {
    return this._getOption("delay");
  }
  set delay(value2) {
    this._setOption("delay", value2);
  }
  get direction() {
    return this._getOption("direction");
  }
  set direction(value2) {
    this._setOption("direction", value2);
  }
  get duration() {
    return this._getOption("duration");
  }
  set duration(value2) {
    this._setOption("duration", value2);
  }
  get easing() {
    return this._getOption("easing");
  }
  set easing(value2) {
    this._setOption("easing", value2);
  }
  get from() {
    return this._getOption("from");
  }
  set from(value2) {
    this._setOption("from", value2);
  }
  get staggerDelay() {
    return this._getOption("staggerDelay");
  }
  set staggerDelay(value2) {
    this._setOption("staggerDelay", value2);
  }
  get start() {
    return this._getOption("start");
  }
  set start(value2) {
    this._setOption("start", value2);
  }
  get to() {
    return this._getOption("to");
  }
  set to(value2) {
    this._setOption("to", value2);
  }
  get type() {
    return this._getOption("type");
  }
  set type(value2) {
    this._setOption("type", value2);
  }
  get _optionPath() {
    return "hide";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridHideComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridHideComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridHideComponent,
    selectors: [["dxo-data-grid-hide"]],
    inputs: {
      complete: "complete",
      delay: "delay",
      direction: "direction",
      duration: "duration",
      easing: "easing",
      from: "from",
      staggerDelay: "staggerDelay",
      start: "start",
      to: "to",
      type: "type"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridHideComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridHideComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-hide",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    complete: [{
      type: Input
    }],
    delay: [{
      type: Input
    }],
    direction: [{
      type: Input
    }],
    duration: [{
      type: Input
    }],
    easing: [{
      type: Input
    }],
    from: [{
      type: Input
    }],
    staggerDelay: [{
      type: Input
    }],
    start: [{
      type: Input
    }],
    to: [{
      type: Input
    }],
    type: [{
      type: Input
    }]
  });
})();
var DxoDataGridHideModule = class _DxoDataGridHideModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridHideModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridHideModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridHideModule,
    imports: [DxoDataGridHideComponent],
    exports: [DxoDataGridHideComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridHideComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridHideModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridHideComponent],
      exports: [DxoDataGridHideComponent]
    }]
  }], null, null);
})();
var DxoDataGridIconsComponent = class _DxoDataGridIconsComponent extends NestedOption {
  get fix() {
    return this._getOption("fix");
  }
  set fix(value2) {
    this._setOption("fix", value2);
  }
  get leftPosition() {
    return this._getOption("leftPosition");
  }
  set leftPosition(value2) {
    this._setOption("leftPosition", value2);
  }
  get rightPosition() {
    return this._getOption("rightPosition");
  }
  set rightPosition(value2) {
    this._setOption("rightPosition", value2);
  }
  get stickyPosition() {
    return this._getOption("stickyPosition");
  }
  set stickyPosition(value2) {
    this._setOption("stickyPosition", value2);
  }
  get unfix() {
    return this._getOption("unfix");
  }
  set unfix(value2) {
    this._setOption("unfix", value2);
  }
  get _optionPath() {
    return "icons";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridIconsComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridIconsComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridIconsComponent,
    selectors: [["dxo-data-grid-icons"]],
    inputs: {
      fix: "fix",
      leftPosition: "leftPosition",
      rightPosition: "rightPosition",
      stickyPosition: "stickyPosition",
      unfix: "unfix"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridIconsComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridIconsComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-icons",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    fix: [{
      type: Input
    }],
    leftPosition: [{
      type: Input
    }],
    rightPosition: [{
      type: Input
    }],
    stickyPosition: [{
      type: Input
    }],
    unfix: [{
      type: Input
    }]
  });
})();
var DxoDataGridIconsModule = class _DxoDataGridIconsModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridIconsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridIconsModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridIconsModule,
    imports: [DxoDataGridIconsComponent],
    exports: [DxoDataGridIconsComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridIconsComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridIconsModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridIconsComponent],
      exports: [DxoDataGridIconsComponent]
    }]
  }], null, null);
})();
var DxiDataGridItemComponent = class _DxiDataGridItemComponent extends CollectionNestedOption {
  renderer;
  document;
  element;
  get cssClass() {
    return this._getOption("cssClass");
  }
  set cssClass(value2) {
    this._setOption("cssClass", value2);
  }
  get disabled() {
    return this._getOption("disabled");
  }
  set disabled(value2) {
    this._setOption("disabled", value2);
  }
  get html() {
    return this._getOption("html");
  }
  set html(value2) {
    this._setOption("html", value2);
  }
  get locateInMenu() {
    return this._getOption("locateInMenu");
  }
  set locateInMenu(value2) {
    this._setOption("locateInMenu", value2);
  }
  get location() {
    return this._getOption("location");
  }
  set location(value2) {
    this._setOption("location", value2);
  }
  get menuItemTemplate() {
    return this._getOption("menuItemTemplate");
  }
  set menuItemTemplate(value2) {
    this._setOption("menuItemTemplate", value2);
  }
  get name() {
    return this._getOption("name");
  }
  set name(value2) {
    this._setOption("name", value2);
  }
  get options() {
    return this._getOption("options");
  }
  set options(value2) {
    this._setOption("options", value2);
  }
  get showText() {
    return this._getOption("showText");
  }
  set showText(value2) {
    this._setOption("showText", value2);
  }
  get template() {
    return this._getOption("template");
  }
  set template(value2) {
    this._setOption("template", value2);
  }
  get text() {
    return this._getOption("text");
  }
  set text(value2) {
    this._setOption("text", value2);
  }
  get visible() {
    return this._getOption("visible");
  }
  set visible(value2) {
    this._setOption("visible", value2);
  }
  get widget() {
    return this._getOption("widget");
  }
  set widget(value2) {
    this._setOption("widget", value2);
  }
  get _optionPath() {
    return "items";
  }
  constructor(parentOptionHost, optionHost, renderer, document, templateHost, element) {
    super();
    this.renderer = renderer;
    this.document = document;
    this.element = element;
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
    templateHost.setHost(this);
  }
  setTemplate(template) {
    this.template = template;
  }
  ngAfterViewInit() {
    extractTemplate(this, this.element, this.renderer, this.document);
  }
  ngOnDestroy() {
    this._deleteRemovedOptions(this._fullOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxiDataGridItemComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridItemComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(DOCUMENT), ɵɵdirectiveInject(DxTemplateHost, 1), ɵɵdirectiveInject(ElementRef));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxiDataGridItemComponent,
    selectors: [["dxi-data-grid-item"]],
    inputs: {
      cssClass: "cssClass",
      disabled: "disabled",
      html: "html",
      locateInMenu: "locateInMenu",
      location: "location",
      menuItemTemplate: "menuItemTemplate",
      name: "name",
      options: "options",
      showText: "showText",
      template: "template",
      text: "text",
      visible: "visible",
      widget: "widget"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost, DxTemplateHost, {
      provide: PROPERTY_TOKEN_items,
      useExisting: _DxiDataGridItemComponent
    }]), ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function DxiDataGridItemComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    dependencies: [DxIntegrationModule],
    styles: ["[_nghost-%COMP%]{display:block}"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridItemComponent, [{
    type: Component,
    args: [{
      selector: "dxi-data-grid-item",
      standalone: true,
      template: "<ng-content></ng-content>",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost, DxTemplateHost, {
        provide: PROPERTY_TOKEN_items,
        useExisting: DxiDataGridItemComponent
      }],
      styles: [":host{display:block}\n"]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }, {
    type: Renderer2
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: DxTemplateHost,
    decorators: [{
      type: Host
    }]
  }, {
    type: ElementRef
  }], {
    cssClass: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    html: [{
      type: Input
    }],
    locateInMenu: [{
      type: Input
    }],
    location: [{
      type: Input
    }],
    menuItemTemplate: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    options: [{
      type: Input
    }],
    showText: [{
      type: Input
    }],
    template: [{
      type: Input
    }],
    text: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    widget: [{
      type: Input
    }]
  });
})();
var DxiDataGridItemModule = class _DxiDataGridItemModule {
  /** @nocollapse */
  static ɵfac = function DxiDataGridItemModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridItemModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxiDataGridItemModule,
    imports: [DxiDataGridItemComponent],
    exports: [DxiDataGridItemComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxiDataGridItemComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridItemModule, [{
    type: NgModule,
    args: [{
      imports: [DxiDataGridItemComponent],
      exports: [DxiDataGridItemComponent]
    }]
  }], null, null);
})();
var DxoDataGridKeyboardNavigationComponent = class _DxoDataGridKeyboardNavigationComponent extends NestedOption {
  get editOnKeyPress() {
    return this._getOption("editOnKeyPress");
  }
  set editOnKeyPress(value2) {
    this._setOption("editOnKeyPress", value2);
  }
  get enabled() {
    return this._getOption("enabled");
  }
  set enabled(value2) {
    this._setOption("enabled", value2);
  }
  get enterKeyAction() {
    return this._getOption("enterKeyAction");
  }
  set enterKeyAction(value2) {
    this._setOption("enterKeyAction", value2);
  }
  get enterKeyDirection() {
    return this._getOption("enterKeyDirection");
  }
  set enterKeyDirection(value2) {
    this._setOption("enterKeyDirection", value2);
  }
  get _optionPath() {
    return "keyboardNavigation";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridKeyboardNavigationComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridKeyboardNavigationComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridKeyboardNavigationComponent,
    selectors: [["dxo-data-grid-keyboard-navigation"]],
    inputs: {
      editOnKeyPress: "editOnKeyPress",
      enabled: "enabled",
      enterKeyAction: "enterKeyAction",
      enterKeyDirection: "enterKeyDirection"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridKeyboardNavigationComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridKeyboardNavigationComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-keyboard-navigation",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    editOnKeyPress: [{
      type: Input
    }],
    enabled: [{
      type: Input
    }],
    enterKeyAction: [{
      type: Input
    }],
    enterKeyDirection: [{
      type: Input
    }]
  });
})();
var DxoDataGridKeyboardNavigationModule = class _DxoDataGridKeyboardNavigationModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridKeyboardNavigationModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridKeyboardNavigationModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridKeyboardNavigationModule,
    imports: [DxoDataGridKeyboardNavigationComponent],
    exports: [DxoDataGridKeyboardNavigationComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridKeyboardNavigationComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridKeyboardNavigationModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridKeyboardNavigationComponent],
      exports: [DxoDataGridKeyboardNavigationComponent]
    }]
  }], null, null);
})();
var DxoDataGridLabelComponent = class _DxoDataGridLabelComponent extends NestedOption {
  renderer;
  document;
  element;
  get alignment() {
    return this._getOption("alignment");
  }
  set alignment(value2) {
    this._setOption("alignment", value2);
  }
  get location() {
    return this._getOption("location");
  }
  set location(value2) {
    this._setOption("location", value2);
  }
  get showColon() {
    return this._getOption("showColon");
  }
  set showColon(value2) {
    this._setOption("showColon", value2);
  }
  get template() {
    return this._getOption("template");
  }
  set template(value2) {
    this._setOption("template", value2);
  }
  get text() {
    return this._getOption("text");
  }
  set text(value2) {
    this._setOption("text", value2);
  }
  get visible() {
    return this._getOption("visible");
  }
  set visible(value2) {
    this._setOption("visible", value2);
  }
  get _optionPath() {
    return "label";
  }
  constructor(parentOptionHost, optionHost, renderer, document, templateHost, element) {
    super();
    this.renderer = renderer;
    this.document = document;
    this.element = element;
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
    templateHost.setHost(this);
  }
  setTemplate(template) {
    this.template = template;
  }
  ngAfterViewInit() {
    extractTemplate(this, this.element, this.renderer, this.document);
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridLabelComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridLabelComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(DOCUMENT), ɵɵdirectiveInject(DxTemplateHost, 1), ɵɵdirectiveInject(ElementRef));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridLabelComponent,
    selectors: [["dxo-data-grid-label"]],
    inputs: {
      alignment: "alignment",
      location: "location",
      showColon: "showColon",
      template: "template",
      text: "text",
      visible: "visible"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost, DxTemplateHost]), ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function DxoDataGridLabelComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    dependencies: [DxIntegrationModule],
    styles: ["[_nghost-%COMP%]{display:block}"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridLabelComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-label",
      standalone: true,
      template: "<ng-content></ng-content>",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost, DxTemplateHost],
      styles: [":host{display:block}\n"]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }, {
    type: Renderer2
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: DxTemplateHost,
    decorators: [{
      type: Host
    }]
  }, {
    type: ElementRef
  }], {
    alignment: [{
      type: Input
    }],
    location: [{
      type: Input
    }],
    showColon: [{
      type: Input
    }],
    template: [{
      type: Input
    }],
    text: [{
      type: Input
    }],
    visible: [{
      type: Input
    }]
  });
})();
var DxoDataGridLabelModule = class _DxoDataGridLabelModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridLabelModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridLabelModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridLabelModule,
    imports: [DxoDataGridLabelComponent],
    exports: [DxoDataGridLabelComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridLabelComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridLabelModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridLabelComponent],
      exports: [DxoDataGridLabelComponent]
    }]
  }], null, null);
})();
var DxoDataGridLoadPanelComponent = class _DxoDataGridLoadPanelComponent extends NestedOption {
  get enabled() {
    return this._getOption("enabled");
  }
  set enabled(value2) {
    this._setOption("enabled", value2);
  }
  get height() {
    return this._getOption("height");
  }
  set height(value2) {
    this._setOption("height", value2);
  }
  get indicatorSrc() {
    return this._getOption("indicatorSrc");
  }
  set indicatorSrc(value2) {
    this._setOption("indicatorSrc", value2);
  }
  get shading() {
    return this._getOption("shading");
  }
  set shading(value2) {
    this._setOption("shading", value2);
  }
  get shadingColor() {
    return this._getOption("shadingColor");
  }
  set shadingColor(value2) {
    this._setOption("shadingColor", value2);
  }
  get showIndicator() {
    return this._getOption("showIndicator");
  }
  set showIndicator(value2) {
    this._setOption("showIndicator", value2);
  }
  get showPane() {
    return this._getOption("showPane");
  }
  set showPane(value2) {
    this._setOption("showPane", value2);
  }
  get text() {
    return this._getOption("text");
  }
  set text(value2) {
    this._setOption("text", value2);
  }
  get width() {
    return this._getOption("width");
  }
  set width(value2) {
    this._setOption("width", value2);
  }
  get _optionPath() {
    return "loadPanel";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridLoadPanelComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridLoadPanelComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridLoadPanelComponent,
    selectors: [["dxo-data-grid-load-panel"]],
    inputs: {
      enabled: "enabled",
      height: "height",
      indicatorSrc: "indicatorSrc",
      shading: "shading",
      shadingColor: "shadingColor",
      showIndicator: "showIndicator",
      showPane: "showPane",
      text: "text",
      width: "width"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridLoadPanelComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridLoadPanelComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-load-panel",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    enabled: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    indicatorSrc: [{
      type: Input
    }],
    shading: [{
      type: Input
    }],
    shadingColor: [{
      type: Input
    }],
    showIndicator: [{
      type: Input
    }],
    showPane: [{
      type: Input
    }],
    text: [{
      type: Input
    }],
    width: [{
      type: Input
    }]
  });
})();
var DxoDataGridLoadPanelModule = class _DxoDataGridLoadPanelModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridLoadPanelModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridLoadPanelModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridLoadPanelModule,
    imports: [DxoDataGridLoadPanelComponent],
    exports: [DxoDataGridLoadPanelComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridLoadPanelComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridLoadPanelModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridLoadPanelComponent],
      exports: [DxoDataGridLoadPanelComponent]
    }]
  }], null, null);
})();
var DxoDataGridLookupComponent = class _DxoDataGridLookupComponent extends NestedOption {
  get allowClearing() {
    return this._getOption("allowClearing");
  }
  set allowClearing(value2) {
    this._setOption("allowClearing", value2);
  }
  get calculateCellValue() {
    return this._getOption("calculateCellValue");
  }
  set calculateCellValue(value2) {
    this._setOption("calculateCellValue", value2);
  }
  get dataSource() {
    return this._getOption("dataSource");
  }
  set dataSource(value2) {
    this._setOption("dataSource", value2);
  }
  get displayExpr() {
    return this._getOption("displayExpr");
  }
  set displayExpr(value2) {
    this._setOption("displayExpr", value2);
  }
  get valueExpr() {
    return this._getOption("valueExpr");
  }
  set valueExpr(value2) {
    this._setOption("valueExpr", value2);
  }
  get _optionPath() {
    return "lookup";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridLookupComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridLookupComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridLookupComponent,
    selectors: [["dxo-data-grid-lookup"]],
    inputs: {
      allowClearing: "allowClearing",
      calculateCellValue: "calculateCellValue",
      dataSource: "dataSource",
      displayExpr: "displayExpr",
      valueExpr: "valueExpr"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridLookupComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridLookupComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-lookup",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    allowClearing: [{
      type: Input
    }],
    calculateCellValue: [{
      type: Input
    }],
    dataSource: [{
      type: Input
    }],
    displayExpr: [{
      type: Input
    }],
    valueExpr: [{
      type: Input
    }]
  });
})();
var DxoDataGridLookupModule = class _DxoDataGridLookupModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridLookupModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridLookupModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridLookupModule,
    imports: [DxoDataGridLookupComponent],
    exports: [DxoDataGridLookupComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridLookupComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridLookupModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridLookupComponent],
      exports: [DxoDataGridLookupComponent]
    }]
  }], null, null);
})();
var DxoDataGridMasterDetailComponent = class _DxoDataGridMasterDetailComponent extends NestedOption {
  renderer;
  document;
  element;
  get autoExpandAll() {
    return this._getOption("autoExpandAll");
  }
  set autoExpandAll(value2) {
    this._setOption("autoExpandAll", value2);
  }
  get enabled() {
    return this._getOption("enabled");
  }
  set enabled(value2) {
    this._setOption("enabled", value2);
  }
  get template() {
    return this._getOption("template");
  }
  set template(value2) {
    this._setOption("template", value2);
  }
  get _optionPath() {
    return "masterDetail";
  }
  constructor(parentOptionHost, optionHost, renderer, document, templateHost, element) {
    super();
    this.renderer = renderer;
    this.document = document;
    this.element = element;
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
    templateHost.setHost(this);
  }
  setTemplate(template) {
    this.template = template;
  }
  ngAfterViewInit() {
    extractTemplate(this, this.element, this.renderer, this.document);
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridMasterDetailComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridMasterDetailComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(DOCUMENT), ɵɵdirectiveInject(DxTemplateHost, 1), ɵɵdirectiveInject(ElementRef));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridMasterDetailComponent,
    selectors: [["dxo-data-grid-master-detail"]],
    inputs: {
      autoExpandAll: "autoExpandAll",
      enabled: "enabled",
      template: "template"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost, DxTemplateHost]), ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function DxoDataGridMasterDetailComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    dependencies: [DxIntegrationModule],
    styles: ["[_nghost-%COMP%]{display:block}"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridMasterDetailComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-master-detail",
      standalone: true,
      template: "<ng-content></ng-content>",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost, DxTemplateHost],
      styles: [":host{display:block}\n"]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }, {
    type: Renderer2
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: DxTemplateHost,
    decorators: [{
      type: Host
    }]
  }, {
    type: ElementRef
  }], {
    autoExpandAll: [{
      type: Input
    }],
    enabled: [{
      type: Input
    }],
    template: [{
      type: Input
    }]
  });
})();
var DxoDataGridMasterDetailModule = class _DxoDataGridMasterDetailModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridMasterDetailModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridMasterDetailModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridMasterDetailModule,
    imports: [DxoDataGridMasterDetailComponent],
    exports: [DxoDataGridMasterDetailComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridMasterDetailComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridMasterDetailModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridMasterDetailComponent],
      exports: [DxoDataGridMasterDetailComponent]
    }]
  }], null, null);
})();
var DxoDataGridMyComponent = class _DxoDataGridMyComponent extends NestedOption {
  get x() {
    return this._getOption("x");
  }
  set x(value2) {
    this._setOption("x", value2);
  }
  get y() {
    return this._getOption("y");
  }
  set y(value2) {
    this._setOption("y", value2);
  }
  get _optionPath() {
    return "my";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridMyComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridMyComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridMyComponent,
    selectors: [["dxo-data-grid-my"]],
    inputs: {
      x: "x",
      y: "y"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridMyComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridMyComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-my",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    x: [{
      type: Input
    }],
    y: [{
      type: Input
    }]
  });
})();
var DxoDataGridMyModule = class _DxoDataGridMyModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridMyModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridMyModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridMyModule,
    imports: [DxoDataGridMyComponent],
    exports: [DxoDataGridMyComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridMyComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridMyModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridMyComponent],
      exports: [DxoDataGridMyComponent]
    }]
  }], null, null);
})();
var DxiDataGridNumericRuleComponent = class _DxiDataGridNumericRuleComponent extends CollectionNestedOption {
  get ignoreEmptyValue() {
    return this._getOption("ignoreEmptyValue");
  }
  set ignoreEmptyValue(value2) {
    this._setOption("ignoreEmptyValue", value2);
  }
  get message() {
    return this._getOption("message");
  }
  set message(value2) {
    this._setOption("message", value2);
  }
  get type() {
    return this._getOption("type");
  }
  set type(value2) {
    this._setOption("type", value2);
  }
  get _optionPath() {
    return "validationRules";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
    this.type = "numeric";
  }
  ngOnDestroy() {
    this._deleteRemovedOptions(this._fullOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxiDataGridNumericRuleComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridNumericRuleComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxiDataGridNumericRuleComponent,
    selectors: [["dxi-data-grid-numeric-rule"]],
    inputs: {
      ignoreEmptyValue: "ignoreEmptyValue",
      message: "message",
      type: "type"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost, {
      provide: PROPERTY_TOKEN_validationRules,
      useExisting: _DxiDataGridNumericRuleComponent
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxiDataGridNumericRuleComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridNumericRuleComponent, [{
    type: Component,
    args: [{
      selector: "dxi-data-grid-numeric-rule",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost, {
        provide: PROPERTY_TOKEN_validationRules,
        useExisting: DxiDataGridNumericRuleComponent
      }]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    ignoreEmptyValue: [{
      type: Input
    }],
    message: [{
      type: Input
    }],
    type: [{
      type: Input
    }]
  });
})();
var DxiDataGridNumericRuleModule = class _DxiDataGridNumericRuleModule {
  /** @nocollapse */
  static ɵfac = function DxiDataGridNumericRuleModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridNumericRuleModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxiDataGridNumericRuleModule,
    imports: [DxiDataGridNumericRuleComponent],
    exports: [DxiDataGridNumericRuleComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxiDataGridNumericRuleComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridNumericRuleModule, [{
    type: NgModule,
    args: [{
      imports: [DxiDataGridNumericRuleComponent],
      exports: [DxiDataGridNumericRuleComponent]
    }]
  }], null, null);
})();
var DxoDataGridOffsetComponent = class _DxoDataGridOffsetComponent extends NestedOption {
  get x() {
    return this._getOption("x");
  }
  set x(value2) {
    this._setOption("x", value2);
  }
  get y() {
    return this._getOption("y");
  }
  set y(value2) {
    this._setOption("y", value2);
  }
  get _optionPath() {
    return "offset";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridOffsetComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridOffsetComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridOffsetComponent,
    selectors: [["dxo-data-grid-offset"]],
    inputs: {
      x: "x",
      y: "y"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridOffsetComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridOffsetComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-offset",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    x: [{
      type: Input
    }],
    y: [{
      type: Input
    }]
  });
})();
var DxoDataGridOffsetModule = class _DxoDataGridOffsetModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridOffsetModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridOffsetModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridOffsetModule,
    imports: [DxoDataGridOffsetComponent],
    exports: [DxoDataGridOffsetComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridOffsetComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridOffsetModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridOffsetComponent],
      exports: [DxoDataGridOffsetComponent]
    }]
  }], null, null);
})();
var DxoDataGridOperationDescriptionsComponent = class _DxoDataGridOperationDescriptionsComponent extends NestedOption {
  get between() {
    return this._getOption("between");
  }
  set between(value2) {
    this._setOption("between", value2);
  }
  get contains() {
    return this._getOption("contains");
  }
  set contains(value2) {
    this._setOption("contains", value2);
  }
  get endsWith() {
    return this._getOption("endsWith");
  }
  set endsWith(value2) {
    this._setOption("endsWith", value2);
  }
  get equal() {
    return this._getOption("equal");
  }
  set equal(value2) {
    this._setOption("equal", value2);
  }
  get greaterThan() {
    return this._getOption("greaterThan");
  }
  set greaterThan(value2) {
    this._setOption("greaterThan", value2);
  }
  get greaterThanOrEqual() {
    return this._getOption("greaterThanOrEqual");
  }
  set greaterThanOrEqual(value2) {
    this._setOption("greaterThanOrEqual", value2);
  }
  get lessThan() {
    return this._getOption("lessThan");
  }
  set lessThan(value2) {
    this._setOption("lessThan", value2);
  }
  get lessThanOrEqual() {
    return this._getOption("lessThanOrEqual");
  }
  set lessThanOrEqual(value2) {
    this._setOption("lessThanOrEqual", value2);
  }
  get notContains() {
    return this._getOption("notContains");
  }
  set notContains(value2) {
    this._setOption("notContains", value2);
  }
  get notEqual() {
    return this._getOption("notEqual");
  }
  set notEqual(value2) {
    this._setOption("notEqual", value2);
  }
  get startsWith() {
    return this._getOption("startsWith");
  }
  set startsWith(value2) {
    this._setOption("startsWith", value2);
  }
  get _optionPath() {
    return "operationDescriptions";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridOperationDescriptionsComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridOperationDescriptionsComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridOperationDescriptionsComponent,
    selectors: [["dxo-data-grid-operation-descriptions"]],
    inputs: {
      between: "between",
      contains: "contains",
      endsWith: "endsWith",
      equal: "equal",
      greaterThan: "greaterThan",
      greaterThanOrEqual: "greaterThanOrEqual",
      lessThan: "lessThan",
      lessThanOrEqual: "lessThanOrEqual",
      notContains: "notContains",
      notEqual: "notEqual",
      startsWith: "startsWith"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridOperationDescriptionsComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridOperationDescriptionsComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-operation-descriptions",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    between: [{
      type: Input
    }],
    contains: [{
      type: Input
    }],
    endsWith: [{
      type: Input
    }],
    equal: [{
      type: Input
    }],
    greaterThan: [{
      type: Input
    }],
    greaterThanOrEqual: [{
      type: Input
    }],
    lessThan: [{
      type: Input
    }],
    lessThanOrEqual: [{
      type: Input
    }],
    notContains: [{
      type: Input
    }],
    notEqual: [{
      type: Input
    }],
    startsWith: [{
      type: Input
    }]
  });
})();
var DxoDataGridOperationDescriptionsModule = class _DxoDataGridOperationDescriptionsModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridOperationDescriptionsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridOperationDescriptionsModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridOperationDescriptionsModule,
    imports: [DxoDataGridOperationDescriptionsComponent],
    exports: [DxoDataGridOperationDescriptionsComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridOperationDescriptionsComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridOperationDescriptionsModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridOperationDescriptionsComponent],
      exports: [DxoDataGridOperationDescriptionsComponent]
    }]
  }], null, null);
})();
var DxoDataGridPagerComponent = class _DxoDataGridPagerComponent extends NestedOption {
  get allowedPageSizes() {
    return this._getOption("allowedPageSizes");
  }
  set allowedPageSizes(value2) {
    this._setOption("allowedPageSizes", value2);
  }
  get displayMode() {
    return this._getOption("displayMode");
  }
  set displayMode(value2) {
    this._setOption("displayMode", value2);
  }
  get infoText() {
    return this._getOption("infoText");
  }
  set infoText(value2) {
    this._setOption("infoText", value2);
  }
  get label() {
    return this._getOption("label");
  }
  set label(value2) {
    this._setOption("label", value2);
  }
  get showInfo() {
    return this._getOption("showInfo");
  }
  set showInfo(value2) {
    this._setOption("showInfo", value2);
  }
  get showNavigationButtons() {
    return this._getOption("showNavigationButtons");
  }
  set showNavigationButtons(value2) {
    this._setOption("showNavigationButtons", value2);
  }
  get showPageSizeSelector() {
    return this._getOption("showPageSizeSelector");
  }
  set showPageSizeSelector(value2) {
    this._setOption("showPageSizeSelector", value2);
  }
  get visible() {
    return this._getOption("visible");
  }
  set visible(value2) {
    this._setOption("visible", value2);
  }
  get _optionPath() {
    return "pager";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridPagerComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridPagerComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridPagerComponent,
    selectors: [["dxo-data-grid-pager"]],
    inputs: {
      allowedPageSizes: "allowedPageSizes",
      displayMode: "displayMode",
      infoText: "infoText",
      label: "label",
      showInfo: "showInfo",
      showNavigationButtons: "showNavigationButtons",
      showPageSizeSelector: "showPageSizeSelector",
      visible: "visible"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridPagerComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridPagerComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-pager",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    allowedPageSizes: [{
      type: Input
    }],
    displayMode: [{
      type: Input
    }],
    infoText: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    showInfo: [{
      type: Input
    }],
    showNavigationButtons: [{
      type: Input
    }],
    showPageSizeSelector: [{
      type: Input
    }],
    visible: [{
      type: Input
    }]
  });
})();
var DxoDataGridPagerModule = class _DxoDataGridPagerModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridPagerModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridPagerModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridPagerModule,
    imports: [DxoDataGridPagerComponent],
    exports: [DxoDataGridPagerComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridPagerComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridPagerModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridPagerComponent],
      exports: [DxoDataGridPagerComponent]
    }]
  }], null, null);
})();
var DxoDataGridPagingComponent = class _DxoDataGridPagingComponent extends NestedOption {
  get enabled() {
    return this._getOption("enabled");
  }
  set enabled(value2) {
    this._setOption("enabled", value2);
  }
  get pageIndex() {
    return this._getOption("pageIndex");
  }
  set pageIndex(value2) {
    this._setOption("pageIndex", value2);
  }
  get pageSize() {
    return this._getOption("pageSize");
  }
  set pageSize(value2) {
    this._setOption("pageSize", value2);
  }
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  pageIndexChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  pageSizeChange;
  get _optionPath() {
    return "paging";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    this._createEventEmitters([{
      emit: "pageIndexChange"
    }, {
      emit: "pageSizeChange"
    }]);
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridPagingComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridPagingComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridPagingComponent,
    selectors: [["dxo-data-grid-paging"]],
    inputs: {
      enabled: "enabled",
      pageIndex: "pageIndex",
      pageSize: "pageSize"
    },
    outputs: {
      pageIndexChange: "pageIndexChange",
      pageSizeChange: "pageSizeChange"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridPagingComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridPagingComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-paging",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    enabled: [{
      type: Input
    }],
    pageIndex: [{
      type: Input
    }],
    pageSize: [{
      type: Input
    }],
    pageIndexChange: [{
      type: Output
    }],
    pageSizeChange: [{
      type: Output
    }]
  });
})();
var DxoDataGridPagingModule = class _DxoDataGridPagingModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridPagingModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridPagingModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridPagingModule,
    imports: [DxoDataGridPagingComponent],
    exports: [DxoDataGridPagingComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridPagingComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridPagingModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridPagingComponent],
      exports: [DxoDataGridPagingComponent]
    }]
  }], null, null);
})();
var DxiDataGridPatternRuleComponent = class _DxiDataGridPatternRuleComponent extends CollectionNestedOption {
  get ignoreEmptyValue() {
    return this._getOption("ignoreEmptyValue");
  }
  set ignoreEmptyValue(value2) {
    this._setOption("ignoreEmptyValue", value2);
  }
  get message() {
    return this._getOption("message");
  }
  set message(value2) {
    this._setOption("message", value2);
  }
  get pattern() {
    return this._getOption("pattern");
  }
  set pattern(value2) {
    this._setOption("pattern", value2);
  }
  get type() {
    return this._getOption("type");
  }
  set type(value2) {
    this._setOption("type", value2);
  }
  get _optionPath() {
    return "validationRules";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
    this.type = "pattern";
  }
  ngOnDestroy() {
    this._deleteRemovedOptions(this._fullOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxiDataGridPatternRuleComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridPatternRuleComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxiDataGridPatternRuleComponent,
    selectors: [["dxi-data-grid-pattern-rule"]],
    inputs: {
      ignoreEmptyValue: "ignoreEmptyValue",
      message: "message",
      pattern: "pattern",
      type: "type"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost, {
      provide: PROPERTY_TOKEN_validationRules,
      useExisting: _DxiDataGridPatternRuleComponent
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxiDataGridPatternRuleComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridPatternRuleComponent, [{
    type: Component,
    args: [{
      selector: "dxi-data-grid-pattern-rule",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost, {
        provide: PROPERTY_TOKEN_validationRules,
        useExisting: DxiDataGridPatternRuleComponent
      }]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    ignoreEmptyValue: [{
      type: Input
    }],
    message: [{
      type: Input
    }],
    pattern: [{
      type: Input
    }],
    type: [{
      type: Input
    }]
  });
})();
var DxiDataGridPatternRuleModule = class _DxiDataGridPatternRuleModule {
  /** @nocollapse */
  static ɵfac = function DxiDataGridPatternRuleModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridPatternRuleModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxiDataGridPatternRuleModule,
    imports: [DxiDataGridPatternRuleComponent],
    exports: [DxiDataGridPatternRuleComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxiDataGridPatternRuleComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridPatternRuleModule, [{
    type: NgModule,
    args: [{
      imports: [DxiDataGridPatternRuleComponent],
      exports: [DxiDataGridPatternRuleComponent]
    }]
  }], null, null);
})();
var DxoDataGridPopupComponent = class _DxoDataGridPopupComponent extends NestedOption {
  set _toolbarItemsContentChildren(value2) {
    this.setChildren("toolbarItems", value2);
  }
  get accessKey() {
    return this._getOption("accessKey");
  }
  set accessKey(value2) {
    this._setOption("accessKey", value2);
  }
  get animation() {
    return this._getOption("animation");
  }
  set animation(value2) {
    this._setOption("animation", value2);
  }
  get container() {
    return this._getOption("container");
  }
  set container(value2) {
    this._setOption("container", value2);
  }
  get contentTemplate() {
    return this._getOption("contentTemplate");
  }
  set contentTemplate(value2) {
    this._setOption("contentTemplate", value2);
  }
  get deferRendering() {
    return this._getOption("deferRendering");
  }
  set deferRendering(value2) {
    this._setOption("deferRendering", value2);
  }
  get disabled() {
    return this._getOption("disabled");
  }
  set disabled(value2) {
    this._setOption("disabled", value2);
  }
  get dragAndResizeArea() {
    return this._getOption("dragAndResizeArea");
  }
  set dragAndResizeArea(value2) {
    this._setOption("dragAndResizeArea", value2);
  }
  get dragEnabled() {
    return this._getOption("dragEnabled");
  }
  set dragEnabled(value2) {
    this._setOption("dragEnabled", value2);
  }
  get dragOutsideBoundary() {
    return this._getOption("dragOutsideBoundary");
  }
  set dragOutsideBoundary(value2) {
    this._setOption("dragOutsideBoundary", value2);
  }
  get enableBodyScroll() {
    return this._getOption("enableBodyScroll");
  }
  set enableBodyScroll(value2) {
    this._setOption("enableBodyScroll", value2);
  }
  get focusStateEnabled() {
    return this._getOption("focusStateEnabled");
  }
  set focusStateEnabled(value2) {
    this._setOption("focusStateEnabled", value2);
  }
  get fullScreen() {
    return this._getOption("fullScreen");
  }
  set fullScreen(value2) {
    this._setOption("fullScreen", value2);
  }
  get height() {
    return this._getOption("height");
  }
  set height(value2) {
    this._setOption("height", value2);
  }
  get hideOnOutsideClick() {
    return this._getOption("hideOnOutsideClick");
  }
  set hideOnOutsideClick(value2) {
    this._setOption("hideOnOutsideClick", value2);
  }
  get hideOnParentScroll() {
    return this._getOption("hideOnParentScroll");
  }
  set hideOnParentScroll(value2) {
    this._setOption("hideOnParentScroll", value2);
  }
  get hint() {
    return this._getOption("hint");
  }
  set hint(value2) {
    this._setOption("hint", value2);
  }
  get hoverStateEnabled() {
    return this._getOption("hoverStateEnabled");
  }
  set hoverStateEnabled(value2) {
    this._setOption("hoverStateEnabled", value2);
  }
  get maxHeight() {
    return this._getOption("maxHeight");
  }
  set maxHeight(value2) {
    this._setOption("maxHeight", value2);
  }
  get maxWidth() {
    return this._getOption("maxWidth");
  }
  set maxWidth(value2) {
    this._setOption("maxWidth", value2);
  }
  get minHeight() {
    return this._getOption("minHeight");
  }
  set minHeight(value2) {
    this._setOption("minHeight", value2);
  }
  get minWidth() {
    return this._getOption("minWidth");
  }
  set minWidth(value2) {
    this._setOption("minWidth", value2);
  }
  get onContentReady() {
    return this._getOption("onContentReady");
  }
  set onContentReady(value2) {
    this._setOption("onContentReady", value2);
  }
  get onDisposing() {
    return this._getOption("onDisposing");
  }
  set onDisposing(value2) {
    this._setOption("onDisposing", value2);
  }
  get onHidden() {
    return this._getOption("onHidden");
  }
  set onHidden(value2) {
    this._setOption("onHidden", value2);
  }
  get onHiding() {
    return this._getOption("onHiding");
  }
  set onHiding(value2) {
    this._setOption("onHiding", value2);
  }
  get onInitialized() {
    return this._getOption("onInitialized");
  }
  set onInitialized(value2) {
    this._setOption("onInitialized", value2);
  }
  get onOptionChanged() {
    return this._getOption("onOptionChanged");
  }
  set onOptionChanged(value2) {
    this._setOption("onOptionChanged", value2);
  }
  get onResize() {
    return this._getOption("onResize");
  }
  set onResize(value2) {
    this._setOption("onResize", value2);
  }
  get onResizeEnd() {
    return this._getOption("onResizeEnd");
  }
  set onResizeEnd(value2) {
    this._setOption("onResizeEnd", value2);
  }
  get onResizeStart() {
    return this._getOption("onResizeStart");
  }
  set onResizeStart(value2) {
    this._setOption("onResizeStart", value2);
  }
  get onShowing() {
    return this._getOption("onShowing");
  }
  set onShowing(value2) {
    this._setOption("onShowing", value2);
  }
  get onShown() {
    return this._getOption("onShown");
  }
  set onShown(value2) {
    this._setOption("onShown", value2);
  }
  get onTitleRendered() {
    return this._getOption("onTitleRendered");
  }
  set onTitleRendered(value2) {
    this._setOption("onTitleRendered", value2);
  }
  get position() {
    return this._getOption("position");
  }
  set position(value2) {
    this._setOption("position", value2);
  }
  get resizeEnabled() {
    return this._getOption("resizeEnabled");
  }
  set resizeEnabled(value2) {
    this._setOption("resizeEnabled", value2);
  }
  get restorePosition() {
    return this._getOption("restorePosition");
  }
  set restorePosition(value2) {
    this._setOption("restorePosition", value2);
  }
  get rtlEnabled() {
    return this._getOption("rtlEnabled");
  }
  set rtlEnabled(value2) {
    this._setOption("rtlEnabled", value2);
  }
  get shading() {
    return this._getOption("shading");
  }
  set shading(value2) {
    this._setOption("shading", value2);
  }
  get shadingColor() {
    return this._getOption("shadingColor");
  }
  set shadingColor(value2) {
    this._setOption("shadingColor", value2);
  }
  get showCloseButton() {
    return this._getOption("showCloseButton");
  }
  set showCloseButton(value2) {
    this._setOption("showCloseButton", value2);
  }
  get showTitle() {
    return this._getOption("showTitle");
  }
  set showTitle(value2) {
    this._setOption("showTitle", value2);
  }
  get tabIndex() {
    return this._getOption("tabIndex");
  }
  set tabIndex(value2) {
    this._setOption("tabIndex", value2);
  }
  get title() {
    return this._getOption("title");
  }
  set title(value2) {
    this._setOption("title", value2);
  }
  get titleTemplate() {
    return this._getOption("titleTemplate");
  }
  set titleTemplate(value2) {
    this._setOption("titleTemplate", value2);
  }
  get toolbarItems() {
    return this._getOption("toolbarItems");
  }
  set toolbarItems(value2) {
    this._setOption("toolbarItems", value2);
  }
  get visible() {
    return this._getOption("visible");
  }
  set visible(value2) {
    this._setOption("visible", value2);
  }
  get width() {
    return this._getOption("width");
  }
  set width(value2) {
    this._setOption("width", value2);
  }
  get wrapperAttr() {
    return this._getOption("wrapperAttr");
  }
  set wrapperAttr(value2) {
    this._setOption("wrapperAttr", value2);
  }
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  heightChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  positionChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  visibleChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  widthChange;
  get _optionPath() {
    return "popup";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    this._createEventEmitters([{
      emit: "heightChange"
    }, {
      emit: "positionChange"
    }, {
      emit: "visibleChange"
    }, {
      emit: "widthChange"
    }]);
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridPopupComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridPopupComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridPopupComponent,
    selectors: [["dxo-data-grid-popup"]],
    contentQueries: function DxoDataGridPopupComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, PROPERTY_TOKEN_toolbarItems, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._toolbarItemsContentChildren = _t);
      }
    },
    inputs: {
      accessKey: "accessKey",
      animation: "animation",
      container: "container",
      contentTemplate: "contentTemplate",
      deferRendering: "deferRendering",
      disabled: "disabled",
      dragAndResizeArea: "dragAndResizeArea",
      dragEnabled: "dragEnabled",
      dragOutsideBoundary: "dragOutsideBoundary",
      enableBodyScroll: "enableBodyScroll",
      focusStateEnabled: "focusStateEnabled",
      fullScreen: "fullScreen",
      height: "height",
      hideOnOutsideClick: "hideOnOutsideClick",
      hideOnParentScroll: "hideOnParentScroll",
      hint: "hint",
      hoverStateEnabled: "hoverStateEnabled",
      maxHeight: "maxHeight",
      maxWidth: "maxWidth",
      minHeight: "minHeight",
      minWidth: "minWidth",
      onContentReady: "onContentReady",
      onDisposing: "onDisposing",
      onHidden: "onHidden",
      onHiding: "onHiding",
      onInitialized: "onInitialized",
      onOptionChanged: "onOptionChanged",
      onResize: "onResize",
      onResizeEnd: "onResizeEnd",
      onResizeStart: "onResizeStart",
      onShowing: "onShowing",
      onShown: "onShown",
      onTitleRendered: "onTitleRendered",
      position: "position",
      resizeEnabled: "resizeEnabled",
      restorePosition: "restorePosition",
      rtlEnabled: "rtlEnabled",
      shading: "shading",
      shadingColor: "shadingColor",
      showCloseButton: "showCloseButton",
      showTitle: "showTitle",
      tabIndex: "tabIndex",
      title: "title",
      titleTemplate: "titleTemplate",
      toolbarItems: "toolbarItems",
      visible: "visible",
      width: "width",
      wrapperAttr: "wrapperAttr"
    },
    outputs: {
      heightChange: "heightChange",
      positionChange: "positionChange",
      visibleChange: "visibleChange",
      widthChange: "widthChange"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridPopupComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridPopupComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-popup",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    _toolbarItemsContentChildren: [{
      type: ContentChildren,
      args: [PROPERTY_TOKEN_toolbarItems]
    }],
    accessKey: [{
      type: Input
    }],
    animation: [{
      type: Input
    }],
    container: [{
      type: Input
    }],
    contentTemplate: [{
      type: Input
    }],
    deferRendering: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    dragAndResizeArea: [{
      type: Input
    }],
    dragEnabled: [{
      type: Input
    }],
    dragOutsideBoundary: [{
      type: Input
    }],
    enableBodyScroll: [{
      type: Input
    }],
    focusStateEnabled: [{
      type: Input
    }],
    fullScreen: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    hideOnOutsideClick: [{
      type: Input
    }],
    hideOnParentScroll: [{
      type: Input
    }],
    hint: [{
      type: Input
    }],
    hoverStateEnabled: [{
      type: Input
    }],
    maxHeight: [{
      type: Input
    }],
    maxWidth: [{
      type: Input
    }],
    minHeight: [{
      type: Input
    }],
    minWidth: [{
      type: Input
    }],
    onContentReady: [{
      type: Input
    }],
    onDisposing: [{
      type: Input
    }],
    onHidden: [{
      type: Input
    }],
    onHiding: [{
      type: Input
    }],
    onInitialized: [{
      type: Input
    }],
    onOptionChanged: [{
      type: Input
    }],
    onResize: [{
      type: Input
    }],
    onResizeEnd: [{
      type: Input
    }],
    onResizeStart: [{
      type: Input
    }],
    onShowing: [{
      type: Input
    }],
    onShown: [{
      type: Input
    }],
    onTitleRendered: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    resizeEnabled: [{
      type: Input
    }],
    restorePosition: [{
      type: Input
    }],
    rtlEnabled: [{
      type: Input
    }],
    shading: [{
      type: Input
    }],
    shadingColor: [{
      type: Input
    }],
    showCloseButton: [{
      type: Input
    }],
    showTitle: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    titleTemplate: [{
      type: Input
    }],
    toolbarItems: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    wrapperAttr: [{
      type: Input
    }],
    heightChange: [{
      type: Output
    }],
    positionChange: [{
      type: Output
    }],
    visibleChange: [{
      type: Output
    }],
    widthChange: [{
      type: Output
    }]
  });
})();
var DxoDataGridPopupModule = class _DxoDataGridPopupModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridPopupModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridPopupModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridPopupModule,
    imports: [DxoDataGridPopupComponent],
    exports: [DxoDataGridPopupComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridPopupComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridPopupModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridPopupComponent],
      exports: [DxoDataGridPopupComponent]
    }]
  }], null, null);
})();
var DxoDataGridPositionComponent = class _DxoDataGridPositionComponent extends NestedOption {
  get at() {
    return this._getOption("at");
  }
  set at(value2) {
    this._setOption("at", value2);
  }
  get boundary() {
    return this._getOption("boundary");
  }
  set boundary(value2) {
    this._setOption("boundary", value2);
  }
  get boundaryOffset() {
    return this._getOption("boundaryOffset");
  }
  set boundaryOffset(value2) {
    this._setOption("boundaryOffset", value2);
  }
  get collision() {
    return this._getOption("collision");
  }
  set collision(value2) {
    this._setOption("collision", value2);
  }
  get my() {
    return this._getOption("my");
  }
  set my(value2) {
    this._setOption("my", value2);
  }
  get of() {
    return this._getOption("of");
  }
  set of(value2) {
    this._setOption("of", value2);
  }
  get offset() {
    return this._getOption("offset");
  }
  set offset(value2) {
    this._setOption("offset", value2);
  }
  get _optionPath() {
    return "position";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridPositionComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridPositionComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridPositionComponent,
    selectors: [["dxo-data-grid-position"]],
    inputs: {
      at: "at",
      boundary: "boundary",
      boundaryOffset: "boundaryOffset",
      collision: "collision",
      my: "my",
      of: "of",
      offset: "offset"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridPositionComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridPositionComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-position",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    at: [{
      type: Input
    }],
    boundary: [{
      type: Input
    }],
    boundaryOffset: [{
      type: Input
    }],
    collision: [{
      type: Input
    }],
    my: [{
      type: Input
    }],
    of: [{
      type: Input
    }],
    offset: [{
      type: Input
    }]
  });
})();
var DxoDataGridPositionModule = class _DxoDataGridPositionModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridPositionModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridPositionModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridPositionModule,
    imports: [DxoDataGridPositionComponent],
    exports: [DxoDataGridPositionComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridPositionComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridPositionModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridPositionComponent],
      exports: [DxoDataGridPositionComponent]
    }]
  }], null, null);
})();
var DxiDataGridRangeRuleComponent = class _DxiDataGridRangeRuleComponent extends CollectionNestedOption {
  get ignoreEmptyValue() {
    return this._getOption("ignoreEmptyValue");
  }
  set ignoreEmptyValue(value2) {
    this._setOption("ignoreEmptyValue", value2);
  }
  get max() {
    return this._getOption("max");
  }
  set max(value2) {
    this._setOption("max", value2);
  }
  get message() {
    return this._getOption("message");
  }
  set message(value2) {
    this._setOption("message", value2);
  }
  get min() {
    return this._getOption("min");
  }
  set min(value2) {
    this._setOption("min", value2);
  }
  get reevaluate() {
    return this._getOption("reevaluate");
  }
  set reevaluate(value2) {
    this._setOption("reevaluate", value2);
  }
  get type() {
    return this._getOption("type");
  }
  set type(value2) {
    this._setOption("type", value2);
  }
  get _optionPath() {
    return "validationRules";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
    this.type = "range";
  }
  ngOnDestroy() {
    this._deleteRemovedOptions(this._fullOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxiDataGridRangeRuleComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridRangeRuleComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxiDataGridRangeRuleComponent,
    selectors: [["dxi-data-grid-range-rule"]],
    inputs: {
      ignoreEmptyValue: "ignoreEmptyValue",
      max: "max",
      message: "message",
      min: "min",
      reevaluate: "reevaluate",
      type: "type"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost, {
      provide: PROPERTY_TOKEN_validationRules,
      useExisting: _DxiDataGridRangeRuleComponent
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxiDataGridRangeRuleComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridRangeRuleComponent, [{
    type: Component,
    args: [{
      selector: "dxi-data-grid-range-rule",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost, {
        provide: PROPERTY_TOKEN_validationRules,
        useExisting: DxiDataGridRangeRuleComponent
      }]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    ignoreEmptyValue: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    message: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    reevaluate: [{
      type: Input
    }],
    type: [{
      type: Input
    }]
  });
})();
var DxiDataGridRangeRuleModule = class _DxiDataGridRangeRuleModule {
  /** @nocollapse */
  static ɵfac = function DxiDataGridRangeRuleModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridRangeRuleModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxiDataGridRangeRuleModule,
    imports: [DxiDataGridRangeRuleComponent],
    exports: [DxiDataGridRangeRuleComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxiDataGridRangeRuleComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridRangeRuleModule, [{
    type: NgModule,
    args: [{
      imports: [DxiDataGridRangeRuleComponent],
      exports: [DxiDataGridRangeRuleComponent]
    }]
  }], null, null);
})();
var DxoDataGridRemoteOperationsComponent = class _DxoDataGridRemoteOperationsComponent extends NestedOption {
  get filtering() {
    return this._getOption("filtering");
  }
  set filtering(value2) {
    this._setOption("filtering", value2);
  }
  get grouping() {
    return this._getOption("grouping");
  }
  set grouping(value2) {
    this._setOption("grouping", value2);
  }
  get groupPaging() {
    return this._getOption("groupPaging");
  }
  set groupPaging(value2) {
    this._setOption("groupPaging", value2);
  }
  get paging() {
    return this._getOption("paging");
  }
  set paging(value2) {
    this._setOption("paging", value2);
  }
  get sorting() {
    return this._getOption("sorting");
  }
  set sorting(value2) {
    this._setOption("sorting", value2);
  }
  get summary() {
    return this._getOption("summary");
  }
  set summary(value2) {
    this._setOption("summary", value2);
  }
  get _optionPath() {
    return "remoteOperations";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridRemoteOperationsComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridRemoteOperationsComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridRemoteOperationsComponent,
    selectors: [["dxo-data-grid-remote-operations"]],
    inputs: {
      filtering: "filtering",
      grouping: "grouping",
      groupPaging: "groupPaging",
      paging: "paging",
      sorting: "sorting",
      summary: "summary"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridRemoteOperationsComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridRemoteOperationsComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-remote-operations",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    filtering: [{
      type: Input
    }],
    grouping: [{
      type: Input
    }],
    groupPaging: [{
      type: Input
    }],
    paging: [{
      type: Input
    }],
    sorting: [{
      type: Input
    }],
    summary: [{
      type: Input
    }]
  });
})();
var DxoDataGridRemoteOperationsModule = class _DxoDataGridRemoteOperationsModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridRemoteOperationsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridRemoteOperationsModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridRemoteOperationsModule,
    imports: [DxoDataGridRemoteOperationsComponent],
    exports: [DxoDataGridRemoteOperationsComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridRemoteOperationsComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridRemoteOperationsModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridRemoteOperationsComponent],
      exports: [DxoDataGridRemoteOperationsComponent]
    }]
  }], null, null);
})();
var DxiDataGridRequiredRuleComponent = class _DxiDataGridRequiredRuleComponent extends CollectionNestedOption {
  get message() {
    return this._getOption("message");
  }
  set message(value2) {
    this._setOption("message", value2);
  }
  get trim() {
    return this._getOption("trim");
  }
  set trim(value2) {
    this._setOption("trim", value2);
  }
  get type() {
    return this._getOption("type");
  }
  set type(value2) {
    this._setOption("type", value2);
  }
  get _optionPath() {
    return "validationRules";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
    this.type = "required";
  }
  ngOnDestroy() {
    this._deleteRemovedOptions(this._fullOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxiDataGridRequiredRuleComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridRequiredRuleComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxiDataGridRequiredRuleComponent,
    selectors: [["dxi-data-grid-required-rule"]],
    inputs: {
      message: "message",
      trim: "trim",
      type: "type"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost, {
      provide: PROPERTY_TOKEN_validationRules,
      useExisting: _DxiDataGridRequiredRuleComponent
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxiDataGridRequiredRuleComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridRequiredRuleComponent, [{
    type: Component,
    args: [{
      selector: "dxi-data-grid-required-rule",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost, {
        provide: PROPERTY_TOKEN_validationRules,
        useExisting: DxiDataGridRequiredRuleComponent
      }]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    message: [{
      type: Input
    }],
    trim: [{
      type: Input
    }],
    type: [{
      type: Input
    }]
  });
})();
var DxiDataGridRequiredRuleModule = class _DxiDataGridRequiredRuleModule {
  /** @nocollapse */
  static ɵfac = function DxiDataGridRequiredRuleModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridRequiredRuleModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxiDataGridRequiredRuleModule,
    imports: [DxiDataGridRequiredRuleComponent],
    exports: [DxiDataGridRequiredRuleComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxiDataGridRequiredRuleComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridRequiredRuleModule, [{
    type: NgModule,
    args: [{
      imports: [DxiDataGridRequiredRuleComponent],
      exports: [DxiDataGridRequiredRuleComponent]
    }]
  }], null, null);
})();
var DxoDataGridRowDraggingComponent = class _DxoDataGridRowDraggingComponent extends NestedOption {
  get allowDropInsideItem() {
    return this._getOption("allowDropInsideItem");
  }
  set allowDropInsideItem(value2) {
    this._setOption("allowDropInsideItem", value2);
  }
  get allowReordering() {
    return this._getOption("allowReordering");
  }
  set allowReordering(value2) {
    this._setOption("allowReordering", value2);
  }
  get autoScroll() {
    return this._getOption("autoScroll");
  }
  set autoScroll(value2) {
    this._setOption("autoScroll", value2);
  }
  get boundary() {
    return this._getOption("boundary");
  }
  set boundary(value2) {
    this._setOption("boundary", value2);
  }
  get container() {
    return this._getOption("container");
  }
  set container(value2) {
    this._setOption("container", value2);
  }
  get cursorOffset() {
    return this._getOption("cursorOffset");
  }
  set cursorOffset(value2) {
    this._setOption("cursorOffset", value2);
  }
  get data() {
    return this._getOption("data");
  }
  set data(value2) {
    this._setOption("data", value2);
  }
  get dragDirection() {
    return this._getOption("dragDirection");
  }
  set dragDirection(value2) {
    this._setOption("dragDirection", value2);
  }
  get dragTemplate() {
    return this._getOption("dragTemplate");
  }
  set dragTemplate(value2) {
    this._setOption("dragTemplate", value2);
  }
  get dropFeedbackMode() {
    return this._getOption("dropFeedbackMode");
  }
  set dropFeedbackMode(value2) {
    this._setOption("dropFeedbackMode", value2);
  }
  get filter() {
    return this._getOption("filter");
  }
  set filter(value2) {
    this._setOption("filter", value2);
  }
  get group() {
    return this._getOption("group");
  }
  set group(value2) {
    this._setOption("group", value2);
  }
  get handle() {
    return this._getOption("handle");
  }
  set handle(value2) {
    this._setOption("handle", value2);
  }
  get onAdd() {
    return this._getOption("onAdd");
  }
  set onAdd(value2) {
    this._setOption("onAdd", value2);
  }
  get onDragChange() {
    return this._getOption("onDragChange");
  }
  set onDragChange(value2) {
    this._setOption("onDragChange", value2);
  }
  get onDragEnd() {
    return this._getOption("onDragEnd");
  }
  set onDragEnd(value2) {
    this._setOption("onDragEnd", value2);
  }
  get onDragMove() {
    return this._getOption("onDragMove");
  }
  set onDragMove(value2) {
    this._setOption("onDragMove", value2);
  }
  get onDragStart() {
    return this._getOption("onDragStart");
  }
  set onDragStart(value2) {
    this._setOption("onDragStart", value2);
  }
  get onRemove() {
    return this._getOption("onRemove");
  }
  set onRemove(value2) {
    this._setOption("onRemove", value2);
  }
  get onReorder() {
    return this._getOption("onReorder");
  }
  set onReorder(value2) {
    this._setOption("onReorder", value2);
  }
  get scrollSensitivity() {
    return this._getOption("scrollSensitivity");
  }
  set scrollSensitivity(value2) {
    this._setOption("scrollSensitivity", value2);
  }
  get scrollSpeed() {
    return this._getOption("scrollSpeed");
  }
  set scrollSpeed(value2) {
    this._setOption("scrollSpeed", value2);
  }
  get showDragIcons() {
    return this._getOption("showDragIcons");
  }
  set showDragIcons(value2) {
    this._setOption("showDragIcons", value2);
  }
  get _optionPath() {
    return "rowDragging";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridRowDraggingComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridRowDraggingComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridRowDraggingComponent,
    selectors: [["dxo-data-grid-row-dragging"]],
    inputs: {
      allowDropInsideItem: "allowDropInsideItem",
      allowReordering: "allowReordering",
      autoScroll: "autoScroll",
      boundary: "boundary",
      container: "container",
      cursorOffset: "cursorOffset",
      data: "data",
      dragDirection: "dragDirection",
      dragTemplate: "dragTemplate",
      dropFeedbackMode: "dropFeedbackMode",
      filter: "filter",
      group: "group",
      handle: "handle",
      onAdd: "onAdd",
      onDragChange: "onDragChange",
      onDragEnd: "onDragEnd",
      onDragMove: "onDragMove",
      onDragStart: "onDragStart",
      onRemove: "onRemove",
      onReorder: "onReorder",
      scrollSensitivity: "scrollSensitivity",
      scrollSpeed: "scrollSpeed",
      showDragIcons: "showDragIcons"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridRowDraggingComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridRowDraggingComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-row-dragging",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    allowDropInsideItem: [{
      type: Input
    }],
    allowReordering: [{
      type: Input
    }],
    autoScroll: [{
      type: Input
    }],
    boundary: [{
      type: Input
    }],
    container: [{
      type: Input
    }],
    cursorOffset: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    dragDirection: [{
      type: Input
    }],
    dragTemplate: [{
      type: Input
    }],
    dropFeedbackMode: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    group: [{
      type: Input
    }],
    handle: [{
      type: Input
    }],
    onAdd: [{
      type: Input
    }],
    onDragChange: [{
      type: Input
    }],
    onDragEnd: [{
      type: Input
    }],
    onDragMove: [{
      type: Input
    }],
    onDragStart: [{
      type: Input
    }],
    onRemove: [{
      type: Input
    }],
    onReorder: [{
      type: Input
    }],
    scrollSensitivity: [{
      type: Input
    }],
    scrollSpeed: [{
      type: Input
    }],
    showDragIcons: [{
      type: Input
    }]
  });
})();
var DxoDataGridRowDraggingModule = class _DxoDataGridRowDraggingModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridRowDraggingModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridRowDraggingModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridRowDraggingModule,
    imports: [DxoDataGridRowDraggingComponent],
    exports: [DxoDataGridRowDraggingComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridRowDraggingComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridRowDraggingModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridRowDraggingComponent],
      exports: [DxoDataGridRowDraggingComponent]
    }]
  }], null, null);
})();
var DxoDataGridScrollingComponent = class _DxoDataGridScrollingComponent extends NestedOption {
  get columnRenderingMode() {
    return this._getOption("columnRenderingMode");
  }
  set columnRenderingMode(value2) {
    this._setOption("columnRenderingMode", value2);
  }
  get mode() {
    return this._getOption("mode");
  }
  set mode(value2) {
    this._setOption("mode", value2);
  }
  get preloadEnabled() {
    return this._getOption("preloadEnabled");
  }
  set preloadEnabled(value2) {
    this._setOption("preloadEnabled", value2);
  }
  get renderAsync() {
    return this._getOption("renderAsync");
  }
  set renderAsync(value2) {
    this._setOption("renderAsync", value2);
  }
  get rowRenderingMode() {
    return this._getOption("rowRenderingMode");
  }
  set rowRenderingMode(value2) {
    this._setOption("rowRenderingMode", value2);
  }
  get scrollByContent() {
    return this._getOption("scrollByContent");
  }
  set scrollByContent(value2) {
    this._setOption("scrollByContent", value2);
  }
  get scrollByThumb() {
    return this._getOption("scrollByThumb");
  }
  set scrollByThumb(value2) {
    this._setOption("scrollByThumb", value2);
  }
  get showScrollbar() {
    return this._getOption("showScrollbar");
  }
  set showScrollbar(value2) {
    this._setOption("showScrollbar", value2);
  }
  get useNative() {
    return this._getOption("useNative");
  }
  set useNative(value2) {
    this._setOption("useNative", value2);
  }
  get _optionPath() {
    return "scrolling";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridScrollingComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridScrollingComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridScrollingComponent,
    selectors: [["dxo-data-grid-scrolling"]],
    inputs: {
      columnRenderingMode: "columnRenderingMode",
      mode: "mode",
      preloadEnabled: "preloadEnabled",
      renderAsync: "renderAsync",
      rowRenderingMode: "rowRenderingMode",
      scrollByContent: "scrollByContent",
      scrollByThumb: "scrollByThumb",
      showScrollbar: "showScrollbar",
      useNative: "useNative"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridScrollingComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridScrollingComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-scrolling",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    columnRenderingMode: [{
      type: Input
    }],
    mode: [{
      type: Input
    }],
    preloadEnabled: [{
      type: Input
    }],
    renderAsync: [{
      type: Input
    }],
    rowRenderingMode: [{
      type: Input
    }],
    scrollByContent: [{
      type: Input
    }],
    scrollByThumb: [{
      type: Input
    }],
    showScrollbar: [{
      type: Input
    }],
    useNative: [{
      type: Input
    }]
  });
})();
var DxoDataGridScrollingModule = class _DxoDataGridScrollingModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridScrollingModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridScrollingModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridScrollingModule,
    imports: [DxoDataGridScrollingComponent],
    exports: [DxoDataGridScrollingComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridScrollingComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridScrollingModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridScrollingComponent],
      exports: [DxoDataGridScrollingComponent]
    }]
  }], null, null);
})();
var DxoDataGridSearchPanelComponent = class _DxoDataGridSearchPanelComponent extends NestedOption {
  get highlightCaseSensitive() {
    return this._getOption("highlightCaseSensitive");
  }
  set highlightCaseSensitive(value2) {
    this._setOption("highlightCaseSensitive", value2);
  }
  get highlightSearchText() {
    return this._getOption("highlightSearchText");
  }
  set highlightSearchText(value2) {
    this._setOption("highlightSearchText", value2);
  }
  get placeholder() {
    return this._getOption("placeholder");
  }
  set placeholder(value2) {
    this._setOption("placeholder", value2);
  }
  get searchVisibleColumnsOnly() {
    return this._getOption("searchVisibleColumnsOnly");
  }
  set searchVisibleColumnsOnly(value2) {
    this._setOption("searchVisibleColumnsOnly", value2);
  }
  get text() {
    return this._getOption("text");
  }
  set text(value2) {
    this._setOption("text", value2);
  }
  get visible() {
    return this._getOption("visible");
  }
  set visible(value2) {
    this._setOption("visible", value2);
  }
  get width() {
    return this._getOption("width");
  }
  set width(value2) {
    this._setOption("width", value2);
  }
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  textChange;
  get _optionPath() {
    return "searchPanel";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    this._createEventEmitters([{
      emit: "textChange"
    }]);
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridSearchPanelComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridSearchPanelComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridSearchPanelComponent,
    selectors: [["dxo-data-grid-search-panel"]],
    inputs: {
      highlightCaseSensitive: "highlightCaseSensitive",
      highlightSearchText: "highlightSearchText",
      placeholder: "placeholder",
      searchVisibleColumnsOnly: "searchVisibleColumnsOnly",
      text: "text",
      visible: "visible",
      width: "width"
    },
    outputs: {
      textChange: "textChange"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridSearchPanelComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridSearchPanelComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-search-panel",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    highlightCaseSensitive: [{
      type: Input
    }],
    highlightSearchText: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    searchVisibleColumnsOnly: [{
      type: Input
    }],
    text: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    textChange: [{
      type: Output
    }]
  });
})();
var DxoDataGridSearchPanelModule = class _DxoDataGridSearchPanelModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridSearchPanelModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridSearchPanelModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridSearchPanelModule,
    imports: [DxoDataGridSearchPanelComponent],
    exports: [DxoDataGridSearchPanelComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridSearchPanelComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridSearchPanelModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridSearchPanelComponent],
      exports: [DxoDataGridSearchPanelComponent]
    }]
  }], null, null);
})();
var DxoDataGridSearchComponent = class _DxoDataGridSearchComponent extends NestedOption {
  get editorOptions() {
    return this._getOption("editorOptions");
  }
  set editorOptions(value2) {
    this._setOption("editorOptions", value2);
  }
  get enabled() {
    return this._getOption("enabled");
  }
  set enabled(value2) {
    this._setOption("enabled", value2);
  }
  get mode() {
    return this._getOption("mode");
  }
  set mode(value2) {
    this._setOption("mode", value2);
  }
  get searchExpr() {
    return this._getOption("searchExpr");
  }
  set searchExpr(value2) {
    this._setOption("searchExpr", value2);
  }
  get timeout() {
    return this._getOption("timeout");
  }
  set timeout(value2) {
    this._setOption("timeout", value2);
  }
  get _optionPath() {
    return "search";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridSearchComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridSearchComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridSearchComponent,
    selectors: [["dxo-data-grid-search"]],
    inputs: {
      editorOptions: "editorOptions",
      enabled: "enabled",
      mode: "mode",
      searchExpr: "searchExpr",
      timeout: "timeout"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridSearchComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridSearchComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-search",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    editorOptions: [{
      type: Input
    }],
    enabled: [{
      type: Input
    }],
    mode: [{
      type: Input
    }],
    searchExpr: [{
      type: Input
    }],
    timeout: [{
      type: Input
    }]
  });
})();
var DxoDataGridSearchModule = class _DxoDataGridSearchModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridSearchModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridSearchModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridSearchModule,
    imports: [DxoDataGridSearchComponent],
    exports: [DxoDataGridSearchComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridSearchComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridSearchModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridSearchComponent],
      exports: [DxoDataGridSearchComponent]
    }]
  }], null, null);
})();
var DxoDataGridSelectionComponent = class _DxoDataGridSelectionComponent extends NestedOption {
  get allowSelectAll() {
    return this._getOption("allowSelectAll");
  }
  set allowSelectAll(value2) {
    this._setOption("allowSelectAll", value2);
  }
  get deferred() {
    return this._getOption("deferred");
  }
  set deferred(value2) {
    this._setOption("deferred", value2);
  }
  get mode() {
    return this._getOption("mode");
  }
  set mode(value2) {
    this._setOption("mode", value2);
  }
  get selectAllMode() {
    return this._getOption("selectAllMode");
  }
  set selectAllMode(value2) {
    this._setOption("selectAllMode", value2);
  }
  get sensitivity() {
    return this._getOption("sensitivity");
  }
  set sensitivity(value2) {
    this._setOption("sensitivity", value2);
  }
  get showCheckBoxesMode() {
    return this._getOption("showCheckBoxesMode");
  }
  set showCheckBoxesMode(value2) {
    this._setOption("showCheckBoxesMode", value2);
  }
  get recursive() {
    return this._getOption("recursive");
  }
  set recursive(value2) {
    this._setOption("recursive", value2);
  }
  get selectByClick() {
    return this._getOption("selectByClick");
  }
  set selectByClick(value2) {
    this._setOption("selectByClick", value2);
  }
  get _optionPath() {
    return "selection";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridSelectionComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridSelectionComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridSelectionComponent,
    selectors: [["dxo-data-grid-selection"]],
    inputs: {
      allowSelectAll: "allowSelectAll",
      deferred: "deferred",
      mode: "mode",
      selectAllMode: "selectAllMode",
      sensitivity: "sensitivity",
      showCheckBoxesMode: "showCheckBoxesMode",
      recursive: "recursive",
      selectByClick: "selectByClick"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridSelectionComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridSelectionComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-selection",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    allowSelectAll: [{
      type: Input
    }],
    deferred: [{
      type: Input
    }],
    mode: [{
      type: Input
    }],
    selectAllMode: [{
      type: Input
    }],
    sensitivity: [{
      type: Input
    }],
    showCheckBoxesMode: [{
      type: Input
    }],
    recursive: [{
      type: Input
    }],
    selectByClick: [{
      type: Input
    }]
  });
})();
var DxoDataGridSelectionModule = class _DxoDataGridSelectionModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridSelectionModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridSelectionModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridSelectionModule,
    imports: [DxoDataGridSelectionComponent],
    exports: [DxoDataGridSelectionComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridSelectionComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridSelectionModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridSelectionComponent],
      exports: [DxoDataGridSelectionComponent]
    }]
  }], null, null);
})();
var DxoDataGridShowComponent = class _DxoDataGridShowComponent extends NestedOption {
  get complete() {
    return this._getOption("complete");
  }
  set complete(value2) {
    this._setOption("complete", value2);
  }
  get delay() {
    return this._getOption("delay");
  }
  set delay(value2) {
    this._setOption("delay", value2);
  }
  get direction() {
    return this._getOption("direction");
  }
  set direction(value2) {
    this._setOption("direction", value2);
  }
  get duration() {
    return this._getOption("duration");
  }
  set duration(value2) {
    this._setOption("duration", value2);
  }
  get easing() {
    return this._getOption("easing");
  }
  set easing(value2) {
    this._setOption("easing", value2);
  }
  get from() {
    return this._getOption("from");
  }
  set from(value2) {
    this._setOption("from", value2);
  }
  get staggerDelay() {
    return this._getOption("staggerDelay");
  }
  set staggerDelay(value2) {
    this._setOption("staggerDelay", value2);
  }
  get start() {
    return this._getOption("start");
  }
  set start(value2) {
    this._setOption("start", value2);
  }
  get to() {
    return this._getOption("to");
  }
  set to(value2) {
    this._setOption("to", value2);
  }
  get type() {
    return this._getOption("type");
  }
  set type(value2) {
    this._setOption("type", value2);
  }
  get _optionPath() {
    return "show";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridShowComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridShowComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridShowComponent,
    selectors: [["dxo-data-grid-show"]],
    inputs: {
      complete: "complete",
      delay: "delay",
      direction: "direction",
      duration: "duration",
      easing: "easing",
      from: "from",
      staggerDelay: "staggerDelay",
      start: "start",
      to: "to",
      type: "type"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridShowComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridShowComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-show",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    complete: [{
      type: Input
    }],
    delay: [{
      type: Input
    }],
    direction: [{
      type: Input
    }],
    duration: [{
      type: Input
    }],
    easing: [{
      type: Input
    }],
    from: [{
      type: Input
    }],
    staggerDelay: [{
      type: Input
    }],
    start: [{
      type: Input
    }],
    to: [{
      type: Input
    }],
    type: [{
      type: Input
    }]
  });
})();
var DxoDataGridShowModule = class _DxoDataGridShowModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridShowModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridShowModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridShowModule,
    imports: [DxoDataGridShowComponent],
    exports: [DxoDataGridShowComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridShowComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridShowModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridShowComponent],
      exports: [DxoDataGridShowComponent]
    }]
  }], null, null);
})();
var DxiDataGridSortByGroupSummaryInfoComponent = class _DxiDataGridSortByGroupSummaryInfoComponent extends CollectionNestedOption {
  get groupColumn() {
    return this._getOption("groupColumn");
  }
  set groupColumn(value2) {
    this._setOption("groupColumn", value2);
  }
  get sortOrder() {
    return this._getOption("sortOrder");
  }
  set sortOrder(value2) {
    this._setOption("sortOrder", value2);
  }
  get summaryItem() {
    return this._getOption("summaryItem");
  }
  set summaryItem(value2) {
    this._setOption("summaryItem", value2);
  }
  get _optionPath() {
    return "sortByGroupSummaryInfo";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnDestroy() {
    this._deleteRemovedOptions(this._fullOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxiDataGridSortByGroupSummaryInfoComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridSortByGroupSummaryInfoComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxiDataGridSortByGroupSummaryInfoComponent,
    selectors: [["dxi-data-grid-sort-by-group-summary-info"]],
    inputs: {
      groupColumn: "groupColumn",
      sortOrder: "sortOrder",
      summaryItem: "summaryItem"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost, {
      provide: PROPERTY_TOKEN_sortByGroupSummaryInfo,
      useExisting: _DxiDataGridSortByGroupSummaryInfoComponent
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxiDataGridSortByGroupSummaryInfoComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridSortByGroupSummaryInfoComponent, [{
    type: Component,
    args: [{
      selector: "dxi-data-grid-sort-by-group-summary-info",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost, {
        provide: PROPERTY_TOKEN_sortByGroupSummaryInfo,
        useExisting: DxiDataGridSortByGroupSummaryInfoComponent
      }]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    groupColumn: [{
      type: Input
    }],
    sortOrder: [{
      type: Input
    }],
    summaryItem: [{
      type: Input
    }]
  });
})();
var DxiDataGridSortByGroupSummaryInfoModule = class _DxiDataGridSortByGroupSummaryInfoModule {
  /** @nocollapse */
  static ɵfac = function DxiDataGridSortByGroupSummaryInfoModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridSortByGroupSummaryInfoModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxiDataGridSortByGroupSummaryInfoModule,
    imports: [DxiDataGridSortByGroupSummaryInfoComponent],
    exports: [DxiDataGridSortByGroupSummaryInfoComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxiDataGridSortByGroupSummaryInfoComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridSortByGroupSummaryInfoModule, [{
    type: NgModule,
    args: [{
      imports: [DxiDataGridSortByGroupSummaryInfoComponent],
      exports: [DxiDataGridSortByGroupSummaryInfoComponent]
    }]
  }], null, null);
})();
var DxoDataGridSortingComponent = class _DxoDataGridSortingComponent extends NestedOption {
  get ascendingText() {
    return this._getOption("ascendingText");
  }
  set ascendingText(value2) {
    this._setOption("ascendingText", value2);
  }
  get clearText() {
    return this._getOption("clearText");
  }
  set clearText(value2) {
    this._setOption("clearText", value2);
  }
  get descendingText() {
    return this._getOption("descendingText");
  }
  set descendingText(value2) {
    this._setOption("descendingText", value2);
  }
  get mode() {
    return this._getOption("mode");
  }
  set mode(value2) {
    this._setOption("mode", value2);
  }
  get showSortIndexes() {
    return this._getOption("showSortIndexes");
  }
  set showSortIndexes(value2) {
    this._setOption("showSortIndexes", value2);
  }
  get _optionPath() {
    return "sorting";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridSortingComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridSortingComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridSortingComponent,
    selectors: [["dxo-data-grid-sorting"]],
    inputs: {
      ascendingText: "ascendingText",
      clearText: "clearText",
      descendingText: "descendingText",
      mode: "mode",
      showSortIndexes: "showSortIndexes"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridSortingComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridSortingComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-sorting",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    ascendingText: [{
      type: Input
    }],
    clearText: [{
      type: Input
    }],
    descendingText: [{
      type: Input
    }],
    mode: [{
      type: Input
    }],
    showSortIndexes: [{
      type: Input
    }]
  });
})();
var DxoDataGridSortingModule = class _DxoDataGridSortingModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridSortingModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridSortingModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridSortingModule,
    imports: [DxoDataGridSortingComponent],
    exports: [DxoDataGridSortingComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridSortingComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridSortingModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridSortingComponent],
      exports: [DxoDataGridSortingComponent]
    }]
  }], null, null);
})();
var DxoDataGridStateStoringComponent = class _DxoDataGridStateStoringComponent extends NestedOption {
  get customLoad() {
    return this._getOption("customLoad");
  }
  set customLoad(value2) {
    this._setOption("customLoad", value2);
  }
  get customSave() {
    return this._getOption("customSave");
  }
  set customSave(value2) {
    this._setOption("customSave", value2);
  }
  get enabled() {
    return this._getOption("enabled");
  }
  set enabled(value2) {
    this._setOption("enabled", value2);
  }
  get savingTimeout() {
    return this._getOption("savingTimeout");
  }
  set savingTimeout(value2) {
    this._setOption("savingTimeout", value2);
  }
  get storageKey() {
    return this._getOption("storageKey");
  }
  set storageKey(value2) {
    this._setOption("storageKey", value2);
  }
  get type() {
    return this._getOption("type");
  }
  set type(value2) {
    this._setOption("type", value2);
  }
  get _optionPath() {
    return "stateStoring";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridStateStoringComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridStateStoringComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridStateStoringComponent,
    selectors: [["dxo-data-grid-state-storing"]],
    inputs: {
      customLoad: "customLoad",
      customSave: "customSave",
      enabled: "enabled",
      savingTimeout: "savingTimeout",
      storageKey: "storageKey",
      type: "type"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridStateStoringComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridStateStoringComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-state-storing",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    customLoad: [{
      type: Input
    }],
    customSave: [{
      type: Input
    }],
    enabled: [{
      type: Input
    }],
    savingTimeout: [{
      type: Input
    }],
    storageKey: [{
      type: Input
    }],
    type: [{
      type: Input
    }]
  });
})();
var DxoDataGridStateStoringModule = class _DxoDataGridStateStoringModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridStateStoringModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridStateStoringModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridStateStoringModule,
    imports: [DxoDataGridStateStoringComponent],
    exports: [DxoDataGridStateStoringComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridStateStoringComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridStateStoringModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridStateStoringComponent],
      exports: [DxoDataGridStateStoringComponent]
    }]
  }], null, null);
})();
var DxiDataGridStringLengthRuleComponent = class _DxiDataGridStringLengthRuleComponent extends CollectionNestedOption {
  get ignoreEmptyValue() {
    return this._getOption("ignoreEmptyValue");
  }
  set ignoreEmptyValue(value2) {
    this._setOption("ignoreEmptyValue", value2);
  }
  get max() {
    return this._getOption("max");
  }
  set max(value2) {
    this._setOption("max", value2);
  }
  get message() {
    return this._getOption("message");
  }
  set message(value2) {
    this._setOption("message", value2);
  }
  get min() {
    return this._getOption("min");
  }
  set min(value2) {
    this._setOption("min", value2);
  }
  get trim() {
    return this._getOption("trim");
  }
  set trim(value2) {
    this._setOption("trim", value2);
  }
  get type() {
    return this._getOption("type");
  }
  set type(value2) {
    this._setOption("type", value2);
  }
  get _optionPath() {
    return "validationRules";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
    this.type = "stringLength";
  }
  ngOnDestroy() {
    this._deleteRemovedOptions(this._fullOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxiDataGridStringLengthRuleComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridStringLengthRuleComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxiDataGridStringLengthRuleComponent,
    selectors: [["dxi-data-grid-string-length-rule"]],
    inputs: {
      ignoreEmptyValue: "ignoreEmptyValue",
      max: "max",
      message: "message",
      min: "min",
      trim: "trim",
      type: "type"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost, {
      provide: PROPERTY_TOKEN_validationRules,
      useExisting: _DxiDataGridStringLengthRuleComponent
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxiDataGridStringLengthRuleComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridStringLengthRuleComponent, [{
    type: Component,
    args: [{
      selector: "dxi-data-grid-string-length-rule",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost, {
        provide: PROPERTY_TOKEN_validationRules,
        useExisting: DxiDataGridStringLengthRuleComponent
      }]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    ignoreEmptyValue: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    message: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    trim: [{
      type: Input
    }],
    type: [{
      type: Input
    }]
  });
})();
var DxiDataGridStringLengthRuleModule = class _DxiDataGridStringLengthRuleModule {
  /** @nocollapse */
  static ɵfac = function DxiDataGridStringLengthRuleModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridStringLengthRuleModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxiDataGridStringLengthRuleModule,
    imports: [DxiDataGridStringLengthRuleComponent],
    exports: [DxiDataGridStringLengthRuleComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxiDataGridStringLengthRuleComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridStringLengthRuleModule, [{
    type: NgModule,
    args: [{
      imports: [DxiDataGridStringLengthRuleComponent],
      exports: [DxiDataGridStringLengthRuleComponent]
    }]
  }], null, null);
})();
var DxoDataGridSummaryTextsComponent = class _DxoDataGridSummaryTextsComponent extends NestedOption {
  get avg() {
    return this._getOption("avg");
  }
  set avg(value2) {
    this._setOption("avg", value2);
  }
  get avgOtherColumn() {
    return this._getOption("avgOtherColumn");
  }
  set avgOtherColumn(value2) {
    this._setOption("avgOtherColumn", value2);
  }
  get count() {
    return this._getOption("count");
  }
  set count(value2) {
    this._setOption("count", value2);
  }
  get max() {
    return this._getOption("max");
  }
  set max(value2) {
    this._setOption("max", value2);
  }
  get maxOtherColumn() {
    return this._getOption("maxOtherColumn");
  }
  set maxOtherColumn(value2) {
    this._setOption("maxOtherColumn", value2);
  }
  get min() {
    return this._getOption("min");
  }
  set min(value2) {
    this._setOption("min", value2);
  }
  get minOtherColumn() {
    return this._getOption("minOtherColumn");
  }
  set minOtherColumn(value2) {
    this._setOption("minOtherColumn", value2);
  }
  get sum() {
    return this._getOption("sum");
  }
  set sum(value2) {
    this._setOption("sum", value2);
  }
  get sumOtherColumn() {
    return this._getOption("sumOtherColumn");
  }
  set sumOtherColumn(value2) {
    this._setOption("sumOtherColumn", value2);
  }
  get _optionPath() {
    return "texts";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridSummaryTextsComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridSummaryTextsComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridSummaryTextsComponent,
    selectors: [["dxo-data-grid-summary-texts"]],
    inputs: {
      avg: "avg",
      avgOtherColumn: "avgOtherColumn",
      count: "count",
      max: "max",
      maxOtherColumn: "maxOtherColumn",
      min: "min",
      minOtherColumn: "minOtherColumn",
      sum: "sum",
      sumOtherColumn: "sumOtherColumn"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridSummaryTextsComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridSummaryTextsComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-summary-texts",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    avg: [{
      type: Input
    }],
    avgOtherColumn: [{
      type: Input
    }],
    count: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    maxOtherColumn: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    minOtherColumn: [{
      type: Input
    }],
    sum: [{
      type: Input
    }],
    sumOtherColumn: [{
      type: Input
    }]
  });
})();
var DxoDataGridSummaryTextsModule = class _DxoDataGridSummaryTextsModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridSummaryTextsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridSummaryTextsModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridSummaryTextsModule,
    imports: [DxoDataGridSummaryTextsComponent],
    exports: [DxoDataGridSummaryTextsComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridSummaryTextsComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridSummaryTextsModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridSummaryTextsComponent],
      exports: [DxoDataGridSummaryTextsComponent]
    }]
  }], null, null);
})();
var DxoDataGridSummaryComponent = class _DxoDataGridSummaryComponent extends NestedOption {
  set _groupItemsContentChildren(value2) {
    this.setChildren("groupItems", value2);
  }
  set _totalItemsContentChildren(value2) {
    this.setChildren("totalItems", value2);
  }
  get calculateCustomSummary() {
    return this._getOption("calculateCustomSummary");
  }
  set calculateCustomSummary(value2) {
    this._setOption("calculateCustomSummary", value2);
  }
  get groupItems() {
    return this._getOption("groupItems");
  }
  set groupItems(value2) {
    this._setOption("groupItems", value2);
  }
  get recalculateWhileEditing() {
    return this._getOption("recalculateWhileEditing");
  }
  set recalculateWhileEditing(value2) {
    this._setOption("recalculateWhileEditing", value2);
  }
  get skipEmptyValues() {
    return this._getOption("skipEmptyValues");
  }
  set skipEmptyValues(value2) {
    this._setOption("skipEmptyValues", value2);
  }
  get texts() {
    return this._getOption("texts");
  }
  set texts(value2) {
    this._setOption("texts", value2);
  }
  get totalItems() {
    return this._getOption("totalItems");
  }
  set totalItems(value2) {
    this._setOption("totalItems", value2);
  }
  get _optionPath() {
    return "summary";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridSummaryComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridSummaryComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridSummaryComponent,
    selectors: [["dxo-data-grid-summary"]],
    contentQueries: function DxoDataGridSummaryComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, PROPERTY_TOKEN_groupItems, 4);
        ɵɵcontentQuery(dirIndex, PROPERTY_TOKEN_totalItems, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._groupItemsContentChildren = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._totalItemsContentChildren = _t);
      }
    },
    inputs: {
      calculateCustomSummary: "calculateCustomSummary",
      groupItems: "groupItems",
      recalculateWhileEditing: "recalculateWhileEditing",
      skipEmptyValues: "skipEmptyValues",
      texts: "texts",
      totalItems: "totalItems"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridSummaryComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridSummaryComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-summary",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    _groupItemsContentChildren: [{
      type: ContentChildren,
      args: [PROPERTY_TOKEN_groupItems]
    }],
    _totalItemsContentChildren: [{
      type: ContentChildren,
      args: [PROPERTY_TOKEN_totalItems]
    }],
    calculateCustomSummary: [{
      type: Input
    }],
    groupItems: [{
      type: Input
    }],
    recalculateWhileEditing: [{
      type: Input
    }],
    skipEmptyValues: [{
      type: Input
    }],
    texts: [{
      type: Input
    }],
    totalItems: [{
      type: Input
    }]
  });
})();
var DxoDataGridSummaryModule = class _DxoDataGridSummaryModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridSummaryModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridSummaryModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridSummaryModule,
    imports: [DxoDataGridSummaryComponent],
    exports: [DxoDataGridSummaryComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridSummaryComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridSummaryModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridSummaryComponent],
      exports: [DxoDataGridSummaryComponent]
    }]
  }], null, null);
})();
var DxoDataGridTextsComponent = class _DxoDataGridTextsComponent extends NestedOption {
  get addRow() {
    return this._getOption("addRow");
  }
  set addRow(value2) {
    this._setOption("addRow", value2);
  }
  get cancelAllChanges() {
    return this._getOption("cancelAllChanges");
  }
  set cancelAllChanges(value2) {
    this._setOption("cancelAllChanges", value2);
  }
  get cancelRowChanges() {
    return this._getOption("cancelRowChanges");
  }
  set cancelRowChanges(value2) {
    this._setOption("cancelRowChanges", value2);
  }
  get confirmDeleteMessage() {
    return this._getOption("confirmDeleteMessage");
  }
  set confirmDeleteMessage(value2) {
    this._setOption("confirmDeleteMessage", value2);
  }
  get confirmDeleteTitle() {
    return this._getOption("confirmDeleteTitle");
  }
  set confirmDeleteTitle(value2) {
    this._setOption("confirmDeleteTitle", value2);
  }
  get deleteRow() {
    return this._getOption("deleteRow");
  }
  set deleteRow(value2) {
    this._setOption("deleteRow", value2);
  }
  get editRow() {
    return this._getOption("editRow");
  }
  set editRow(value2) {
    this._setOption("editRow", value2);
  }
  get saveAllChanges() {
    return this._getOption("saveAllChanges");
  }
  set saveAllChanges(value2) {
    this._setOption("saveAllChanges", value2);
  }
  get saveRowChanges() {
    return this._getOption("saveRowChanges");
  }
  set saveRowChanges(value2) {
    this._setOption("saveRowChanges", value2);
  }
  get undeleteRow() {
    return this._getOption("undeleteRow");
  }
  set undeleteRow(value2) {
    this._setOption("undeleteRow", value2);
  }
  get validationCancelChanges() {
    return this._getOption("validationCancelChanges");
  }
  set validationCancelChanges(value2) {
    this._setOption("validationCancelChanges", value2);
  }
  get exportAll() {
    return this._getOption("exportAll");
  }
  set exportAll(value2) {
    this._setOption("exportAll", value2);
  }
  get exportSelectedRows() {
    return this._getOption("exportSelectedRows");
  }
  set exportSelectedRows(value2) {
    this._setOption("exportSelectedRows", value2);
  }
  get exportTo() {
    return this._getOption("exportTo");
  }
  set exportTo(value2) {
    this._setOption("exportTo", value2);
  }
  get groupByThisColumn() {
    return this._getOption("groupByThisColumn");
  }
  set groupByThisColumn(value2) {
    this._setOption("groupByThisColumn", value2);
  }
  get groupContinuedMessage() {
    return this._getOption("groupContinuedMessage");
  }
  set groupContinuedMessage(value2) {
    this._setOption("groupContinuedMessage", value2);
  }
  get groupContinuesMessage() {
    return this._getOption("groupContinuesMessage");
  }
  set groupContinuesMessage(value2) {
    this._setOption("groupContinuesMessage", value2);
  }
  get ungroup() {
    return this._getOption("ungroup");
  }
  set ungroup(value2) {
    this._setOption("ungroup", value2);
  }
  get ungroupAll() {
    return this._getOption("ungroupAll");
  }
  set ungroupAll(value2) {
    this._setOption("ungroupAll", value2);
  }
  get avg() {
    return this._getOption("avg");
  }
  set avg(value2) {
    this._setOption("avg", value2);
  }
  get avgOtherColumn() {
    return this._getOption("avgOtherColumn");
  }
  set avgOtherColumn(value2) {
    this._setOption("avgOtherColumn", value2);
  }
  get count() {
    return this._getOption("count");
  }
  set count(value2) {
    this._setOption("count", value2);
  }
  get max() {
    return this._getOption("max");
  }
  set max(value2) {
    this._setOption("max", value2);
  }
  get maxOtherColumn() {
    return this._getOption("maxOtherColumn");
  }
  set maxOtherColumn(value2) {
    this._setOption("maxOtherColumn", value2);
  }
  get min() {
    return this._getOption("min");
  }
  set min(value2) {
    this._setOption("min", value2);
  }
  get minOtherColumn() {
    return this._getOption("minOtherColumn");
  }
  set minOtherColumn(value2) {
    this._setOption("minOtherColumn", value2);
  }
  get sum() {
    return this._getOption("sum");
  }
  set sum(value2) {
    this._setOption("sum", value2);
  }
  get sumOtherColumn() {
    return this._getOption("sumOtherColumn");
  }
  set sumOtherColumn(value2) {
    this._setOption("sumOtherColumn", value2);
  }
  get fix() {
    return this._getOption("fix");
  }
  set fix(value2) {
    this._setOption("fix", value2);
  }
  get leftPosition() {
    return this._getOption("leftPosition");
  }
  set leftPosition(value2) {
    this._setOption("leftPosition", value2);
  }
  get rightPosition() {
    return this._getOption("rightPosition");
  }
  set rightPosition(value2) {
    this._setOption("rightPosition", value2);
  }
  get stickyPosition() {
    return this._getOption("stickyPosition");
  }
  set stickyPosition(value2) {
    this._setOption("stickyPosition", value2);
  }
  get unfix() {
    return this._getOption("unfix");
  }
  set unfix(value2) {
    this._setOption("unfix", value2);
  }
  get clearFilter() {
    return this._getOption("clearFilter");
  }
  set clearFilter(value2) {
    this._setOption("clearFilter", value2);
  }
  get createFilter() {
    return this._getOption("createFilter");
  }
  set createFilter(value2) {
    this._setOption("createFilter", value2);
  }
  get filterEnabledHint() {
    return this._getOption("filterEnabledHint");
  }
  set filterEnabledHint(value2) {
    this._setOption("filterEnabledHint", value2);
  }
  get cancel() {
    return this._getOption("cancel");
  }
  set cancel(value2) {
    this._setOption("cancel", value2);
  }
  get emptyValue() {
    return this._getOption("emptyValue");
  }
  set emptyValue(value2) {
    this._setOption("emptyValue", value2);
  }
  get ok() {
    return this._getOption("ok");
  }
  set ok(value2) {
    this._setOption("ok", value2);
  }
  get _optionPath() {
    return "texts";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridTextsComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridTextsComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridTextsComponent,
    selectors: [["dxo-data-grid-texts"]],
    inputs: {
      addRow: "addRow",
      cancelAllChanges: "cancelAllChanges",
      cancelRowChanges: "cancelRowChanges",
      confirmDeleteMessage: "confirmDeleteMessage",
      confirmDeleteTitle: "confirmDeleteTitle",
      deleteRow: "deleteRow",
      editRow: "editRow",
      saveAllChanges: "saveAllChanges",
      saveRowChanges: "saveRowChanges",
      undeleteRow: "undeleteRow",
      validationCancelChanges: "validationCancelChanges",
      exportAll: "exportAll",
      exportSelectedRows: "exportSelectedRows",
      exportTo: "exportTo",
      groupByThisColumn: "groupByThisColumn",
      groupContinuedMessage: "groupContinuedMessage",
      groupContinuesMessage: "groupContinuesMessage",
      ungroup: "ungroup",
      ungroupAll: "ungroupAll",
      avg: "avg",
      avgOtherColumn: "avgOtherColumn",
      count: "count",
      max: "max",
      maxOtherColumn: "maxOtherColumn",
      min: "min",
      minOtherColumn: "minOtherColumn",
      sum: "sum",
      sumOtherColumn: "sumOtherColumn",
      fix: "fix",
      leftPosition: "leftPosition",
      rightPosition: "rightPosition",
      stickyPosition: "stickyPosition",
      unfix: "unfix",
      clearFilter: "clearFilter",
      createFilter: "createFilter",
      filterEnabledHint: "filterEnabledHint",
      cancel: "cancel",
      emptyValue: "emptyValue",
      ok: "ok"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridTextsComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridTextsComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-texts",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    addRow: [{
      type: Input
    }],
    cancelAllChanges: [{
      type: Input
    }],
    cancelRowChanges: [{
      type: Input
    }],
    confirmDeleteMessage: [{
      type: Input
    }],
    confirmDeleteTitle: [{
      type: Input
    }],
    deleteRow: [{
      type: Input
    }],
    editRow: [{
      type: Input
    }],
    saveAllChanges: [{
      type: Input
    }],
    saveRowChanges: [{
      type: Input
    }],
    undeleteRow: [{
      type: Input
    }],
    validationCancelChanges: [{
      type: Input
    }],
    exportAll: [{
      type: Input
    }],
    exportSelectedRows: [{
      type: Input
    }],
    exportTo: [{
      type: Input
    }],
    groupByThisColumn: [{
      type: Input
    }],
    groupContinuedMessage: [{
      type: Input
    }],
    groupContinuesMessage: [{
      type: Input
    }],
    ungroup: [{
      type: Input
    }],
    ungroupAll: [{
      type: Input
    }],
    avg: [{
      type: Input
    }],
    avgOtherColumn: [{
      type: Input
    }],
    count: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    maxOtherColumn: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    minOtherColumn: [{
      type: Input
    }],
    sum: [{
      type: Input
    }],
    sumOtherColumn: [{
      type: Input
    }],
    fix: [{
      type: Input
    }],
    leftPosition: [{
      type: Input
    }],
    rightPosition: [{
      type: Input
    }],
    stickyPosition: [{
      type: Input
    }],
    unfix: [{
      type: Input
    }],
    clearFilter: [{
      type: Input
    }],
    createFilter: [{
      type: Input
    }],
    filterEnabledHint: [{
      type: Input
    }],
    cancel: [{
      type: Input
    }],
    emptyValue: [{
      type: Input
    }],
    ok: [{
      type: Input
    }]
  });
})();
var DxoDataGridTextsModule = class _DxoDataGridTextsModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridTextsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridTextsModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridTextsModule,
    imports: [DxoDataGridTextsComponent],
    exports: [DxoDataGridTextsComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridTextsComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridTextsModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridTextsComponent],
      exports: [DxoDataGridTextsComponent]
    }]
  }], null, null);
})();
var DxoDataGridToComponent = class _DxoDataGridToComponent extends NestedOption {
  get left() {
    return this._getOption("left");
  }
  set left(value2) {
    this._setOption("left", value2);
  }
  get opacity() {
    return this._getOption("opacity");
  }
  set opacity(value2) {
    this._setOption("opacity", value2);
  }
  get position() {
    return this._getOption("position");
  }
  set position(value2) {
    this._setOption("position", value2);
  }
  get scale() {
    return this._getOption("scale");
  }
  set scale(value2) {
    this._setOption("scale", value2);
  }
  get top() {
    return this._getOption("top");
  }
  set top(value2) {
    this._setOption("top", value2);
  }
  get _optionPath() {
    return "to";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridToComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridToComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridToComponent,
    selectors: [["dxo-data-grid-to"]],
    inputs: {
      left: "left",
      opacity: "opacity",
      position: "position",
      scale: "scale",
      top: "top"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridToComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridToComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-to",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    left: [{
      type: Input
    }],
    opacity: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    scale: [{
      type: Input
    }],
    top: [{
      type: Input
    }]
  });
})();
var DxoDataGridToModule = class _DxoDataGridToModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridToModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridToModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridToModule,
    imports: [DxoDataGridToComponent],
    exports: [DxoDataGridToComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridToComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridToModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridToComponent],
      exports: [DxoDataGridToComponent]
    }]
  }], null, null);
})();
var DxiDataGridToolbarItemComponent = class _DxiDataGridToolbarItemComponent extends CollectionNestedOption {
  renderer;
  document;
  element;
  get cssClass() {
    return this._getOption("cssClass");
  }
  set cssClass(value2) {
    this._setOption("cssClass", value2);
  }
  get disabled() {
    return this._getOption("disabled");
  }
  set disabled(value2) {
    this._setOption("disabled", value2);
  }
  get html() {
    return this._getOption("html");
  }
  set html(value2) {
    this._setOption("html", value2);
  }
  get locateInMenu() {
    return this._getOption("locateInMenu");
  }
  set locateInMenu(value2) {
    this._setOption("locateInMenu", value2);
  }
  get location() {
    return this._getOption("location");
  }
  set location(value2) {
    this._setOption("location", value2);
  }
  get menuItemTemplate() {
    return this._getOption("menuItemTemplate");
  }
  set menuItemTemplate(value2) {
    this._setOption("menuItemTemplate", value2);
  }
  get options() {
    return this._getOption("options");
  }
  set options(value2) {
    this._setOption("options", value2);
  }
  get showText() {
    return this._getOption("showText");
  }
  set showText(value2) {
    this._setOption("showText", value2);
  }
  get template() {
    return this._getOption("template");
  }
  set template(value2) {
    this._setOption("template", value2);
  }
  get text() {
    return this._getOption("text");
  }
  set text(value2) {
    this._setOption("text", value2);
  }
  get toolbar() {
    return this._getOption("toolbar");
  }
  set toolbar(value2) {
    this._setOption("toolbar", value2);
  }
  get visible() {
    return this._getOption("visible");
  }
  set visible(value2) {
    this._setOption("visible", value2);
  }
  get widget() {
    return this._getOption("widget");
  }
  set widget(value2) {
    this._setOption("widget", value2);
  }
  get _optionPath() {
    return "toolbarItems";
  }
  constructor(parentOptionHost, optionHost, renderer, document, templateHost, element) {
    super();
    this.renderer = renderer;
    this.document = document;
    this.element = element;
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
    templateHost.setHost(this);
  }
  setTemplate(template) {
    this.template = template;
  }
  ngAfterViewInit() {
    extractTemplate(this, this.element, this.renderer, this.document);
  }
  ngOnDestroy() {
    this._deleteRemovedOptions(this._fullOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxiDataGridToolbarItemComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridToolbarItemComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(DOCUMENT), ɵɵdirectiveInject(DxTemplateHost, 1), ɵɵdirectiveInject(ElementRef));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxiDataGridToolbarItemComponent,
    selectors: [["dxi-data-grid-toolbar-item"]],
    inputs: {
      cssClass: "cssClass",
      disabled: "disabled",
      html: "html",
      locateInMenu: "locateInMenu",
      location: "location",
      menuItemTemplate: "menuItemTemplate",
      options: "options",
      showText: "showText",
      template: "template",
      text: "text",
      toolbar: "toolbar",
      visible: "visible",
      widget: "widget"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost, DxTemplateHost, {
      provide: PROPERTY_TOKEN_toolbarItems,
      useExisting: _DxiDataGridToolbarItemComponent
    }]), ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function DxiDataGridToolbarItemComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    dependencies: [DxIntegrationModule],
    styles: ["[_nghost-%COMP%]{display:block}"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridToolbarItemComponent, [{
    type: Component,
    args: [{
      selector: "dxi-data-grid-toolbar-item",
      standalone: true,
      template: "<ng-content></ng-content>",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost, DxTemplateHost, {
        provide: PROPERTY_TOKEN_toolbarItems,
        useExisting: DxiDataGridToolbarItemComponent
      }],
      styles: [":host{display:block}\n"]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }, {
    type: Renderer2
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: DxTemplateHost,
    decorators: [{
      type: Host
    }]
  }, {
    type: ElementRef
  }], {
    cssClass: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    html: [{
      type: Input
    }],
    locateInMenu: [{
      type: Input
    }],
    location: [{
      type: Input
    }],
    menuItemTemplate: [{
      type: Input
    }],
    options: [{
      type: Input
    }],
    showText: [{
      type: Input
    }],
    template: [{
      type: Input
    }],
    text: [{
      type: Input
    }],
    toolbar: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    widget: [{
      type: Input
    }]
  });
})();
var DxiDataGridToolbarItemModule = class _DxiDataGridToolbarItemModule {
  /** @nocollapse */
  static ɵfac = function DxiDataGridToolbarItemModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridToolbarItemModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxiDataGridToolbarItemModule,
    imports: [DxiDataGridToolbarItemComponent],
    exports: [DxiDataGridToolbarItemComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxiDataGridToolbarItemComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridToolbarItemModule, [{
    type: NgModule,
    args: [{
      imports: [DxiDataGridToolbarItemComponent],
      exports: [DxiDataGridToolbarItemComponent]
    }]
  }], null, null);
})();
var DxoDataGridToolbarComponent = class _DxoDataGridToolbarComponent extends NestedOption {
  set _itemsContentChildren(value2) {
    this.setChildren("items", value2);
  }
  get disabled() {
    return this._getOption("disabled");
  }
  set disabled(value2) {
    this._setOption("disabled", value2);
  }
  get items() {
    return this._getOption("items");
  }
  set items(value2) {
    this._setOption("items", value2);
  }
  get visible() {
    return this._getOption("visible");
  }
  set visible(value2) {
    this._setOption("visible", value2);
  }
  get _optionPath() {
    return "toolbar";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridToolbarComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridToolbarComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridToolbarComponent,
    selectors: [["dxo-data-grid-toolbar"]],
    contentQueries: function DxoDataGridToolbarComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, PROPERTY_TOKEN_items, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._itemsContentChildren = _t);
      }
    },
    inputs: {
      disabled: "disabled",
      items: "items",
      visible: "visible"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridToolbarComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridToolbarComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-toolbar",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    _itemsContentChildren: [{
      type: ContentChildren,
      args: [PROPERTY_TOKEN_items]
    }],
    disabled: [{
      type: Input
    }],
    items: [{
      type: Input
    }],
    visible: [{
      type: Input
    }]
  });
})();
var DxoDataGridToolbarModule = class _DxoDataGridToolbarModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridToolbarModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridToolbarModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridToolbarModule,
    imports: [DxoDataGridToolbarComponent],
    exports: [DxoDataGridToolbarComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridToolbarComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridToolbarModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridToolbarComponent],
      exports: [DxoDataGridToolbarComponent]
    }]
  }], null, null);
})();
var DxiDataGridTotalItemComponent = class _DxiDataGridTotalItemComponent extends CollectionNestedOption {
  get alignment() {
    return this._getOption("alignment");
  }
  set alignment(value2) {
    this._setOption("alignment", value2);
  }
  get column() {
    return this._getOption("column");
  }
  set column(value2) {
    this._setOption("column", value2);
  }
  get cssClass() {
    return this._getOption("cssClass");
  }
  set cssClass(value2) {
    this._setOption("cssClass", value2);
  }
  get customizeText() {
    return this._getOption("customizeText");
  }
  set customizeText(value2) {
    this._setOption("customizeText", value2);
  }
  get displayFormat() {
    return this._getOption("displayFormat");
  }
  set displayFormat(value2) {
    this._setOption("displayFormat", value2);
  }
  get name() {
    return this._getOption("name");
  }
  set name(value2) {
    this._setOption("name", value2);
  }
  get showInColumn() {
    return this._getOption("showInColumn");
  }
  set showInColumn(value2) {
    this._setOption("showInColumn", value2);
  }
  get skipEmptyValues() {
    return this._getOption("skipEmptyValues");
  }
  set skipEmptyValues(value2) {
    this._setOption("skipEmptyValues", value2);
  }
  get summaryType() {
    return this._getOption("summaryType");
  }
  set summaryType(value2) {
    this._setOption("summaryType", value2);
  }
  get valueFormat() {
    return this._getOption("valueFormat");
  }
  set valueFormat(value2) {
    this._setOption("valueFormat", value2);
  }
  get _optionPath() {
    return "totalItems";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnDestroy() {
    this._deleteRemovedOptions(this._fullOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxiDataGridTotalItemComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridTotalItemComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxiDataGridTotalItemComponent,
    selectors: [["dxi-data-grid-total-item"]],
    inputs: {
      alignment: "alignment",
      column: "column",
      cssClass: "cssClass",
      customizeText: "customizeText",
      displayFormat: "displayFormat",
      name: "name",
      showInColumn: "showInColumn",
      skipEmptyValues: "skipEmptyValues",
      summaryType: "summaryType",
      valueFormat: "valueFormat"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost, {
      provide: PROPERTY_TOKEN_totalItems,
      useExisting: _DxiDataGridTotalItemComponent
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxiDataGridTotalItemComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridTotalItemComponent, [{
    type: Component,
    args: [{
      selector: "dxi-data-grid-total-item",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost, {
        provide: PROPERTY_TOKEN_totalItems,
        useExisting: DxiDataGridTotalItemComponent
      }]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    alignment: [{
      type: Input
    }],
    column: [{
      type: Input
    }],
    cssClass: [{
      type: Input
    }],
    customizeText: [{
      type: Input
    }],
    displayFormat: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    showInColumn: [{
      type: Input
    }],
    skipEmptyValues: [{
      type: Input
    }],
    summaryType: [{
      type: Input
    }],
    valueFormat: [{
      type: Input
    }]
  });
})();
var DxiDataGridTotalItemModule = class _DxiDataGridTotalItemModule {
  /** @nocollapse */
  static ɵfac = function DxiDataGridTotalItemModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridTotalItemModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxiDataGridTotalItemModule,
    imports: [DxiDataGridTotalItemComponent],
    exports: [DxiDataGridTotalItemComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxiDataGridTotalItemComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridTotalItemModule, [{
    type: NgModule,
    args: [{
      imports: [DxiDataGridTotalItemComponent],
      exports: [DxiDataGridTotalItemComponent]
    }]
  }], null, null);
})();
var DxiDataGridValidationRuleComponent = class _DxiDataGridValidationRuleComponent extends CollectionNestedOption {
  get message() {
    return this._getOption("message");
  }
  set message(value2) {
    this._setOption("message", value2);
  }
  get trim() {
    return this._getOption("trim");
  }
  set trim(value2) {
    this._setOption("trim", value2);
  }
  get type() {
    return this._getOption("type");
  }
  set type(value2) {
    this._setOption("type", value2);
  }
  get ignoreEmptyValue() {
    return this._getOption("ignoreEmptyValue");
  }
  set ignoreEmptyValue(value2) {
    this._setOption("ignoreEmptyValue", value2);
  }
  get max() {
    return this._getOption("max");
  }
  set max(value2) {
    this._setOption("max", value2);
  }
  get min() {
    return this._getOption("min");
  }
  set min(value2) {
    this._setOption("min", value2);
  }
  get reevaluate() {
    return this._getOption("reevaluate");
  }
  set reevaluate(value2) {
    this._setOption("reevaluate", value2);
  }
  get validationCallback() {
    return this._getOption("validationCallback");
  }
  set validationCallback(value2) {
    this._setOption("validationCallback", value2);
  }
  get comparisonTarget() {
    return this._getOption("comparisonTarget");
  }
  set comparisonTarget(value2) {
    this._setOption("comparisonTarget", value2);
  }
  get comparisonType() {
    return this._getOption("comparisonType");
  }
  set comparisonType(value2) {
    this._setOption("comparisonType", value2);
  }
  get pattern() {
    return this._getOption("pattern");
  }
  set pattern(value2) {
    this._setOption("pattern", value2);
  }
  get _optionPath() {
    return "validationRules";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
    this.type = "required";
  }
  ngOnDestroy() {
    this._deleteRemovedOptions(this._fullOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxiDataGridValidationRuleComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridValidationRuleComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxiDataGridValidationRuleComponent,
    selectors: [["dxi-data-grid-validation-rule"]],
    inputs: {
      message: "message",
      trim: "trim",
      type: "type",
      ignoreEmptyValue: "ignoreEmptyValue",
      max: "max",
      min: "min",
      reevaluate: "reevaluate",
      validationCallback: "validationCallback",
      comparisonTarget: "comparisonTarget",
      comparisonType: "comparisonType",
      pattern: "pattern"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost, {
      provide: PROPERTY_TOKEN_validationRules,
      useExisting: _DxiDataGridValidationRuleComponent
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxiDataGridValidationRuleComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridValidationRuleComponent, [{
    type: Component,
    args: [{
      selector: "dxi-data-grid-validation-rule",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost, {
        provide: PROPERTY_TOKEN_validationRules,
        useExisting: DxiDataGridValidationRuleComponent
      }]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    message: [{
      type: Input
    }],
    trim: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    ignoreEmptyValue: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    reevaluate: [{
      type: Input
    }],
    validationCallback: [{
      type: Input
    }],
    comparisonTarget: [{
      type: Input
    }],
    comparisonType: [{
      type: Input
    }],
    pattern: [{
      type: Input
    }]
  });
})();
var DxiDataGridValidationRuleModule = class _DxiDataGridValidationRuleModule {
  /** @nocollapse */
  static ɵfac = function DxiDataGridValidationRuleModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxiDataGridValidationRuleModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxiDataGridValidationRuleModule,
    imports: [DxiDataGridValidationRuleComponent],
    exports: [DxiDataGridValidationRuleComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxiDataGridValidationRuleComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxiDataGridValidationRuleModule, [{
    type: NgModule,
    args: [{
      imports: [DxiDataGridValidationRuleComponent],
      exports: [DxiDataGridValidationRuleComponent]
    }]
  }], null, null);
})();
var DxoDataGridValueFormatComponent = class _DxoDataGridValueFormatComponent extends NestedOption {
  get currency() {
    return this._getOption("currency");
  }
  set currency(value2) {
    this._setOption("currency", value2);
  }
  get formatter() {
    return this._getOption("formatter");
  }
  set formatter(value2) {
    this._setOption("formatter", value2);
  }
  get parser() {
    return this._getOption("parser");
  }
  set parser(value2) {
    this._setOption("parser", value2);
  }
  get precision() {
    return this._getOption("precision");
  }
  set precision(value2) {
    this._setOption("precision", value2);
  }
  get type() {
    return this._getOption("type");
  }
  set type(value2) {
    this._setOption("type", value2);
  }
  get useCurrencyAccountingStyle() {
    return this._getOption("useCurrencyAccountingStyle");
  }
  set useCurrencyAccountingStyle(value2) {
    this._setOption("useCurrencyAccountingStyle", value2);
  }
  get _optionPath() {
    return "valueFormat";
  }
  constructor(parentOptionHost, optionHost) {
    super();
    parentOptionHost.setNestedOption(this);
    optionHost.setHost(this, this._fullOptionPath.bind(this));
  }
  ngOnInit() {
    this._addRecreatedComponent();
  }
  ngOnDestroy() {
    this._addRemovedOption(this._getOptionPath());
  }
  /** @nocollapse */
  static ɵfac = function DxoDataGridValueFormatComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridValueFormatComponent)(ɵɵdirectiveInject(NestedOptionHost, 5), ɵɵdirectiveInject(NestedOptionHost, 1));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxoDataGridValueFormatComponent,
    selectors: [["dxo-data-grid-value-format"]],
    inputs: {
      currency: "currency",
      formatter: "formatter",
      parser: "parser",
      precision: "precision",
      type: "type",
      useCurrencyAccountingStyle: "useCurrencyAccountingStyle"
    },
    features: [ɵɵProvidersFeature([NestedOptionHost]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DxoDataGridValueFormatComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridValueFormatComponent, [{
    type: Component,
    args: [{
      selector: "dxo-data-grid-value-format",
      standalone: true,
      template: "",
      imports: [DxIntegrationModule],
      providers: [NestedOptionHost]
    }]
  }], () => [{
    type: NestedOptionHost,
    decorators: [{
      type: SkipSelf
    }, {
      type: Host
    }]
  }, {
    type: NestedOptionHost,
    decorators: [{
      type: Host
    }]
  }], {
    currency: [{
      type: Input
    }],
    formatter: [{
      type: Input
    }],
    parser: [{
      type: Input
    }],
    precision: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    useCurrencyAccountingStyle: [{
      type: Input
    }]
  });
})();
var DxoDataGridValueFormatModule = class _DxoDataGridValueFormatModule {
  /** @nocollapse */
  static ɵfac = function DxoDataGridValueFormatModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxoDataGridValueFormatModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxoDataGridValueFormatModule,
    imports: [DxoDataGridValueFormatComponent],
    exports: [DxoDataGridValueFormatComponent]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxoDataGridValueFormatComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxoDataGridValueFormatModule, [{
    type: NgModule,
    args: [{
      imports: [DxoDataGridValueFormatComponent],
      exports: [DxoDataGridValueFormatComponent]
    }]
  }], null, null);
})();

// node_modules/devextreme-angular/fesm2022/devextreme-angular-ui-data-grid.mjs
var DxDataGridComponent = class _DxDataGridComponent extends DxComponent {
  _watcherHelper;
  _idh;
  set _validationRulesContentChildren(value2) {
    this.setChildren("validationRules", value2);
  }
  set _buttonsContentChildren(value2) {
    this.setChildren("buttons", value2);
  }
  set _changesContentChildren(value2) {
    this.setChildren("changes", value2);
  }
  set _columnsContentChildren(value2) {
    this.setChildren("columns", value2);
  }
  set _customOperationsContentChildren(value2) {
    this.setChildren("customOperations", value2);
  }
  set _fieldsContentChildren(value2) {
    this.setChildren("fields", value2);
  }
  set _groupItemsContentChildren(value2) {
    this.setChildren("groupItems", value2);
  }
  set _itemsContentChildren(value2) {
    this.setChildren("items", value2);
  }
  set _sortByGroupSummaryInfoContentChildren(value2) {
    this.setChildren("sortByGroupSummaryInfo", value2);
  }
  set _toolbarItemsContentChildren(value2) {
    this.setChildren("toolbarItems", value2);
  }
  set _totalItemsContentChildren(value2) {
    this.setChildren("totalItems", value2);
  }
  instance = null;
  /**
   * Specifies the shortcut key that sets focus on the UI component.
  
   */
  get accessKey() {
    return this._getOption("accessKey");
  }
  set accessKey(value2) {
    this._setOption("accessKey", value2);
  }
  /**
   * Specifies whether the UI component changes its visual state as a result of user interaction.
  
   */
  get activeStateEnabled() {
    return this._getOption("activeStateEnabled");
  }
  set activeStateEnabled(value2) {
    this._setOption("activeStateEnabled", value2);
  }
  /**
   * Specifies whether a user can reorder columns.
  
   */
  get allowColumnReordering() {
    return this._getOption("allowColumnReordering");
  }
  set allowColumnReordering(value2) {
    this._setOption("allowColumnReordering", value2);
  }
  /**
   * Specifies whether a user can resize columns.
  
   */
  get allowColumnResizing() {
    return this._getOption("allowColumnResizing");
  }
  set allowColumnResizing(value2) {
    this._setOption("allowColumnResizing", value2);
  }
  /**
   * Automatically scrolls the component to the focused row when the focusedRowKey is changed.
  
   */
  get autoNavigateToFocusedRow() {
    return this._getOption("autoNavigateToFocusedRow");
  }
  set autoNavigateToFocusedRow(value2) {
    this._setOption("autoNavigateToFocusedRow", value2);
  }
  /**
   * Specifies whether data should be cached.
  
   */
  get cacheEnabled() {
    return this._getOption("cacheEnabled");
  }
  set cacheEnabled(value2) {
    this._setOption("cacheEnabled", value2);
  }
  /**
   * Enables a hint that appears when a user hovers the mouse pointer over a cell with truncated content.
  
   */
  get cellHintEnabled() {
    return this._getOption("cellHintEnabled");
  }
  set cellHintEnabled(value2) {
    this._setOption("cellHintEnabled", value2);
  }
  /**
   * Specifies if the component adjusts column widths to fit content.
  
   */
  get columnAutoWidth() {
    return this._getOption("columnAutoWidth");
  }
  set columnAutoWidth(value2) {
    this._setOption("columnAutoWidth", value2);
  }
  /**
   * Configures the column chooser.
  
   */
  get columnChooser() {
    return this._getOption("columnChooser");
  }
  set columnChooser(value2) {
    this._setOption("columnChooser", value2);
  }
  /**
   * Configures column fixing.
  
   */
  get columnFixing() {
    return this._getOption("columnFixing");
  }
  set columnFixing(value2) {
    this._setOption("columnFixing", value2);
  }
  /**
   * Specifies whether the UI component should hide columns to adapt to the screen or container size. Ignored if allowColumnResizing is true and columnResizingMode is &apos;widget&apos;.
  
   */
  get columnHidingEnabled() {
    return this._getOption("columnHidingEnabled");
  }
  set columnHidingEnabled(value2) {
    this._setOption("columnHidingEnabled", value2);
  }
  /**
   * Specifies the minimum width of columns.
  
   */
  get columnMinWidth() {
    return this._getOption("columnMinWidth");
  }
  set columnMinWidth(value2) {
    this._setOption("columnMinWidth", value2);
  }
  /**
   * Specifies how the UI component resizes columns. Applies only if allowColumnResizing is true.
  
   */
  get columnResizingMode() {
    return this._getOption("columnResizingMode");
  }
  set columnResizingMode(value2) {
    this._setOption("columnResizingMode", value2);
  }
  /**
   * An array of grid columns.
  
   */
  get columns() {
    return this._getOption("columns");
  }
  set columns(value2) {
    this._setOption("columns", value2);
  }
  /**
   * Specifies the width for all data columns. Has a lower priority than the column.width property.
  
   */
  get columnWidth() {
    return this._getOption("columnWidth");
  }
  set columnWidth(value2) {
    this._setOption("columnWidth", value2);
  }
  /**
   * Customizes columns after they are created.
  
   */
  get customizeColumns() {
    return this._getOption("customizeColumns");
  }
  set customizeColumns(value2) {
    this._setOption("customizeColumns", value2);
  }
  /**
   * Specifies a custom template for data rows.
  
   */
  get dataRowTemplate() {
    return this._getOption("dataRowTemplate");
  }
  set dataRowTemplate(value2) {
    this._setOption("dataRowTemplate", value2);
  }
  /**
   * Binds the UI component to data.
  
   */
  get dataSource() {
    return this._getOption("dataSource");
  }
  set dataSource(value2) {
    this._setOption("dataSource", value2);
  }
  /**
   * Specifies the format in which date-time values should be sent to the server.
  
   */
  get dateSerializationFormat() {
    return this._getOption("dateSerializationFormat");
  }
  set dateSerializationFormat(value2) {
    this._setOption("dateSerializationFormat", value2);
  }
  /**
   * Specifies whether the UI component responds to user interaction.
  
   */
  get disabled() {
    return this._getOption("disabled");
  }
  set disabled(value2) {
    this._setOption("disabled", value2);
  }
  /**
   * Configures editing.
  
   */
  get editing() {
    return this._getOption("editing");
  }
  set editing(value2) {
    this._setOption("editing", value2);
  }
  /**
   * Specifies the global attributes to be attached to the UI component&apos;s container element.
  
   */
  get elementAttr() {
    return this._getOption("elementAttr");
  }
  set elementAttr(value2) {
    this._setOption("elementAttr", value2);
  }
  /**
   * Indicates whether to show the error row.
  
   */
  get errorRowEnabled() {
    return this._getOption("errorRowEnabled");
  }
  set errorRowEnabled(value2) {
    this._setOption("errorRowEnabled", value2);
  }
  /**
   * Configures client-side exporting.
  
   */
  get export() {
    return this._getOption("export");
  }
  set export(value2) {
    this._setOption("export", value2);
  }
  /**
   * Configures the integrated filter builder.
  
   */
  get filterBuilder() {
    return this._getOption("filterBuilder");
  }
  set filterBuilder(value2) {
    this._setOption("filterBuilder", value2);
  }
  /**
   * Configures the popup in which the integrated filter builder is shown.
  
   */
  get filterBuilderPopup() {
    return this._getOption("filterBuilderPopup");
  }
  set filterBuilderPopup(value2) {
    this._setOption("filterBuilderPopup", value2);
  }
  /**
   * Configures the filter panel.
  
   */
  get filterPanel() {
    return this._getOption("filterPanel");
  }
  set filterPanel(value2) {
    this._setOption("filterPanel", value2);
  }
  /**
   * Configures the filter row.
  
   */
  get filterRow() {
    return this._getOption("filterRow");
  }
  set filterRow(value2) {
    this._setOption("filterRow", value2);
  }
  /**
   * Specifies whether to synchronize the filter row, header filter, and filter builder. The synchronized filter expression is stored in the filterValue property.
  
   */
  get filterSyncEnabled() {
    return this._getOption("filterSyncEnabled");
  }
  set filterSyncEnabled(value2) {
    this._setOption("filterSyncEnabled", value2);
  }
  /**
   * Specifies a filter expression.
  
   */
  get filterValue() {
    return this._getOption("filterValue");
  }
  set filterValue(value2) {
    this._setOption("filterValue", value2);
  }
  /**
   * The index of the column that contains the focused data cell. This index is taken from the columns array.
  
   */
  get focusedColumnIndex() {
    return this._getOption("focusedColumnIndex");
  }
  set focusedColumnIndex(value2) {
    this._setOption("focusedColumnIndex", value2);
  }
  /**
   * Specifies whether the focused row feature is enabled.
  
   */
  get focusedRowEnabled() {
    return this._getOption("focusedRowEnabled");
  }
  set focusedRowEnabled(value2) {
    this._setOption("focusedRowEnabled", value2);
  }
  /**
   * Specifies or indicates the focused data row&apos;s index.
  
   */
  get focusedRowIndex() {
    return this._getOption("focusedRowIndex");
  }
  set focusedRowIndex(value2) {
    this._setOption("focusedRowIndex", value2);
  }
  /**
   * Specifies initially or currently focused grid row&apos;s key.
  
   */
  get focusedRowKey() {
    return this._getOption("focusedRowKey");
  }
  set focusedRowKey(value2) {
    this._setOption("focusedRowKey", value2);
  }
  /**
   * Configures grouping.
  
   */
  get grouping() {
    return this._getOption("grouping");
  }
  set grouping(value2) {
    this._setOption("grouping", value2);
  }
  /**
   * Configures the group panel.
  
   */
  get groupPanel() {
    return this._getOption("groupPanel");
  }
  set groupPanel(value2) {
    this._setOption("groupPanel", value2);
  }
  /**
   * Configures the header filter feature.
  
   */
  get headerFilter() {
    return this._getOption("headerFilter");
  }
  set headerFilter(value2) {
    this._setOption("headerFilter", value2);
  }
  /**
   * Specifies the UI component&apos;s height.
  
   */
  get height() {
    return this._getOption("height");
  }
  set height(value2) {
    this._setOption("height", value2);
  }
  /**
   * Specifies whether to highlight rows and cells with edited data. repaintChangesOnly should be true.
  
   */
  get highlightChanges() {
    return this._getOption("highlightChanges");
  }
  set highlightChanges(value2) {
    this._setOption("highlightChanges", value2);
  }
  /**
   * Specifies text for a hint that appears when a user pauses on the UI component.
  
   */
  get hint() {
    return this._getOption("hint");
  }
  set hint(value2) {
    this._setOption("hint", value2);
  }
  /**
   * Specifies whether the UI component changes its state when a user pauses on it.
  
   */
  get hoverStateEnabled() {
    return this._getOption("hoverStateEnabled");
  }
  set hoverStateEnabled(value2) {
    this._setOption("hoverStateEnabled", value2);
  }
  /**
   * Configures keyboard navigation.
  
   */
  get keyboardNavigation() {
    return this._getOption("keyboardNavigation");
  }
  set keyboardNavigation(value2) {
    this._setOption("keyboardNavigation", value2);
  }
  /**
   * Specifies the key property (or properties) that provide(s) key values to access data items. Each key value must be unique. This property applies only if data is a simple array.
  
   */
  get keyExpr() {
    return this._getOption("keyExpr");
  }
  set keyExpr(value2) {
    this._setOption("keyExpr", value2);
  }
  /**
   * Configures the load panel.
  
   */
  get loadPanel() {
    return this._getOption("loadPanel");
  }
  set loadPanel(value2) {
    this._setOption("loadPanel", value2);
  }
  /**
   * Allows you to build a master-detail interface in the grid.
  
   */
  get masterDetail() {
    return this._getOption("masterDetail");
  }
  set masterDetail(value2) {
    this._setOption("masterDetail", value2);
  }
  /**
   * Specifies a text string shown when the widget does not display any data.
  
   */
  get noDataText() {
    return this._getOption("noDataText");
  }
  set noDataText(value2) {
    this._setOption("noDataText", value2);
  }
  /**
   * Configures the pager.
  
   */
  get pager() {
    return this._getOption("pager");
  }
  set pager(value2) {
    this._setOption("pager", value2);
  }
  /**
   * Configures paging.
  
   */
  get paging() {
    return this._getOption("paging");
  }
  set paging(value2) {
    this._setOption("paging", value2);
  }
  /**
   * Specifies DataGrid operations to be executed on the server side.
  
   */
  get remoteOperations() {
    return this._getOption("remoteOperations");
  }
  set remoteOperations(value2) {
    this._setOption("remoteOperations", value2);
  }
  /**
   * Specifies whether to render the filter row, command columns, and columns with showEditorAlways set to true after other elements.
  
   */
  get renderAsync() {
    return this._getOption("renderAsync");
  }
  set renderAsync(value2) {
    this._setOption("renderAsync", value2);
  }
  /**
   * Specifies whether to repaint only those cells whose data changed.
  
   */
  get repaintChangesOnly() {
    return this._getOption("repaintChangesOnly");
  }
  set repaintChangesOnly(value2) {
    this._setOption("repaintChangesOnly", value2);
  }
  /**
   * Specifies whether rows should be shaded differently.
  
   */
  get rowAlternationEnabled() {
    return this._getOption("rowAlternationEnabled");
  }
  set rowAlternationEnabled(value2) {
    this._setOption("rowAlternationEnabled", value2);
  }
  /**
   * Configures row reordering using drag and drop gestures.
  
   */
  get rowDragging() {
    return this._getOption("rowDragging");
  }
  set rowDragging(value2) {
    this._setOption("rowDragging", value2);
  }
  /**
   * Specifies a custom template for rows.
  
   * @deprecated Use the dataRowTemplate option instead.
  
   */
  get rowTemplate() {
    return this._getOption("rowTemplate");
  }
  set rowTemplate(value2) {
    this._setOption("rowTemplate", value2);
  }
  /**
   * Switches the UI component to a right-to-left representation.
  
   */
  get rtlEnabled() {
    return this._getOption("rtlEnabled");
  }
  set rtlEnabled(value2) {
    this._setOption("rtlEnabled", value2);
  }
  /**
   * Configures scrolling.
  
   */
  get scrolling() {
    return this._getOption("scrolling");
  }
  set scrolling(value2) {
    this._setOption("scrolling", value2);
  }
  /**
   * Configures the search panel.
  
   */
  get searchPanel() {
    return this._getOption("searchPanel");
  }
  set searchPanel(value2) {
    this._setOption("searchPanel", value2);
  }
  /**
   * Allows you to select rows or determine which rows are selected.
  
   */
  get selectedRowKeys() {
    return this._getOption("selectedRowKeys");
  }
  set selectedRowKeys(value2) {
    this._setOption("selectedRowKeys", value2);
  }
  /**
   * Configures runtime selection.
  
   */
  get selection() {
    return this._getOption("selection");
  }
  set selection(value2) {
    this._setOption("selection", value2);
  }
  /**
   * Specifies filters for the rows that must be selected initially. Applies only if selection.deferred is true.
  
   */
  get selectionFilter() {
    return this._getOption("selectionFilter");
  }
  set selectionFilter(value2) {
    this._setOption("selectionFilter", value2);
  }
  /**
   * Specifies whether the outer borders of the UI component are visible.
  
   */
  get showBorders() {
    return this._getOption("showBorders");
  }
  set showBorders(value2) {
    this._setOption("showBorders", value2);
  }
  /**
   * Specifies whether column headers are visible.
  
   */
  get showColumnHeaders() {
    return this._getOption("showColumnHeaders");
  }
  set showColumnHeaders(value2) {
    this._setOption("showColumnHeaders", value2);
  }
  /**
   * Specifies whether vertical lines that separate one column from another are visible.
  
   */
  get showColumnLines() {
    return this._getOption("showColumnLines");
  }
  set showColumnLines(value2) {
    this._setOption("showColumnLines", value2);
  }
  /**
   * Specifies whether horizontal lines that separate one row from another are visible.
  
   */
  get showRowLines() {
    return this._getOption("showRowLines");
  }
  set showRowLines(value2) {
    this._setOption("showRowLines", value2);
  }
  /**
   * Allows you to sort groups according to the values of group summary items.
  
   */
  get sortByGroupSummaryInfo() {
    return this._getOption("sortByGroupSummaryInfo");
  }
  set sortByGroupSummaryInfo(value2) {
    this._setOption("sortByGroupSummaryInfo", value2);
  }
  /**
   * Configures runtime sorting.
  
   */
  get sorting() {
    return this._getOption("sorting");
  }
  set sorting(value2) {
    this._setOption("sorting", value2);
  }
  /**
   * Configures state storing.
  
   */
  get stateStoring() {
    return this._getOption("stateStoring");
  }
  set stateStoring(value2) {
    this._setOption("stateStoring", value2);
  }
  /**
   * Specifies the properties of the grid summary.
  
   */
  get summary() {
    return this._getOption("summary");
  }
  set summary(value2) {
    this._setOption("summary", value2);
  }
  /**
   * Specifies whether to show only relevant values in the header filter and filter row.
  
   */
  get syncLookupFilterValues() {
    return this._getOption("syncLookupFilterValues");
  }
  set syncLookupFilterValues(value2) {
    this._setOption("syncLookupFilterValues", value2);
  }
  /**
   * Specifies the number of the element when the Tab key is used for navigating.
  
   */
  get tabIndex() {
    return this._getOption("tabIndex");
  }
  set tabIndex(value2) {
    this._setOption("tabIndex", value2);
  }
  /**
   * Configures the toolbar.
  
   */
  get toolbar() {
    return this._getOption("toolbar");
  }
  set toolbar(value2) {
    this._setOption("toolbar", value2);
  }
  /**
   * Specifies whether to enable two-way data binding.
  
   */
  get twoWayBindingEnabled() {
    return this._getOption("twoWayBindingEnabled");
  }
  set twoWayBindingEnabled(value2) {
    this._setOption("twoWayBindingEnabled", value2);
  }
  /**
   * Specifies whether the UI component is visible.
  
   */
  get visible() {
    return this._getOption("visible");
  }
  set visible(value2) {
    this._setOption("visible", value2);
  }
  /**
   * Specifies the UI component&apos;s width.
  
   */
  get width() {
    return this._getOption("width");
  }
  set width(value2) {
    this._setOption("width", value2);
  }
  /**
   * Specifies whether text that does not fit into a column should be wrapped.
  
   */
  get wordWrapEnabled() {
    return this._getOption("wordWrapEnabled");
  }
  set wordWrapEnabled(value2) {
    this._setOption("wordWrapEnabled", value2);
  }
  /**
  
   * A function that is executed before an adaptive detail row is rendered.
  
  
   */
  onAdaptiveDetailRowPreparing;
  /**
  
   * A function that is executed when a cell is clicked or tapped. Executed before onRowClick.
  
  
   */
  onCellClick;
  /**
  
   * A function that is executed when a cell is double-clicked or double-tapped. Executed before onRowDblClick.
  
  
   */
  onCellDblClick;
  /**
  
   * A function that is executed after the pointer enters or leaves a cell.
  
  
   */
  onCellHoverChanged;
  /**
  
   * A function that is executed after a grid cell is created.
  
  
   */
  onCellPrepared;
  /**
  
   * A function that is executed when the UI component is rendered and each time the component is repainted.
  
  
   */
  onContentReady;
  /**
  
   * A function that is executed before the context menu is rendered.
  
  
   */
  onContextMenuPreparing;
  /**
  
   * A function that is executed when an error occurs in the data source.
  
  
   */
  onDataErrorOccurred;
  /**
  
   * A function that is executed before the UI component is disposed of.
  
  
   */
  onDisposing;
  /**
  
   * A function that is executed after row changes are discarded.
  
  
   */
  onEditCanceled;
  /**
  
   * A function that is executed when the edit operation is canceled, but row changes are not yet discarded.
  
  
   */
  onEditCanceling;
  /**
  
   * A function that is executed before a cell or row switches to the editing state.
  
  
   */
  onEditingStart;
  /**
  
   * A function that is executed after an editor is created. Not executed for cells with an editCellTemplate.
  
  
   */
  onEditorPrepared;
  /**
  
   * A function used to customize cell editors. Not executed for cells with an editCellTemplate.
  
  
   */
  onEditorPreparing;
  /**
  
   * A function that is executed before data is exported.
  
  
   */
  onExporting;
  /**
  
   * A function that is executed after the focused cell changes. Applies only to cells in data or group rows.
  
  
   */
  onFocusedCellChanged;
  /**
  
   * A function that is executed before the focused cell changes. Applies only to cells in data or group rows.
  
  
   */
  onFocusedCellChanging;
  /**
  
   * A function that is executed after the focused row changes. Applies only to data or group rows. focusedRowEnabled should be true.
  
  
   */
  onFocusedRowChanged;
  /**
  
   * A function that is executed before the focused row changes. Applies only to data or group rows. focusedRowEnabled should be true.
  
  
   */
  onFocusedRowChanging;
  /**
  
   * A function used in JavaScript frameworks to save the UI component instance.
  
  
   */
  onInitialized;
  /**
  
   * A function that is executed before a new row is added to the UI component.
  
  
   */
  onInitNewRow;
  /**
  
   * A function that is executed when the UI component is in focus and a key has been pressed down.
  
  
   */
  onKeyDown;
  /**
  
   * A function that is executed after a UI component property is changed.
  
  
   */
  onOptionChanged;
  /**
  
   * A function that is executed when a row is clicked or tapped.
  
  
   */
  onRowClick;
  /**
  
   * A function that is executed after a row is collapsed.
  
  
   */
  onRowCollapsed;
  /**
  
   * A function that is executed before a row is collapsed.
  
  
   */
  onRowCollapsing;
  /**
  
   * A function that is executed when a row is double-clicked or double-tapped. Executed after onCellDblClick.
  
  
   */
  onRowDblClick;
  /**
  
   * A function that is executed after a row is expanded.
  
  
   */
  onRowExpanded;
  /**
  
   * A function that is executed before a row is expanded.
  
  
   */
  onRowExpanding;
  /**
  
   * A function that is executed after a new row has been inserted into the data source.
  
  
   */
  onRowInserted;
  /**
  
   * A function that is executed before a new row is inserted into the data source.
  
  
   */
  onRowInserting;
  /**
  
   * A function that is executed after a row is created.
  
  
   */
  onRowPrepared;
  /**
  
   * A function that is executed after a row has been removed from the data source.
  
  
   */
  onRowRemoved;
  /**
  
   * A function that is executed before a row is removed from the data source.
  
  
   */
  onRowRemoving;
  /**
  
   * A function that is executed after a row has been updated in the data source.
  
  
   */
  onRowUpdated;
  /**
  
   * A function that is executed before a row is updated in the data source.
  
  
   */
  onRowUpdating;
  /**
  
   * A function that is executed after cells in a row are validated against validation rules.
  
  
   */
  onRowValidating;
  /**
  
   * A function that is executed after row changes are saved.
  
  
   */
  onSaved;
  /**
  
   * A function that is executed before pending row changes are saved.
  
  
   */
  onSaving;
  /**
  
   * A function that is executed after selecting a row or clearing its selection.
  
  
   */
  onSelectionChanged;
  /**
  
   * A function that is executed before the toolbar is created.
  
  
   */
  onToolbarPreparing;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  accessKeyChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  activeStateEnabledChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  allowColumnReorderingChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  allowColumnResizingChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  autoNavigateToFocusedRowChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  cacheEnabledChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  cellHintEnabledChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  columnAutoWidthChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  columnChooserChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  columnFixingChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  columnHidingEnabledChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  columnMinWidthChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  columnResizingModeChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  columnsChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  columnWidthChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  customizeColumnsChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  dataRowTemplateChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  dataSourceChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  dateSerializationFormatChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  disabledChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  editingChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  elementAttrChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  errorRowEnabledChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  exportChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  filterBuilderChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  filterBuilderPopupChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  filterPanelChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  filterRowChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  filterSyncEnabledChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  filterValueChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  focusedColumnIndexChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  focusedRowEnabledChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  focusedRowIndexChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  focusedRowKeyChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  groupingChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  groupPanelChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  headerFilterChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  heightChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  highlightChangesChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  hintChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  hoverStateEnabledChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  keyboardNavigationChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  keyExprChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  loadPanelChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  masterDetailChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  noDataTextChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  pagerChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  pagingChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  remoteOperationsChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  renderAsyncChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  repaintChangesOnlyChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  rowAlternationEnabledChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  rowDraggingChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  rowTemplateChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  rtlEnabledChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  scrollingChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  searchPanelChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  selectedRowKeysChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  selectionChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  selectionFilterChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  showBordersChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  showColumnHeadersChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  showColumnLinesChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  showRowLinesChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  sortByGroupSummaryInfoChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  sortingChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  stateStoringChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  summaryChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  syncLookupFilterValuesChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  tabIndexChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  toolbarChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  twoWayBindingEnabledChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  visibleChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  widthChange;
  /**
  
   * This member supports the internal infrastructure and is not intended to be used directly from your code.
  
   */
  wordWrapEnabledChange;
  constructor(elementRef, ngZone, templateHost, _watcherHelper, _idh, optionHost, transferState, platformId) {
    super(elementRef, ngZone, templateHost, _watcherHelper, transferState, platformId);
    this._watcherHelper = _watcherHelper;
    this._idh = _idh;
    this._createEventEmitters([{
      subscribe: "adaptiveDetailRowPreparing",
      emit: "onAdaptiveDetailRowPreparing"
    }, {
      subscribe: "cellClick",
      emit: "onCellClick"
    }, {
      subscribe: "cellDblClick",
      emit: "onCellDblClick"
    }, {
      subscribe: "cellHoverChanged",
      emit: "onCellHoverChanged"
    }, {
      subscribe: "cellPrepared",
      emit: "onCellPrepared"
    }, {
      subscribe: "contentReady",
      emit: "onContentReady"
    }, {
      subscribe: "contextMenuPreparing",
      emit: "onContextMenuPreparing"
    }, {
      subscribe: "dataErrorOccurred",
      emit: "onDataErrorOccurred"
    }, {
      subscribe: "disposing",
      emit: "onDisposing"
    }, {
      subscribe: "editCanceled",
      emit: "onEditCanceled"
    }, {
      subscribe: "editCanceling",
      emit: "onEditCanceling"
    }, {
      subscribe: "editingStart",
      emit: "onEditingStart"
    }, {
      subscribe: "editorPrepared",
      emit: "onEditorPrepared"
    }, {
      subscribe: "editorPreparing",
      emit: "onEditorPreparing"
    }, {
      subscribe: "exporting",
      emit: "onExporting"
    }, {
      subscribe: "focusedCellChanged",
      emit: "onFocusedCellChanged"
    }, {
      subscribe: "focusedCellChanging",
      emit: "onFocusedCellChanging"
    }, {
      subscribe: "focusedRowChanged",
      emit: "onFocusedRowChanged"
    }, {
      subscribe: "focusedRowChanging",
      emit: "onFocusedRowChanging"
    }, {
      subscribe: "initialized",
      emit: "onInitialized"
    }, {
      subscribe: "initNewRow",
      emit: "onInitNewRow"
    }, {
      subscribe: "keyDown",
      emit: "onKeyDown"
    }, {
      subscribe: "optionChanged",
      emit: "onOptionChanged"
    }, {
      subscribe: "rowClick",
      emit: "onRowClick"
    }, {
      subscribe: "rowCollapsed",
      emit: "onRowCollapsed"
    }, {
      subscribe: "rowCollapsing",
      emit: "onRowCollapsing"
    }, {
      subscribe: "rowDblClick",
      emit: "onRowDblClick"
    }, {
      subscribe: "rowExpanded",
      emit: "onRowExpanded"
    }, {
      subscribe: "rowExpanding",
      emit: "onRowExpanding"
    }, {
      subscribe: "rowInserted",
      emit: "onRowInserted"
    }, {
      subscribe: "rowInserting",
      emit: "onRowInserting"
    }, {
      subscribe: "rowPrepared",
      emit: "onRowPrepared"
    }, {
      subscribe: "rowRemoved",
      emit: "onRowRemoved"
    }, {
      subscribe: "rowRemoving",
      emit: "onRowRemoving"
    }, {
      subscribe: "rowUpdated",
      emit: "onRowUpdated"
    }, {
      subscribe: "rowUpdating",
      emit: "onRowUpdating"
    }, {
      subscribe: "rowValidating",
      emit: "onRowValidating"
    }, {
      subscribe: "saved",
      emit: "onSaved"
    }, {
      subscribe: "saving",
      emit: "onSaving"
    }, {
      subscribe: "selectionChanged",
      emit: "onSelectionChanged"
    }, {
      subscribe: "toolbarPreparing",
      emit: "onToolbarPreparing"
    }, {
      emit: "accessKeyChange"
    }, {
      emit: "activeStateEnabledChange"
    }, {
      emit: "allowColumnReorderingChange"
    }, {
      emit: "allowColumnResizingChange"
    }, {
      emit: "autoNavigateToFocusedRowChange"
    }, {
      emit: "cacheEnabledChange"
    }, {
      emit: "cellHintEnabledChange"
    }, {
      emit: "columnAutoWidthChange"
    }, {
      emit: "columnChooserChange"
    }, {
      emit: "columnFixingChange"
    }, {
      emit: "columnHidingEnabledChange"
    }, {
      emit: "columnMinWidthChange"
    }, {
      emit: "columnResizingModeChange"
    }, {
      emit: "columnsChange"
    }, {
      emit: "columnWidthChange"
    }, {
      emit: "customizeColumnsChange"
    }, {
      emit: "dataRowTemplateChange"
    }, {
      emit: "dataSourceChange"
    }, {
      emit: "dateSerializationFormatChange"
    }, {
      emit: "disabledChange"
    }, {
      emit: "editingChange"
    }, {
      emit: "elementAttrChange"
    }, {
      emit: "errorRowEnabledChange"
    }, {
      emit: "exportChange"
    }, {
      emit: "filterBuilderChange"
    }, {
      emit: "filterBuilderPopupChange"
    }, {
      emit: "filterPanelChange"
    }, {
      emit: "filterRowChange"
    }, {
      emit: "filterSyncEnabledChange"
    }, {
      emit: "filterValueChange"
    }, {
      emit: "focusedColumnIndexChange"
    }, {
      emit: "focusedRowEnabledChange"
    }, {
      emit: "focusedRowIndexChange"
    }, {
      emit: "focusedRowKeyChange"
    }, {
      emit: "groupingChange"
    }, {
      emit: "groupPanelChange"
    }, {
      emit: "headerFilterChange"
    }, {
      emit: "heightChange"
    }, {
      emit: "highlightChangesChange"
    }, {
      emit: "hintChange"
    }, {
      emit: "hoverStateEnabledChange"
    }, {
      emit: "keyboardNavigationChange"
    }, {
      emit: "keyExprChange"
    }, {
      emit: "loadPanelChange"
    }, {
      emit: "masterDetailChange"
    }, {
      emit: "noDataTextChange"
    }, {
      emit: "pagerChange"
    }, {
      emit: "pagingChange"
    }, {
      emit: "remoteOperationsChange"
    }, {
      emit: "renderAsyncChange"
    }, {
      emit: "repaintChangesOnlyChange"
    }, {
      emit: "rowAlternationEnabledChange"
    }, {
      emit: "rowDraggingChange"
    }, {
      emit: "rowTemplateChange"
    }, {
      emit: "rtlEnabledChange"
    }, {
      emit: "scrollingChange"
    }, {
      emit: "searchPanelChange"
    }, {
      emit: "selectedRowKeysChange"
    }, {
      emit: "selectionChange"
    }, {
      emit: "selectionFilterChange"
    }, {
      emit: "showBordersChange"
    }, {
      emit: "showColumnHeadersChange"
    }, {
      emit: "showColumnLinesChange"
    }, {
      emit: "showRowLinesChange"
    }, {
      emit: "sortByGroupSummaryInfoChange"
    }, {
      emit: "sortingChange"
    }, {
      emit: "stateStoringChange"
    }, {
      emit: "summaryChange"
    }, {
      emit: "syncLookupFilterValuesChange"
    }, {
      emit: "tabIndexChange"
    }, {
      emit: "toolbarChange"
    }, {
      emit: "twoWayBindingEnabledChange"
    }, {
      emit: "visibleChange"
    }, {
      emit: "widthChange"
    }, {
      emit: "wordWrapEnabledChange"
    }]);
    this._idh.setHost(this);
    optionHost.setHost(this);
  }
  _createInstance(element, options) {
    return new data_grid_default(element, options);
  }
  ngOnDestroy() {
    this._destroyWidget();
  }
  ngOnChanges(changes) {
    super.ngOnChanges(changes);
    this.setupChanges("columns", changes);
    this.setupChanges("dataSource", changes);
    this.setupChanges("filterValue", changes);
    this.setupChanges("keyExpr", changes);
    this.setupChanges("selectedRowKeys", changes);
    this.setupChanges("selectionFilter", changes);
    this.setupChanges("sortByGroupSummaryInfo", changes);
  }
  setupChanges(prop, changes) {
    if (!(prop in this._optionsToUpdate)) {
      this._idh.setup(prop, changes);
    }
  }
  ngDoCheck() {
    this._idh.doCheck("columns");
    this._idh.doCheck("dataSource");
    this._idh.doCheck("filterValue");
    this._idh.doCheck("keyExpr");
    this._idh.doCheck("selectedRowKeys");
    this._idh.doCheck("selectionFilter");
    this._idh.doCheck("sortByGroupSummaryInfo");
    this._watcherHelper.checkWatchers();
    super.ngDoCheck();
    super.clearChangedOptions();
  }
  _setOption(name, value2) {
    let isSetup = this._idh.setupSingle(name, value2);
    let isChanged = this._idh.getChanges(name, value2) !== null;
    if (isSetup || isChanged) {
      super._setOption(name, value2);
    }
  }
  /** @nocollapse */
  static ɵfac = function DxDataGridComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxDataGridComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(DxTemplateHost), ɵɵdirectiveInject(WatcherHelper), ɵɵdirectiveInject(IterableDifferHelper), ɵɵdirectiveInject(NestedOptionHost), ɵɵdirectiveInject(TransferState), ɵɵdirectiveInject(PLATFORM_ID));
  };
  /** @nocollapse */
  static ɵcmp = ɵɵdefineComponent({
    type: _DxDataGridComponent,
    selectors: [["dx-data-grid"]],
    contentQueries: function DxDataGridComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, PROPERTY_TOKEN_validationRules, 4);
        ɵɵcontentQuery(dirIndex, PROPERTY_TOKEN_buttons, 4);
        ɵɵcontentQuery(dirIndex, PROPERTY_TOKEN_changes, 4);
        ɵɵcontentQuery(dirIndex, PROPERTY_TOKEN_columns, 4);
        ɵɵcontentQuery(dirIndex, PROPERTY_TOKEN_customOperations, 4);
        ɵɵcontentQuery(dirIndex, PROPERTY_TOKEN_fields, 4);
        ɵɵcontentQuery(dirIndex, PROPERTY_TOKEN_groupItems, 4);
        ɵɵcontentQuery(dirIndex, PROPERTY_TOKEN_items, 4);
        ɵɵcontentQuery(dirIndex, PROPERTY_TOKEN_sortByGroupSummaryInfo, 4);
        ɵɵcontentQuery(dirIndex, PROPERTY_TOKEN_toolbarItems, 4);
        ɵɵcontentQuery(dirIndex, PROPERTY_TOKEN_totalItems, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._validationRulesContentChildren = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._buttonsContentChildren = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._changesContentChildren = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._columnsContentChildren = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._customOperationsContentChildren = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._fieldsContentChildren = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._groupItemsContentChildren = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._itemsContentChildren = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._sortByGroupSummaryInfoContentChildren = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._toolbarItemsContentChildren = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._totalItemsContentChildren = _t);
      }
    },
    hostAttrs: ["ngSkipHydration", "true"],
    inputs: {
      accessKey: "accessKey",
      activeStateEnabled: "activeStateEnabled",
      allowColumnReordering: "allowColumnReordering",
      allowColumnResizing: "allowColumnResizing",
      autoNavigateToFocusedRow: "autoNavigateToFocusedRow",
      cacheEnabled: "cacheEnabled",
      cellHintEnabled: "cellHintEnabled",
      columnAutoWidth: "columnAutoWidth",
      columnChooser: "columnChooser",
      columnFixing: "columnFixing",
      columnHidingEnabled: "columnHidingEnabled",
      columnMinWidth: "columnMinWidth",
      columnResizingMode: "columnResizingMode",
      columns: "columns",
      columnWidth: "columnWidth",
      customizeColumns: "customizeColumns",
      dataRowTemplate: "dataRowTemplate",
      dataSource: "dataSource",
      dateSerializationFormat: "dateSerializationFormat",
      disabled: "disabled",
      editing: "editing",
      elementAttr: "elementAttr",
      errorRowEnabled: "errorRowEnabled",
      export: "export",
      filterBuilder: "filterBuilder",
      filterBuilderPopup: "filterBuilderPopup",
      filterPanel: "filterPanel",
      filterRow: "filterRow",
      filterSyncEnabled: "filterSyncEnabled",
      filterValue: "filterValue",
      focusedColumnIndex: "focusedColumnIndex",
      focusedRowEnabled: "focusedRowEnabled",
      focusedRowIndex: "focusedRowIndex",
      focusedRowKey: "focusedRowKey",
      grouping: "grouping",
      groupPanel: "groupPanel",
      headerFilter: "headerFilter",
      height: "height",
      highlightChanges: "highlightChanges",
      hint: "hint",
      hoverStateEnabled: "hoverStateEnabled",
      keyboardNavigation: "keyboardNavigation",
      keyExpr: "keyExpr",
      loadPanel: "loadPanel",
      masterDetail: "masterDetail",
      noDataText: "noDataText",
      pager: "pager",
      paging: "paging",
      remoteOperations: "remoteOperations",
      renderAsync: "renderAsync",
      repaintChangesOnly: "repaintChangesOnly",
      rowAlternationEnabled: "rowAlternationEnabled",
      rowDragging: "rowDragging",
      rowTemplate: "rowTemplate",
      rtlEnabled: "rtlEnabled",
      scrolling: "scrolling",
      searchPanel: "searchPanel",
      selectedRowKeys: "selectedRowKeys",
      selection: "selection",
      selectionFilter: "selectionFilter",
      showBorders: "showBorders",
      showColumnHeaders: "showColumnHeaders",
      showColumnLines: "showColumnLines",
      showRowLines: "showRowLines",
      sortByGroupSummaryInfo: "sortByGroupSummaryInfo",
      sorting: "sorting",
      stateStoring: "stateStoring",
      summary: "summary",
      syncLookupFilterValues: "syncLookupFilterValues",
      tabIndex: "tabIndex",
      toolbar: "toolbar",
      twoWayBindingEnabled: "twoWayBindingEnabled",
      visible: "visible",
      width: "width",
      wordWrapEnabled: "wordWrapEnabled"
    },
    outputs: {
      onAdaptiveDetailRowPreparing: "onAdaptiveDetailRowPreparing",
      onCellClick: "onCellClick",
      onCellDblClick: "onCellDblClick",
      onCellHoverChanged: "onCellHoverChanged",
      onCellPrepared: "onCellPrepared",
      onContentReady: "onContentReady",
      onContextMenuPreparing: "onContextMenuPreparing",
      onDataErrorOccurred: "onDataErrorOccurred",
      onDisposing: "onDisposing",
      onEditCanceled: "onEditCanceled",
      onEditCanceling: "onEditCanceling",
      onEditingStart: "onEditingStart",
      onEditorPrepared: "onEditorPrepared",
      onEditorPreparing: "onEditorPreparing",
      onExporting: "onExporting",
      onFocusedCellChanged: "onFocusedCellChanged",
      onFocusedCellChanging: "onFocusedCellChanging",
      onFocusedRowChanged: "onFocusedRowChanged",
      onFocusedRowChanging: "onFocusedRowChanging",
      onInitialized: "onInitialized",
      onInitNewRow: "onInitNewRow",
      onKeyDown: "onKeyDown",
      onOptionChanged: "onOptionChanged",
      onRowClick: "onRowClick",
      onRowCollapsed: "onRowCollapsed",
      onRowCollapsing: "onRowCollapsing",
      onRowDblClick: "onRowDblClick",
      onRowExpanded: "onRowExpanded",
      onRowExpanding: "onRowExpanding",
      onRowInserted: "onRowInserted",
      onRowInserting: "onRowInserting",
      onRowPrepared: "onRowPrepared",
      onRowRemoved: "onRowRemoved",
      onRowRemoving: "onRowRemoving",
      onRowUpdated: "onRowUpdated",
      onRowUpdating: "onRowUpdating",
      onRowValidating: "onRowValidating",
      onSaved: "onSaved",
      onSaving: "onSaving",
      onSelectionChanged: "onSelectionChanged",
      onToolbarPreparing: "onToolbarPreparing",
      accessKeyChange: "accessKeyChange",
      activeStateEnabledChange: "activeStateEnabledChange",
      allowColumnReorderingChange: "allowColumnReorderingChange",
      allowColumnResizingChange: "allowColumnResizingChange",
      autoNavigateToFocusedRowChange: "autoNavigateToFocusedRowChange",
      cacheEnabledChange: "cacheEnabledChange",
      cellHintEnabledChange: "cellHintEnabledChange",
      columnAutoWidthChange: "columnAutoWidthChange",
      columnChooserChange: "columnChooserChange",
      columnFixingChange: "columnFixingChange",
      columnHidingEnabledChange: "columnHidingEnabledChange",
      columnMinWidthChange: "columnMinWidthChange",
      columnResizingModeChange: "columnResizingModeChange",
      columnsChange: "columnsChange",
      columnWidthChange: "columnWidthChange",
      customizeColumnsChange: "customizeColumnsChange",
      dataRowTemplateChange: "dataRowTemplateChange",
      dataSourceChange: "dataSourceChange",
      dateSerializationFormatChange: "dateSerializationFormatChange",
      disabledChange: "disabledChange",
      editingChange: "editingChange",
      elementAttrChange: "elementAttrChange",
      errorRowEnabledChange: "errorRowEnabledChange",
      exportChange: "exportChange",
      filterBuilderChange: "filterBuilderChange",
      filterBuilderPopupChange: "filterBuilderPopupChange",
      filterPanelChange: "filterPanelChange",
      filterRowChange: "filterRowChange",
      filterSyncEnabledChange: "filterSyncEnabledChange",
      filterValueChange: "filterValueChange",
      focusedColumnIndexChange: "focusedColumnIndexChange",
      focusedRowEnabledChange: "focusedRowEnabledChange",
      focusedRowIndexChange: "focusedRowIndexChange",
      focusedRowKeyChange: "focusedRowKeyChange",
      groupingChange: "groupingChange",
      groupPanelChange: "groupPanelChange",
      headerFilterChange: "headerFilterChange",
      heightChange: "heightChange",
      highlightChangesChange: "highlightChangesChange",
      hintChange: "hintChange",
      hoverStateEnabledChange: "hoverStateEnabledChange",
      keyboardNavigationChange: "keyboardNavigationChange",
      keyExprChange: "keyExprChange",
      loadPanelChange: "loadPanelChange",
      masterDetailChange: "masterDetailChange",
      noDataTextChange: "noDataTextChange",
      pagerChange: "pagerChange",
      pagingChange: "pagingChange",
      remoteOperationsChange: "remoteOperationsChange",
      renderAsyncChange: "renderAsyncChange",
      repaintChangesOnlyChange: "repaintChangesOnlyChange",
      rowAlternationEnabledChange: "rowAlternationEnabledChange",
      rowDraggingChange: "rowDraggingChange",
      rowTemplateChange: "rowTemplateChange",
      rtlEnabledChange: "rtlEnabledChange",
      scrollingChange: "scrollingChange",
      searchPanelChange: "searchPanelChange",
      selectedRowKeysChange: "selectedRowKeysChange",
      selectionChange: "selectionChange",
      selectionFilterChange: "selectionFilterChange",
      showBordersChange: "showBordersChange",
      showColumnHeadersChange: "showColumnHeadersChange",
      showColumnLinesChange: "showColumnLinesChange",
      showRowLinesChange: "showRowLinesChange",
      sortByGroupSummaryInfoChange: "sortByGroupSummaryInfoChange",
      sortingChange: "sortingChange",
      stateStoringChange: "stateStoringChange",
      summaryChange: "summaryChange",
      syncLookupFilterValuesChange: "syncLookupFilterValuesChange",
      tabIndexChange: "tabIndexChange",
      toolbarChange: "toolbarChange",
      twoWayBindingEnabledChange: "twoWayBindingEnabledChange",
      visibleChange: "visibleChange",
      widthChange: "widthChange",
      wordWrapEnabledChange: "wordWrapEnabledChange"
    },
    features: [ɵɵProvidersFeature([DxTemplateHost, WatcherHelper, NestedOptionHost, IterableDifferHelper]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    decls: 0,
    vars: 0,
    template: function DxDataGridComponent_Template(rf, ctx) {
    },
    dependencies: [DxIntegrationModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxDataGridComponent, [{
    type: Component,
    args: [{
      selector: "dx-data-grid",
      standalone: true,
      template: "",
      host: {
        ngSkipHydration: "true"
      },
      imports: [DxIntegrationModule],
      providers: [DxTemplateHost, WatcherHelper, NestedOptionHost, IterableDifferHelper]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NgZone
  }, {
    type: DxTemplateHost
  }, {
    type: WatcherHelper
  }, {
    type: IterableDifferHelper
  }, {
    type: NestedOptionHost
  }, {
    type: TransferState
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }], {
    _validationRulesContentChildren: [{
      type: ContentChildren,
      args: [PROPERTY_TOKEN_validationRules]
    }],
    _buttonsContentChildren: [{
      type: ContentChildren,
      args: [PROPERTY_TOKEN_buttons]
    }],
    _changesContentChildren: [{
      type: ContentChildren,
      args: [PROPERTY_TOKEN_changes]
    }],
    _columnsContentChildren: [{
      type: ContentChildren,
      args: [PROPERTY_TOKEN_columns]
    }],
    _customOperationsContentChildren: [{
      type: ContentChildren,
      args: [PROPERTY_TOKEN_customOperations]
    }],
    _fieldsContentChildren: [{
      type: ContentChildren,
      args: [PROPERTY_TOKEN_fields]
    }],
    _groupItemsContentChildren: [{
      type: ContentChildren,
      args: [PROPERTY_TOKEN_groupItems]
    }],
    _itemsContentChildren: [{
      type: ContentChildren,
      args: [PROPERTY_TOKEN_items]
    }],
    _sortByGroupSummaryInfoContentChildren: [{
      type: ContentChildren,
      args: [PROPERTY_TOKEN_sortByGroupSummaryInfo]
    }],
    _toolbarItemsContentChildren: [{
      type: ContentChildren,
      args: [PROPERTY_TOKEN_toolbarItems]
    }],
    _totalItemsContentChildren: [{
      type: ContentChildren,
      args: [PROPERTY_TOKEN_totalItems]
    }],
    accessKey: [{
      type: Input
    }],
    activeStateEnabled: [{
      type: Input
    }],
    allowColumnReordering: [{
      type: Input
    }],
    allowColumnResizing: [{
      type: Input
    }],
    autoNavigateToFocusedRow: [{
      type: Input
    }],
    cacheEnabled: [{
      type: Input
    }],
    cellHintEnabled: [{
      type: Input
    }],
    columnAutoWidth: [{
      type: Input
    }],
    columnChooser: [{
      type: Input
    }],
    columnFixing: [{
      type: Input
    }],
    columnHidingEnabled: [{
      type: Input
    }],
    columnMinWidth: [{
      type: Input
    }],
    columnResizingMode: [{
      type: Input
    }],
    columns: [{
      type: Input
    }],
    columnWidth: [{
      type: Input
    }],
    customizeColumns: [{
      type: Input
    }],
    dataRowTemplate: [{
      type: Input
    }],
    dataSource: [{
      type: Input
    }],
    dateSerializationFormat: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    editing: [{
      type: Input
    }],
    elementAttr: [{
      type: Input
    }],
    errorRowEnabled: [{
      type: Input
    }],
    export: [{
      type: Input
    }],
    filterBuilder: [{
      type: Input
    }],
    filterBuilderPopup: [{
      type: Input
    }],
    filterPanel: [{
      type: Input
    }],
    filterRow: [{
      type: Input
    }],
    filterSyncEnabled: [{
      type: Input
    }],
    filterValue: [{
      type: Input
    }],
    focusedColumnIndex: [{
      type: Input
    }],
    focusedRowEnabled: [{
      type: Input
    }],
    focusedRowIndex: [{
      type: Input
    }],
    focusedRowKey: [{
      type: Input
    }],
    grouping: [{
      type: Input
    }],
    groupPanel: [{
      type: Input
    }],
    headerFilter: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    highlightChanges: [{
      type: Input
    }],
    hint: [{
      type: Input
    }],
    hoverStateEnabled: [{
      type: Input
    }],
    keyboardNavigation: [{
      type: Input
    }],
    keyExpr: [{
      type: Input
    }],
    loadPanel: [{
      type: Input
    }],
    masterDetail: [{
      type: Input
    }],
    noDataText: [{
      type: Input
    }],
    pager: [{
      type: Input
    }],
    paging: [{
      type: Input
    }],
    remoteOperations: [{
      type: Input
    }],
    renderAsync: [{
      type: Input
    }],
    repaintChangesOnly: [{
      type: Input
    }],
    rowAlternationEnabled: [{
      type: Input
    }],
    rowDragging: [{
      type: Input
    }],
    rowTemplate: [{
      type: Input
    }],
    rtlEnabled: [{
      type: Input
    }],
    scrolling: [{
      type: Input
    }],
    searchPanel: [{
      type: Input
    }],
    selectedRowKeys: [{
      type: Input
    }],
    selection: [{
      type: Input
    }],
    selectionFilter: [{
      type: Input
    }],
    showBorders: [{
      type: Input
    }],
    showColumnHeaders: [{
      type: Input
    }],
    showColumnLines: [{
      type: Input
    }],
    showRowLines: [{
      type: Input
    }],
    sortByGroupSummaryInfo: [{
      type: Input
    }],
    sorting: [{
      type: Input
    }],
    stateStoring: [{
      type: Input
    }],
    summary: [{
      type: Input
    }],
    syncLookupFilterValues: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    toolbar: [{
      type: Input
    }],
    twoWayBindingEnabled: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    wordWrapEnabled: [{
      type: Input
    }],
    onAdaptiveDetailRowPreparing: [{
      type: Output
    }],
    onCellClick: [{
      type: Output
    }],
    onCellDblClick: [{
      type: Output
    }],
    onCellHoverChanged: [{
      type: Output
    }],
    onCellPrepared: [{
      type: Output
    }],
    onContentReady: [{
      type: Output
    }],
    onContextMenuPreparing: [{
      type: Output
    }],
    onDataErrorOccurred: [{
      type: Output
    }],
    onDisposing: [{
      type: Output
    }],
    onEditCanceled: [{
      type: Output
    }],
    onEditCanceling: [{
      type: Output
    }],
    onEditingStart: [{
      type: Output
    }],
    onEditorPrepared: [{
      type: Output
    }],
    onEditorPreparing: [{
      type: Output
    }],
    onExporting: [{
      type: Output
    }],
    onFocusedCellChanged: [{
      type: Output
    }],
    onFocusedCellChanging: [{
      type: Output
    }],
    onFocusedRowChanged: [{
      type: Output
    }],
    onFocusedRowChanging: [{
      type: Output
    }],
    onInitialized: [{
      type: Output
    }],
    onInitNewRow: [{
      type: Output
    }],
    onKeyDown: [{
      type: Output
    }],
    onOptionChanged: [{
      type: Output
    }],
    onRowClick: [{
      type: Output
    }],
    onRowCollapsed: [{
      type: Output
    }],
    onRowCollapsing: [{
      type: Output
    }],
    onRowDblClick: [{
      type: Output
    }],
    onRowExpanded: [{
      type: Output
    }],
    onRowExpanding: [{
      type: Output
    }],
    onRowInserted: [{
      type: Output
    }],
    onRowInserting: [{
      type: Output
    }],
    onRowPrepared: [{
      type: Output
    }],
    onRowRemoved: [{
      type: Output
    }],
    onRowRemoving: [{
      type: Output
    }],
    onRowUpdated: [{
      type: Output
    }],
    onRowUpdating: [{
      type: Output
    }],
    onRowValidating: [{
      type: Output
    }],
    onSaved: [{
      type: Output
    }],
    onSaving: [{
      type: Output
    }],
    onSelectionChanged: [{
      type: Output
    }],
    onToolbarPreparing: [{
      type: Output
    }],
    accessKeyChange: [{
      type: Output
    }],
    activeStateEnabledChange: [{
      type: Output
    }],
    allowColumnReorderingChange: [{
      type: Output
    }],
    allowColumnResizingChange: [{
      type: Output
    }],
    autoNavigateToFocusedRowChange: [{
      type: Output
    }],
    cacheEnabledChange: [{
      type: Output
    }],
    cellHintEnabledChange: [{
      type: Output
    }],
    columnAutoWidthChange: [{
      type: Output
    }],
    columnChooserChange: [{
      type: Output
    }],
    columnFixingChange: [{
      type: Output
    }],
    columnHidingEnabledChange: [{
      type: Output
    }],
    columnMinWidthChange: [{
      type: Output
    }],
    columnResizingModeChange: [{
      type: Output
    }],
    columnsChange: [{
      type: Output
    }],
    columnWidthChange: [{
      type: Output
    }],
    customizeColumnsChange: [{
      type: Output
    }],
    dataRowTemplateChange: [{
      type: Output
    }],
    dataSourceChange: [{
      type: Output
    }],
    dateSerializationFormatChange: [{
      type: Output
    }],
    disabledChange: [{
      type: Output
    }],
    editingChange: [{
      type: Output
    }],
    elementAttrChange: [{
      type: Output
    }],
    errorRowEnabledChange: [{
      type: Output
    }],
    exportChange: [{
      type: Output
    }],
    filterBuilderChange: [{
      type: Output
    }],
    filterBuilderPopupChange: [{
      type: Output
    }],
    filterPanelChange: [{
      type: Output
    }],
    filterRowChange: [{
      type: Output
    }],
    filterSyncEnabledChange: [{
      type: Output
    }],
    filterValueChange: [{
      type: Output
    }],
    focusedColumnIndexChange: [{
      type: Output
    }],
    focusedRowEnabledChange: [{
      type: Output
    }],
    focusedRowIndexChange: [{
      type: Output
    }],
    focusedRowKeyChange: [{
      type: Output
    }],
    groupingChange: [{
      type: Output
    }],
    groupPanelChange: [{
      type: Output
    }],
    headerFilterChange: [{
      type: Output
    }],
    heightChange: [{
      type: Output
    }],
    highlightChangesChange: [{
      type: Output
    }],
    hintChange: [{
      type: Output
    }],
    hoverStateEnabledChange: [{
      type: Output
    }],
    keyboardNavigationChange: [{
      type: Output
    }],
    keyExprChange: [{
      type: Output
    }],
    loadPanelChange: [{
      type: Output
    }],
    masterDetailChange: [{
      type: Output
    }],
    noDataTextChange: [{
      type: Output
    }],
    pagerChange: [{
      type: Output
    }],
    pagingChange: [{
      type: Output
    }],
    remoteOperationsChange: [{
      type: Output
    }],
    renderAsyncChange: [{
      type: Output
    }],
    repaintChangesOnlyChange: [{
      type: Output
    }],
    rowAlternationEnabledChange: [{
      type: Output
    }],
    rowDraggingChange: [{
      type: Output
    }],
    rowTemplateChange: [{
      type: Output
    }],
    rtlEnabledChange: [{
      type: Output
    }],
    scrollingChange: [{
      type: Output
    }],
    searchPanelChange: [{
      type: Output
    }],
    selectedRowKeysChange: [{
      type: Output
    }],
    selectionChange: [{
      type: Output
    }],
    selectionFilterChange: [{
      type: Output
    }],
    showBordersChange: [{
      type: Output
    }],
    showColumnHeadersChange: [{
      type: Output
    }],
    showColumnLinesChange: [{
      type: Output
    }],
    showRowLinesChange: [{
      type: Output
    }],
    sortByGroupSummaryInfoChange: [{
      type: Output
    }],
    sortingChange: [{
      type: Output
    }],
    stateStoringChange: [{
      type: Output
    }],
    summaryChange: [{
      type: Output
    }],
    syncLookupFilterValuesChange: [{
      type: Output
    }],
    tabIndexChange: [{
      type: Output
    }],
    toolbarChange: [{
      type: Output
    }],
    twoWayBindingEnabledChange: [{
      type: Output
    }],
    visibleChange: [{
      type: Output
    }],
    widthChange: [{
      type: Output
    }],
    wordWrapEnabledChange: [{
      type: Output
    }]
  });
})();
var DxDataGridModule = class _DxDataGridModule {
  /** @nocollapse */
  static ɵfac = function DxDataGridModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DxDataGridModule)();
  };
  /** @nocollapse */
  static ɵmod = ɵɵdefineNgModule({
    type: _DxDataGridModule,
    imports: [DxDataGridComponent, DxoColumnChooserModule, DxoPositionModule, DxoAtModule, DxoBoundaryOffsetModule, DxoCollisionModule, DxoMyModule, DxoOffsetModule, DxoSearchModule, DxoSelectionModule, DxoColumnFixingModule, DxoIconsModule, DxoTextsModule, DxiColumnModule, DxiButtonModule, DxoLookupModule, DxoFormatModule, DxoFormItemModule, DxoLabelModule, DxiValidationRuleModule, DxoHeaderFilterModule, DxoEditingModule, DxiChangeModule, DxoFormModule, DxoColCountByScreenModule, DxiItemModule, DxoTabPanelOptionsModule, DxiTabModule, DxoButtonOptionsModule, DxoPopupModule, DxoAnimationModule, DxoHideModule, DxoFromModule, DxoToModule, DxoShowModule, DxoExportModule, DxoFilterBuilderModule, DxiCustomOperationModule, DxiFieldModule, DxoFilterOperationDescriptionsModule, DxoGroupOperationDescriptionsModule, DxoFilterBuilderPopupModule, DxoFilterPanelModule, DxoFilterRowModule, DxoOperationDescriptionsModule, DxoGroupingModule, DxoGroupPanelModule, DxoKeyboardNavigationModule, DxoLoadPanelModule, DxoMasterDetailModule, DxoPagerModule, DxoPagingModule, DxoRemoteOperationsModule, DxoRowDraggingModule, DxoCursorOffsetModule, DxoScrollingModule, DxoSearchPanelModule, DxiSortByGroupSummaryInfoModule, DxoSortingModule, DxoStateStoringModule, DxoSummaryModule, DxiGroupItemModule, DxoValueFormatModule, DxiTotalItemModule, DxoToolbarModule, DxoDataGridAnimationModule, DxiDataGridAsyncRuleModule, DxoDataGridAtModule, DxoDataGridBoundaryOffsetModule, DxiDataGridButtonModule, DxiDataGridChangeModule, DxoDataGridColCountByScreenModule, DxoDataGridCollisionModule, DxiDataGridColumnModule, DxoDataGridColumnChooserModule, DxoDataGridColumnChooserSearchModule, DxoDataGridColumnChooserSelectionModule, DxoDataGridColumnFixingModule, DxoDataGridColumnFixingTextsModule, DxoDataGridColumnHeaderFilterModule, DxoDataGridColumnHeaderFilterSearchModule, DxoDataGridColumnLookupModule, DxiDataGridCompareRuleModule, DxoDataGridCursorOffsetModule, DxiDataGridCustomOperationModule, DxiDataGridCustomRuleModule, DxoDataGridDataGridHeaderFilterModule, DxoDataGridDataGridHeaderFilterSearchModule, DxoDataGridDataGridHeaderFilterTextsModule, DxoDataGridDataGridSelectionModule, DxoDataGridEditingModule, DxoDataGridEditingTextsModule, DxiDataGridEmailRuleModule, DxoDataGridExportModule, DxoDataGridExportTextsModule, DxiDataGridFieldModule, DxoDataGridFieldLookupModule, DxoDataGridFilterBuilderModule, DxoDataGridFilterBuilderPopupModule, DxoDataGridFilterOperationDescriptionsModule, DxoDataGridFilterPanelModule, DxoDataGridFilterPanelTextsModule, DxoDataGridFilterRowModule, DxoDataGridFormModule, DxoDataGridFormatModule, DxoDataGridFormItemModule, DxoDataGridFromModule, DxoDataGridGroupingModule, DxoDataGridGroupingTextsModule, DxiDataGridGroupItemModule, DxoDataGridGroupOperationDescriptionsModule, DxoDataGridGroupPanelModule, DxoDataGridHeaderFilterModule, DxoDataGridHideModule, DxoDataGridIconsModule, DxiDataGridItemModule, DxoDataGridKeyboardNavigationModule, DxoDataGridLabelModule, DxoDataGridLoadPanelModule, DxoDataGridLookupModule, DxoDataGridMasterDetailModule, DxoDataGridMyModule, DxiDataGridNumericRuleModule, DxoDataGridOffsetModule, DxoDataGridOperationDescriptionsModule, DxoDataGridPagerModule, DxoDataGridPagingModule, DxiDataGridPatternRuleModule, DxoDataGridPopupModule, DxoDataGridPositionModule, DxiDataGridRangeRuleModule, DxoDataGridRemoteOperationsModule, DxiDataGridRequiredRuleModule, DxoDataGridRowDraggingModule, DxoDataGridScrollingModule, DxoDataGridSearchModule, DxoDataGridSearchPanelModule, DxoDataGridSelectionModule, DxoDataGridShowModule, DxiDataGridSortByGroupSummaryInfoModule, DxoDataGridSortingModule, DxoDataGridStateStoringModule, DxiDataGridStringLengthRuleModule, DxoDataGridSummaryModule, DxoDataGridSummaryTextsModule, DxoDataGridTextsModule, DxoDataGridToModule, DxoDataGridToolbarModule, DxiDataGridToolbarItemModule, DxiDataGridTotalItemModule, DxiDataGridValidationRuleModule, DxoDataGridValueFormatModule, DxIntegrationModule, DxTemplateModule],
    exports: [DxDataGridComponent, DxoColumnChooserModule, DxoPositionModule, DxoAtModule, DxoBoundaryOffsetModule, DxoCollisionModule, DxoMyModule, DxoOffsetModule, DxoSearchModule, DxoSelectionModule, DxoColumnFixingModule, DxoIconsModule, DxoTextsModule, DxiColumnModule, DxiButtonModule, DxoLookupModule, DxoFormatModule, DxoFormItemModule, DxoLabelModule, DxiValidationRuleModule, DxoHeaderFilterModule, DxoEditingModule, DxiChangeModule, DxoFormModule, DxoColCountByScreenModule, DxiItemModule, DxoTabPanelOptionsModule, DxiTabModule, DxoButtonOptionsModule, DxoPopupModule, DxoAnimationModule, DxoHideModule, DxoFromModule, DxoToModule, DxoShowModule, DxoExportModule, DxoFilterBuilderModule, DxiCustomOperationModule, DxiFieldModule, DxoFilterOperationDescriptionsModule, DxoGroupOperationDescriptionsModule, DxoFilterBuilderPopupModule, DxoFilterPanelModule, DxoFilterRowModule, DxoOperationDescriptionsModule, DxoGroupingModule, DxoGroupPanelModule, DxoKeyboardNavigationModule, DxoLoadPanelModule, DxoMasterDetailModule, DxoPagerModule, DxoPagingModule, DxoRemoteOperationsModule, DxoRowDraggingModule, DxoCursorOffsetModule, DxoScrollingModule, DxoSearchPanelModule, DxiSortByGroupSummaryInfoModule, DxoSortingModule, DxoStateStoringModule, DxoSummaryModule, DxiGroupItemModule, DxoValueFormatModule, DxiTotalItemModule, DxoToolbarModule, DxoDataGridAnimationModule, DxiDataGridAsyncRuleModule, DxoDataGridAtModule, DxoDataGridBoundaryOffsetModule, DxiDataGridButtonModule, DxiDataGridChangeModule, DxoDataGridColCountByScreenModule, DxoDataGridCollisionModule, DxiDataGridColumnModule, DxoDataGridColumnChooserModule, DxoDataGridColumnChooserSearchModule, DxoDataGridColumnChooserSelectionModule, DxoDataGridColumnFixingModule, DxoDataGridColumnFixingTextsModule, DxoDataGridColumnHeaderFilterModule, DxoDataGridColumnHeaderFilterSearchModule, DxoDataGridColumnLookupModule, DxiDataGridCompareRuleModule, DxoDataGridCursorOffsetModule, DxiDataGridCustomOperationModule, DxiDataGridCustomRuleModule, DxoDataGridDataGridHeaderFilterModule, DxoDataGridDataGridHeaderFilterSearchModule, DxoDataGridDataGridHeaderFilterTextsModule, DxoDataGridDataGridSelectionModule, DxoDataGridEditingModule, DxoDataGridEditingTextsModule, DxiDataGridEmailRuleModule, DxoDataGridExportModule, DxoDataGridExportTextsModule, DxiDataGridFieldModule, DxoDataGridFieldLookupModule, DxoDataGridFilterBuilderModule, DxoDataGridFilterBuilderPopupModule, DxoDataGridFilterOperationDescriptionsModule, DxoDataGridFilterPanelModule, DxoDataGridFilterPanelTextsModule, DxoDataGridFilterRowModule, DxoDataGridFormModule, DxoDataGridFormatModule, DxoDataGridFormItemModule, DxoDataGridFromModule, DxoDataGridGroupingModule, DxoDataGridGroupingTextsModule, DxiDataGridGroupItemModule, DxoDataGridGroupOperationDescriptionsModule, DxoDataGridGroupPanelModule, DxoDataGridHeaderFilterModule, DxoDataGridHideModule, DxoDataGridIconsModule, DxiDataGridItemModule, DxoDataGridKeyboardNavigationModule, DxoDataGridLabelModule, DxoDataGridLoadPanelModule, DxoDataGridLookupModule, DxoDataGridMasterDetailModule, DxoDataGridMyModule, DxiDataGridNumericRuleModule, DxoDataGridOffsetModule, DxoDataGridOperationDescriptionsModule, DxoDataGridPagerModule, DxoDataGridPagingModule, DxiDataGridPatternRuleModule, DxoDataGridPopupModule, DxoDataGridPositionModule, DxiDataGridRangeRuleModule, DxoDataGridRemoteOperationsModule, DxiDataGridRequiredRuleModule, DxoDataGridRowDraggingModule, DxoDataGridScrollingModule, DxoDataGridSearchModule, DxoDataGridSearchPanelModule, DxoDataGridSelectionModule, DxoDataGridShowModule, DxiDataGridSortByGroupSummaryInfoModule, DxoDataGridSortingModule, DxoDataGridStateStoringModule, DxiDataGridStringLengthRuleModule, DxoDataGridSummaryModule, DxoDataGridSummaryTextsModule, DxoDataGridTextsModule, DxoDataGridToModule, DxoDataGridToolbarModule, DxiDataGridToolbarItemModule, DxiDataGridTotalItemModule, DxiDataGridValidationRuleModule, DxoDataGridValueFormatModule, DxTemplateModule]
  });
  /** @nocollapse */
  static ɵinj = ɵɵdefineInjector({
    imports: [DxDataGridComponent, DxoColumnChooserModule, DxoPositionModule, DxoAtModule, DxoBoundaryOffsetModule, DxoCollisionModule, DxoMyModule, DxoOffsetModule, DxoSearchModule, DxoSelectionModule, DxoColumnFixingModule, DxoIconsModule, DxoTextsModule, DxiColumnModule, DxiButtonModule, DxoLookupModule, DxoFormatModule, DxoFormItemModule, DxoLabelModule, DxiValidationRuleModule, DxoHeaderFilterModule, DxoEditingModule, DxiChangeModule, DxoFormModule, DxoColCountByScreenModule, DxiItemModule, DxoTabPanelOptionsModule, DxiTabModule, DxoButtonOptionsModule, DxoPopupModule, DxoAnimationModule, DxoHideModule, DxoFromModule, DxoToModule, DxoShowModule, DxoExportModule, DxoFilterBuilderModule, DxiCustomOperationModule, DxiFieldModule, DxoFilterOperationDescriptionsModule, DxoGroupOperationDescriptionsModule, DxoFilterBuilderPopupModule, DxoFilterPanelModule, DxoFilterRowModule, DxoOperationDescriptionsModule, DxoGroupingModule, DxoGroupPanelModule, DxoKeyboardNavigationModule, DxoLoadPanelModule, DxoMasterDetailModule, DxoPagerModule, DxoPagingModule, DxoRemoteOperationsModule, DxoRowDraggingModule, DxoCursorOffsetModule, DxoScrollingModule, DxoSearchPanelModule, DxiSortByGroupSummaryInfoModule, DxoSortingModule, DxoStateStoringModule, DxoSummaryModule, DxiGroupItemModule, DxoValueFormatModule, DxiTotalItemModule, DxoToolbarModule, DxoDataGridAnimationModule, DxiDataGridAsyncRuleModule, DxoDataGridAtModule, DxoDataGridBoundaryOffsetModule, DxiDataGridButtonModule, DxiDataGridChangeModule, DxoDataGridColCountByScreenModule, DxoDataGridCollisionModule, DxiDataGridColumnModule, DxoDataGridColumnChooserModule, DxoDataGridColumnChooserSearchModule, DxoDataGridColumnChooserSelectionModule, DxoDataGridColumnFixingModule, DxoDataGridColumnFixingTextsModule, DxoDataGridColumnHeaderFilterModule, DxoDataGridColumnHeaderFilterSearchModule, DxoDataGridColumnLookupModule, DxiDataGridCompareRuleModule, DxoDataGridCursorOffsetModule, DxiDataGridCustomOperationModule, DxiDataGridCustomRuleModule, DxoDataGridDataGridHeaderFilterModule, DxoDataGridDataGridHeaderFilterSearchModule, DxoDataGridDataGridHeaderFilterTextsModule, DxoDataGridDataGridSelectionModule, DxoDataGridEditingModule, DxoDataGridEditingTextsModule, DxiDataGridEmailRuleModule, DxoDataGridExportModule, DxoDataGridExportTextsModule, DxiDataGridFieldModule, DxoDataGridFieldLookupModule, DxoDataGridFilterBuilderModule, DxoDataGridFilterBuilderPopupModule, DxoDataGridFilterOperationDescriptionsModule, DxoDataGridFilterPanelModule, DxoDataGridFilterPanelTextsModule, DxoDataGridFilterRowModule, DxoDataGridFormModule, DxoDataGridFormatModule, DxoDataGridFormItemModule, DxoDataGridFromModule, DxoDataGridGroupingModule, DxoDataGridGroupingTextsModule, DxiDataGridGroupItemModule, DxoDataGridGroupOperationDescriptionsModule, DxoDataGridGroupPanelModule, DxoDataGridHeaderFilterModule, DxoDataGridHideModule, DxoDataGridIconsModule, DxiDataGridItemModule, DxoDataGridKeyboardNavigationModule, DxoDataGridLabelModule, DxoDataGridLoadPanelModule, DxoDataGridLookupModule, DxoDataGridMasterDetailModule, DxoDataGridMyModule, DxiDataGridNumericRuleModule, DxoDataGridOffsetModule, DxoDataGridOperationDescriptionsModule, DxoDataGridPagerModule, DxoDataGridPagingModule, DxiDataGridPatternRuleModule, DxoDataGridPopupModule, DxoDataGridPositionModule, DxiDataGridRangeRuleModule, DxoDataGridRemoteOperationsModule, DxiDataGridRequiredRuleModule, DxoDataGridRowDraggingModule, DxoDataGridScrollingModule, DxoDataGridSearchModule, DxoDataGridSearchPanelModule, DxoDataGridSelectionModule, DxoDataGridShowModule, DxiDataGridSortByGroupSummaryInfoModule, DxoDataGridSortingModule, DxoDataGridStateStoringModule, DxiDataGridStringLengthRuleModule, DxoDataGridSummaryModule, DxoDataGridSummaryTextsModule, DxoDataGridTextsModule, DxoDataGridToModule, DxoDataGridToolbarModule, DxiDataGridToolbarItemModule, DxiDataGridTotalItemModule, DxiDataGridValidationRuleModule, DxoDataGridValueFormatModule, DxIntegrationModule, DxTemplateModule, DxoColumnChooserModule, DxoPositionModule, DxoAtModule, DxoBoundaryOffsetModule, DxoCollisionModule, DxoMyModule, DxoOffsetModule, DxoSearchModule, DxoSelectionModule, DxoColumnFixingModule, DxoIconsModule, DxoTextsModule, DxiColumnModule, DxiButtonModule, DxoLookupModule, DxoFormatModule, DxoFormItemModule, DxoLabelModule, DxiValidationRuleModule, DxoHeaderFilterModule, DxoEditingModule, DxiChangeModule, DxoFormModule, DxoColCountByScreenModule, DxiItemModule, DxoTabPanelOptionsModule, DxiTabModule, DxoButtonOptionsModule, DxoPopupModule, DxoAnimationModule, DxoHideModule, DxoFromModule, DxoToModule, DxoShowModule, DxoExportModule, DxoFilterBuilderModule, DxiCustomOperationModule, DxiFieldModule, DxoFilterOperationDescriptionsModule, DxoGroupOperationDescriptionsModule, DxoFilterBuilderPopupModule, DxoFilterPanelModule, DxoFilterRowModule, DxoOperationDescriptionsModule, DxoGroupingModule, DxoGroupPanelModule, DxoKeyboardNavigationModule, DxoLoadPanelModule, DxoMasterDetailModule, DxoPagerModule, DxoPagingModule, DxoRemoteOperationsModule, DxoRowDraggingModule, DxoCursorOffsetModule, DxoScrollingModule, DxoSearchPanelModule, DxiSortByGroupSummaryInfoModule, DxoSortingModule, DxoStateStoringModule, DxoSummaryModule, DxiGroupItemModule, DxoValueFormatModule, DxiTotalItemModule, DxoToolbarModule, DxoDataGridAnimationModule, DxiDataGridAsyncRuleModule, DxoDataGridAtModule, DxoDataGridBoundaryOffsetModule, DxiDataGridButtonModule, DxiDataGridChangeModule, DxoDataGridColCountByScreenModule, DxoDataGridCollisionModule, DxiDataGridColumnModule, DxoDataGridColumnChooserModule, DxoDataGridColumnChooserSearchModule, DxoDataGridColumnChooserSelectionModule, DxoDataGridColumnFixingModule, DxoDataGridColumnFixingTextsModule, DxoDataGridColumnHeaderFilterModule, DxoDataGridColumnHeaderFilterSearchModule, DxoDataGridColumnLookupModule, DxiDataGridCompareRuleModule, DxoDataGridCursorOffsetModule, DxiDataGridCustomOperationModule, DxiDataGridCustomRuleModule, DxoDataGridDataGridHeaderFilterModule, DxoDataGridDataGridHeaderFilterSearchModule, DxoDataGridDataGridHeaderFilterTextsModule, DxoDataGridDataGridSelectionModule, DxoDataGridEditingModule, DxoDataGridEditingTextsModule, DxiDataGridEmailRuleModule, DxoDataGridExportModule, DxoDataGridExportTextsModule, DxiDataGridFieldModule, DxoDataGridFieldLookupModule, DxoDataGridFilterBuilderModule, DxoDataGridFilterBuilderPopupModule, DxoDataGridFilterOperationDescriptionsModule, DxoDataGridFilterPanelModule, DxoDataGridFilterPanelTextsModule, DxoDataGridFilterRowModule, DxoDataGridFormModule, DxoDataGridFormatModule, DxoDataGridFormItemModule, DxoDataGridFromModule, DxoDataGridGroupingModule, DxoDataGridGroupingTextsModule, DxiDataGridGroupItemModule, DxoDataGridGroupOperationDescriptionsModule, DxoDataGridGroupPanelModule, DxoDataGridHeaderFilterModule, DxoDataGridHideModule, DxoDataGridIconsModule, DxiDataGridItemModule, DxoDataGridKeyboardNavigationModule, DxoDataGridLabelModule, DxoDataGridLoadPanelModule, DxoDataGridLookupModule, DxoDataGridMasterDetailModule, DxoDataGridMyModule, DxiDataGridNumericRuleModule, DxoDataGridOffsetModule, DxoDataGridOperationDescriptionsModule, DxoDataGridPagerModule, DxoDataGridPagingModule, DxiDataGridPatternRuleModule, DxoDataGridPopupModule, DxoDataGridPositionModule, DxiDataGridRangeRuleModule, DxoDataGridRemoteOperationsModule, DxiDataGridRequiredRuleModule, DxoDataGridRowDraggingModule, DxoDataGridScrollingModule, DxoDataGridSearchModule, DxoDataGridSearchPanelModule, DxoDataGridSelectionModule, DxoDataGridShowModule, DxiDataGridSortByGroupSummaryInfoModule, DxoDataGridSortingModule, DxoDataGridStateStoringModule, DxiDataGridStringLengthRuleModule, DxoDataGridSummaryModule, DxoDataGridSummaryTextsModule, DxoDataGridTextsModule, DxoDataGridToModule, DxoDataGridToolbarModule, DxiDataGridToolbarItemModule, DxiDataGridTotalItemModule, DxiDataGridValidationRuleModule, DxoDataGridValueFormatModule, DxTemplateModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DxDataGridModule, [{
    type: NgModule,
    args: [{
      imports: [DxDataGridComponent, DxoColumnChooserModule, DxoPositionModule, DxoAtModule, DxoBoundaryOffsetModule, DxoCollisionModule, DxoMyModule, DxoOffsetModule, DxoSearchModule, DxoSelectionModule, DxoColumnFixingModule, DxoIconsModule, DxoTextsModule, DxiColumnModule, DxiButtonModule, DxoLookupModule, DxoFormatModule, DxoFormItemModule, DxoLabelModule, DxiValidationRuleModule, DxoHeaderFilterModule, DxoEditingModule, DxiChangeModule, DxoFormModule, DxoColCountByScreenModule, DxiItemModule, DxoTabPanelOptionsModule, DxiTabModule, DxoButtonOptionsModule, DxoPopupModule, DxoAnimationModule, DxoHideModule, DxoFromModule, DxoToModule, DxoShowModule, DxoExportModule, DxoFilterBuilderModule, DxiCustomOperationModule, DxiFieldModule, DxoFilterOperationDescriptionsModule, DxoGroupOperationDescriptionsModule, DxoFilterBuilderPopupModule, DxoFilterPanelModule, DxoFilterRowModule, DxoOperationDescriptionsModule, DxoGroupingModule, DxoGroupPanelModule, DxoKeyboardNavigationModule, DxoLoadPanelModule, DxoMasterDetailModule, DxoPagerModule, DxoPagingModule, DxoRemoteOperationsModule, DxoRowDraggingModule, DxoCursorOffsetModule, DxoScrollingModule, DxoSearchPanelModule, DxiSortByGroupSummaryInfoModule, DxoSortingModule, DxoStateStoringModule, DxoSummaryModule, DxiGroupItemModule, DxoValueFormatModule, DxiTotalItemModule, DxoToolbarModule, DxoDataGridAnimationModule, DxiDataGridAsyncRuleModule, DxoDataGridAtModule, DxoDataGridBoundaryOffsetModule, DxiDataGridButtonModule, DxiDataGridChangeModule, DxoDataGridColCountByScreenModule, DxoDataGridCollisionModule, DxiDataGridColumnModule, DxoDataGridColumnChooserModule, DxoDataGridColumnChooserSearchModule, DxoDataGridColumnChooserSelectionModule, DxoDataGridColumnFixingModule, DxoDataGridColumnFixingTextsModule, DxoDataGridColumnHeaderFilterModule, DxoDataGridColumnHeaderFilterSearchModule, DxoDataGridColumnLookupModule, DxiDataGridCompareRuleModule, DxoDataGridCursorOffsetModule, DxiDataGridCustomOperationModule, DxiDataGridCustomRuleModule, DxoDataGridDataGridHeaderFilterModule, DxoDataGridDataGridHeaderFilterSearchModule, DxoDataGridDataGridHeaderFilterTextsModule, DxoDataGridDataGridSelectionModule, DxoDataGridEditingModule, DxoDataGridEditingTextsModule, DxiDataGridEmailRuleModule, DxoDataGridExportModule, DxoDataGridExportTextsModule, DxiDataGridFieldModule, DxoDataGridFieldLookupModule, DxoDataGridFilterBuilderModule, DxoDataGridFilterBuilderPopupModule, DxoDataGridFilterOperationDescriptionsModule, DxoDataGridFilterPanelModule, DxoDataGridFilterPanelTextsModule, DxoDataGridFilterRowModule, DxoDataGridFormModule, DxoDataGridFormatModule, DxoDataGridFormItemModule, DxoDataGridFromModule, DxoDataGridGroupingModule, DxoDataGridGroupingTextsModule, DxiDataGridGroupItemModule, DxoDataGridGroupOperationDescriptionsModule, DxoDataGridGroupPanelModule, DxoDataGridHeaderFilterModule, DxoDataGridHideModule, DxoDataGridIconsModule, DxiDataGridItemModule, DxoDataGridKeyboardNavigationModule, DxoDataGridLabelModule, DxoDataGridLoadPanelModule, DxoDataGridLookupModule, DxoDataGridMasterDetailModule, DxoDataGridMyModule, DxiDataGridNumericRuleModule, DxoDataGridOffsetModule, DxoDataGridOperationDescriptionsModule, DxoDataGridPagerModule, DxoDataGridPagingModule, DxiDataGridPatternRuleModule, DxoDataGridPopupModule, DxoDataGridPositionModule, DxiDataGridRangeRuleModule, DxoDataGridRemoteOperationsModule, DxiDataGridRequiredRuleModule, DxoDataGridRowDraggingModule, DxoDataGridScrollingModule, DxoDataGridSearchModule, DxoDataGridSearchPanelModule, DxoDataGridSelectionModule, DxoDataGridShowModule, DxiDataGridSortByGroupSummaryInfoModule, DxoDataGridSortingModule, DxoDataGridStateStoringModule, DxiDataGridStringLengthRuleModule, DxoDataGridSummaryModule, DxoDataGridSummaryTextsModule, DxoDataGridTextsModule, DxoDataGridToModule, DxoDataGridToolbarModule, DxiDataGridToolbarItemModule, DxiDataGridTotalItemModule, DxiDataGridValidationRuleModule, DxoDataGridValueFormatModule, DxIntegrationModule, DxTemplateModule],
      exports: [DxDataGridComponent, DxoColumnChooserModule, DxoPositionModule, DxoAtModule, DxoBoundaryOffsetModule, DxoCollisionModule, DxoMyModule, DxoOffsetModule, DxoSearchModule, DxoSelectionModule, DxoColumnFixingModule, DxoIconsModule, DxoTextsModule, DxiColumnModule, DxiButtonModule, DxoLookupModule, DxoFormatModule, DxoFormItemModule, DxoLabelModule, DxiValidationRuleModule, DxoHeaderFilterModule, DxoEditingModule, DxiChangeModule, DxoFormModule, DxoColCountByScreenModule, DxiItemModule, DxoTabPanelOptionsModule, DxiTabModule, DxoButtonOptionsModule, DxoPopupModule, DxoAnimationModule, DxoHideModule, DxoFromModule, DxoToModule, DxoShowModule, DxoExportModule, DxoFilterBuilderModule, DxiCustomOperationModule, DxiFieldModule, DxoFilterOperationDescriptionsModule, DxoGroupOperationDescriptionsModule, DxoFilterBuilderPopupModule, DxoFilterPanelModule, DxoFilterRowModule, DxoOperationDescriptionsModule, DxoGroupingModule, DxoGroupPanelModule, DxoKeyboardNavigationModule, DxoLoadPanelModule, DxoMasterDetailModule, DxoPagerModule, DxoPagingModule, DxoRemoteOperationsModule, DxoRowDraggingModule, DxoCursorOffsetModule, DxoScrollingModule, DxoSearchPanelModule, DxiSortByGroupSummaryInfoModule, DxoSortingModule, DxoStateStoringModule, DxoSummaryModule, DxiGroupItemModule, DxoValueFormatModule, DxiTotalItemModule, DxoToolbarModule, DxoDataGridAnimationModule, DxiDataGridAsyncRuleModule, DxoDataGridAtModule, DxoDataGridBoundaryOffsetModule, DxiDataGridButtonModule, DxiDataGridChangeModule, DxoDataGridColCountByScreenModule, DxoDataGridCollisionModule, DxiDataGridColumnModule, DxoDataGridColumnChooserModule, DxoDataGridColumnChooserSearchModule, DxoDataGridColumnChooserSelectionModule, DxoDataGridColumnFixingModule, DxoDataGridColumnFixingTextsModule, DxoDataGridColumnHeaderFilterModule, DxoDataGridColumnHeaderFilterSearchModule, DxoDataGridColumnLookupModule, DxiDataGridCompareRuleModule, DxoDataGridCursorOffsetModule, DxiDataGridCustomOperationModule, DxiDataGridCustomRuleModule, DxoDataGridDataGridHeaderFilterModule, DxoDataGridDataGridHeaderFilterSearchModule, DxoDataGridDataGridHeaderFilterTextsModule, DxoDataGridDataGridSelectionModule, DxoDataGridEditingModule, DxoDataGridEditingTextsModule, DxiDataGridEmailRuleModule, DxoDataGridExportModule, DxoDataGridExportTextsModule, DxiDataGridFieldModule, DxoDataGridFieldLookupModule, DxoDataGridFilterBuilderModule, DxoDataGridFilterBuilderPopupModule, DxoDataGridFilterOperationDescriptionsModule, DxoDataGridFilterPanelModule, DxoDataGridFilterPanelTextsModule, DxoDataGridFilterRowModule, DxoDataGridFormModule, DxoDataGridFormatModule, DxoDataGridFormItemModule, DxoDataGridFromModule, DxoDataGridGroupingModule, DxoDataGridGroupingTextsModule, DxiDataGridGroupItemModule, DxoDataGridGroupOperationDescriptionsModule, DxoDataGridGroupPanelModule, DxoDataGridHeaderFilterModule, DxoDataGridHideModule, DxoDataGridIconsModule, DxiDataGridItemModule, DxoDataGridKeyboardNavigationModule, DxoDataGridLabelModule, DxoDataGridLoadPanelModule, DxoDataGridLookupModule, DxoDataGridMasterDetailModule, DxoDataGridMyModule, DxiDataGridNumericRuleModule, DxoDataGridOffsetModule, DxoDataGridOperationDescriptionsModule, DxoDataGridPagerModule, DxoDataGridPagingModule, DxiDataGridPatternRuleModule, DxoDataGridPopupModule, DxoDataGridPositionModule, DxiDataGridRangeRuleModule, DxoDataGridRemoteOperationsModule, DxiDataGridRequiredRuleModule, DxoDataGridRowDraggingModule, DxoDataGridScrollingModule, DxoDataGridSearchModule, DxoDataGridSearchPanelModule, DxoDataGridSelectionModule, DxoDataGridShowModule, DxiDataGridSortByGroupSummaryInfoModule, DxoDataGridSortingModule, DxoDataGridStateStoringModule, DxiDataGridStringLengthRuleModule, DxoDataGridSummaryModule, DxoDataGridSummaryTextsModule, DxoDataGridTextsModule, DxoDataGridToModule, DxoDataGridToolbarModule, DxiDataGridToolbarItemModule, DxiDataGridTotalItemModule, DxiDataGridValidationRuleModule, DxoDataGridValueFormatModule, DxTemplateModule]
    }]
  }], null, null);
})();

export {
  format_helper_default,
  DEFAULT_TOOLBAR_ITEMS,
  isVisible,
  getSortedToolbarItems,
  normalizeToolbarItems,
  filtering_default,
  load_panel_default2 as load_panel_default,
  m_utils_default,
  sortColumns,
  strictParseNumber,
  isGroup,
  isCondition,
  getFilterExpression,
  removeFieldConditionsFromFilter,
  syncFilters,
  getMatchedConditions,
  filterHasField,
  renderValueText,
  m_modules_default,
  updateHeaderFilterItemSelectionState,
  HeaderFilterView,
  headerFilterMixin,
  convertDataFromUTCToLocal,
  isUTCFormat,
  getFormatOptions,
  headerFilterModule,
  defaultOptions,
  sortable_default,
  custom,
  confirm,
  generateNewRowTempKey,
  forEachFormItems,
  select_box_default,
  getElementMaxHeightByWindow,
  filter_builder_default,
  FilterBuilderView,
  filterBuilderModule,
  FilterPanelView,
  filterPanelModule,
  Pagination2 as Pagination,
  MAX_PAGES_COUNT,
  pagerModule,
  ui_scrollable_default,
  m_column_state_mixin_default,
  columnHeadersModule,
  ColumnsController,
  columnsControllerModule,
  DataController,
  dataControllerModule,
  DataSourceAdapter,
  m_sorting_mixin_default,
  sortingModule,
  RowsView,
  rowsModule,
  contextMenuModule,
  errorHandlingModule,
  ResizingController,
  gridViewModule,
  headerPanelModule,
  GridCoreWidget,
  m_state_storing_core_default,
  stateStoringModule,
  dataSelectionExtenderMixin,
  columnHeadersSelectionExtenderMixin,
  rowsViewSelectionExtenderMixin,
  selectionModule,
  columnChooserModule,
  dataMasterDetailExtenderMixin,
  masterDetailModule,
  editorFactoryModule,
  dataControllerEditingExtenderMixin,
  editingModule,
  editingRowBasedModule,
  editingFormBasedModule,
  editingCellBasedModule,
  validator_default,
  validatingModule,
  m_virtual_scrolling_core_default,
  dataSourceAdapterExtender2 as dataSourceAdapterExtender,
  data7 as data,
  rowsView7 as rowsView,
  virtualScrollingModule,
  DX_MENU_ITEM_CLASS,
  menu_default2 as menu_default,
  filterRowModule,
  filterSyncModule,
  searchModule,
  columnsResizingReorderingModule,
  keyboardNavigationScrollableA11yExtender,
  keyboardNavigationModule,
  headersKeyboardNavigationModule,
  stickyColumnsModule,
  columnFixingModule,
  adaptivityModule,
  foreachColumnInfo,
  createColumnsInfo,
  virtualColumnsModule,
  prepareItems,
  focusModule,
  rowDraggingModule,
  data_grid_default,
  DxoDataGridAnimationComponent,
  DxoDataGridAnimationModule,
  DxiDataGridAsyncRuleComponent,
  DxiDataGridAsyncRuleModule,
  DxoDataGridAtComponent,
  DxoDataGridAtModule,
  DxoDataGridBoundaryOffsetComponent,
  DxoDataGridBoundaryOffsetModule,
  DxiDataGridButtonComponent,
  DxiDataGridButtonModule,
  DxiDataGridChangeComponent,
  DxiDataGridChangeModule,
  DxoDataGridColCountByScreenComponent,
  DxoDataGridColCountByScreenModule,
  DxoDataGridCollisionComponent,
  DxoDataGridCollisionModule,
  DxoDataGridColumnChooserSearchComponent,
  DxoDataGridColumnChooserSearchModule,
  DxoDataGridColumnChooserSelectionComponent,
  DxoDataGridColumnChooserSelectionModule,
  DxoDataGridColumnChooserComponent,
  DxoDataGridColumnChooserModule,
  DxiDataGridColumnComponent,
  DxiDataGridColumnModule,
  DxoDataGridColumnFixingTextsComponent,
  DxoDataGridColumnFixingTextsModule,
  DxoDataGridColumnFixingComponent,
  DxoDataGridColumnFixingModule,
  DxoDataGridColumnHeaderFilterSearchComponent,
  DxoDataGridColumnHeaderFilterSearchModule,
  DxoDataGridColumnHeaderFilterComponent,
  DxoDataGridColumnHeaderFilterModule,
  DxoDataGridColumnLookupComponent,
  DxoDataGridColumnLookupModule,
  DxiDataGridCompareRuleComponent,
  DxiDataGridCompareRuleModule,
  DxoDataGridCursorOffsetComponent,
  DxoDataGridCursorOffsetModule,
  DxiDataGridCustomOperationComponent,
  DxiDataGridCustomOperationModule,
  DxiDataGridCustomRuleComponent,
  DxiDataGridCustomRuleModule,
  DxoDataGridDataGridHeaderFilterSearchComponent,
  DxoDataGridDataGridHeaderFilterSearchModule,
  DxoDataGridDataGridHeaderFilterTextsComponent,
  DxoDataGridDataGridHeaderFilterTextsModule,
  DxoDataGridDataGridHeaderFilterComponent,
  DxoDataGridDataGridHeaderFilterModule,
  DxoDataGridDataGridSelectionComponent,
  DxoDataGridDataGridSelectionModule,
  DxoDataGridEditingTextsComponent,
  DxoDataGridEditingTextsModule,
  DxoDataGridEditingComponent,
  DxoDataGridEditingModule,
  DxiDataGridEmailRuleComponent,
  DxiDataGridEmailRuleModule,
  DxoDataGridExportTextsComponent,
  DxoDataGridExportTextsModule,
  DxoDataGridExportComponent,
  DxoDataGridExportModule,
  DxiDataGridFieldComponent,
  DxiDataGridFieldModule,
  DxoDataGridFieldLookupComponent,
  DxoDataGridFieldLookupModule,
  DxoDataGridFilterBuilderPopupComponent,
  DxoDataGridFilterBuilderPopupModule,
  DxoDataGridFilterBuilderComponent,
  DxoDataGridFilterBuilderModule,
  DxoDataGridFilterOperationDescriptionsComponent,
  DxoDataGridFilterOperationDescriptionsModule,
  DxoDataGridFilterPanelTextsComponent,
  DxoDataGridFilterPanelTextsModule,
  DxoDataGridFilterPanelComponent,
  DxoDataGridFilterPanelModule,
  DxoDataGridFilterRowComponent,
  DxoDataGridFilterRowModule,
  DxoDataGridFormItemComponent,
  DxoDataGridFormItemModule,
  DxoDataGridFormComponent,
  DxoDataGridFormModule,
  DxoDataGridFormatComponent,
  DxoDataGridFormatModule,
  DxoDataGridFromComponent,
  DxoDataGridFromModule,
  DxiDataGridGroupItemComponent,
  DxiDataGridGroupItemModule,
  DxoDataGridGroupOperationDescriptionsComponent,
  DxoDataGridGroupOperationDescriptionsModule,
  DxoDataGridGroupPanelComponent,
  DxoDataGridGroupPanelModule,
  DxoDataGridGroupingTextsComponent,
  DxoDataGridGroupingTextsModule,
  DxoDataGridGroupingComponent,
  DxoDataGridGroupingModule,
  DxoDataGridHeaderFilterComponent,
  DxoDataGridHeaderFilterModule,
  DxoDataGridHideComponent,
  DxoDataGridHideModule,
  DxoDataGridIconsComponent,
  DxoDataGridIconsModule,
  DxiDataGridItemComponent,
  DxiDataGridItemModule,
  DxoDataGridKeyboardNavigationComponent,
  DxoDataGridKeyboardNavigationModule,
  DxoDataGridLabelComponent,
  DxoDataGridLabelModule,
  DxoDataGridLoadPanelComponent,
  DxoDataGridLoadPanelModule,
  DxoDataGridLookupComponent,
  DxoDataGridLookupModule,
  DxoDataGridMasterDetailComponent,
  DxoDataGridMasterDetailModule,
  DxoDataGridMyComponent,
  DxoDataGridMyModule,
  DxiDataGridNumericRuleComponent,
  DxiDataGridNumericRuleModule,
  DxoDataGridOffsetComponent,
  DxoDataGridOffsetModule,
  DxoDataGridOperationDescriptionsComponent,
  DxoDataGridOperationDescriptionsModule,
  DxoDataGridPagerComponent,
  DxoDataGridPagerModule,
  DxoDataGridPagingComponent,
  DxoDataGridPagingModule,
  DxiDataGridPatternRuleComponent,
  DxiDataGridPatternRuleModule,
  DxoDataGridPopupComponent,
  DxoDataGridPopupModule,
  DxoDataGridPositionComponent,
  DxoDataGridPositionModule,
  DxiDataGridRangeRuleComponent,
  DxiDataGridRangeRuleModule,
  DxoDataGridRemoteOperationsComponent,
  DxoDataGridRemoteOperationsModule,
  DxiDataGridRequiredRuleComponent,
  DxiDataGridRequiredRuleModule,
  DxoDataGridRowDraggingComponent,
  DxoDataGridRowDraggingModule,
  DxoDataGridScrollingComponent,
  DxoDataGridScrollingModule,
  DxoDataGridSearchPanelComponent,
  DxoDataGridSearchPanelModule,
  DxoDataGridSearchComponent,
  DxoDataGridSearchModule,
  DxoDataGridSelectionComponent,
  DxoDataGridSelectionModule,
  DxoDataGridShowComponent,
  DxoDataGridShowModule,
  DxiDataGridSortByGroupSummaryInfoComponent,
  DxiDataGridSortByGroupSummaryInfoModule,
  DxoDataGridSortingComponent,
  DxoDataGridSortingModule,
  DxoDataGridStateStoringComponent,
  DxoDataGridStateStoringModule,
  DxiDataGridStringLengthRuleComponent,
  DxiDataGridStringLengthRuleModule,
  DxoDataGridSummaryTextsComponent,
  DxoDataGridSummaryTextsModule,
  DxoDataGridSummaryComponent,
  DxoDataGridSummaryModule,
  DxoDataGridTextsComponent,
  DxoDataGridTextsModule,
  DxoDataGridToComponent,
  DxoDataGridToModule,
  DxiDataGridToolbarItemComponent,
  DxiDataGridToolbarItemModule,
  DxoDataGridToolbarComponent,
  DxoDataGridToolbarModule,
  DxiDataGridTotalItemComponent,
  DxiDataGridTotalItemModule,
  DxiDataGridValidationRuleComponent,
  DxiDataGridValidationRuleModule,
  DxoDataGridValueFormatComponent,
  DxoDataGridValueFormatModule,
  DxDataGridComponent,
  DxDataGridModule
};
/*! Bundled license information:

devextreme-angular/fesm2022/devextreme-angular-ui-data-grid-nested.mjs:
devextreme-angular/fesm2022/devextreme-angular-ui-data-grid.mjs:
  (*!
   * devextreme-angular
   * Version: 25.1.6
   * Build date: Mon Oct 13 2025
   *
   * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-angular
   *)
*/
//# sourceMappingURL=chunk-XC4KJMRA.js.map
