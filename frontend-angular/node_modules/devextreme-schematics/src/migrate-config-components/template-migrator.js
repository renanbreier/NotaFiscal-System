"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformTemplate = exports.applyInlineComponentTemplateMigrations = exports.applyHostAwareTemplateMigrations = void 0;
const parse5 = __importStar(require("parse5"));
const picomatch_1 = __importDefault(require("picomatch"));
const typescript_resolver_1 = require("../utility/typescript-resolver");
// Dynamically require TypeScript if available; skip inline template migration if not.
// Uses a 3-level fallback: project search -> global search -> temporary install
const tsResolution = (0, typescript_resolver_1.resolveTypeScript)();
const ts = tsResolution.ts;
const tsResolutionErrors = tsResolution.errors;
// Transform external HTML template files matched by includeGlobs.
function applyHostAwareTemplateMigrations(tree, runner, exec) {
    return __awaiter(this, void 0, void 0, function* () {
        const matcher = (0, picomatch_1.default)(runner.includeGlobs.length ? runner.includeGlobs : ['**/*.html']);
        tree.visit(filePath => {
            if (!matcher(filePath)) {
                return;
            }
            if (!filePath.endsWith('.html')) {
                return;
            }
            const buffer = tree.read(filePath);
            if (!buffer) {
                return;
            }
            const source = buffer.toString('utf8');
            const { updated, changeCount } = transformTemplate(source, runner.rules);
            if (changeCount === 0) {
                return;
            }
            if (exec.dryRun) {
                exec.logger.info(`[dry] ${filePath} → ${changeCount} changes`);
            }
            else {
                exec.logger.info(`${filePath} → ${changeCount} changes`);
                tree.overwrite(filePath, updated);
            }
        });
    });
}
exports.applyHostAwareTemplateMigrations = applyHostAwareTemplateMigrations;
// Apply migrations inside inline component templates found in TS/JS files.
function applyInlineComponentTemplateMigrations(tree, runner, exec, scriptGlobs) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!scriptGlobs.length) {
            return;
        }
        if (!ts) {
            const errorDetails = tsResolutionErrors.length
                ? `Resolution attempts:\n${tsResolutionErrors.map(e => '  - ' + e).join('\n')}\n`
                : '';
            exec.logger.warn('[config-migrator] Failed to import TypeScript. Skipping inline template migration.\n' +
                errorDetails +
                'The schematic attempted to import TypeScript from the following locations:\n' +
                '  1. Project node_modules\n' +
                '  2. Global node_modules\n' +
                '  3. Temporary installation (npm cache)\n\n' +
                'To resolve this issue, install TypeScript.\n\n' +
                'Project install:\n' +
                '  npm install typescript --save-dev\n\n' +
                'Global install:\n' +
                '  npm install -g typescript\n\n');
            return;
        }
        const matcher = (0, picomatch_1.default)(scriptGlobs);
        tree.visit(filePath => {
            if (!matcher(filePath)) {
                return;
            }
            if (!(filePath.endsWith('.ts') || filePath.endsWith('.js'))) {
                return;
            }
            const buffer = tree.read(filePath);
            if (!buffer) {
                return;
            }
            const sourceText = buffer.toString('utf8');
            const sf = ts.createSourceFile(filePath, sourceText, ts.ScriptTarget.ES2022, true, filePath.endsWith('.ts') ? ts.ScriptKind.TS : ts.ScriptKind.JS);
            const edits = [];
            function visit(node) {
                if (ts.isDecorator(node) && ts.isCallExpression(node.expression)) {
                    const call = node.expression;
                    if (ts.isIdentifier(call.expression) && call.expression.text === 'Component' && call.arguments.length) {
                        const arg = call.arguments[0];
                        if (ts.isObjectLiteralExpression(arg)) {
                            for (const prop of arg.properties) {
                                if (!ts.isPropertyAssignment(prop)) {
                                    continue;
                                }
                                const name = prop.name;
                                const propName = ts.isIdentifier(name) ? name.text : ts.isStringLiteral(name) ? name.text : undefined;
                                if (propName !== 'template') {
                                    continue;
                                }
                                const init = prop.initializer;
                                if (ts.isStringLiteral(init)) {
                                    const raw = init.text;
                                    const { updated, changeCount } = transformTemplate(raw, runner.rules);
                                    if (changeCount > 0) {
                                        const quote = init.getText().startsWith("'") ? '"' : init.getText()[0];
                                        const newLiteral = quote + updated.replace(new RegExp(quote, 'g'), '\\' + quote) + quote;
                                        edits.push({ start: init.getStart(), end: init.getEnd(), text: newLiteral, changes: changeCount });
                                    }
                                }
                                else if (ts.isNoSubstitutionTemplateLiteral(init)) {
                                    const raw = init.text;
                                    const { updated, changeCount } = transformTemplate(raw, runner.rules);
                                    if (changeCount > 0) {
                                        const newLiteral = '`' + escapeBackticks(updated) + '`';
                                        edits.push({ start: init.getStart(), end: init.getEnd(), text: newLiteral, changes: changeCount });
                                    }
                                }
                                else if (ts.isTemplateExpression(init)) {
                                    const { placeholderContent, placeholders } = flattenTemplateExpression(init, sourceText);
                                    const { updated, changeCount } = transformTemplate(placeholderContent, runner.rules);
                                    if (changeCount > 0) {
                                        let rebuilt = updated;
                                        placeholders.forEach(placeholder => {
                                            rebuilt = rebuilt.replace(new RegExp(placeholder.token, 'g'), placeholder.fullText);
                                        });
                                        const newLiteral = '`' + escapeBackticks(rebuilt) + '`';
                                        edits.push({ start: init.getStart(), end: init.getEnd(), text: newLiteral, changes: changeCount });
                                    }
                                }
                            }
                        }
                    }
                }
                ts.forEachChild(node, visit);
            }
            visit(sf);
            if (!edits.length) {
                return;
            }
            edits.sort((a, b) => b.start - a.start); // edits from last to first
            let updatedFile = sourceText;
            for (const edit of edits) {
                updatedFile = updatedFile.slice(0, edit.start) + edit.text + updatedFile.slice(edit.end);
            }
            const totalChanges = edits.reduce((acc, edit) => acc + edit.changes, 0);
            if (exec.dryRun) {
                exec.logger.info(`[dry] ${filePath} (inline templates) → ${totalChanges} changes in ${edits.length} template(s)`);
            }
            else {
                exec.logger.info(`${filePath} (inline templates) → ${totalChanges} changes in ${edits.length} template(s)`);
                tree.overwrite(filePath, updatedFile);
            }
        });
    });
}
exports.applyInlineComponentTemplateMigrations = applyInlineComponentTemplateMigrations;
function transformTemplate(source, rules) {
    const document = parse5.parse(source, { sourceCodeLocationInfo: true });
    const replacements = [];
    const hostSelectorSet = new Set(rules.map(rule => rule.hostSelector));
    const seenOpens = new Set();
    const seenCloses = new Set();
    function walkHost(root, visitFn) {
        function recursiveWalk(node) {
            visitFn(node);
            const childNodes = node.childNodes;
            if (!childNodes) {
                return;
            }
            for (const childNode of childNodes) {
                if (isElement(childNode) && hostSelectorSet.has(childNode.tagName) && childNode !== root) {
                    continue;
                }
                recursiveWalk(childNode);
            }
        }
        recursiveWalk(root);
    }
    for (const rule of rules) {
        const hosts = findElementsByTag(document, rule.hostSelector);
        for (const host of hosts) {
            if (!host.sourceCodeLocation) {
                continue;
            }
            walkHost(host, (node) => {
                if (!isElement(node)) {
                    return;
                }
                const oldName = node.tagName;
                if (!oldName) {
                    return;
                }
                const newName = rule.configMap[oldName];
                if (!newName) {
                    return;
                }
                const loc = node.sourceCodeLocation;
                if (!loc) {
                    return;
                }
                if (loc.startTag) {
                    const openStart = loc.startTag.startOffset + 1;
                    const openEnd = openStart + oldName.length;
                    if (!seenOpens.has(openStart)) {
                        seenOpens.add(openStart);
                        replacements.push({ start: openStart, end: openEnd, text: newName });
                    }
                }
                if (loc.endTag) {
                    const endStart = loc.endTag.startOffset + 2;
                    const endEnd = endStart + oldName.length;
                    if (!seenCloses.has(endStart)) {
                        seenCloses.add(endStart);
                        replacements.push({ start: endStart, end: endEnd, text: newName });
                    }
                }
            });
        }
    }
    if (!replacements.length) {
        return { updated: source, changeCount: 0 };
    }
    replacements.sort((a, b) => b.start - a.start);
    let updated = source;
    for (const replacement of replacements) {
        updated = updated.slice(0, replacement.start) + replacement.text + updated.slice(replacement.end);
    }
    return { updated, changeCount: replacements.length };
}
exports.transformTemplate = transformTemplate;
// Helpers
function flattenTemplateExpression(node, source) {
    const placeholders = [];
    let content = node.head.text;
    node.templateSpans.forEach((span, i) => {
        const token = `__NG_EXPR_PLACEHOLDER_${i}__`;
        const fullText = '${' + source.slice(span.expression.getStart(), span.expression.getEnd()) + '}';
        placeholders.push({ token, fullText });
        content += token + span.literal.text;
    });
    return { placeholderContent: content, placeholders };
}
function escapeBackticks(text) {
    // First escape backslashes, then escape backticks
    return text.replace(/\\/g, '\\\\').replace(/`/g, '\\`');
}
// Utilities
function isElement(n) {
    return n.tagName !== undefined;
}
function walk(node, visit) {
    visit(node);
    const childNodes = node.childNodes;
    if (!childNodes) {
        return;
    }
    for (const childNode of childNodes) {
        walk(childNode, visit);
    }
}
function findElementsByTag(doc, tag) {
    const result = [];
    walk(doc, (node) => {
        if (isElement(node) && node.tagName === tag) {
            result.push(node);
        }
    });
    return result;
}
//# sourceMappingURL=template-migrator.js.map