/**
 * DevExtreme (cjs/__internal/scheduler/recurrence/base.js)
 * Version: 25.1.6
 * Build date: Mon Oct 13 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parseRecurrenceRule = exports.getRecurrenceString = exports.getDateByAsciiString = exports.getAsciiStringByDate = void 0;
var _date = _interopRequireDefault(require("../../../core/utils/date"));

function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    }
}
const toMs = _date.default.dateToMilliseconds;
const getAsciiStringByDate = date => {
    const currentOffset = date.getTimezoneOffset() * toMs("minute");
    const offsetDate = new Date(date.getTime() + currentOffset);
    return `${offsetDate.getFullYear()+`0${offsetDate.getMonth()+1}`.slice(-2)+`0${offsetDate.getDate()}`.slice(-2)}T${`0${offsetDate.getHours()}`.slice(-2)}${`0${offsetDate.getMinutes()}`.slice(-2)}${`0${offsetDate.getSeconds()}`.slice(-2)}Z`
};
exports.getAsciiStringByDate = getAsciiStringByDate;
const getRecurrenceString = rule => {
    if (!(null !== rule && void 0 !== rule && rule.freq)) {
        return
    }
    const result = Object.entries(rule).reduce(((acc, _ref) => {
        let [field, value] = _ref;
        if ("freq" === field || "interval" === field && value < 2) {
            return acc
        }
        if ("until" === field) {
            return `${acc}${field}=${getAsciiStringByDate(value)};`
        }
        return `${acc}${field}=${value};`
    }), `freq=${rule.freq};`);
    return result.substring(0, result.length - 1).toUpperCase()
};
exports.getRecurrenceString = getRecurrenceString;
const createDateTuple = parseResult => {
    const isUtc = void 0 !== parseResult[8];
    parseResult.shift();
    if (void 0 === parseResult[3]) {
        parseResult.splice(3)
    } else {
        parseResult.splice(3, 1);
        parseResult.splice(6)
    }
    parseResult.unshift("");
    return [parseInt(parseResult[1], 10), parseInt(parseResult[2], 10) - 1, parseInt(parseResult[3], 10), parseInt(parseResult[4], 10) || 0, parseInt(parseResult[5], 10) || 0, parseInt(parseResult[6], 10) || 0, isUtc]
};
const parseExceptionToRawArray = value => /(\d{4})(\d{2})(\d{2})(T(\d{2})(\d{2})(\d{2}))?(Z)?/.exec(value);
const getDateByAsciiString = exceptionText => {
    if ("string" !== typeof exceptionText) {
        return exceptionText
    }
    const result = parseExceptionToRawArray(exceptionText);
    if (!result) {
        return null
    }
    const [year, month, date, hours, minutes, seconds, isUtc] = createDateTuple(result);
    if (isUtc) {
        return new Date(Date.UTC(year, month, date, hours, minutes, seconds))
    }
    return new Date(year, month, date, hours, minutes, seconds)
};
exports.getDateByAsciiString = getDateByAsciiString;
const parseRecurrenceRule = recurrenceRule => {
    const emptyRule = {
        interval: 1
    };
    if (!recurrenceRule) {
        return emptyRule
    }
    const ruleParts = recurrenceRule.split(";");
    const ruleObject = ruleParts.reduce(((result, part) => {
        const rule = part.split("=");
        const ruleName = rule[0].toLowerCase();
        const ruleValue = rule[1];
        switch (ruleName) {
            case "count":
            case "interval": {
                const value = parseInt(ruleValue, 10);
                if (!isNaN(value)) {
                    result[ruleName] = value
                }
                break
            }
            default:
                result[ruleName] = ruleValue
        }
        return result
    }), emptyRule);
    if (ruleObject.freq && ruleObject.until) {
        ruleObject.until = getDateByAsciiString(ruleObject.until)
    }
    return ruleObject
};
exports.parseRecurrenceRule = parseRecurrenceRule;
