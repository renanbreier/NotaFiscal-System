/**
 * DevExtreme (cjs/__internal/scheduler/utils/data_accessor/appointment_data_accessor.js)
 * Version: 25.1.6
 * Build date: Mon Oct 13 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AppointmentDataAccessor = void 0;
var _data = require("../../../../core/utils/data");
var _date_serialization = _interopRequireDefault(require("../../../../core/utils/date_serialization"));
var _validate_rule = require("../../recurrence/validate_rule");
var _data_accessor = require("./data_accessor");

function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    }
}

function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var r in t) {
                ({}).hasOwnProperty.call(t, r) && (n[r] = t[r])
            }
        }
        return n
    }, _extends.apply(null, arguments)
}
const isDateField = field => "startDate" === field || "endDate" === field;
const isBooleanField = field => "allDay" === field || "disabled" === field;
class AppointmentDataAccessor extends _data_accessor.DataAccessor {
    constructor(fields) {
        let forceIsoDateParsing = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : true;
        let dateSerializationFormat = arguments.length > 2 ? arguments[2] : void 0;
        super();
        this.forceIsoDateParsing = forceIsoDateParsing;
        this.dateSerializationFormat = dateSerializationFormat;
        this.expr = _extends({}, fields);
        this.updateExpressions(fields)
    }
    getCommonAccessExpressions(expr) {
        return {
            getter: (0, _data.compileGetter)(expr),
            setter: (0, _data.compileSetter)(expr)
        }
    }
    getDateFieldAccessExpressions(expr) {
        const {
            getter: commonGetter,
            setter: commonSetter
        } = this.getCommonAccessExpressions(expr);
        let serializationFormatCache;
        return {
            getter: object => {
                const date = this.forceIsoDateParsing ? _date_serialization.default.deserializeDate(commonGetter(object)) : commonGetter(object);
                return void 0 === date ? date : new Date(date)
            },
            setter: (object, value) => {
                if (this.dateSerializationFormat) {
                    serializationFormatCache = this.dateSerializationFormat
                } else if (this.forceIsoDateParsing && !serializationFormatCache) {
                    const oldValue = commonGetter(object);
                    serializationFormatCache = _date_serialization.default.getDateSerializationFormat(oldValue)
                }
                const newValue = _date_serialization.default.serializeDate(value, serializationFormatCache);
                commonSetter(object, newValue)
            }
        }
    }
    getBooleanFieldAccessExpressions(expr) {
        const {
            getter: commonGetter,
            setter: setter
        } = this.getCommonAccessExpressions(expr);
        return {
            getter: object => Boolean(commonGetter(object)),
            setter: setter
        }
    }
    getAccessExpressions(name, expr) {
        switch (true) {
            case isBooleanField(name):
                return this.getBooleanFieldAccessExpressions(expr);
            case isDateField(name):
                return this.getDateFieldAccessExpressions(expr);
            default:
                return this.getCommonAccessExpressions(expr)
        }
    }
    updateExpression(field, expr) {
        const name = field.replace("Expr", "");
        if (!expr) {
            delete this.getter[name];
            delete this.setter[name];
            delete this.expr[field];
            return
        }
        const {
            getter: getter,
            setter: setter
        } = this.getAccessExpressions(name, expr);
        this.getter[name] = getter;
        this.setter[name] = setter;
        this.expr[field] = expr
    }
    isRecurrent(appointment) {
        const recurrenceRule = this.get("recurrenceRule", appointment);
        const isRecurrent = (0, _validate_rule.validateRRule)(recurrenceRule);
        return isRecurrent
    }
}
exports.AppointmentDataAccessor = AppointmentDataAccessor;
