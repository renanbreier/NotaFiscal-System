/**
 * DevExtreme (esm/__internal/ui/context_menu/context_menu.js)
 * Version: 25.1.6
 * Build date: Mon Oct 13 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
import _extends from "@babel/runtime/helpers/esm/extends";
import {
    fx
} from "../../../common/core/animation";
import animationPosition from "../../../common/core/animation/position";
import {
    name as contextMenuEventName
} from "../../../common/core/events/contextmenu";
import eventsEngine from "../../../common/core/events/core/events_engine";
import holdEvent from "../../../common/core/events/hold";
import {
    addNamespace
} from "../../../common/core/events/utils";
import registerComponent from "../../../core/component_registrator";
import devices from "../../../core/devices";
import domAdapter from "../../../core/dom_adapter";
import {
    getPublicElement
} from "../../../core/element";
import Guid from "../../../core/guid";
import $ from "../../../core/renderer";
import {
    noop
} from "../../../core/utils/common";
import {
    Deferred
} from "../../../core/utils/deferred";
import {
    contains
} from "../../../core/utils/dom";
import {
    extend
} from "../../../core/utils/extend";
import {
    each
} from "../../../core/utils/iterator";
import {
    getOuterHeight
} from "../../../core/utils/size";
import {
    isDefined,
    isFunction,
    isObject,
    isPlainObject,
    isRenderer,
    isString
} from "../../../core/utils/type";
import {
    getWindow,
    hasWindow
} from "../../../core/utils/window";
import {
    current as currentTheme,
    isGeneric
} from "../../../ui/themes";
import MenuBase from "../../ui/context_menu/menu_base";
import Overlay from "../../ui/overlay/overlay";
import {
    SCROLLABLE_CLASS
} from "../../ui/scroll_view/consts";
import Scrollable from "../../ui/scroll_view/scrollable";
const DX_MENU_CLASS = "dx-menu";
export const DX_MENU_ITEM_CLASS = "dx-menu-item";
const DX_MENU_ITEM_EXPANDED_CLASS = "dx-menu-item-expanded";
const DX_MENU_PHONE_CLASS = "dx-menu-phone-overlay";
const DX_MENU_ITEMS_CONTAINER_CLASS = "dx-menu-items-container";
const DX_MENU_ITEM_WRAPPER_CLASS = "dx-menu-item-wrapper";
const DX_SUBMENU_CLASS = "dx-submenu";
export const DX_CONTEXT_MENU_CLASS = "dx-context-menu";
const DX_HAS_CONTEXT_MENU_CLASS = "dx-has-context-menu";
const DX_STATE_DISABLED_CLASS = "dx-state-disabled";
const DX_STATE_FOCUSED_CLASS = "dx-state-focused";
const DX_STATE_HOVER_CLASS = "dx-state-hover";
const OVERLAY_CONTENT_CLASS = "dx-overlay-content";
const FOCUS_UP = "up";
const FOCUS_DOWN = "down";
const FOCUS_LEFT = "left";
const FOCUS_RIGHT = "right";
const FOCUS_FIRST = "first";
const FOCUS_LAST = "last";
const ACTIONS = ["onShowing", "onShown", "onSubmenuCreated", "onHiding", "onHidden", "onPositioning", "onLeftFirstItem", "onLeftLastItem", "onCloseRootSubmenu", "onExpandLastSubmenu"];
const LOCAL_SUBMENU_DIRECTIONS = ["up", "down", "first", "last"];
const DEFAULT_SHOW_EVENT = "dxcontextmenu";
const SUBMENU_PADDING = 10;
const BORDER_WIDTH = 1;
const window = getWindow();
class ContextMenu extends MenuBase {
    getShowEvent(showEventOption) {
        if (isObject(showEventOption)) {
            if (null === showEventOption.name) {
                return null
            }
            return showEventOption.name ?? "dxcontextmenu"
        }
        return showEventOption ?? null
    }
    getShowDelay(showEventOption) {
        return isObject(showEventOption) ? showEventOption.delay ?? 0 : 0
    }
    _getDefaultOptions() {
        return _extends({}, super._getDefaultOptions(), {
            showEvent: "dxcontextmenu",
            hideOnOutsideClick: true,
            position: {
                at: "top left",
                my: "top left"
            },
            onShowing: null,
            onShown: null,
            onSubmenuCreated: null,
            onHiding: null,
            onHidden: null,
            onPositioning: null,
            submenuDirection: "auto",
            visible: false,
            target: void 0,
            onLeftFirstItem: null,
            onLeftLastItem: null,
            onCloseRootSubmenu: null,
            onExpandLastSubmenu: null,
            hideOnParentScroll: true,
            visualContainer: window
        })
    }
    _defaultOptionsRules() {
        return super._defaultOptionsRules().concat([{
            device: () => !hasWindow(),
            options: {
                animation: null
            }
        }])
    }
    _initActions() {
        this._actions = {};
        each(ACTIONS, ((_index, action) => {
            this._actions[action] = this._createActionByOption(action) || noop
        }))
    }
    _setOptionsByReference() {
        super._setOptionsByReference();
        extend(this._optionsByReference, {
            animation: true,
            selectedItem: true
        })
    }
    _focusInHandler() {}
    _itemContainer() {
        return this._overlay ? this._overlay.$content() : $()
    }
    _eventBindingTarget() {
        return this._itemContainer()
    }
    itemsContainer() {
        var _this$_overlay;
        return (null === (_this$_overlay = this._overlay) || void 0 === _this$_overlay ? void 0 : _this$_overlay.$content()) ?? $()
    }
    _supportedKeys() {
        return _extends({}, super._supportedKeys(), {
            space: () => {
                const {
                    focusedElement: focusedElement
                } = this.option();
                const $item = $(focusedElement);
                this.hide();
                if (!$item.length || !this._isSelectionEnabled()) {
                    return
                }
                this.selectItem($item[0])
            },
            escape: () => {
                this.hide()
            }
        })
    }
    _getActiveItem(_last) {
        const $availableItems = this._getAvailableItems();
        const $focusedItem = $availableItems.filter(".dx-state-focused");
        const $hoveredItem = $availableItems.filter(".dx-state-hover");
        const $hoveredItemContainer = $hoveredItem.closest(".dx-menu-items-container");
        if ($hoveredItemContainer.find(".dx-menu-item").index($focusedItem) >= 0) {
            return $focusedItem
        }
        if ($hoveredItem.length) {
            return $hoveredItem
        }
        return super._getActiveItem()
    }
    _moveFocus(location) {
        const $items = this._getItemsByLocation(location);
        const $oldTarget = this._getActiveItem(true);
        const $hoveredItem = this.itemsContainer().find(".dx-state-hover");
        const {
            focusedElement: focusedElement,
            rtlEnabled: rtlEnabled
        } = this.option();
        const $focusedItem = $(focusedElement);
        const $activeItemHighlighted = !!($focusedItem.length || null !== $hoveredItem && void 0 !== $hoveredItem && $hoveredItem.length);
        let $newTarget;
        switch (location) {
            case "up":
                $newTarget = $activeItemHighlighted ? this._prevItem($items) : $oldTarget;
                this._setFocusedElement($newTarget);
                if ($oldTarget.is($items.first())) {
                    var _this$_actions$onLeft, _this$_actions;
                    null === (_this$_actions$onLeft = (_this$_actions = this._actions).onLeftFirstItem) || void 0 === _this$_actions$onLeft || _this$_actions$onLeft.call(_this$_actions, $oldTarget)
                }
                break;
            case "down":
                $newTarget = $activeItemHighlighted ? this._nextItem($items) : $oldTarget;
                this._setFocusedElement($newTarget);
                if ($oldTarget.is($items.last())) {
                    var _this$_actions$onLeft2, _this$_actions2;
                    null === (_this$_actions$onLeft2 = (_this$_actions2 = this._actions).onLeftLastItem) || void 0 === _this$_actions$onLeft2 || _this$_actions$onLeft2.call(_this$_actions2, $oldTarget)
                }
                break;
            case "right":
                $newTarget = rtlEnabled ? this._hideSubmenuHandler() : this._expandSubmenuHandler($items, location);
                this._setFocusedElement($newTarget);
                break;
            case "left":
                $newTarget = rtlEnabled ? this._expandSubmenuHandler($items, location) : this._hideSubmenuHandler();
                this._setFocusedElement($newTarget);
                break;
            case "first":
                $newTarget = $items.first();
                this._setFocusedElement($newTarget);
                break;
            case "last":
                $newTarget = $items.last();
                this._setFocusedElement($newTarget);
                break;
            default:
                return super._moveFocus(location)
        }
    }
    _setFocusedElement($element) {
        if ($element && 0 !== $element.length) {
            this.option("focusedElement", getPublicElement($element));
            this._scrollToElement($element)
        }
    }
    _scrollToElement($element) {
        const $scrollableElement = $element.closest(`.${SCROLLABLE_CLASS}`);
        const scrollableInstance = Scrollable.getInstance($scrollableElement.get(0));
        null === scrollableInstance || void 0 === scrollableInstance || scrollableInstance.scrollToElement($element)
    }
    _getItemsByLocation(location) {
        const $activeItem = this._getActiveItem(true);
        let $items;
        if (LOCAL_SUBMENU_DIRECTIONS.includes(location)) {
            $items = $activeItem.closest(".dx-menu-items-container").children().children()
        }
        $items = this._getAvailableItems($items);
        return $items
    }
    _getAriaTarget() {
        return this.$element()
    }
    _refreshActiveDescendant() {
        if (isDefined(this._overlay)) {
            const $target = this._overlay.$content();
            super._refreshActiveDescendant($target)
        }
    }
    _hideSubmenuHandler() {
        var _this$_actions$onClos, _this$_actions3;
        const $curItem = this._getActiveItem(true);
        const $parentItem = $curItem.parents(".dx-menu-item-expanded").first();
        if ($parentItem.length) {
            this._hideSubmenusOnSameLevel($parentItem);
            this._hideSubmenu($curItem.closest(".dx-submenu"));
            return $parentItem
        }
        null === (_this$_actions$onClos = (_this$_actions3 = this._actions).onCloseRootSubmenu) || void 0 === _this$_actions$onClos || _this$_actions$onClos.call(_this$_actions3, $curItem);
        return
    }
    _expandSubmenuHandler($items, location) {
        var _this$_actions$onExpa, _this$_actions4;
        const $curItem = this._getActiveItem(true);
        const itemData = this._getItemData($curItem);
        const node = this._dataAdapter.getNodeByItem(itemData);
        const isItemHasSubmenu = this._hasSubmenu(node);
        const $submenu = $curItem.children(".dx-submenu");
        if (isItemHasSubmenu && !$curItem.hasClass("dx-state-disabled")) {
            if (!$submenu.length || "hidden" === $submenu.css("visibility")) {
                this._showSubmenu($curItem)
            }
            return this._nextItem(this._getItemsByLocation(location))
        }
        null === (_this$_actions$onExpa = (_this$_actions4 = this._actions).onExpandLastSubmenu) || void 0 === _this$_actions$onExpa || _this$_actions$onExpa.call(_this$_actions4, $curItem);
        return
    }
    _clean() {
        if (this._overlay) {
            this._overlay.$element().remove();
            this._overlay = null
        }
        this._detachShowContextMenuEvents(this._getTarget());
        this._shownSubmenus = [];
        super._clean()
    }
    _initMarkup() {
        this.$element().addClass("dx-has-context-menu");
        this._eventNamespace = `${this.NAME}${new Guid}`;
        super._initMarkup()
    }
    _render() {
        super._render();
        const {
            visible: visible
        } = this.option();
        this._renderVisibility(visible);
        this._addWidgetClass()
    }
    _isTargetOutOfComponent(relatedTarget) {
        const isInsideContextMenu = 0 !== $(relatedTarget).closest(".dx-context-menu").length;
        return !isInsideContextMenu
    }
    _focusOutHandler(e) {
        const {
            relatedTarget: relatedTarget
        } = e;
        if (relatedTarget) {
            const isTargetOutside = this._isTargetOutOfComponent(relatedTarget);
            if (isTargetOutside) {
                this.hide()
            }
        }
        super._focusOutHandler(e)
    }
    _renderContentImpl() {
        this._detachShowContextMenuEvents(this._getTarget());
        this._showContextMenuEventHandler = this._createShowContextMenuEventHandler();
        this._attachShowContextMenuEvents()
    }
    _attachKeyboardEvents() {
        if (!this._keyboardListenerId && this._focusTarget().length) {
            super._attachKeyboardEvents()
        }
    }
    _renderContextMenuOverlay() {
        if (this._overlay) {
            return
        }
        const overlayOptions = this._getOverlayOptions();
        this._overlay = this._createComponent($("<div>").appendTo(this.$element()), Overlay, overlayOptions);
        const $overlayContent = this._overlay.$content();
        $overlayContent.addClass("dx-context-menu");
        this._addCustomCssClass($overlayContent);
        this._addPlatformDependentClass($overlayContent);
        this._attachContextMenuEvent()
    }
    preventShowingDefaultContextMenuAboveOverlay() {
        const $itemContainer = this._itemContainer();
        const eventName = addNamespace(contextMenuEventName, this._eventNamespace);
        eventsEngine.off($itemContainer, eventName, ".dx-submenu");
        eventsEngine.on($itemContainer, eventName, ".dx-submenu", (e => {
            e.stopPropagation();
            e.preventDefault();
            eventsEngine.off($itemContainer, eventName, ".dx-submenu")
        }))
    }
    _itemContextMenuHandler(e) {
        super._itemContextMenuHandler(e);
        e.stopPropagation()
    }
    _addPlatformDependentClass($element) {
        if (devices.current().phone) {
            $element.addClass(DX_MENU_PHONE_CLASS)
        }
    }
    _createShowContextMenuEventHandler() {
        const showContextMenuAction = this._createAction((e => {
            const {
                showEvent: showEvent
            } = this.option();
            const delay = this.getShowDelay(showEvent);
            if (delay) {
                setTimeout((() => this._show(e.event)), delay)
            } else {
                this._show(e.event)
            }
        }), {
            validatingTargetName: "target"
        });
        return e => showContextMenuAction({
            event: e,
            target: $(e.currentTarget)
        })
    }
    _detachShowContextMenuEvents(target, event) {
        const {
            showEvent: showEventOption
        } = this.option();
        const showEvent = this.getShowEvent(event ?? showEventOption);
        if (!showEvent) {
            return
        }
        const isSelector = isString(target);
        const eventName = addNamespace(showEvent, this._eventNamespace);
        if (isSelector) {
            eventsEngine.off(domAdapter.getDocument(), eventName, target, this._showContextMenuEventHandler)
        } else {
            eventsEngine.off($(target), eventName, this._showContextMenuEventHandler)
        }
    }
    _attachShowContextMenuEvents() {
        const {
            showEvent: showEventOption,
            disabled: disabled
        } = this.option();
        const showEvent = this.getShowEvent(showEventOption);
        if (!showEvent || disabled) {
            return
        }
        const target = this._getTarget();
        const isSelector = isString(target);
        const eventName = addNamespace(showEvent, this._eventNamespace);
        if (isSelector) {
            eventsEngine.on(domAdapter.getDocument(), eventName, target, this._showContextMenuEventHandler)
        } else {
            eventsEngine.on(target, eventName, this._showContextMenuEventHandler)
        }
    }
    _hoverEndHandler(e) {
        super._hoverEndHandler(e);
        e.stopPropagation()
    }
    _renderDimensions() {}
    _renderContainer($wrapper, submenuContainer) {
        const $holder = submenuContainer ?? this._itemContainer();
        $wrapper = $("<div>");
        $wrapper.appendTo($holder).addClass("dx-submenu").css("visibility", submenuContainer ? "hidden" : "visible");
        if (!$wrapper.parent().hasClass("dx-overlay-content")) {
            this._addCustomCssClass($wrapper)
        }
        const $itemsContainer = super._renderContainer($wrapper);
        if (submenuContainer) {
            return $itemsContainer
        }
        const {
            width: width,
            height: height
        } = this.option();
        if (width) {
            return $itemsContainer.css("minWidth", width)
        }
        if (height) {
            return $itemsContainer.css("minHeight", height)
        }
        return $itemsContainer
    }
    _renderSubmenuItems(node, $itemFrame) {
        var _this$_actions$onSubm, _this$_actions5;
        this._renderItems(this._getChildNodes(node), $itemFrame);
        const $submenu = $itemFrame.children(".dx-submenu");
        null === (_this$_actions$onSubm = (_this$_actions5 = this._actions).onSubmenuCreated) || void 0 === _this$_actions$onSubm || _this$_actions$onSubm.call(_this$_actions5, {
            itemElement: getPublicElement($itemFrame),
            itemData: node.internalFields.item,
            submenuElement: getPublicElement($submenu)
        });
        this._initScrollable($submenu);
        this.setAria({
            role: "menu"
        }, $submenu)
    }
    _getOverlayOptions() {
        const {
            position: position,
            focusStateEnabled: focusStateEnabled,
            animation: animation,
            hideOnParentScroll: hideOnParentScroll,
            visualContainer: visualContainer,
            overlayContainer: overlayContainer,
            boundaryOffset: boundaryOffset
        } = this.option();
        return {
            focusStateEnabled: focusStateEnabled,
            animation: animation,
            innerOverlay: true,
            hideOnOutsideClick: e => this._hideOnOutsideClickHandler(e),
            propagateOutsideClick: true,
            hideOnParentScroll: hideOnParentScroll,
            deferRendering: false,
            container: overlayContainer,
            position: {
                at: position.at,
                my: position.my,
                of: this._getTarget(),
                collision: "flipfit",
                boundary: visualContainer,
                boundaryOffset: boundaryOffset
            },
            shading: false,
            showTitle: false,
            height: "auto",
            width: "auto",
            onShown: this._overlayShownActionHandler.bind(this),
            onHiding: this._overlayHidingActionHandler.bind(this),
            onHidden: this._overlayHiddenActionHandler.bind(this),
            visualContainer: visualContainer
        }
    }
    _overlayShownActionHandler(arg) {
        var _this$_actions$onShow, _this$_actions6;
        null === (_this$_actions$onShow = (_this$_actions6 = this._actions).onShown) || void 0 === _this$_actions$onShow || _this$_actions$onShow.call(_this$_actions6, arg)
    }
    _overlayHidingActionHandler(arg) {
        var _this$_actions$onHidi, _this$_actions7;
        null === (_this$_actions$onHidi = (_this$_actions7 = this._actions).onHiding) || void 0 === _this$_actions$onHidi || _this$_actions$onHidi.call(_this$_actions7, arg);
        if (!arg.cancel) {
            this._hideAllShownSubmenus();
            this._setOptionWithoutOptionChange("visible", false)
        }
    }
    _overlayHiddenActionHandler(arg) {
        var _this$_actions$onHidd, _this$_actions8;
        null === (_this$_actions$onHidd = (_this$_actions8 = this._actions).onHidden) || void 0 === _this$_actions$onHidd || _this$_actions$onHidd.call(_this$_actions8, arg)
    }
    _shouldHideOnOutsideClick(e) {
        const {
            hideOnOutsideClick: hideOnOutsideClick
        } = this.option();
        if (isFunction(hideOnOutsideClick)) {
            return hideOnOutsideClick(e)
        }
        return hideOnOutsideClick
    }
    _hideOnOutsideClickHandler(e) {
        if (!this._shouldHideOnOutsideClick(e)) {
            return false
        }
        if (domAdapter.isDocument(e.target)) {
            return true
        }
        const $activeItemContainer = this._getActiveItemsContainer(e.target);
        const $itemContainers = this._getItemsContainers();
        const $clickedItem = this._searchActiveItem(e.target);
        const $rootItem = this.$element().parents(".dx-menu-item");
        const isRootItemClicked = $clickedItem[0] === $rootItem[0] && !!$clickedItem.length && !!$rootItem.length;
        const isInnerOverlayClicked = this._isIncludeOverlay($activeItemContainer, $itemContainers) && !!$clickedItem.length;
        if (isInnerOverlayClicked || isRootItemClicked) {
            if ("onClick" === this._getShowSubmenuMode()) {
                this._hideAllShownChildSubmenus($clickedItem)
            }
            return false
        }
        return true
    }
    _getActiveItemsContainer(target) {
        return $(target).closest(".dx-menu-items-container")
    }
    _getItemsContainers() {
        var _this$_overlay2;
        return (null === (_this$_overlay2 = this._overlay) || void 0 === _this$_overlay2 ? void 0 : _this$_overlay2.$content().find(".dx-menu-items-container")) ?? $()
    }
    _searchActiveItem(target) {
        return $(target).closest(".dx-menu-item").eq(0)
    }
    _isIncludeOverlay($activeOverlay, $allOverlays) {
        let isSame = false;
        each($allOverlays, ((_index, $overlay) => {
            if ($activeOverlay.is($overlay) && !isSame) {
                isSame = true
            }
        }));
        return isSame
    }
    _hideAllShownChildSubmenus($clickedItem) {
        const $submenuElements = $clickedItem.find(".dx-submenu");
        const shownSubmenus = extend([], this._shownSubmenus);
        if ($submenuElements.length > 0) {
            each(shownSubmenus, ((index, $submenu) => {
                const $context = this._searchActiveItem($submenu.context).parent();
                if ($context.parent().is($clickedItem.parent().parent()) && !$context.is($clickedItem.parent())) {
                    this._hideSubmenu($submenu)
                }
            }))
        }
    }
    _initScrollable($container) {
        this._createComponent($container, Scrollable, {
            useKeyboard: false,
            _onVisibilityChanged: scrollable => {
                scrollable.scrollTo(0)
            }
        })
    }
    _setSubMenuHeight($submenu, $anchor) {
        const $itemsContainer = $submenu.find(".dx-menu-items-container");
        const contentHeight = getOuterHeight($itemsContainer);
        const maxHeight = this._getMaxHeight($anchor, false);
        const menuHeight = Math.min(contentHeight, maxHeight);
        $submenu.css("height", menuHeight)
    }
    _getMaxUsableSpace(_offsetTop, windowHeight, _anchorHeight) {
        return windowHeight
    }
    _getMaxHeight($anchor) {
        let considerAnchorHeight = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : true;
        const windowHeight = getOuterHeight(window);
        const isAnchorRenderer = isRenderer($anchor);
        const document = domAdapter.getDocument();
        const isAnchorDocument = isObject($anchor) && "length" in $anchor && $anchor.length && $anchor[0] === document;
        if (!isAnchorRenderer || isAnchorDocument) {
            return windowHeight
        }
        const offsetTop = null === $anchor || void 0 === $anchor ? void 0 : $anchor[0].getBoundingClientRect().top;
        const anchorHeight = getOuterHeight($anchor);
        const availableHeight = considerAnchorHeight ? this._getMaxUsableSpace(offsetTop, windowHeight, anchorHeight) : Math.max(offsetTop + anchorHeight, windowHeight - offsetTop);
        return availableHeight - 10
    }
    _setOverlayMaxHeight($subMenu) {
        var _this$_overlay3;
        if (!$subMenu) {
            return
        }
        null === (_this$_overlay3 = this._overlay) || void 0 === _this$_overlay3 || _this$_overlay3.option({
            maxHeight: () => {
                const $content = $subMenu.find(".dx-menu-items-container");
                const outerHeight = getOuterHeight($content);
                const borderWidth = this._getSubmenuBorderWidth();
                return outerHeight + 2 * borderWidth
            }
        });
        $subMenu.css("height", "100%")
    }
    _dimensionChanged() {
        if (!this._shownSubmenus) {
            return
        }
        this._shownSubmenus.forEach(($submenu => {
            const $item = $submenu.closest(".dx-menu-item");
            this._setSubMenuHeight($submenu, $item);
            this._scrollToElement($item);
            const submenuPosition = this._getSubmenuPosition($item);
            animationPosition.setup($submenu, submenuPosition)
        }))
    }
    _getSubmenuBorderWidth() {
        return isGeneric(currentTheme()) ? 1 : 0
    }
    _showSubmenu($item) {
        const node = this._dataAdapter.getNodeByItem(this._getItemData($item));
        this._hideSubmenusOnSameLevel($item);
        if (!this._hasSubmenu(node)) {
            return
        }
        let $submenu = $item.children(".dx-submenu");
        const isSubmenuRendered = $submenu.length;
        super._showSubmenu($item);
        if (node && !isSubmenuRendered) {
            this._renderSubmenuItems(node, $item);
            $submenu = $item.children(".dx-submenu")
        }
        this._planPostRenderActions($submenu)
    }
    _setSubmenuVisible($submenu) {
        if (!$submenu) {
            return
        }
        const $item = null === $submenu || void 0 === $submenu ? void 0 : $submenu.closest(".dx-menu-item");
        this._setSubMenuHeight($submenu, $item);
        if (!this._isSubmenuVisible($submenu) && $item) {
            this._drawSubmenu($item)
        }
    }
    _hideSubmenusOnSameLevel($item) {
        const $expandedItems = $item.parent(".dx-menu-item-wrapper").siblings().find(".dx-menu-item-expanded");
        if ($expandedItems.length) {
            $expandedItems.removeClass("dx-menu-item-expanded");
            this._hideSubmenu($expandedItems.find(".dx-submenu"))
        }
    }
    _isSubmenuVisible($submenu) {
        return "visible" === $submenu.css("visibility")
    }
    _drawSubmenu($itemElement) {
        var _this$_overlay4;
        const {
            animation: animationOption
        } = this.option();
        const animation = animationOption ? animationOption.show : {};
        const $submenu = $itemElement.children(".dx-submenu");
        const submenuPosition = this._getSubmenuPosition($itemElement);
        if (null !== (_this$_overlay4 = this._overlay) && void 0 !== _this$_overlay4 && _this$_overlay4.option("visible")) {
            if (!isDefined(this._shownSubmenus)) {
                this._shownSubmenus = []
            }
            if (!this._shownSubmenus.includes($submenu)) {
                this._shownSubmenus.push($submenu)
            }
            if (animation) {
                fx.stop($submenu.get(0), false)
            }
            animationPosition.setup($submenu, submenuPosition);
            if (animation) {
                if (isPlainObject(animation.to)) {
                    animation.to.position = submenuPosition
                }
                this._animate($submenu.get(0), animation)
            }
            $submenu.css("visibility", "visible")
        }
    }
    _animate(container, options) {
        fx.animate(container, options)
    }
    _getSubmenuPosition($rootItem) {
        const {
            submenuDirection: submenuDirectionOption,
            rtlEnabled: rtlEnabled
        } = this.option();
        const submenuDirection = null === submenuDirectionOption || void 0 === submenuDirectionOption ? void 0 : submenuDirectionOption.toLowerCase();
        const $rootItemWrapper = $rootItem.parent(".dx-menu-item-wrapper");
        const position = {
            collision: "flip",
            of: $rootItemWrapper,
            offset: {
                h: 0,
                v: -1
            }
        };
        switch (submenuDirection) {
            case "left":
                position.at = "left top";
                position.my = "right top";
                break;
            case "right":
                position.at = "right top";
                position.my = "left top";
                break;
            default:
                if (rtlEnabled) {
                    position.at = "left top";
                    position.my = "right top"
                } else {
                    position.at = "right top";
                    position.my = "left top"
                }
        }
        return position
    }
    _updateSubmenuVisibilityOnClick(actionArgs) {
        var _actionArgs$args;
        if (!(null !== (_actionArgs$args = actionArgs.args) && void 0 !== _actionArgs$args && _actionArgs$args.length)) {
            return
        }
        const {
            itemData: itemData,
            itemElement: itemElement
        } = actionArgs.args[0];
        if (!itemData) {
            return
        }
        const node = this._dataAdapter.getNodeByItem(itemData);
        if (!node) {
            return
        }
        const $itemElement = $(itemElement);
        let $submenu = $itemElement.find(".dx-submenu");
        const shouldRenderSubmenu = this._hasSubmenu(node) && !$submenu.length;
        if (shouldRenderSubmenu) {
            this._renderSubmenuItems(node, $itemElement);
            $submenu = $itemElement.find(".dx-submenu")
        }
        if ($itemElement.context === $submenu.context && "visible" === $submenu.css("visibility")) {
            return
        }
        this._updateSelectedItemOnClick(actionArgs);
        const notCloseMenuOnItemClick = itemData && false === itemData.closeMenuOnClick;
        if (!itemData || itemData.disabled || notCloseMenuOnItemClick) {
            return
        }
        if (0 === $submenu.length) {
            var _this$_overlay5;
            const $prevSubmenu = $($itemElement.parents(".dx-submenu")[0]);
            this._hideSubmenu($prevSubmenu);
            if (!actionArgs.canceled && null !== (_this$_overlay5 = this._overlay) && void 0 !== _this$_overlay5 && _this$_overlay5.option("visible")) {
                this.option("visible", false)
            }
        } else {
            if (this._shownSubmenus && this._shownSubmenus.length > 0) {
                if (this._shownSubmenus[0].is($submenu)) {
                    this._hideSubmenu($submenu)
                }
            }
            this._showSubmenu($itemElement)
        }
    }
    _hideSubmenu($curSubmenu) {
        const shownSubmenus = this._shownSubmenus ?? [];
        each(shownSubmenus, ((_index, $submenu) => {
            if ($curSubmenu.is($submenu) || contains($curSubmenu[0], $submenu[0])) {
                $submenu.parent().removeClass("dx-menu-item-expanded");
                this._hideSubmenuCore($submenu)
            }
        }))
    }
    _hideSubmenuCore($submenu) {
        const index = (this._shownSubmenus ?? []).indexOf($submenu);
        const {
            animation: animationOption
        } = this.option();
        const animation = animationOption ? animationOption.hide : null;
        if (index >= 0) {
            (this._shownSubmenus ?? []).splice(index, 1)
        }
        this._stopAnimate($submenu);
        if (animation) {
            this._animate($submenu.get(0), animation)
        }
        $submenu.css("visibility", "hidden");
        const scrollableInstance = $submenu.dxScrollable("instance");
        scrollableInstance.scrollTo(0);
        this.option("focusedElement", null)
    }
    _stopAnimate($container) {
        fx.stop($container.get(0), true)
    }
    _hideAllShownSubmenus() {
        var _this$_overlay6;
        const shownSubmenus = extend([], this._shownSubmenus);
        const $expandedItems = (null === (_this$_overlay6 = this._overlay) || void 0 === _this$_overlay6 ? void 0 : _this$_overlay6.$content().find(".dx-menu-item-expanded")) ?? $();
        $expandedItems.removeClass("dx-menu-item-expanded");
        each(shownSubmenus, ((_, $submenu) => {
            this._hideSubmenu($submenu)
        }))
    }
    _visibilityChanged(visible) {
        if (visible) {
            this._renderContentImpl()
        }
    }
    _optionChanged(args) {
        const {
            name: name,
            value: value,
            previousValue: previousValue
        } = args;
        if (ACTIONS.includes(name)) {
            this._initActions();
            return
        }
        switch (name) {
            case "visible":
                this._renderVisibility(value);
                break;
            case "disabled":
            case "position":
            case "submenuDirection":
                this._invalidate();
                break;
            case "showEvent":
                if (previousValue) {
                    this._detachShowContextMenuEvents(this._getTarget(), previousValue)
                }
                this._invalidate();
                break;
            case "target":
                if (previousValue) {
                    this._detachShowContextMenuEvents(previousValue)
                }
                this._invalidate();
                break;
            case "hideOnOutsideClick":
            case "hideOnParentScroll":
            case "visualContainer":
                break;
            default:
                super._optionChanged(args)
        }
    }
    _renderVisibility(showing) {
        return showing ? this._show() : this._hide()
    }
    _toggleVisibility() {}
    _show(event) {
        var _this$_actions$onShow2, _this$_actions9;
        const args = {
            jQEvent: event
        };
        let promise = Deferred().reject().promise();
        null === (_this$_actions$onShow2 = (_this$_actions9 = this._actions).onShowing) || void 0 === _this$_actions$onShow2 || _this$_actions$onShow2.call(_this$_actions9, args);
        if (args.cancel) {
            return promise
        }
        const position = this._positionContextMenu(event);
        if (position) {
            var _this$_overlay7, _this$_overlay8, _event$originalEvent;
            if (!this._overlay) {
                this._renderContextMenuOverlay();
                this._overlay.$content().addClass(this._widgetClass());
                this._renderFocusState();
                this._attachHoverEvents();
                this._attachClickEvent();
                this._renderItems(this._dataAdapter.getRootNodes())
            }
            const $subMenu = $(null === (_this$_overlay7 = this._overlay) || void 0 === _this$_overlay7 ? void 0 : _this$_overlay7.content()).children(".dx-submenu");
            this._setOptionWithoutOptionChange("visible", true);
            null === (_this$_overlay8 = this._overlay) || void 0 === _this$_overlay8 || _this$_overlay8.option({
                height: () => this._getMaxHeight(position.of),
                position: position
            });
            this._setOverlayMaxHeight($subMenu);
            this._planPostRenderActions($subMenu, true);
            if (this._overlay) {
                promise = this._overlay.show()
            }
            null === event || void 0 === event || event.stopPropagation();
            this._setAriaAttributes();
            if ((null === event || void 0 === event || null === (_event$originalEvent = event.originalEvent) || void 0 === _event$originalEvent ? void 0 : _event$originalEvent.type) === holdEvent.name) {
                this.preventShowingDefaultContextMenuAboveOverlay()
            }
        }
        return promise
    }
    _renderItems(nodes, submenuContainer) {
        var _this$_overlay9;
        super._renderItems(nodes, submenuContainer);
        const $submenu = $(null === (_this$_overlay9 = this._overlay) || void 0 === _this$_overlay9 ? void 0 : _this$_overlay9.content()).children(".dx-submenu");
        if ($submenu.length) {
            this._initScrollable($submenu)
        }
    }
    _setAriaAttributes() {
        var _this$_overlay10;
        this._overlayContentId = `dx-${new Guid}`;
        this.setAria("owns", this._overlayContentId);
        this.setAria({
            id: this._overlayContentId,
            role: "menu"
        }, null === (_this$_overlay10 = this._overlay) || void 0 === _this$_overlay10 ? void 0 : _this$_overlay10.$content())
    }
    _cleanAriaAttributes() {
        if (this._overlay) {
            this.setAria("id", null, this._overlay.$content())
        }
        this.setAria("owns", void 0)
    }
    _getTarget() {
        const {
            target: target,
            position: position
        } = this.option();
        return target || (null === position || void 0 === position ? void 0 : position.of) || $(domAdapter.getDocument())
    }
    _getContextMenuPosition() {
        const {
            position: position
        } = this.option();
        return _extends({}, position, {
            of: this._getTarget()
        })
    }
    _positionContextMenu(jQEvent) {
        let position = this._getContextMenuPosition();
        const isInitialPosition = this._isInitialOptionValue("position");
        const positioningAction = this._createActionByOption("onPositioning");
        if (null !== jQEvent && void 0 !== jQEvent && jQEvent.preventDefault && isInitialPosition) {
            position.of = jQEvent
        }
        const actionArgs = {
            position: position,
            event: jQEvent
        };
        positioningAction(actionArgs);
        if (actionArgs.cancel) {
            position = null
        } else if (actionArgs.event) {
            actionArgs.event.cancel = true;
            null === jQEvent || void 0 === jQEvent || jQEvent.preventDefault()
        }
        return position
    }
    _refresh() {
        if (!hasWindow()) {
            super._refresh()
        } else if (this._overlay) {
            const {
                position: lastPosition
            } = this._overlay.option();
            super._refresh();
            if (this._overlay) {
                this._overlay.option("position", lastPosition)
            }
        } else {
            super._refresh()
        }
    }
    _hide() {
        let promise;
        if (this._overlay) {
            promise = this._overlay.hide();
            this._setOptionWithoutOptionChange("visible", false)
        }
        this._cleanAriaAttributes();
        this.option("focusedElement", null);
        return promise ?? Deferred().reject().promise()
    }
    toggle(showing) {
        const {
            visible: visible
        } = this.option();
        return this._renderVisibility(showing ?? !visible)
    }
    show() {
        return this.toggle(true)
    }
    hide() {
        return this.toggle(false)
    }
    _postProcessRenderItems($subMenu, isRootSubMenu) {
        if (!isRootSubMenu) {
            this._setSubmenuVisible($subMenu);
            return
        }
        this._setOverlayMaxHeight($subMenu)
    }
}
registerComponent("dxContextMenu", ContextMenu);
export default ContextMenu;
